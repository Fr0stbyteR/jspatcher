/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ServerOptions.ts":
/*!******************************!*\
  !*** ./src/ServerOptions.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

const serverOptions = {
  hosts: {
    domain: "meet.jit.si",
    focus: "focus.meet.jit.si",
    muc: "conference.meet.jit.si"
  },
  bosh: "https://meet.jit.si/http-bind"
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (serverOptions);


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   author: () => (/* binding */ author),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   jspatcher: () => (/* binding */ jspatcher),
/* harmony export */   keywords: () => (/* binding */ keywords),
/* harmony export */   license: () => (/* binding */ license),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var _package_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./package-info */ "./src/package-info.ts");

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

const name = _package_info__WEBPACK_IMPORTED_MODULE_0__["default"].name.split("/").pop().replace(/^package-/, "");
const { author, license, keywords, version, description, jspatcher } = _package_info__WEBPACK_IMPORTED_MODULE_0__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__spreadValues({ name, author, license, keywords, version, description }, jspatcher));


/***/ }),

/***/ "./src/objects/base.ts":
/*!*****************************!*\
  !*** ./src/objects/base.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitsiObject)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index */ "./src/index.ts");
/* harmony import */ var _sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sdk */ "./src/sdk.ts");



class JitsiObject extends _sdk__WEBPACK_IMPORTED_MODULE_1__.DefaultObject {
}
JitsiObject.package = _index__WEBPACK_IMPORTED_MODULE_0__.name;
JitsiObject.author = _index__WEBPACK_IMPORTED_MODULE_0__.author;
JitsiObject.version = _index__WEBPACK_IMPORTED_MODULE_0__.version;
JitsiObject.description = _index__WEBPACK_IMPORTED_MODULE_0__.description;


/***/ }),

/***/ "./src/objects/meeting.ts":
/*!********************************!*\
  !*** ./src/objects/meeting.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Meeting)
/* harmony export */ });
/* harmony import */ var _shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shren/lib-jitsi-meet */ "../../lib-jitsi-meet/dist/esm/JitsiMeetJS.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./src/objects/base.ts");
/* harmony import */ var _sdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sdk */ "./src/sdk.ts");
/* harmony import */ var _ServerOptions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ServerOptions */ "./src/ServerOptions.ts");





_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].setLogLevel(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].logLevels.ERROR);
class Meeting extends _base__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super(...arguments);
    this._ = {
      audioInStreamNode: this.audioCtx.createMediaStreamDestination(),
      audioOutGainNode: this.audioCtx.createGain(),
      connection: null,
      room: null,
      streamMap: {},
      audioMap: {},
      localTrack: null
    };
    this.handleRemoteTrackAdded = (track) => {
      if (track.isLocal())
        return;
      if (track.getType() !== "audio")
        return;
      const participant = track.getParticipantId();
      const stream = track.getOriginalStream();
      const audio = new Audio();
      audio.muted = true;
      audio.srcObject = stream;
      const streamSourceNode = this.audioCtx.createMediaStreamSource(audio.srcObject);
      audio.play();
      if (!this._.streamMap[participant])
        this._.streamMap[participant] = /* @__PURE__ */ new Set([streamSourceNode]);
      else
        this._.streamMap[participant].add(streamSourceNode);
      if (!this._.audioMap[participant])
        this._.audioMap[participant] = /* @__PURE__ */ new Set([audio]);
      else
        this._.audioMap[participant].add(audio);
      streamSourceNode.connect(this._.audioOutGainNode);
      track.addEventListener(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.track.LOCAL_TRACK_STOPPED, () => {
        var _a, _b;
        (_a = this._.streamMap[participant]) == null ? void 0 : _a.delete(streamSourceNode);
        (_b = this._.audioMap[participant]) == null ? void 0 : _b.delete(audio);
        streamSourceNode.disconnect();
        audio.pause();
      });
    };
    this.handleRemoteTrackRemoved = (track) => {
      var _a, _b;
      const participant = track.getParticipantId();
      if (!participant)
        return;
      const stream = track.getOriginalStream();
      const streamSourceNode = [...this._.streamMap[participant]].find((node) => node.mediaStream === stream);
      const audio = [...this._.audioMap[participant]].find((audio2) => audio2.srcObject === stream);
      if (streamSourceNode)
        (_a = this._.streamMap[participant]) == null ? void 0 : _a.delete(streamSourceNode);
      if (audio)
        (_b = this._.audioMap[participant]) == null ? void 0 : _b.delete(audio);
      streamSourceNode == null ? void 0 : streamSourceNode.disconnect();
      audio == null ? void 0 : audio.pause();
    };
    this.handleUserLeft = (id) => {
      if (this._.streamMap[id]) {
        [...this._.streamMap[id]].forEach((node) => node.disconnect());
        this._.streamMap[id].clear();
      }
      if (this._.audioMap[id]) {
        [...this._.audioMap[id]].forEach((audio) => audio.pause());
        this._.audioMap[id].clear();
      }
    };
    this.handleConferenceJoined = async () => {
      const [track] = _shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].util.RTC.createLocalTracks([{
        mediaType: "audio",
        stream: this._.audioInStreamNode.stream,
        track: this._.audioInStreamNode.stream.getAudioTracks()[0]
      }]);
      this._.localTrack = track;
      this._.room._setupNewTrack(track);
      await this._.room.addTrack(track);
      track.unmute();
    };
    this.handleMessageReceived = (id, message, timestamp) => {
      var _a;
      const username = (_a = this._.room.getParticipantById(id)) == null ? void 0 : _a.getDisplayName();
      this.outlet(0, { username, message, timestamp });
    };
    this.handleConnectionSuccess = () => {
      const confOptions = {};
      const room = this._.connection.initJitsiConference(this.args[0], confOptions);
      this._.room = room;
      this.outlet(1, room);
      room.on(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.conference.TRACK_ADDED, this.handleRemoteTrackAdded);
      room.on(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.conference.TRACK_REMOVED, this.handleRemoteTrackRemoved);
      room.on(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.conference.CONFERENCE_JOINED, this.handleConferenceJoined);
      room.on(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.conference.MESSAGE_RECEIVED, this.handleMessageReceived);
      room.on(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.conference.USER_LEFT, this.handleUserLeft);
      room.setDisplayName(this.getProp("username"));
      room.join(null);
    };
    this.handleConnectionFailed = () => {
      this.error("Connection Failed.");
      this.handleConnectionDisconnect();
    };
    this.handleConnectionDisconnect = async () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      (_a = this._.room) == null ? void 0 : _a.off(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.conference.TRACK_ADDED, this.handleRemoteTrackAdded);
      (_b = this._.room) == null ? void 0 : _b.off(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.conference.TRACK_REMOVED, this.handleRemoteTrackRemoved);
      (_c = this._.room) == null ? void 0 : _c.off(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.conference.CONFERENCE_JOINED, this.handleConferenceJoined);
      (_d = this._.room) == null ? void 0 : _d.off(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.conference.MESSAGE_RECEIVED, this.handleMessageReceived);
      (_e = this._.room) == null ? void 0 : _e.off(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.conference.USER_LEFT, this.handleUserLeft);
      (_f = this._.connection) == null ? void 0 : _f.removeEventListener(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.connection.CONNECTION_ESTABLISHED, this.handleConnectionSuccess);
      (_g = this._.connection) == null ? void 0 : _g.removeEventListener(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.connection.CONNECTION_FAILED, this.handleConnectionFailed);
      (_h = this._.connection) == null ? void 0 : _h.removeEventListener(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.connection.CONNECTION_DISCONNECTED, this.handleConnectionDisconnect);
      for (const id in this._.streamMap) {
        [...this._.streamMap[id]].forEach((node) => node.disconnect());
        this._.streamMap[id].clear();
      }
      for (const id in this._.audioMap) {
        [...this._.audioMap[id]].forEach((audio) => audio.pause());
        this._.audioMap[id].clear();
      }
      await ((_i = this._.localTrack) == null ? void 0 : _i.mute());
      await ((_j = this._.localTrack) == null ? void 0 : _j.dispose());
      await ((_k = this._.room) == null ? void 0 : _k.leave());
      await ((_l = this._.connection) == null ? void 0 : _l.disconnect());
      this._.localTrack = void 0;
      this._.connection = void 0;
      this._.room = void 0;
    };
    this.connect = () => {
      const connection = new _shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].JitsiConnection(null, null, _ServerOptions__WEBPACK_IMPORTED_MODULE_3__["default"]);
      this._.connection = connection;
      connection.addEventListener(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.connection.CONNECTION_ESTABLISHED, this.handleConnectionSuccess);
      connection.addEventListener(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.connection.CONNECTION_FAILED, this.handleConnectionFailed);
      connection.addEventListener(_shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].events.connection.CONNECTION_DISCONNECTED, this.handleConnectionDisconnect);
      connection.connect({});
    };
  }
  subscribe() {
    super.subscribe();
    this.on("preInit", () => {
      this.inlets = 1;
      this.outlets = 2;
      this.inletAudioConnections = [{ node: this._.audioInStreamNode, index: 0 }];
      this.outletAudioConnections = [{ node: this._.audioOutGainNode, index: 0 }];
    });
    this.on("postInit", () => {
      _shren_lib_jitsi_meet__WEBPACK_IMPORTED_MODULE_0__["default"].init({
        disableAudioLevels: true,
        audioQuality: {
          stereo: false,
          opusMaxAverageBitrate: ~~+this.getProp("opusMaxAverageBitrate"),
          enableOpusDtx: false
        }
      });
      this.connect();
    });
    this.on("argsUpdated", async ({ args }) => {
      await this.handleConnectionDisconnect();
      this.connect();
    });
    this.on("propsUpdated", ({ props: { username } }) => {
      var _a;
      if (username)
        (_a = this._.room) == null ? void 0 : _a.setDisplayName(username);
    });
    this.on("destroy", async () => {
      var _a, _b;
      await this.handleConnectionDisconnect();
      await ((_a = this._.room) == null ? void 0 : _a.leave());
      await ((_b = this._.connection) == null ? void 0 : _b.disconnect());
    });
    this.on("inlet", async ({ data, inlet }) => {
      if (inlet === 0) {
        if ((0,_sdk__WEBPACK_IMPORTED_MODULE_2__.isBang)(data)) {
          if (!this._.connection)
            this.connect();
        } else if (typeof data === "string") {
          if (this._.room) {
            this._.room.sendMessage(data);
          }
        } else if (typeof data === "object") {
          if (this._.room) {
            const id = this._.room.getParticipants().find((p) => p.getDisplayName() === data.username).getId();
            if (id)
              this._.room.sendMessage(data.message, id);
          }
        }
      }
    });
  }
}
Meeting.description = "Send/Receive Audio or Text Message to a Jitsi Meeting";
Meeting.inlets = [{
  isHot: true,
  type: "signal",
  description: "Audio to send, text string to broadcast, { username: string; message: string } to send private message"
}];
Meeting.outlets = [{
  type: "signal",
  description: "Audio and text received, text message under format { username: string; message: string }"
}, {
  type: "object",
  description: "The JitsiConference instance"
}];
Meeting.args = [{
  type: "string",
  optional: true,
  description: "Jitsi Meeting Name",
  default: `jspatcher${new Date().toISOString().slice(0, 10).replace("-", "")}`
}];
Meeting.props = {
  opusMaxAverageBitrate: {
    type: "number",
    description: "Jitsi audio quality, Value to fit the 6000 to 510000 range",
    default: 48e3
  },
  username: {
    type: "string",
    description: "Jitsi display username in the room",
    default: `JSPatcher User ${Math.random().toFixed(3).slice(2)}`
  }
};


/***/ }),

/***/ "./src/package-info.ts":
/*!*****************************!*\
  !*** ./src/package-info.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var _package_json__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json */ "./package.json");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/ (_package_json__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_package_json__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_package_json__WEBPACK_IMPORTED_MODULE_0__, 2))));


/***/ }),

/***/ "./src/sdk.ts":
/*!********************!*\
  !*** ./src/sdk.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bang: () => (/* binding */ Bang),
/* harmony export */   BaseObject: () => (/* binding */ BaseObject),
/* harmony export */   BaseUI: () => (/* binding */ BaseUI),
/* harmony export */   Box: () => (/* binding */ Box),
/* harmony export */   DefaultObject: () => (/* binding */ DefaultObject),
/* harmony export */   DefaultUI: () => (/* binding */ DefaultUI),
/* harmony export */   Line: () => (/* binding */ Line),
/* harmony export */   Patcher: () => (/* binding */ Patcher),
/* harmony export */   React: () => (/* binding */ React),
/* harmony export */   Utils: () => (/* binding */ Utils),
/* harmony export */   generateDefaultObject: () => (/* binding */ generateDefaultObject),
/* harmony export */   generateRemoteObject: () => (/* binding */ generateRemoteObject),
/* harmony export */   generateRemotedObject: () => (/* binding */ generateRemotedObject),
/* harmony export */   isBang: () => (/* binding */ isBang)
/* harmony export */ });

const sdk = globalThis.jspatcherEnv.sdk;
const {
  React,
  Patcher,
  Box,
  Line,
  BaseObject,
  BaseUI,
  DefaultObject,
  DefaultUI,
  generateRemotedObject,
  generateDefaultObject,
  generateRemoteObject,
  Bang,
  isBang,
  Utils
} = sdk;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiConference.js":
/*!********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiConference.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitsiConference)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash.isequal */ "../../lib-jitsi-meet/node_modules/lodash.isequal/index.js");
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./JitsiConferenceErrors */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceErrors.js");
/* harmony import */ var _JitsiConferenceEventManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./JitsiConferenceEventManager */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEventManager.js");
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _JitsiParticipant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./JitsiParticipant */ "../../lib-jitsi-meet/dist/esm/JitsiParticipant.js");
/* harmony import */ var _JitsiTrackError__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./JitsiTrackError */ "../../lib-jitsi-meet/dist/esm/JitsiTrackError.js");
/* harmony import */ var _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./JitsiTrackErrors */ "../../lib-jitsi-meet/dist/esm/JitsiTrackErrors.js");
/* harmony import */ var _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./JitsiTrackEvents */ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js");
/* harmony import */ var _authenticateAndUpgradeRole__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./authenticateAndUpgradeRole */ "../../lib-jitsi-meet/dist/esm/authenticateAndUpgradeRole.js");
/* harmony import */ var _modules_RTC_CodecSelection__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/RTC/CodecSelection */ "../../lib-jitsi-meet/dist/esm/modules/RTC/CodecSelection.js");
/* harmony import */ var _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./modules/RTC/RTC */ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTC.js");
/* harmony import */ var _modules_RTC_ScreenObtainer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./modules/RTC/ScreenObtainer */ "../../lib-jitsi-meet/dist/esm/modules/RTC/ScreenObtainer.js");
/* harmony import */ var _modules_browser__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./modules/browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _modules_connectivity_ConnectionQuality__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./modules/connectivity/ConnectionQuality */ "../../lib-jitsi-meet/dist/esm/modules/connectivity/ConnectionQuality.js");
/* harmony import */ var _modules_connectivity_IceFailedHandling__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./modules/connectivity/IceFailedHandling */ "../../lib-jitsi-meet/dist/esm/modules/connectivity/IceFailedHandling.js");
/* harmony import */ var _modules_detection_DetectionEvents__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./modules/detection/DetectionEvents */ "../../lib-jitsi-meet/dist/esm/modules/detection/DetectionEvents.js");
/* harmony import */ var _modules_detection_NoAudioSignalDetection__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./modules/detection/NoAudioSignalDetection */ "../../lib-jitsi-meet/dist/esm/modules/detection/NoAudioSignalDetection.js");
/* harmony import */ var _modules_detection_P2PDominantSpeakerDetection__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./modules/detection/P2PDominantSpeakerDetection */ "../../lib-jitsi-meet/dist/esm/modules/detection/P2PDominantSpeakerDetection.js");
/* harmony import */ var _modules_detection_VADAudioAnalyser__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./modules/detection/VADAudioAnalyser */ "../../lib-jitsi-meet/dist/esm/modules/detection/VADAudioAnalyser.js");
/* harmony import */ var _modules_detection_VADNoiseDetection__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./modules/detection/VADNoiseDetection */ "../../lib-jitsi-meet/dist/esm/modules/detection/VADNoiseDetection.js");
/* harmony import */ var _modules_detection_VADTalkMutedDetection__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./modules/detection/VADTalkMutedDetection */ "../../lib-jitsi-meet/dist/esm/modules/detection/VADTalkMutedDetection.js");
/* harmony import */ var _modules_e2ee_E2EEncryption__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./modules/e2ee/E2EEncryption */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/E2EEncryption.js");
/* harmony import */ var _modules_e2eping_e2eping__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./modules/e2eping/e2eping */ "../../lib-jitsi-meet/dist/esm/modules/e2eping/e2eping.js");
/* harmony import */ var _modules_event_Jvb121EventGenerator__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./modules/event/Jvb121EventGenerator */ "../../lib-jitsi-meet/dist/esm/modules/event/Jvb121EventGenerator.js");
/* harmony import */ var _modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./modules/flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");
/* harmony import */ var _modules_litemode_LiteModeContext__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./modules/litemode/LiteModeContext */ "../../lib-jitsi-meet/dist/esm/modules/litemode/LiteModeContext.js");
/* harmony import */ var _modules_qualitycontrol_ReceiveVideoController__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./modules/qualitycontrol/ReceiveVideoController */ "../../lib-jitsi-meet/dist/esm/modules/qualitycontrol/ReceiveVideoController.js");
/* harmony import */ var _modules_qualitycontrol_SendVideoController__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./modules/qualitycontrol/SendVideoController */ "../../lib-jitsi-meet/dist/esm/modules/qualitycontrol/SendVideoController.js");
/* harmony import */ var _modules_recording_RecordingManager__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./modules/recording/RecordingManager */ "../../lib-jitsi-meet/dist/esm/modules/recording/RecordingManager.js");
/* harmony import */ var _modules_settings_Settings__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./modules/settings/Settings */ "../../lib-jitsi-meet/dist/esm/modules/settings/Settings.js");
/* harmony import */ var _modules_statistics_AudioOutputProblemDetector__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./modules/statistics/AudioOutputProblemDetector */ "../../lib-jitsi-meet/dist/esm/modules/statistics/AudioOutputProblemDetector.js");
/* harmony import */ var _modules_statistics_AvgRTPStatsReporter__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./modules/statistics/AvgRTPStatsReporter */ "../../lib-jitsi-meet/dist/esm/modules/statistics/AvgRTPStatsReporter.js");
/* harmony import */ var _modules_statistics_LocalStatsCollector__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./modules/statistics/LocalStatsCollector */ "../../lib-jitsi-meet/dist/esm/modules/statistics/LocalStatsCollector.js");
/* harmony import */ var _modules_statistics_SpeakerStatsCollector__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./modules/statistics/SpeakerStatsCollector */ "../../lib-jitsi-meet/dist/esm/modules/statistics/SpeakerStatsCollector.js");
/* harmony import */ var _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./modules/statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _modules_transcription_transcriber__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./modules/transcription/transcriber */ "../../lib-jitsi-meet/dist/esm/modules/transcription/transcriber.js");
/* harmony import */ var _modules_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./modules/util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _modules_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_40___default = /*#__PURE__*/__webpack_require__.n(_modules_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_40__);
/* harmony import */ var _modules_util_RandomUtil__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./modules/util/RandomUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/RandomUtil.js");
/* harmony import */ var _modules_util_RandomUtil__WEBPACK_IMPORTED_MODULE_41___default = /*#__PURE__*/__webpack_require__.n(_modules_util_RandomUtil__WEBPACK_IMPORTED_MODULE_41__);
/* harmony import */ var _modules_version_ComponentsVersions__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./modules/version/ComponentsVersions */ "../../lib-jitsi-meet/dist/esm/modules/version/ComponentsVersions.js");
/* harmony import */ var _modules_videosipgw_VideoSIPGW__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./modules/videosipgw/VideoSIPGW */ "../../lib-jitsi-meet/dist/esm/modules/videosipgw/VideoSIPGW.js");
/* harmony import */ var _modules_videosipgw_VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./modules/videosipgw/VideoSIPGWConstants */ "../../lib-jitsi-meet/dist/esm/modules/videosipgw/VideoSIPGWConstants.js");
/* harmony import */ var _modules_xmpp_SignalingLayerImpl__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./modules/xmpp/SignalingLayerImpl */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/SignalingLayerImpl.js");
/* harmony import */ var _modules_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./modules/xmpp/xmpp */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/xmpp.js");
/* harmony import */ var _service_RTC_BridgeVideoType__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./service/RTC/BridgeVideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/BridgeVideoType.js");
/* harmony import */ var _service_RTC_BridgeVideoType__WEBPACK_IMPORTED_MODULE_47___default = /*#__PURE__*/__webpack_require__.n(_service_RTC_BridgeVideoType__WEBPACK_IMPORTED_MODULE_47__);
/* harmony import */ var _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./service/RTC/CodecMimeType */ "../../lib-jitsi-meet/dist/esm/service/RTC/CodecMimeType.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./service/RTC/SignalingEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingEvents.js");
/* harmony import */ var _service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./service/RTC/SignalingLayer */ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingLayer.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");

var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
























































const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const JINGLE_SI_TIMEOUT = 5e3;
function _getCodecMimeType(codec) {
  if (typeof codec === "string") {
    return Object.values(_service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_48__["default"]).find((value) => value === codec.toLowerCase());
  }
  return null;
}
function JitsiConference(options) {
  var _a, _b, _c;
  if (!options.name || options.name.toLowerCase() !== options.name.toString()) {
    const errmsg = "Invalid conference name (no conference name passed or it contains invalid characters like capital letters)!";
    logger.error(errmsg);
    throw new Error(errmsg);
  }
  this.connection = options.connection;
  this.xmpp = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.xmpp;
  if (this.xmpp.isRoomCreated(options.name, options.customDomain)) {
    const errmsg = "A conference with the same name has already been created!";
    delete this.connection;
    delete this.xmpp;
    logger.error(errmsg);
    throw new Error(errmsg);
  }
  this.eventEmitter = new (events__WEBPACK_IMPORTED_MODULE_1___default())();
  this.options = options;
  this.eventManager = new _JitsiConferenceEventManager__WEBPACK_IMPORTED_MODULE_6__["default"](this);
  this.participants = /* @__PURE__ */ new Map();
  this._signalingLayer = new _modules_xmpp_SignalingLayerImpl__WEBPACK_IMPORTED_MODULE_45__["default"]();
  this._init(options);
  this.componentsVersions = new _modules_version_ComponentsVersions__WEBPACK_IMPORTED_MODULE_42__["default"](this);
  this.jvbJingleSession = null;
  this.lastDominantSpeaker = null;
  this.dtmfManager = null;
  this.somebodySupportsDTMF = false;
  this.authEnabled = false;
  this.startAudioMuted = false;
  this.startVideoMuted = false;
  this.startMutedPolicy = {
    audio: false,
    video: false
  };
  this.isMutedByFocus = false;
  this.mutedByFocusActor = null;
  this.isVideoMutedByFocus = false;
  this.mutedVideoByFocusActor = null;
  this.wasStopped = false;
  this.properties = {};
  this.connectionQuality = new _modules_connectivity_ConnectionQuality__WEBPACK_IMPORTED_MODULE_17__["default"](this, this.eventEmitter, options);
  this.avgRtpStatsReporter = new _modules_statistics_AvgRTPStatsReporter__WEBPACK_IMPORTED_MODULE_35__["default"](this, options.config.avgRtpStatsN || 15);
  if (!options.config.disableAudioLevels) {
    this._audioOutputProblemDetector = new _modules_statistics_AudioOutputProblemDetector__WEBPACK_IMPORTED_MODULE_34__["default"](this);
  }
  this.isJvbConnectionInterrupted = false;
  this.speakerStatsCollector = new _modules_statistics_SpeakerStatsCollector__WEBPACK_IMPORTED_MODULE_37__["default"](this);
  this.deferredStartP2PTask = null;
  const delay = parseInt(options.config.p2p && options.config.p2p.backToP2PDelay, 10);
  this.backToP2PDelay = isNaN(delay) ? 5 : delay;
  logger.info(`backToP2PDelay: ${this.backToP2PDelay}`);
  this.isP2PConnectionInterrupted = false;
  this.p2p = false;
  this.p2pJingleSession = null;
  this.videoSIPGWHandler = new _modules_videosipgw_VideoSIPGW__WEBPACK_IMPORTED_MODULE_43__["default"](this.room);
  this.recordingManager = new _modules_recording_RecordingManager__WEBPACK_IMPORTED_MODULE_32__["default"](this.room);
  this._conferenceJoinAnalyticsEventSent = void 0;
  if (this.isE2EESupported()) {
    logger.info("End-to-End Encryption is supported");
    this._e2eEncryption = new _modules_e2ee_E2EEncryption__WEBPACK_IMPORTED_MODULE_25__.E2EEncryption(this);
  }
  if (_modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_28__["default"].isRunInLiteModeEnabled()) {
    logger.info("Lite mode enabled");
    this._liteModeContext = new _modules_litemode_LiteModeContext__WEBPACK_IMPORTED_MODULE_29__.LiteModeContext(this);
  }
  this._audioSenderLimitReached = void 0;
  this._videoSenderLimitReached = void 0;
  this._firefoxP2pEnabled = _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].isVersionGreaterThan(109) && ((_c = (_b = this.options.config.testing) === null || _b === void 0 ? void 0 : _b.enableFirefoxP2p) !== null && _c !== void 0 ? _c : true);
}
JitsiConference.prototype.constructor = JitsiConference;
JitsiConference.resourceCreator = function(jid, isAuthenticatedUser) {
  var _a;
  let mucNickname;
  if (isAuthenticatedUser) {
    mucNickname = _modules_util_RandomUtil__WEBPACK_IMPORTED_MODULE_41___default().randomHexString(8).toLowerCase();
  } else {
    mucNickname = (_a = strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getNodeFromJid(jid)) === null || _a === void 0 ? void 0 : _a.substr(0, 8).toLowerCase();
    const re = /[0-9a-f]{8}/g;
    if (!mucNickname || !re.test(mucNickname)) {
      mucNickname = _modules_util_RandomUtil__WEBPACK_IMPORTED_MODULE_41___default().randomHexString(8).toLowerCase();
    }
  }
  return mucNickname;
};
JitsiConference.prototype._init = function(options = {}) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;
  this.eventManager.setupXMPPListeners();
  const { config } = this.options;
  const codecSettings = {
    jvb: {
      preferenceOrder: _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].isMobileDevice() && ((_a = config.videoQuality) === null || _a === void 0 ? void 0 : _a.mobileCodecPreferenceOrder) ? config.videoQuality.mobileCodecPreferenceOrder : (_b = config.videoQuality) === null || _b === void 0 ? void 0 : _b.codecPreferenceOrder,
      disabledCodec: _getCodecMimeType((_c = config.videoQuality) === null || _c === void 0 ? void 0 : _c.disabledCodec),
      preferredCodec: _getCodecMimeType((_d = config.videoQuality) === null || _d === void 0 ? void 0 : _d.preferredCodec)
    },
    p2p: {
      preferenceOrder: _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].isMobileDevice() && ((_e = config.p2p) === null || _e === void 0 ? void 0 : _e.mobileCodecPreferenceOrder) ? config.p2p.mobileCodecPreferenceOrder : (_f = config.p2p) === null || _f === void 0 ? void 0 : _f.codecPreferenceOrder,
      disabledCodec: _getCodecMimeType((_g = config.p2p) === null || _g === void 0 ? void 0 : _g.disabledCodec),
      preferredCodec: _getCodecMimeType((_h = config.p2p) === null || _h === void 0 ? void 0 : _h.preferredCodec)
    }
  };
  this.codecSelection = new _modules_RTC_CodecSelection__WEBPACK_IMPORTED_MODULE_13__.CodecSelection(this, codecSettings);
  this._statsCurrentId = config.statisticsId ? config.statisticsId : _modules_settings_Settings__WEBPACK_IMPORTED_MODULE_33__["default"].callStatsUserName;
  this.room = this.xmpp.createRoom(this.options.name, Object.assign(Object.assign({}, config), { statsId: this._statsCurrentId }), JitsiConference.resourceCreator);
  this._signalingLayer.setChatRoom(this.room);
  this._signalingLayer.on(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_51__.SignalingEvents.SOURCE_UPDATED, (sourceName, endpointId, muted, videoType) => {
    const participant = this.participants.get(endpointId);
    const mediaType = (0,_service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_52__.getMediaTypeFromSourceName)(sourceName);
    if (participant) {
      participant._setSources(mediaType, muted, sourceName, videoType);
      this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.PARTICIPANT_SOURCE_UPDATED, participant);
    }
  });
  this._onIceConnectionInterrupted = this._onIceConnectionInterrupted.bind(this);
  this.room.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted);
  this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this);
  this.room.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored);
  this._onIceConnectionEstablished = this._onIceConnectionEstablished.bind(this);
  this.room.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished);
  this._updateProperties = this._updateProperties.bind(this);
  this.room.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties);
  this._sendConferenceJoinAnalyticsEvent = this._sendConferenceJoinAnalyticsEvent.bind(this);
  this.room.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent);
  this._removeLocalSourceOnReject = this._removeLocalSourceOnReject.bind(this);
  this._updateRoomPresence = this._updateRoomPresence.bind(this);
  this.room.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.SESSION_ACCEPT, this._updateRoomPresence);
  this.room.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.SOURCE_ADD, this._updateRoomPresence);
  this.room.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.SOURCE_ADD_ERROR, this._removeLocalSourceOnReject);
  this.room.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.SOURCE_REMOVE, this._updateRoomPresence);
  if ((_j = config.e2eping) === null || _j === void 0 ? void 0 : _j.enabled) {
    this.e2eping = new _modules_e2eping_e2eping__WEBPACK_IMPORTED_MODULE_26__["default"](this, config, (message, to) => {
      try {
        this.sendMessage(message, to, true);
      } catch (error) {
        logger.warn("Failed to send E2E ping request or response.", error && error.msg);
      }
    });
  }
  if (!this.rtc) {
    this.rtc = new _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_14__["default"](this, options);
    this.eventManager.setupRTCListeners();
    this._registerRtcListeners(this.rtc);
  }
  this.receiveVideoController = new _modules_qualitycontrol_ReceiveVideoController__WEBPACK_IMPORTED_MODULE_30__["default"](this, this.rtc);
  this.sendVideoController = new _modules_qualitycontrol_SendVideoController__WEBPACK_IMPORTED_MODULE_31__["default"](this, this.rtc);
  if (!this.statistics) {
    this.statistics = new _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"](this.xmpp, {
      aliasName: this._statsCurrentId,
      userName: config.statisticsDisplayName ? config.statisticsDisplayName : this.myUserId(),
      confID: config.confID || `${this.connection.options.hosts.domain}/${this.options.name}`,
      siteID: config.siteID,
      customScriptUrl: config.callStatsCustomScriptUrl,
      callStatsID: config.callStatsID,
      callStatsSecret: config.callStatsSecret,
      callStatsApplicationLogsDisabled: config.callStatsApplicationLogsDisabled,
      roomName: this.options.name,
      applicationName: config.applicationName,
      configParams: config.callStatsConfigParams
    });
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].analytics.addPermanentProperties({
      "callstats_name": this._statsCurrentId
    });
    if (config.longTasksStatsInterval) {
      this.statistics.attachLongTasksStats(this);
    }
  }
  this.eventManager.setupChatRoomListeners();
  this.eventManager.setupStatisticsListeners();
  if (config.enableTalkWhileMuted && _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].supportsVADDetection()) {
    if (config.createVADProcessor) {
      logger.info("Using VAD detection for generating talk while muted events");
      if (!this._audioAnalyser) {
        this._audioAnalyser = new _modules_detection_VADAudioAnalyser__WEBPACK_IMPORTED_MODULE_22__["default"](this, config.createVADProcessor);
      }
      const vadTalkMutedDetection = new _modules_detection_VADTalkMutedDetection__WEBPACK_IMPORTED_MODULE_24__["default"]();
      vadTalkMutedDetection.on(_modules_detection_DetectionEvents__WEBPACK_IMPORTED_MODULE_19__.VAD_TALK_WHILE_MUTED, () => this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.TALK_WHILE_MUTED));
      this._audioAnalyser.addVADDetectionService(vadTalkMutedDetection);
    } else {
      logger.warn("No VAD Processor was provided. Talk while muted detection service was not initialized!");
    }
  }
  if (config.enableNoisyMicDetection && _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].supportsVADDetection()) {
    if (config.createVADProcessor) {
      if (!this._audioAnalyser) {
        this._audioAnalyser = new _modules_detection_VADAudioAnalyser__WEBPACK_IMPORTED_MODULE_22__["default"](this, config.createVADProcessor);
      }
      const vadNoiseDetection = new _modules_detection_VADNoiseDetection__WEBPACK_IMPORTED_MODULE_23__["default"]();
      vadNoiseDetection.on(_modules_detection_DetectionEvents__WEBPACK_IMPORTED_MODULE_19__.VAD_NOISY_DEVICE, () => this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.NOISY_MIC));
      this._audioAnalyser.addVADDetectionService(vadNoiseDetection);
    } else {
      logger.warn("No VAD Processor was provided. Noisy microphone detection service was not initialized!");
    }
  }
  if (config.enableNoAudioDetection && !config.disableAudioLevels && _modules_statistics_LocalStatsCollector__WEBPACK_IMPORTED_MODULE_36__["default"].isLocalStatsSupported()) {
    this._noAudioSignalDetection = new _modules_detection_NoAudioSignalDetection__WEBPACK_IMPORTED_MODULE_20__["default"](this);
    this._noAudioSignalDetection.on(_modules_detection_DetectionEvents__WEBPACK_IMPORTED_MODULE_19__.NO_AUDIO_INPUT, () => {
      this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.NO_AUDIO_INPUT);
    });
    this._noAudioSignalDetection.on(_modules_detection_DetectionEvents__WEBPACK_IMPORTED_MODULE_19__.AUDIO_INPUT_STATE_CHANGE, (hasAudioSignal) => {
      this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.AUDIO_INPUT_STATE_CHANGE, hasAudioSignal);
    });
  }
  if ("channelLastN" in config) {
    this.setLastN(config.channelLastN);
  }
  this.jvb121Status = new _modules_event_Jvb121EventGenerator__WEBPACK_IMPORTED_MODULE_27__["default"](this);
  this.p2pDominantSpeakerDetection = new _modules_detection_P2PDominantSpeakerDetection__WEBPACK_IMPORTED_MODULE_21__["default"](this);
  if (config && config.deploymentInfo && config.deploymentInfo.userRegion) {
    this.setLocalParticipantProperty("region", config.deploymentInfo.userRegion);
  }
  this.setLocalParticipantProperty("codecList", this.codecSelection.getCodecPreferenceList("jvb"));
  if (config && config.transcriptionLanguage && config.transcriptionLanguage !== "en-US") {
    this.setLocalParticipantProperty("transcription_language", config.transcriptionLanguage);
  }
};
JitsiConference.prototype.join = function(password, replaceParticipant = false) {
  if (this.room) {
    this.room.join(password, replaceParticipant).then(() => this._maybeSetSITimeout());
  }
};
JitsiConference.prototype.authenticateAndUpgradeRole = function(options) {
  return _authenticateAndUpgradeRole__WEBPACK_IMPORTED_MODULE_12__["default"].call(this, Object.assign(Object.assign({}, options), { onCreateResource: JitsiConference.resourceCreator }));
};
JitsiConference.prototype.isJoined = function() {
  return this.room && this.room.joined;
};
JitsiConference.prototype.isP2PEnabled = function() {
  return Boolean(this.options.config.p2p && this.options.config.p2p.enabled) || typeof this.options.config.p2p === "undefined";
};
JitsiConference.prototype.isP2PTestModeEnabled = function() {
  return Boolean(this.options.config.testing && this.options.config.testing.p2pTestMode);
};
JitsiConference.prototype.leave = function(reason) {
  return __awaiter(this, void 0, void 0, function* () {
    if (this.avgRtpStatsReporter) {
      this.avgRtpStatsReporter.dispose();
      this.avgRtpStatsReporter = null;
    }
    if (this._audioOutputProblemDetector) {
      this._audioOutputProblemDetector.dispose();
      this._audioOutputProblemDetector = null;
    }
    if (this.e2eping) {
      this.e2eping.stop();
      this.e2eping = null;
    }
    this.getLocalTracks().forEach((track) => this.onLocalTrackRemoved(track));
    this.rtc.closeBridgeChannel();
    this._sendConferenceLeftAnalyticsEvent();
    if (this.statistics) {
      this.statistics.dispose();
    }
    this._delayedIceFailed && this._delayedIceFailed.cancel();
    this._maybeClearSITimeout();
    if (this.jvbJingleSession) {
      this.jvbJingleSession.close();
      this.jvbJingleSession = null;
    }
    if (this.p2pJingleSession) {
      this.p2pJingleSession.close();
      this.p2pJingleSession = null;
    }
    if (!this.room) {
      throw new Error("You have already left the conference");
    }
    const room = this.room;
    room.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted);
    room.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored);
    room.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished);
    room.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties);
    room.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent);
    room.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.SESSION_ACCEPT, this._updateRoomPresence);
    room.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.SOURCE_ADD, this._updateRoomPresence);
    room.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.SOURCE_ADD_ERROR, this._removeLocalSourceOnReject);
    room.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_55__.XMPPEvents.SOURCE_REMOVE, this._updateRoomPresence);
    this.eventManager.removeXMPPListeners();
    this._signalingLayer.setChatRoom(null);
    this.room = null;
    let leaveError;
    try {
      yield room.leave(reason);
    } catch (err) {
      leaveError = err;
      this.getParticipants().forEach((participant) => this.onMemberLeft(participant.getJid()));
    }
    if (this.rtc) {
      this.rtc.destroy();
    }
    if (leaveError) {
      throw leaveError;
    }
  });
};
JitsiConference.prototype.isEndConferenceSupported = function() {
  return Boolean(this.room && this.room.xmpp.endConferenceComponentAddress);
};
JitsiConference.prototype.end = function() {
  if (!this.isEndConferenceSupported()) {
    logger.warn("Cannot end conference: is not supported.");
    return;
  }
  if (!this.room) {
    throw new Error("You have already left the conference");
  }
  this.room.end();
};
JitsiConference.prototype.getActiveMediaSession = function() {
  return this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession;
};
JitsiConference.prototype.getMediaSessions = function() {
  const sessions = [];
  this.jvbJingleSession && sessions.push(this.jvbJingleSession);
  this.p2pJingleSession && sessions.push(this.p2pJingleSession);
  return sessions;
};
JitsiConference.prototype._registerRtcListeners = function(rtc) {
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_50__["default"].DATA_CHANNEL_OPEN, () => {
    for (const localTrack of this.rtc.localTracks) {
      localTrack.isVideoTrack() && this._sendBridgeVideoTypeMessage(localTrack);
    }
  });
};
JitsiConference.prototype._sendBridgeVideoTypeMessage = function(localtrack) {
  let videoType = !localtrack || localtrack.isMuted() ? (_service_RTC_BridgeVideoType__WEBPACK_IMPORTED_MODULE_47___default().NONE) : localtrack.getVideoType();
  if (videoType === (_service_RTC_BridgeVideoType__WEBPACK_IMPORTED_MODULE_47___default().DESKTOP) && this._desktopSharingFrameRate > _modules_RTC_ScreenObtainer__WEBPACK_IMPORTED_MODULE_15__.SS_DEFAULT_FRAME_RATE) {
    videoType = (_service_RTC_BridgeVideoType__WEBPACK_IMPORTED_MODULE_47___default().DESKTOP_HIGH_FPS);
  }
  localtrack && this.rtc.sendSourceVideoType(localtrack.getSourceName(), videoType);
};
JitsiConference.prototype.getName = function() {
  return this.options.name.toString();
};
JitsiConference.prototype.getConnection = function() {
  return this.connection;
};
JitsiConference.prototype.isAuthEnabled = function() {
  return this.authEnabled;
};
JitsiConference.prototype.isLoggedIn = function() {
  return Boolean(this.authIdentity);
};
JitsiConference.prototype.getAuthLogin = function() {
  return this.authIdentity;
};
JitsiConference.prototype.isExternalAuthEnabled = function() {
  return this.room && this.room.moderator.isExternalAuthEnabled();
};
JitsiConference.prototype.getExternalAuthUrl = function(urlForPopup) {
  return new Promise((resolve, reject) => {
    if (!this.isExternalAuthEnabled()) {
      reject();
      return;
    }
    if (urlForPopup) {
      this.room.moderator.getPopupLoginUrl(resolve, reject);
    } else {
      this.room.moderator.getLoginUrl(resolve, reject);
    }
  });
};
JitsiConference.prototype.getLocalTracks = function(mediaType) {
  let tracks = [];
  if (this.rtc) {
    tracks = this.rtc.getLocalTracks(mediaType);
  }
  return tracks;
};
JitsiConference.prototype.getLocalAudioTrack = function() {
  return this.rtc ? this.rtc.getLocalAudioTrack() : null;
};
JitsiConference.prototype.getLocalVideoTrack = function() {
  return this.rtc ? this.rtc.getLocalVideoTrack() : null;
};
JitsiConference.prototype.getLocalVideoTracks = function() {
  return this.rtc ? this.rtc.getLocalVideoTracks() : null;
};
JitsiConference.prototype.getPerformanceStats = function() {
  return {
    longTasksStats: this.statistics.getLongTasksStats()
  };
};
JitsiConference.prototype.on = function(eventId, handler) {
  if (this.eventEmitter) {
    this.eventEmitter.on(eventId, handler);
  }
};
JitsiConference.prototype.off = function(eventId, handler) {
  if (this.eventEmitter) {
    this.eventEmitter.removeListener(eventId, handler);
  }
};
JitsiConference.prototype.addEventListener = JitsiConference.prototype.on;
JitsiConference.prototype.removeEventListener = JitsiConference.prototype.off;
JitsiConference.prototype.addCommandListener = function(command, handler) {
  if (this.room) {
    this.room.addPresenceListener(command, handler);
  }
};
JitsiConference.prototype.removeCommandListener = function(command, handler) {
  if (this.room) {
    this.room.removePresenceListener(command, handler);
  }
};
JitsiConference.prototype.sendTextMessage = function(message, elementName = "body") {
  if (this.room) {
    this.room.sendMessage(message, elementName);
  }
};
JitsiConference.prototype.sendPrivateTextMessage = function(id, message, elementName = "body") {
  if (this.room) {
    this.room.sendPrivateMessage(id, message, elementName);
  }
};
JitsiConference.prototype.sendCommand = function(name, values) {
  if (this.room) {
    this.room.addOrReplaceInPresence(name, values) && this.room.sendPresence();
  } else {
    logger.warn("Not sending a command, room not initialized.");
  }
};
JitsiConference.prototype.sendCommandOnce = function(name, values) {
  this.sendCommand(name, values);
  this.removeCommand(name);
};
JitsiConference.prototype.removeCommand = function(name) {
  if (this.room) {
    this.room.removeFromPresence(name);
  }
};
JitsiConference.prototype.setDisplayName = function(name) {
  if (this.room) {
    const nickKey = "nick";
    if (name) {
      this.room.addOrReplaceInPresence(nickKey, {
        attributes: { xmlns: "http://jabber.org/protocol/nick" },
        value: name
      }) && this.room.sendPresence();
    } else if (this.room.getFromPresence(nickKey)) {
      this.room.removeFromPresence(nickKey);
      this.room.sendPresence();
    }
  }
};
JitsiConference.prototype.setSubject = function(subject) {
  if (this.room && this.isModerator()) {
    this.room.setSubject(subject);
  } else {
    logger.warn(`Failed to set subject, ${this.room ? "" : "not in a room, "}${this.isModerator() ? "" : "participant is not a moderator"}`);
  }
};
JitsiConference.prototype.getTranscriber = function() {
  if (this.transcriber === void 0) {
    this.transcriber = new _modules_transcription_transcriber__WEBPACK_IMPORTED_MODULE_39__["default"]();
    const localAudioTracks = this.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.AUDIO);
    for (const localAudio of localAudioTracks) {
      this.transcriber.addTrack(localAudio);
    }
    const remoteAudioTracks = this.rtc.getRemoteTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.AUDIO);
    for (const remoteTrack of remoteAudioTracks) {
      this.transcriber.addTrack(remoteTrack);
    }
  }
  return this.transcriber;
};
JitsiConference.prototype.getTranscriptionStatus = function() {
  return this.room.transcriptionStatus;
};
JitsiConference.prototype.addTrack = function(track) {
  var _a;
  if (!track) {
    throw new Error("addTrack - a track is required");
  }
  const mediaType = track.getType();
  const localTracks = this.rtc.getLocalTracks(mediaType);
  if (localTracks.length > 0) {
    if (track === localTracks[0]) {
      return Promise.resolve(track);
    }
    if (_modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_28__["default"].isMultiStreamSendSupportEnabled() && mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO && !localTracks.find((t) => t.getVideoType() === track.getVideoType())) {
      const sourceName = (0,_service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_52__.getSourceNameForJitsiTrack)(this.myUserId(), mediaType, (_a = this.getLocalTracks(mediaType)) === null || _a === void 0 ? void 0 : _a.length);
      track.setSourceName(sourceName);
      const addTrackPromises = [];
      this.p2pJingleSession && addTrackPromises.push(this.p2pJingleSession.addTracks([track]));
      this.jvbJingleSession && addTrackPromises.push(this.jvbJingleSession.addTracks([track]));
      return Promise.all(addTrackPromises).then(() => {
        this._setupNewTrack(track);
        this._sendBridgeVideoTypeMessage(track);
        this._updateRoomPresence(this.getActiveMediaSession());
        if (this.isMutedByFocus || this.isVideoMutedByFocus) {
          this._fireMuteChangeEvent(track);
        }
      });
    }
    return Promise.reject(new Error(`Cannot add second ${mediaType} track to the conference`));
  }
  return this.replaceTrack(null, track).then(() => {
    if (track.getVideoType() === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_53__.VideoType.DESKTOP && _modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_28__["default"].isMultiStreamSendSupportEnabled()) {
      this._updateRoomPresence(this.getActiveMediaSession());
    }
  });
};
JitsiConference.prototype._fireAudioLevelChangeEvent = function(audioLevel, tpc) {
  const activeTpc = this.getActivePeerConnection();
  if (!tpc || activeTpc === tpc) {
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.TRACK_AUDIO_LEVEL_CHANGED, this.myUserId(), audioLevel);
  }
};
JitsiConference.prototype._fireMuteChangeEvent = function(track) {
  if (this.isMutedByFocus && track.isAudioTrack() && !track.isMuted()) {
    this.isMutedByFocus = false;
    this.room.muteParticipant(this.room.myroomjid, false, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.AUDIO);
  } else if (this.isVideoMutedByFocus && track.isVideoTrack() && !track.isMuted()) {
    this.isVideoMutedByFocus = false;
    this.room.muteParticipant(this.room.myroomjid, false, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO);
  }
  let actorParticipant;
  if (this.mutedByFocusActor && track.isAudioTrack()) {
    const actorId = strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getResourceFromJid(this.mutedByFocusActor);
    actorParticipant = this.participants.get(actorId);
  } else if (this.mutedVideoByFocusActor && track.isVideoTrack()) {
    const actorId = strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getResourceFromJid(this.mutedVideoByFocusActor);
    actorParticipant = this.participants.get(actorId);
  }
  const doesVideoMuteByStreamRemove = _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].isReactNative() ? track.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_53__.VideoType.DESKTOP : _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].doesVideoMuteByStreamRemove();
  if (track.isVideoTrack() && !doesVideoMuteByStreamRemove) {
    this._sendBridgeVideoTypeMessage(track);
  }
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.TRACK_MUTE_CHANGED, track, actorParticipant);
};
JitsiConference.prototype._getInitialLocalTracks = function() {
  return this.getLocalTracks().filter((track) => {
    const trackType = track.getType();
    if (trackType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.AUDIO && (!(this.isStartAudioMuted() || this.startMutedPolicy.audio) || _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].isWebKitBased() || _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].isReactNative())) {
      return true;
    } else if (trackType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO && !this.isStartVideoMuted() && !this.startMutedPolicy.video) {
      return true;
    }
    return false;
  });
};
JitsiConference.prototype.onLocalTrackRemoved = function(track) {
  track.setConference(null);
  this.rtc.removeLocalTrack(track);
  track.removeEventListener(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_11__.TRACK_MUTE_CHANGED, track.muteHandler);
  if (track.isAudioTrack()) {
    track.removeEventListener(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_11__.TRACK_AUDIO_LEVEL_CHANGED, track.audioLevelHandler);
  }
  if (track.isVideoTrack() && track.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_53__.VideoType.DESKTOP) {
    this.statistics.sendScreenSharingEvent(false);
  }
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.TRACK_REMOVED, track);
};
JitsiConference.prototype.removeTrack = function(track) {
  return this.replaceTrack(track, null);
};
JitsiConference.prototype.replaceTrack = function(oldTrack, newTrack) {
  var _a;
  const oldVideoType = oldTrack === null || oldTrack === void 0 ? void 0 : oldTrack.getVideoType();
  const mediaType = (oldTrack === null || oldTrack === void 0 ? void 0 : oldTrack.getType()) || (newTrack === null || newTrack === void 0 ? void 0 : newTrack.getType());
  const newVideoType = newTrack === null || newTrack === void 0 ? void 0 : newTrack.getVideoType();
  if (_modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_28__["default"].isMultiStreamSendSupportEnabled() && oldTrack && newTrack && oldVideoType !== newVideoType) {
    throw new Error(`Replacing a track of videoType=${oldVideoType} with a track of videoType=${newVideoType} is not supported in this mode.`);
  }
  if (newTrack) {
    const sourceName = oldTrack ? oldTrack.getSourceName() : (0,_service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_52__.getSourceNameForJitsiTrack)(this.myUserId(), mediaType, (_a = this.getLocalTracks(mediaType)) === null || _a === void 0 ? void 0 : _a.length);
    newTrack.setSourceName(sourceName);
  }
  const oldTrackBelongsToConference = this === (oldTrack === null || oldTrack === void 0 ? void 0 : oldTrack.conference);
  if (oldTrackBelongsToConference && oldTrack.disposed) {
    return Promise.reject(new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_9__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_10__.TRACK_IS_DISPOSED));
  }
  if (newTrack === null || newTrack === void 0 ? void 0 : newTrack.disposed) {
    return Promise.reject(new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_9__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_10__.TRACK_IS_DISPOSED));
  }
  if (oldTrack && !oldTrackBelongsToConference) {
    logger.warn(`JitsiConference.replaceTrack oldTrack (${oldTrack} does not belong to this conference`);
  }
  return this._doReplaceTrack(oldTrackBelongsToConference ? oldTrack : null, newTrack).then(() => {
    if (oldTrackBelongsToConference && !oldTrack.isMuted() && !newTrack) {
      oldTrack._sendMuteStatus(true);
    }
    oldTrackBelongsToConference && this.onLocalTrackRemoved(oldTrack);
    newTrack && this._setupNewTrack(newTrack);
    if (oldTrackBelongsToConference && (oldTrack === null || oldTrack === void 0 ? void 0 : oldTrack.isVideoTrack()) || (newTrack === null || newTrack === void 0 ? void 0 : newTrack.isVideoTrack())) {
      this._sendBridgeVideoTypeMessage(newTrack);
    }
    this._updateRoomPresence(this.getActiveMediaSession());
    if (newTrack !== null && (this.isMutedByFocus || this.isVideoMutedByFocus)) {
      this._fireMuteChangeEvent(newTrack);
    }
    return Promise.resolve();
  }).catch((error) => {
    logger.error(`replaceTrack failed: ${error === null || error === void 0 ? void 0 : error.stack}`);
    return Promise.reject(error);
  });
};
JitsiConference.prototype._doReplaceTrack = function(oldTrack, newTrack) {
  const replaceTrackPromises = [];
  if (this.jvbJingleSession) {
    replaceTrackPromises.push(this.jvbJingleSession.replaceTrack(oldTrack, newTrack));
  } else {
    logger.info("_doReplaceTrack - no JVB JingleSession");
  }
  if (this.p2pJingleSession) {
    replaceTrackPromises.push(this.p2pJingleSession.replaceTrack(oldTrack, newTrack));
  } else {
    logger.info("_doReplaceTrack - no P2P JingleSession");
  }
  return Promise.all(replaceTrackPromises);
};
JitsiConference.prototype._removeLocalSourceOnReject = function(jingleSession, error, mediaType) {
  if (!jingleSession) {
    return;
  }
  logger.warn(`Source-add rejected on ${jingleSession}, reason="${error === null || error === void 0 ? void 0 : error.reason}", message="${error === null || error === void 0 ? void 0 : error.msg}"`);
  const track = this.getLocalTracks(mediaType)[0];
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.TRACK_UNMUTE_REJECTED, track);
};
JitsiConference.prototype._setupNewTrack = function(newTrack) {
  var _a;
  const mediaType = newTrack.getType();
  if (newTrack.isAudioTrack() || newTrack.isVideoTrack() && newTrack.videoType !== _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_53__.VideoType.DESKTOP) {
    const devices = _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_14__["default"].getCurrentlyAvailableMediaDevices();
    const device = devices.find((d) => d.kind === `${newTrack.getTrack().kind}input` && d.label === newTrack.getTrack().label);
    if (device) {
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendActiveDeviceListEvent(_modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_14__["default"].getEventDataForActiveDevice(device));
    }
  }
  if (!newTrack.getSourceName()) {
    const sourceName = (0,_service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_52__.getSourceNameForJitsiTrack)(this.myUserId(), mediaType, (_a = this.getLocalTracks(mediaType)) === null || _a === void 0 ? void 0 : _a.length);
    newTrack.setSourceName(sourceName);
  }
  this.rtc.addLocalTrack(newTrack);
  newTrack.setConference(this);
  if (this.isP2PActive()) {
    this._suspendMediaTransferForJvbConnection();
  }
  newTrack.muteHandler = this._fireMuteChangeEvent.bind(this, newTrack);
  newTrack.addEventListener(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_11__.TRACK_MUTE_CHANGED, newTrack.muteHandler);
  if (newTrack.isAudioTrack()) {
    newTrack.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this);
    newTrack.addEventListener(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_11__.TRACK_AUDIO_LEVEL_CHANGED, newTrack.audioLevelHandler);
  }
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.TRACK_ADDED, newTrack);
};
JitsiConference.prototype._setNewVideoType = function(track) {
  let videoTypeChanged = false;
  if (track) {
    videoTypeChanged = this._signalingLayer.setTrackVideoType(track.getSourceName(), track.videoType);
  }
  return videoTypeChanged;
};
JitsiConference.prototype._setTrackMuteStatus = function(mediaType, localTrack, isMuted) {
  let presenceChanged = false;
  if (localTrack) {
    presenceChanged = this._signalingLayer.setTrackMuteStatus(localTrack.getSourceName(), isMuted);
    presenceChanged && logger.debug(`Mute state of ${localTrack} changed to muted=${isMuted}`);
  }
  return presenceChanged;
};
JitsiConference.prototype._addLocalTrackToPc = function(track) {
  const addPromises = [];
  if (this.jvbJingleSession) {
    addPromises.push(this.jvbJingleSession.addTrackToPc(track));
  } else {
    logger.debug("Add local MediaStream - no JVB Jingle session started yet");
  }
  if (this.p2pJingleSession) {
    addPromises.push(this.p2pJingleSession.addTrackToPc(track));
  } else {
    logger.debug("Add local MediaStream - no P2P Jingle session started yet");
  }
  return Promise.allSettled(addPromises);
};
JitsiConference.prototype._removeLocalTrackFromPc = function(track) {
  const removePromises = [];
  if (this.jvbJingleSession) {
    removePromises.push(this.jvbJingleSession.removeTrackFromPc(track));
  } else {
    logger.debug("Remove local MediaStream - no JVB JingleSession started yet");
  }
  if (this.p2pJingleSession) {
    removePromises.push(this.p2pJingleSession.removeTrackFromPc(track));
  } else {
    logger.debug("Remove local MediaStream - no P2P JingleSession started yet");
  }
  return Promise.allSettled(removePromises);
};
JitsiConference.prototype.getRole = function() {
  return this.room.role;
};
JitsiConference.prototype.isHidden = function() {
  if (!this.connection) {
    return null;
  }
  return strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getDomainFromJid(this.connection.getJid()) === this.options.config.hiddenDomain;
};
JitsiConference.prototype.isModerator = function() {
  return this.room ? this.room.isModerator() : null;
};
JitsiConference.prototype.lock = function(password) {
  if (!this.isModerator()) {
    return Promise.reject(new Error("You are not moderator."));
  }
  return new Promise((resolve, reject) => {
    this.room.lockRoom(password || "", () => resolve(), (err) => reject(err), () => reject(_JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_5__.PASSWORD_NOT_SUPPORTED));
  });
};
JitsiConference.prototype.unlock = function() {
  return this.lock();
};
JitsiConference.prototype.getLastN = function() {
  return this.receiveVideoController.getLastN();
};
JitsiConference.prototype.getForwardedSources = function() {
  return this.rtc.getForwardedSources();
};
JitsiConference.prototype.setLastN = function(lastN) {
  if (!Number.isInteger(lastN) && !Number.parseInt(lastN, 10)) {
    throw new Error(`Invalid value for lastN: ${lastN}`);
  }
  const n = Number(lastN);
  if (n < -1) {
    throw new RangeError("lastN cannot be smaller than -1");
  }
  this.receiveVideoController.setLastN(n);
  if (this.p2pJingleSession) {
    const isVideoActive = n !== 0;
    this.p2pJingleSession.setP2pVideoTransferActive(isVideoActive).catch((error) => {
      logger.error(`Failed to adjust video transfer status (${isVideoActive})`, error);
    });
  }
};
JitsiConference.prototype.getParticipants = function() {
  return Array.from(this.participants.values());
};
JitsiConference.prototype.getParticipantCount = function(countHidden = false) {
  let participants = this.getParticipants();
  if (!countHidden) {
    participants = participants.filter((p) => !p.isHidden());
  }
  return participants.length + 1;
};
JitsiConference.prototype.getParticipantById = function(id) {
  return this.participants.get(id);
};
JitsiConference.prototype.grantOwner = function(id) {
  const participant = this.getParticipantById(id);
  if (!participant) {
    return;
  }
  this.room.setAffiliation(participant.getConnectionJid(), "owner");
};
JitsiConference.prototype.revokeOwner = function(id) {
  const participant = this.getParticipantById(id);
  const isMyself = this.myUserId() === id;
  const role = this.isMembersOnly() ? "member" : "none";
  if (isMyself) {
    this.room.setAffiliation(this.connection.getJid(), role);
  } else if (participant) {
    this.room.setAffiliation(participant.getConnectionJid(), role);
  }
};
JitsiConference.prototype.kickParticipant = function(id, reason) {
  const participant = this.getParticipantById(id);
  if (!participant) {
    return;
  }
  this.room.kick(participant.getJid(), reason);
};
JitsiConference.prototype._maybeClearSITimeout = function() {
  if (this._sessionInitiateTimeout && (this.jvbJingleSession || this.getParticipantCount() < 2)) {
    window.clearTimeout(this._sessionInitiateTimeout);
    this._sessionInitiateTimeout = null;
  }
};
JitsiConference.prototype._maybeSetSITimeout = function() {
  if (!this.jvbJingleSession && this.getParticipantCount() >= 2 && !this._sessionInitiateTimeout) {
    this._sessionInitiateTimeout = window.setTimeout(() => {
      this._sessionInitiateTimeout = null;
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.createJingleEvent)(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.ACTION_JINGLE_SI_TIMEOUT, {
        p2p: false,
        value: JINGLE_SI_TIMEOUT
      }));
    }, JINGLE_SI_TIMEOUT);
  }
};
JitsiConference.prototype.muteParticipant = function(id, mediaType) {
  const muteMediaType = mediaType ? mediaType : _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.AUDIO;
  if (muteMediaType !== _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.AUDIO && muteMediaType !== _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO) {
    logger.error(`Unsupported media type: ${muteMediaType}`);
    return;
  }
  const participant = this.getParticipantById(id);
  if (!participant) {
    return;
  }
  this.room.muteParticipant(participant.getJid(), true, muteMediaType);
};
JitsiConference.prototype.onMemberJoined = function(jid, nick, role, isHidden, statsID, status, identity, botType, fullJid, features, isReplaceParticipant) {
  var _a, _b, _c, _d;
  const id = strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getResourceFromJid(jid);
  if (id === "focus" || this.myUserId() === id) {
    return;
  }
  const participant = new _JitsiParticipant__WEBPACK_IMPORTED_MODULE_8__["default"](jid, this, nick, isHidden, statsID, status, identity);
  participant.setConnectionJid(fullJid);
  participant.setRole(role);
  participant.setBotType(botType);
  participant.setFeatures(features);
  participant.setIsReplacing(isReplaceParticipant);
  const remoteTracks = this.isP2PActive() ? (_b = (_a = this.p2pJingleSession) === null || _a === void 0 ? void 0 : _a.peerconnection.getRemoteTracks(id)) !== null && _b !== void 0 ? _b : [] : (_d = (_c = this.jvbJingleSession) === null || _c === void 0 ? void 0 : _c.peerconnection.getRemoteTracks(id)) !== null && _d !== void 0 ? _d : [];
  for (const track of remoteTracks) {
    participant._tracks.push(track);
  }
  this.participants.set(id, participant);
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.USER_JOINED, id, participant);
  this._updateFeatures(participant);
  if (this.isJoined()) {
    this._maybeStartOrStopP2P();
  }
  this._maybeSetSITimeout();
};
JitsiConference.prototype._onMucJoined = function() {
  this._maybeStartOrStopP2P();
};
JitsiConference.prototype._updateFeatures = function(participant) {
  participant.getFeatures().then((features) => {
    participant._supportsDTMF = features.has("urn:xmpp:jingle:dtmf:0");
    this.updateDTMFSupport();
    if (features.has(_modules_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_46__.FEATURE_JIGASI)) {
      participant.setProperty("features_jigasi", true);
    }
    if (features.has(_modules_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_46__.FEATURE_E2EE)) {
      participant.setProperty("features_e2ee", true);
    }
  }).catch(() => false);
};
JitsiConference.prototype._onMemberBotTypeChanged = function(jid, botType) {
  const peers = this.getParticipants();
  const botParticipant = peers.find((p) => p.getJid() === jid);
  if (botParticipant) {
    botParticipant.setBotType(botType);
    const id = strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getResourceFromJid(jid);
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.BOT_TYPE_CHANGED, id, botType);
  }
  if (!botParticipant.getBotType()) {
    this._maybeStartOrStopP2P();
  }
};
JitsiConference.prototype.onMemberLeft = function(jid, reason) {
  const id = strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getResourceFromJid(jid);
  if (id === "focus" || this.myUserId() === id) {
    return;
  }
  const mediaSessions = this.getMediaSessions();
  let tracksToBeRemoved = [];
  for (const session of mediaSessions) {
    const remoteTracks = session.peerconnection.getRemoteTracks(id);
    remoteTracks && (tracksToBeRemoved = [...tracksToBeRemoved, ...remoteTracks]);
    session._signalingLayer.updateSsrcOwnersOnLeave(id);
    if (!_modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_28__["default"].isSsrcRewritingSupported()) {
      session.removeRemoteStreamsOnLeave(id);
    }
  }
  tracksToBeRemoved.forEach((track) => {
    if (_modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_28__["default"].isSsrcRewritingSupported()) {
      track.setSourceName(null);
      track.setOwner(null);
    } else {
      this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.TRACK_REMOVED, track);
    }
  });
  const participant = this.participants.get(id);
  if (participant) {
    this.participants.delete(id);
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.USER_LEFT, id, participant, reason);
  }
  if (this.room !== null) {
    this._maybeStartOrStopP2P(true);
    this._maybeClearSITimeout();
  }
};
JitsiConference.prototype.onMemberKicked = function(isSelfPresence, actorId, kickedParticipantId, reason, isReplaceParticipant) {
  if (actorId === this.myUserId()) {
    return;
  }
  const actorParticipant = this.participants.get(actorId);
  if (isSelfPresence) {
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.KICKED, actorParticipant, reason, isReplaceParticipant);
    this.leave().finally(() => this.xmpp.disconnect());
    return;
  }
  const kickedParticipant = this.participants.get(kickedParticipantId);
  kickedParticipant.setIsReplaced(isReplaceParticipant);
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.PARTICIPANT_KICKED, actorParticipant, kickedParticipant, reason);
};
JitsiConference.prototype.onLocalRoleChanged = function(role) {
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.USER_ROLE_CHANGED, this.myUserId(), role);
};
JitsiConference.prototype.onUserRoleChanged = function(jid, role) {
  const id = strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getResourceFromJid(jid);
  const participant = this.getParticipantById(id);
  if (!participant) {
    return;
  }
  participant.setRole(role);
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.USER_ROLE_CHANGED, id, role);
};
JitsiConference.prototype.onDisplayNameChanged = function(jid, displayName) {
  const id = strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getResourceFromJid(jid);
  const participant = this.getParticipantById(id);
  if (!participant) {
    return;
  }
  if (participant._displayName === displayName) {
    return;
  }
  participant._displayName = displayName;
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.DISPLAY_NAME_CHANGED, id, displayName);
};
JitsiConference.prototype.onRemoteTrackAdded = function(track) {
  if (track.isP2P && !this.isP2PActive()) {
    logger.info("Trying to add remote P2P track, when not in P2P - IGNORED");
    return;
  } else if (!track.isP2P && this.isP2PActive()) {
    logger.info("Trying to add remote JVB track, when in P2P - IGNORED");
    return;
  }
  const id = track.getParticipantId();
  const participant = this.getParticipantById(id);
  if (participant) {
    participant._tracks.push(track);
  } else {
    logger.info(`Source signaling received before presence for ${id}`);
  }
  if (this.transcriber) {
    this.transcriber.addTrack(track);
  }
  const emitter = this.eventEmitter;
  track.addEventListener(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_11__.TRACK_MUTE_CHANGED, () => emitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.TRACK_MUTE_CHANGED, track));
  track.isAudioTrack() && track.addEventListener(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_11__.TRACK_AUDIO_LEVEL_CHANGED, (audioLevel, tpc) => {
    const activeTPC = this.getActivePeerConnection();
    if (activeTPC === tpc) {
      emitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.TRACK_AUDIO_LEVEL_CHANGED, id, audioLevel);
    }
  });
  emitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.TRACK_ADDED, track);
};
JitsiConference.prototype.onCallAccepted = function(session, answer) {
  if (this.p2pJingleSession === session) {
    logger.info("P2P setAnswer");
    this.p2pJingleSession.setAnswer(answer);
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__._MEDIA_SESSION_STARTED, this.p2pJingleSession);
  }
};
JitsiConference.prototype.onTransportInfo = function(session, transportInfo) {
  if (this.p2pJingleSession === session) {
    logger.info("P2P addIceCandidates");
    this.p2pJingleSession.addIceCandidates(transportInfo);
  }
};
JitsiConference.prototype.onRemoteTrackRemoved = function(removedTrack) {
  this.getParticipants().forEach((participant) => {
    const tracks = participant.getTracks();
    for (let i = 0; i < tracks.length; i++) {
      if (tracks[i] === removedTrack) {
        participant._tracks.splice(i, 1);
        this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.TRACK_REMOVED, removedTrack);
        if (this.transcriber) {
          this.transcriber.removeTrack(removedTrack);
        }
        break;
      }
    }
  }, this);
};
JitsiConference.prototype._onIncomingCallP2P = function(jingleSession, jingleOffer) {
  let rejectReason;
  const usesUnifiedPlan = _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].supportsUnifiedPlan();
  const contentName = jingleOffer.find(">content").attr("name");
  const peerUsesUnifiedPlan = contentName === "0" || contentName === "1";
  if (usesUnifiedPlan !== peerUsesUnifiedPlan) {
    rejectReason = {
      reason: "decline",
      reasonDescription: "P2P disabled",
      errorMsg: "P2P across two endpoints in different SDP modes is disabled"
    };
  } else if (!this.isP2PEnabled() && !this.isP2PTestModeEnabled() || _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].isFirefox() && !this._firefoxP2pEnabled) {
    rejectReason = {
      reason: "decline",
      reasonDescription: "P2P disabled",
      errorMsg: "P2P mode disabled in the configuration or browser unsupported"
    };
  } else if (this.p2pJingleSession) {
    rejectReason = {
      reason: "busy",
      reasonDescription: "P2P already in progress",
      errorMsg: 'Duplicated P2P "session-initiate"'
    };
  } else if (!this._shouldBeInP2PMode()) {
    rejectReason = {
      reason: "decline",
      reasonDescription: "P2P requirements not met",
      errorMsg: 'Received P2P "session-initiate" when should not be in P2P mode'
    };
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.createJingleEvent)(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.ACTION_P2P_DECLINED));
  }
  if (rejectReason) {
    this._rejectIncomingCall(jingleSession, rejectReason);
  } else {
    this._acceptP2PIncomingCall(jingleSession, jingleOffer);
  }
};
JitsiConference.prototype.onIncomingCall = function(jingleSession, jingleOffer, now) {
  if (jingleSession.isP2P) {
    this._onIncomingCallP2P(jingleSession, jingleOffer);
  } else {
    if (!this.isFocus(jingleSession.remoteJid)) {
      const description = "Rejecting session-initiate from non-focus.";
      this._rejectIncomingCall(jingleSession, {
        reason: "security-error",
        reasonDescription: description,
        errorMsg: description
      });
      return;
    }
    this._acceptJvbIncomingCall(jingleSession, jingleOffer, now);
  }
};
JitsiConference.prototype._acceptJvbIncomingCall = function(jingleSession, jingleOffer, now) {
  this.jvbJingleSession = jingleSession;
  this.room.connectionTimes["session.initiate"] = now;
  this._sendConferenceJoinAnalyticsEvent();
  if (this.wasStopped) {
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendAnalyticsAndLog((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.createJingleEvent)(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.ACTION_JINGLE_RESTART, { p2p: false }));
  }
  const serverRegion = jquery__WEBPACK_IMPORTED_MODULE_2___default()(jingleOffer).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("region");
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.SERVER_REGION_CHANGED, serverRegion);
  this._maybeClearSITimeout();
  _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.createJingleEvent)(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.ACTION_JINGLE_SI_RECEIVED, {
    p2p: false,
    value: now
  }));
  try {
    jingleSession.initialize(this.room, this.rtc, this._signalingLayer, Object.assign(Object.assign({}, this.options.config), { codecSettings: {
      mediaType: _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO,
      codecList: this.codecSelection.getCodecPreferenceList("jvb")
    }, enableInsertableStreams: this.isE2EEEnabled() || _modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_28__["default"].isRunInLiteModeEnabled() }));
  } catch (error) {
    _modules_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_40___default().callErrorHandler(error);
    logger.error(error);
    return;
  }
  this._setBridgeChannel(jingleOffer, jingleSession.peerconnection);
  const localTracks = this._getInitialLocalTracks();
  try {
    jingleSession.acceptOffer(jingleOffer, () => {
      if (this.isP2PActive() && this.jvbJingleSession) {
        this._suspendMediaTransferForJvbConnection();
      }
      this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__._MEDIA_SESSION_STARTED, jingleSession);
      if (!this.isP2PActive()) {
        this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__._MEDIA_SESSION_ACTIVE_CHANGED, jingleSession);
      }
    }, (error) => {
      _modules_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_40___default().callErrorHandler(error);
      logger.error("Failed to accept incoming Jingle session", error);
    }, localTracks);
    this._desktopSharingFrameRate && jingleSession.peerconnection.setDesktopSharingFrameRate(this._desktopSharingFrameRate);
    logger.info("Starting CallStats for JVB connection...");
    this.statistics.startCallStats(this.jvbJingleSession.peerconnection, "jitsi");
    this.statistics.startRemoteStats(this.jvbJingleSession.peerconnection);
  } catch (e) {
    _modules_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_40___default().callErrorHandler(e);
    logger.error(e);
  }
};
JitsiConference.prototype._setBridgeChannel = function(offerIq, pc) {
  var _a, _b, _c, _d, _e, _f, _g;
  const ignoreDomain = (_c = (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.bridgeChannel) === null || _c === void 0 ? void 0 : _c.ignoreDomain;
  const preferSctp = (_g = (_f = (_e = (_d = this.connection) === null || _d === void 0 ? void 0 : _d.options) === null || _e === void 0 ? void 0 : _e.bridgeChannel) === null || _f === void 0 ? void 0 : _f.preferSctp) !== null && _g !== void 0 ? _g : false;
  const sctpOffered = jquery__WEBPACK_IMPORTED_MODULE_2___default()(offerIq).find('>content[name="data"]').first().length === 1;
  let wsUrl = null;
  logger.info(`SCTP: offered=${sctpOffered}, prefered=${preferSctp}`);
  if (!(sctpOffered && preferSctp)) {
    jquery__WEBPACK_IMPORTED_MODULE_2___default()(offerIq).find(">content>transport>web-socket").toArray().map((e) => e.getAttribute("url")).forEach((url) => {
      if (!wsUrl && (!ignoreDomain || ignoreDomain !== new URL(url).hostname)) {
        wsUrl = url;
        logger.info(`Using colibri-ws url ${url}`);
      } else if (!wsUrl) {
        logger.info(`Ignoring colibri-ws url with domain ${ignoreDomain}`);
      }
    });
    if (!wsUrl) {
      const firstWsUrl = jquery__WEBPACK_IMPORTED_MODULE_2___default()(offerIq).find(">content>transport>web-socket").first();
      if (firstWsUrl.length === 1) {
        wsUrl = firstWsUrl[0].getAttribute("url");
        logger.info(`Falling back to ${wsUrl}`);
      }
    }
  }
  if (wsUrl && !(sctpOffered && preferSctp)) {
    this.rtc.initializeBridgeChannel(null, wsUrl);
  } else if (sctpOffered) {
    this.rtc.initializeBridgeChannel(pc, null);
  } else {
    logger.warn("Neither SCTP nor a websocket is available. Will not initialize bridge channel.");
  }
};
JitsiConference.prototype._rejectIncomingCall = function(jingleSession, options) {
  if (options === null || options === void 0 ? void 0 : options.errorMsg) {
    logger.warn(options.errorMsg);
  }
  jingleSession.terminate(null, (error) => {
    logger.warn("An error occurred while trying to terminate invalid Jingle session", error);
  }, {
    reason: options && options.reason,
    reasonDescription: options && options.reasonDescription,
    sendSessionTerminate: true
  });
};
JitsiConference.prototype.onCallEnded = function(jingleSession, reasonCondition, reasonText) {
  logger.info(`Call ended: ${reasonCondition} - ${reasonText} P2P ?${jingleSession.isP2P}`);
  if (jingleSession === this.jvbJingleSession) {
    this.wasStopped = true;
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.createJingleEvent)(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.ACTION_JINGLE_TERMINATE, { p2p: false }));
    if (this.statistics) {
      this.statistics.stopRemoteStats(this.jvbJingleSession.peerconnection);
      logger.info("Stopping JVB CallStats");
      this.statistics.stopCallStats(this.jvbJingleSession.peerconnection);
    }
    this.jvbJingleSession = null;
    this.rtc.onCallEnded();
  } else if (jingleSession === this.p2pJingleSession) {
    const stopOptions = {};
    if (reasonCondition === "decline" && reasonText === "force JVB121") {
      logger.info("In forced JVB 121 mode...");
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].analytics.addPermanentProperties({ forceJvb121: true });
    } else if (reasonCondition === "connectivity-error" && reasonText === "ICE FAILED") {
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].analytics.addPermanentProperties({ p2pFailed: true });
    } else if (reasonCondition === "success" && reasonText === "restart") {
      stopOptions.requestRestart = true;
    }
    this._stopP2PSession(stopOptions);
  } else {
    logger.error("Received onCallEnded for invalid session", jingleSession.sid, jingleSession.remoteJid, reasonCondition, reasonText);
  }
};
JitsiConference.prototype.onSuspendDetected = function(jingleSession) {
  if (!jingleSession.isP2P) {
    this.leave();
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.SUSPEND_DETECTED);
  }
};
JitsiConference.prototype.updateDTMFSupport = function() {
  let somebodySupportsDTMF = false;
  const participants = this.getParticipants();
  for (let i = 0; i < participants.length; i += 1) {
    if (participants[i].supportsDTMF()) {
      somebodySupportsDTMF = true;
      break;
    }
  }
  if (somebodySupportsDTMF !== this.somebodySupportsDTMF) {
    this.somebodySupportsDTMF = somebodySupportsDTMF;
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.DTMF_SUPPORT_CHANGED, somebodySupportsDTMF);
  }
};
JitsiConference.prototype.isDTMFSupported = function() {
  return this.somebodySupportsDTMF;
};
JitsiConference.prototype.myUserId = function() {
  return this.room && this.room.myroomjid ? strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getResourceFromJid(this.room.myroomjid) : null;
};
JitsiConference.prototype.sendTones = function(tones, duration, pause) {
  const peerConnection = this.getActivePeerConnection();
  if (peerConnection) {
    peerConnection.sendTones(tones, duration, pause);
  } else {
    logger.warn("cannot sendTones: no peer connection");
  }
};
JitsiConference.prototype.startRecording = function(options) {
  if (this.room) {
    return this.recordingManager.startRecording(options);
  }
  return Promise.reject(new Error("The conference is not created yet!"));
};
JitsiConference.prototype.stopRecording = function(sessionID) {
  if (this.room) {
    return this.recordingManager.stopRecording(sessionID);
  }
  return Promise.reject(new Error("The conference is not created yet!"));
};
JitsiConference.prototype.isSIPCallingSupported = function() {
  var _a, _b, _c;
  return (_c = (_b = (_a = this.room) === null || _a === void 0 ? void 0 : _a.moderator) === null || _b === void 0 ? void 0 : _b.isSipGatewayEnabled()) !== null && _c !== void 0 ? _c : false;
};
JitsiConference.prototype.dial = function(number) {
  if (this.room) {
    return this.room.dial(number);
  }
  return new Promise((resolve, reject) => {
    reject(new Error("The conference is not created yet!"));
  });
};
JitsiConference.prototype.hangup = function() {
  if (this.room) {
    return this.room.hangup();
  }
  return new Promise((resolve, reject) => {
    reject(new Error("The conference is not created yet!"));
  });
};
JitsiConference.prototype.startTranscriber = function() {
  return this.dial("jitsi_meet_transcribe");
};
JitsiConference.prototype.stopTranscriber = JitsiConference.prototype.hangup;
JitsiConference.prototype.getPhoneNumber = function() {
  if (this.room) {
    return this.room.getPhoneNumber();
  }
  return null;
};
JitsiConference.prototype.getPhonePin = function() {
  if (this.room) {
    return this.room.getPhonePin();
  }
  return null;
};
JitsiConference.prototype.getMeetingUniqueId = function() {
  if (this.room) {
    return this.room.getMeetingId();
  }
};
JitsiConference.prototype.getActivePeerConnection = function() {
  const session = this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession;
  return session ? session.peerconnection : null;
};
JitsiConference.prototype.getConnectionState = function() {
  const peerConnection = this.getActivePeerConnection();
  return peerConnection ? peerConnection.getConnectionState() : null;
};
JitsiConference.prototype.setStartMutedPolicy = function(policy) {
  if (!this.isModerator()) {
    logger.warn(`Failed to set start muted policy, ${this.room ? "" : "not in a room, "}${this.isModerator() ? "" : "participant is not a moderator"}`);
    return;
  }
  this.room.addOrReplaceInPresence("startmuted", {
    attributes: {
      audio: policy.audio,
      video: policy.video,
      xmlns: "http://jitsi.org/jitmeet/start-muted"
    }
  }) && this.room.sendPresence();
};
JitsiConference.prototype.getStartMutedPolicy = function() {
  return this.startMutedPolicy;
};
JitsiConference.prototype.isStartAudioMuted = function() {
  return this.startAudioMuted;
};
JitsiConference.prototype.isStartVideoMuted = function() {
  return this.startVideoMuted;
};
JitsiConference.prototype.getConnectionTimes = function() {
  return this.room.connectionTimes;
};
JitsiConference.prototype.setLocalParticipantProperty = function(name, value) {
  this.sendCommand(`jitsi_participant_${name}`, { value });
};
JitsiConference.prototype.removeLocalParticipantProperty = function(name) {
  this.removeCommand(`jitsi_participant_${name}`);
  this.room.sendPresence();
};
JitsiConference.prototype.getLocalParticipantProperty = function(name) {
  const property = this.room.presMap.nodes.find((prop) => prop.tagName === `jitsi_participant_${name}`);
  return property ? property.value : void 0;
};
JitsiConference.prototype.sendFeedback = function(overallFeedback, detailedFeedback) {
  return this.statistics.sendFeedback(overallFeedback, detailedFeedback);
};
JitsiConference.prototype.isCallstatsEnabled = function() {
  return this.statistics.isCallstatsEnabled();
};
JitsiConference.prototype.getSsrcByTrack = function(track) {
  var _a;
  return track.isLocal() ? (_a = this.getActivePeerConnection()) === null || _a === void 0 ? void 0 : _a.getLocalSSRC(track) : track.getSSRC();
};
JitsiConference.prototype._onTrackAttach = function(track, container) {
  const isLocal = track.isLocal();
  let ssrc = null;
  const isP2P = track.isP2P;
  const remoteUserId = isP2P ? track.getParticipantId() : "jitsi";
  const peerConnection = isP2P ? this.p2pJingleSession && this.p2pJingleSession.peerconnection : this.jvbJingleSession && this.jvbJingleSession.peerconnection;
  if (isLocal) {
    if (peerConnection) {
      ssrc = peerConnection.getLocalSSRC(track);
    }
  } else {
    ssrc = track.getSSRC();
  }
  if (!container.id || !ssrc || !peerConnection) {
    return;
  }
  this.statistics.associateStreamWithVideoTag(peerConnection, ssrc, isLocal, remoteUserId, track.getUsageLabel(), container.id);
};
JitsiConference.prototype.sendApplicationLog = function(message) {
  _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendLog(message);
};
JitsiConference.prototype.isFocus = function(mucJid) {
  return this.room ? this.room.isFocus(mucJid) : null;
};
JitsiConference.prototype._fireIncompatibleVersionsEvent = function() {
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_5__.INCOMPATIBLE_SERVER_VERSIONS);
};
JitsiConference.prototype.sendEndpointMessage = function(to, payload) {
  this.rtc.sendChannelMessage(to, payload);
};
JitsiConference.prototype.sendEndpointStatsMessage = function(payload) {
  this.rtc.sendEndpointStatsMessage(payload);
};
JitsiConference.prototype.broadcastEndpointMessage = function(payload) {
  this.sendEndpointMessage("", payload);
};
JitsiConference.prototype.sendMessage = function(message, to = "", sendThroughVideobridge = false) {
  const messageType = typeof message;
  if (messageType !== "object" && (sendThroughVideobridge || messageType !== "string")) {
    logger.error(`Can not send a message of type ${messageType}`);
    return;
  }
  if (sendThroughVideobridge) {
    this.sendEndpointMessage(to, message);
  } else {
    let messageToSend = message;
    let elementName = "body";
    if (messageType === "object") {
      elementName = "json-message";
      if (!messageToSend.hasOwnProperty(_modules_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_46__.JITSI_MEET_MUC_TYPE)) {
        messageToSend[_modules_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_46__.JITSI_MEET_MUC_TYPE] = "";
      }
      try {
        messageToSend = JSON.stringify(messageToSend);
      } catch (e) {
        logger.error("Can not send a message, stringify failed: ", e);
        return;
      }
    }
    if (to) {
      this.sendPrivateTextMessage(to, messageToSend, elementName);
    } else {
      this.sendTextMessage(messageToSend, elementName);
    }
  }
};
JitsiConference.prototype.isConnectionInterrupted = function() {
  return this.isP2PActive() ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted;
};
JitsiConference.prototype._onConferenceRestarted = function(session) {
  if (!session.isP2P && this.options.config.enableForcedReload) {
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_5__.CONFERENCE_RESTARTED);
  }
};
JitsiConference.prototype._onIceConnectionInterrupted = function(session) {
  if (session.isP2P) {
    this.isP2PConnectionInterrupted = true;
  } else {
    this.isJvbConnectionInterrupted = true;
  }
  if (session.isP2P === this.isP2PActive()) {
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.CONNECTION_INTERRUPTED);
  }
};
JitsiConference.prototype._onIceConnectionFailed = function(session) {
  if (session.isP2P) {
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].analytics.addPermanentProperties({ p2pFailed: true });
    if (this.p2pJingleSession) {
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendAnalyticsAndLog((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.createP2PEvent)(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.ACTION_P2P_FAILED, {
        initiator: this.p2pJingleSession.isInitiator
      }));
    }
    this._stopP2PSession({
      reason: "connectivity-error",
      reasonDescription: "ICE FAILED"
    });
  } else if (session && this.jvbJingleSession === session) {
    this._delayedIceFailed = new _modules_connectivity_IceFailedHandling__WEBPACK_IMPORTED_MODULE_18__["default"](this);
    this._delayedIceFailed.start(session);
  }
};
JitsiConference.prototype._onIceConnectionRestored = function(session) {
  if (session.isP2P) {
    this.isP2PConnectionInterrupted = false;
  } else {
    this.isJvbConnectionInterrupted = false;
    this._delayedIceFailed && this._delayedIceFailed.cancel();
  }
  if (session.isP2P === this.isP2PActive()) {
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.CONNECTION_RESTORED);
  }
};
JitsiConference.prototype._acceptP2PIncomingCall = function(jingleSession, jingleOffer) {
  this.isP2PConnectionInterrupted = false;
  this.p2pJingleSession = jingleSession;
  this._sendConferenceJoinAnalyticsEvent();
  this.p2pJingleSession.initialize(this.room, this.rtc, this._signalingLayer, Object.assign(Object.assign({}, this.options.config), { codecSettings: {
    mediaType: _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO,
    codecList: this.codecSelection.getCodecPreferenceList("p2p")
  }, enableInsertableStreams: this.isE2EEEnabled() || _modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_28__["default"].isRunInLiteModeEnabled() }));
  logger.info("Starting CallStats for P2P connection...");
  let remoteID = strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
  const participant = this.participants.get(remoteID);
  if (participant) {
    remoteID = participant.getStatsID() || remoteID;
  }
  this.statistics.startCallStats(this.p2pJingleSession.peerconnection, remoteID);
  const localTracks = this.getLocalTracks();
  this.p2pJingleSession.acceptOffer(jingleOffer, () => {
    logger.debug('Got RESULT for P2P "session-accept"');
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__._MEDIA_SESSION_STARTED, jingleSession);
  }, (error) => {
    logger.error("Failed to accept incoming P2P Jingle session", error);
  }, localTracks);
};
JitsiConference.prototype._addRemoteJVBTracks = function() {
  this._addRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks());
};
JitsiConference.prototype._addRemoteP2PTracks = function() {
  this._addRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks());
};
JitsiConference.prototype._addRemoteTracks = function(logName, remoteTracks) {
  for (const track of remoteTracks) {
    if (_modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_28__["default"].isSsrcRewritingSupported() || this.participants.has(track.ownerEndpointId)) {
      logger.info(`Adding remote ${logName} track: ${track}`);
      this.onRemoteTrackAdded(track);
    }
  }
};
JitsiConference.prototype._onIceConnectionEstablished = function(jingleSession) {
  if (this.p2pJingleSession !== null) {
    this.p2pEstablishmentDuration = this.p2pJingleSession.establishmentDuration;
  }
  if (this.jvbJingleSession !== null) {
    this.jvbEstablishmentDuration = this.jvbJingleSession.establishmentDuration;
  }
  let done = false;
  const forceJVB121Ratio = this.options.config.forceJVB121Ratio;
  if (!jingleSession.isP2P) {
    done = true;
  } else if (this.p2pJingleSession !== jingleSession) {
    logger.error("CONNECTION_ESTABLISHED - wrong P2P session instance ?!");
    done = true;
  } else if (!jingleSession.isInitiator && typeof forceJVB121Ratio === "number" && Math.random() < forceJVB121Ratio) {
    logger.info(`Forcing JVB 121 mode (ratio=${forceJVB121Ratio})...`);
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].analytics.addPermanentProperties({ forceJvb121: true });
    this._stopP2PSession({
      reason: "decline",
      reasonDescription: "force JVB121"
    });
    done = true;
  }
  if (!isNaN(this.p2pEstablishmentDuration) && !isNaN(this.jvbEstablishmentDuration)) {
    const establishmentDurationDiff = this.p2pEstablishmentDuration - this.jvbEstablishmentDuration;
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendAnalytics(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.ICE_ESTABLISHMENT_DURATION_DIFF, { value: establishmentDurationDiff });
  }
  if (jingleSession.isP2P === this.isP2PActive()) {
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.CONNECTION_ESTABLISHED);
  }
  if (done) {
    return;
  }
  this._setP2PStatus(true);
  if (this.jvbJingleSession) {
    this._removeRemoteJVBTracks();
  } else {
    logger.info("Not removing remote JVB tracks - no session yet");
  }
  this._addRemoteP2PTracks();
  if (this.jvbJingleSession) {
    this._suspendMediaTransferForJvbConnection();
  }
  logger.info("Starting remote stats with p2p connection");
  this.statistics.startRemoteStats(this.p2pJingleSession.peerconnection);
  _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendAnalyticsAndLog((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.createP2PEvent)(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.ACTION_P2P_ESTABLISHED, {
    initiator: this.p2pJingleSession.isInitiator
  }));
};
JitsiConference.prototype._updateProperties = function(properties = {}) {
  const changed = !lodash_isequal__WEBPACK_IMPORTED_MODULE_3___default()(properties, this.properties);
  this.properties = properties;
  if (changed) {
    this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.PROPERTIES_CHANGED, this.properties);
    const audioLimitReached = this.properties["audio-limit-reached"] === "true";
    const videoLimitReached = this.properties["video-limit-reached"] === "true";
    if (this._audioSenderLimitReached !== audioLimitReached) {
      this._audioSenderLimitReached = audioLimitReached;
      this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.AUDIO_UNMUTE_PERMISSIONS_CHANGED, audioLimitReached);
      logger.info(`Audio unmute permissions set by Jicofo to ${audioLimitReached}`);
    }
    if (this._videoSenderLimitReached !== videoLimitReached) {
      this._videoSenderLimitReached = videoLimitReached;
      this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.VIDEO_UNMUTE_PERMISSIONS_CHANGED, videoLimitReached);
      logger.info(`Video unmute permissions set by Jicofo to ${videoLimitReached}`);
    }
    const analyticsKeys = [
      "bridge-count"
    ];
    analyticsKeys.forEach((key) => {
      if (properties[key] !== void 0) {
        _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].analytics.addPermanentProperties({
          [key.replace("-", "_")]: properties[key]
        });
      }
    });
  }
};
JitsiConference.prototype.getProperty = function(key) {
  return this.properties[key];
};
JitsiConference.prototype._maybeClearDeferredStartP2P = function() {
  if (this.deferredStartP2PTask) {
    logger.info("Cleared deferred start P2P task");
    clearTimeout(this.deferredStartP2PTask);
    this.deferredStartP2PTask = null;
  }
};
JitsiConference.prototype._removeRemoteJVBTracks = function() {
  this._removeRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks());
};
JitsiConference.prototype._removeRemoteP2PTracks = function() {
  this._removeRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks());
};
JitsiConference.prototype._removeRemoteTracks = function(sessionNickname, remoteTracks) {
  for (const track of remoteTracks) {
    logger.info(`Removing remote ${sessionNickname} track: ${track}`);
    this.onRemoteTrackRemoved(track);
  }
};
JitsiConference.prototype._resumeMediaTransferForJvbConnection = function() {
  logger.info("Resuming media transfer over the JVB connection...");
  this.jvbJingleSession.setMediaTransferActive(true).then(() => {
    logger.info("Resumed media transfer over the JVB connection!");
  }).catch((error) => {
    logger.error("Failed to resume media transfer over the JVB connection:", error);
  });
};
JitsiConference.prototype._setP2PStatus = function(newStatus) {
  if (this.p2p === newStatus) {
    logger.debug(`Called _setP2PStatus with the same status: ${newStatus}`);
    return;
  }
  this.p2p = newStatus;
  if (newStatus) {
    logger.info("Peer to peer connection established!");
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].analytics.addPermanentProperties({
      p2pFailed: false,
      forceJvb121: false
    });
    const isVideoActive = this.getLastN() !== 0;
    this.p2pJingleSession.setP2pVideoTransferActive(isVideoActive).catch((error) => {
      logger.error(`Failed to sync up P2P video transfer status (${isVideoActive}), ${error}`);
    });
  } else {
    logger.info("Peer to peer connection closed!");
  }
  if (this.jvbJingleSession) {
    this.statistics.sendConnectionResumeOrHoldEvent(this.jvbJingleSession.peerconnection, !newStatus);
  }
  this.dtmfManager = null;
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.P2P_STATUS, this, this.p2p);
  this.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__._MEDIA_SESSION_ACTIVE_CHANGED, this.getActiveMediaSession());
  this.eventEmitter.emit(this.isConnectionInterrupted() ? _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.CONNECTION_INTERRUPTED : _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_7__.CONNECTION_RESTORED);
};
JitsiConference.prototype._startP2PSession = function(remoteJid) {
  this._maybeClearDeferredStartP2P();
  if (this.p2pJingleSession) {
    logger.error("P2P session already started!");
    return;
  }
  this.isP2PConnectionInterrupted = false;
  this.p2pJingleSession = this.xmpp.connection.jingle.newP2PJingleSession(this.room.myroomjid, remoteJid);
  logger.info("Created new P2P JingleSession", this.room.myroomjid, remoteJid);
  this._sendConferenceJoinAnalyticsEvent();
  this.p2pJingleSession.initialize(this.room, this.rtc, this._signalingLayer, Object.assign(Object.assign({}, this.options.config), { codecSettings: {
    mediaType: _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO,
    codecList: this.codecSelection.getCodecPreferenceList("p2p")
  }, enableInsertableStreams: this.isE2EEEnabled() || _modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_28__["default"].isRunInLiteModeEnabled() }));
  logger.info("Starting CallStats for P2P connection...");
  let remoteID = strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
  const participant = this.participants.get(remoteID);
  if (participant) {
    remoteID = participant.getStatsID() || remoteID;
  }
  this.statistics.startCallStats(this.p2pJingleSession.peerconnection, remoteID);
  const localTracks = this.getLocalTracks();
  this.p2pJingleSession.invite(localTracks);
};
JitsiConference.prototype._suspendMediaTransferForJvbConnection = function() {
  logger.info("Suspending media transfer over the JVB connection...");
  this.jvbJingleSession.setMediaTransferActive(false).then(() => {
    logger.info("Suspended media transfer over the JVB connection !");
  }).catch((error) => {
    logger.error("Failed to suspend media transfer over the JVB connection:", error);
  });
};
JitsiConference.prototype._maybeStartOrStopP2P = function(userLeftEvent) {
  if (!this.isP2PEnabled() || this.isP2PTestModeEnabled() || _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].isFirefox() && !this._firefoxP2pEnabled || this.isE2EEEnabled()) {
    logger.info("Auto P2P disabled");
    return;
  }
  const peers = this.getParticipants();
  const peerCount = peers.length;
  const shouldBeInP2P = this._shouldBeInP2PMode();
  if (!shouldBeInP2P && this.deferredStartP2PTask) {
    this._maybeClearDeferredStartP2P();
  }
  if (!this.p2pJingleSession && shouldBeInP2P) {
    const peer = peerCount && peers[0];
    const myId = this.myUserId();
    const peersId = peer.getId();
    if (myId > peersId) {
      logger.debug("I'm the bigger peersId - the other peer should start P2P", myId, peersId);
      return;
    } else if (myId === peersId) {
      logger.error("The same IDs ? ", myId, peersId);
      return;
    }
    const jid = peer.getJid();
    if (userLeftEvent) {
      if (this.deferredStartP2PTask) {
        logger.error("Deferred start P2P task's been set already!");
        return;
      }
      logger.info(`Will start P2P with: ${jid} after ${this.backToP2PDelay} seconds...`);
      this.deferredStartP2PTask = setTimeout(this._startP2PSession.bind(this, jid), this.backToP2PDelay * 1e3);
    } else {
      logger.info(`Will start P2P with: ${jid}`);
      this._startP2PSession(jid);
    }
  } else if (this.p2pJingleSession && !shouldBeInP2P) {
    logger.info(`Will stop P2P with: ${this.p2pJingleSession.remoteJid}`);
    if (this.p2pJingleSession.isInitiator && peerCount > 1) {
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendAnalyticsAndLog((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.createP2PEvent)(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.ACTION_P2P_SWITCH_TO_JVB));
    }
    this._stopP2PSession();
  }
};
JitsiConference.prototype._shouldBeInP2PMode = function() {
  const peers = this.getParticipants();
  const peerCount = peers.length;
  const hasBotPeer = peers.find((p) => p.getBotType() === "poltergeist" || p.hasFeature(_modules_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_46__.FEATURE_JIGASI)) !== void 0;
  const shouldBeInP2P = peerCount === 1 && !hasBotPeer;
  logger.debug(`P2P? peerCount: ${peerCount}, hasBotPeer: ${hasBotPeer} => ${shouldBeInP2P}`);
  return shouldBeInP2P;
};
JitsiConference.prototype._stopP2PSession = function(options = {}) {
  const { reason = "success", reasonDescription = "Turning off P2P session", requestRestart = false } = options;
  if (!this.p2pJingleSession) {
    logger.error("No P2P session to be stopped!");
    return;
  }
  const wasP2PEstablished = this.isP2PActive();
  if (wasP2PEstablished) {
    if (this.jvbJingleSession && !requestRestart) {
      this._resumeMediaTransferForJvbConnection();
    }
    this._removeRemoteP2PTracks();
  }
  logger.info("Stopping remote stats for P2P connection");
  this.statistics.stopRemoteStats(this.p2pJingleSession.peerconnection);
  logger.info("Stopping CallStats for P2P connection");
  this.statistics.stopCallStats(this.p2pJingleSession.peerconnection);
  this.p2pJingleSession.terminate(() => {
    logger.info("P2P session terminate RESULT");
  }, (error) => {
    if (reason !== "success") {
      logger.error("An error occurred while trying to terminate P2P Jingle session", error);
    }
  }, {
    reason,
    reasonDescription,
    sendSessionTerminate: this.room && this.getParticipantById(strophe_js__WEBPACK_IMPORTED_MODULE_4__.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid))
  });
  this.p2pJingleSession = null;
  this._setP2PStatus(false);
  if (wasP2PEstablished) {
    if (this.jvbJingleSession && !requestRestart) {
      this._addRemoteJVBTracks();
    } else {
      logger.info("Not adding remote JVB tracks - no session yet");
    }
  }
};
JitsiConference.prototype._updateRoomPresence = function(jingleSession, ctx) {
  if (!jingleSession) {
    return;
  }
  if (ctx) {
    if (ctx.skip) {
      return;
    }
    ctx.skip = true;
  }
  let presenceChanged = false;
  let muteStatusChanged, videoTypeChanged;
  const localTracks = jingleSession.peerconnection.getLocalTracks();
  for (const track of localTracks) {
    const muted = track.isMuted();
    muteStatusChanged = this._setTrackMuteStatus(track.getType(), track, muted);
    muteStatusChanged && logger.debug(`Updating mute state of ${track} in presence to muted=${muted}`);
    if (track.getType() === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO) {
      videoTypeChanged = this._setNewVideoType(track);
      videoTypeChanged && logger.debug(`Updating videoType in presence to ${track.getVideoType()}`);
    }
    presenceChanged = presenceChanged || muteStatusChanged || videoTypeChanged;
  }
  presenceChanged && this.room.sendPresence();
};
JitsiConference.prototype.isP2PActive = function() {
  return this.p2p;
};
JitsiConference.prototype.getP2PConnectionState = function() {
  if (this.isP2PActive()) {
    return this.p2pJingleSession.peerconnection.getConnectionState();
  }
  return null;
};
JitsiConference.prototype.setDesktopSharingFrameRate = function(maxFps) {
  if (typeof maxFps !== "number" || isNaN(maxFps)) {
    logger.error(`Invalid value ${maxFps} specified for desktop capture frame rate`);
    return false;
  }
  this._desktopSharingFrameRate = maxFps;
  this.jvbJingleSession && this.jvbJingleSession.peerconnection.setDesktopSharingFrameRate(maxFps);
  this.rtc.setDesktopSharingFrameRate(maxFps);
  return true;
};
JitsiConference.prototype.startP2PSession = function() {
  const peers = this.getParticipants();
  if (peers.length === 1) {
    const peerJid = peers[0].getJid();
    this._startP2PSession(peerJid);
  } else {
    throw new Error("There must be exactly 1 participant to start the P2P session !");
  }
};
JitsiConference.prototype.stopP2PSession = function(options) {
  this._stopP2PSession(options);
};
JitsiConference.prototype.getSpeakerStats = function() {
  return this.speakerStatsCollector.getStats();
};
JitsiConference.prototype.sendFaceLandmarks = function(payload) {
  if (payload.faceExpression) {
    this.xmpp.sendFaceLandmarksEvent(this.room.roomjid, payload);
  }
};
JitsiConference.prototype.setReceiverConstraints = function(videoConstraints) {
  this.receiveVideoController.setReceiverConstraints(videoConstraints);
};
JitsiConference.prototype.setAssumedBandwidthBps = function(assumedBandwidthBps) {
  this.receiveVideoController.setAssumedBandwidthBps(assumedBandwidthBps);
};
JitsiConference.prototype.setReceiverVideoConstraint = function(maxFrameHeight) {
  this.receiveVideoController.setPreferredReceiveMaxFrameHeight(maxFrameHeight);
};
JitsiConference.prototype.setSenderVideoConstraint = function(maxFrameHeight) {
  return this.sendVideoController.setPreferredSendMaxFrameHeight(maxFrameHeight);
};
JitsiConference.prototype.createVideoSIPGWSession = function(sipAddress, displayName) {
  if (!this.room) {
    return new Error(_modules_videosipgw_VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_44__.ERROR_NO_CONNECTION);
  }
  return this.videoSIPGWHandler.createVideoSIPGWSession(sipAddress, displayName);
};
JitsiConference.prototype._sendConferenceJoinAnalyticsEvent = function() {
  const meetingId = this.getMeetingUniqueId();
  if (this._conferenceJoinAnalyticsEventSent || !meetingId || this.getActivePeerConnection() === null) {
    return;
  }
  _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.createConferenceEvent)("joined", {
    meetingId,
    participantId: `${meetingId}.${this._statsCurrentId}`
  }));
  this._conferenceJoinAnalyticsEventSent = Date.now();
};
JitsiConference.prototype._sendConferenceLeftAnalyticsEvent = function() {
  const meetingId = this.getMeetingUniqueId();
  if (!meetingId || !this._conferenceJoinAnalyticsEventSent) {
    return;
  }
  _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_38__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_54__.createConferenceEvent)("left", {
    meetingId,
    participantId: `${meetingId}.${this._statsCurrentId}`,
    stats: {
      duration: Math.floor((Date.now() - this._conferenceJoinAnalyticsEventSent) / 1e3),
      perf: this.getPerformanceStats()
    }
  }));
};
JitsiConference.prototype._restartMediaSessions = function() {
  if (this.p2pJingleSession) {
    this._stopP2PSession({
      reasonDescription: "restart",
      requestRestart: true
    });
  }
  if (this.jvbJingleSession) {
    this.jvbJingleSession.terminate(null, (error) => {
      logger.warn("An error occurred while trying to terminate the JVB session", error);
    }, {
      reason: "success",
      reasonDescription: "restart required",
      requestRestart: true,
      sendSessionTerminate: true
    });
  }
  this._maybeStartOrStopP2P(false);
};
JitsiConference.prototype.isE2EEEnabled = function() {
  return Boolean(this._e2eEncryption && this._e2eEncryption.isEnabled());
};
JitsiConference.prototype.isE2EESupported = function() {
  return _modules_e2ee_E2EEncryption__WEBPACK_IMPORTED_MODULE_25__.E2EEncryption.isSupported(this.options.config);
};
JitsiConference.prototype.toggleE2EE = function(enabled) {
  if (!this.isE2EESupported()) {
    logger.warn("Cannot enable / disable E2EE: platform is not supported.");
    return;
  }
  this._e2eEncryption.setEnabled(enabled);
};
JitsiConference.prototype.setMediaEncryptionKey = function(keyInfo) {
  this._e2eEncryption.setEncryptionKey(keyInfo);
};
JitsiConference.prototype.startVerification = function(participantId) {
  const participant = this.getParticipantById(participantId);
  if (!participant) {
    return;
  }
  this._e2eEncryption.startVerification(participant);
};
JitsiConference.prototype.markParticipantVerified = function(participantId, isVerified) {
  const participant = this.getParticipantById(participantId);
  if (!participant) {
    return;
  }
  this._e2eEncryption.markParticipantVerified(participant, isVerified);
};
JitsiConference.prototype.isLobbySupported = function() {
  return Boolean(this.room && this.room.getLobby().isSupported());
};
JitsiConference.prototype.isMembersOnly = function() {
  return Boolean(this.room && this.room.membersOnlyEnabled);
};
JitsiConference.prototype.enableLobby = function() {
  if (this.room && this.isModerator()) {
    return this.room.getLobby().enable();
  }
  return Promise.reject(new Error("The conference not started or user is not moderator"));
};
JitsiConference.prototype.disableLobby = function() {
  if (this.room && this.isModerator()) {
    this.room.getLobby().disable();
  } else {
    logger.warn(`Failed to disable lobby, ${this.room ? "" : "not in a room, "}${this.isModerator() ? "" : "participant is not a moderator"}`);
  }
};
JitsiConference.prototype.joinLobby = function(displayName, email) {
  if (this.room) {
    return this.room.getLobby().join(displayName, email);
  }
  return Promise.reject(new Error("The conference not started"));
};
JitsiConference.prototype.myLobbyUserId = function() {
  if (this.room) {
    return this.room.getLobby().getLocalId();
  }
};
JitsiConference.prototype.sendLobbyMessage = function(message, id) {
  if (this.room) {
    if (id) {
      return this.room.getLobby().sendPrivateMessage(id, message);
    }
    return this.room.getLobby().sendMessage(message);
  }
};
JitsiConference.prototype.addLobbyMessageListener = function(listener) {
  if (this.room) {
    return this.room.getLobby().addMessageListener(listener);
  }
};
JitsiConference.prototype.removeLobbyMessageHandler = function(handler) {
  if (this.room) {
    return this.room.getLobby().removeMessageHandler(handler);
  }
};
JitsiConference.prototype.lobbyDenyAccess = function(id) {
  if (this.room) {
    this.room.getLobby().denyAccess(id);
  }
};
JitsiConference.prototype.lobbyApproveAccess = function(id) {
  if (this.room) {
    this.room.getLobby().approveAccess(id);
  }
};
JitsiConference.prototype.isAVModerationSupported = function() {
  return Boolean(this.room && this.room.getAVModeration().isSupported());
};
JitsiConference.prototype.enableAVModeration = function(mediaType) {
  if (this.room && this.isModerator() && (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.AUDIO || mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO)) {
    this.room.getAVModeration().enable(true, mediaType);
  } else {
    logger.warn(`Failed to enable AV moderation, ${this.room ? "" : "not in a room, "}${this.isModerator() ? "" : "participant is not a moderator, "}${this.room && this.isModerator() ? "wrong media type passed" : ""}`);
  }
};
JitsiConference.prototype.disableAVModeration = function(mediaType) {
  if (this.room && this.isModerator() && (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.AUDIO || mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO)) {
    this.room.getAVModeration().enable(false, mediaType);
  } else {
    logger.warn(`Failed to disable AV moderation, ${this.room ? "" : "not in a room, "}${this.isModerator() ? "" : "participant is not a moderator, "}${this.room && this.isModerator() ? "wrong media type passed" : ""}`);
  }
};
JitsiConference.prototype.avModerationApprove = function(mediaType, id) {
  if (this.room && this.isModerator() && (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.AUDIO || mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO)) {
    const participant = this.getParticipantById(id);
    if (!participant) {
      return;
    }
    this.room.getAVModeration().approve(mediaType, participant.getJid());
  } else {
    logger.warn(`AV moderation approve skipped , ${this.room ? "" : "not in a room, "}${this.isModerator() ? "" : "participant is not a moderator, "}${this.room && this.isModerator() ? "wrong media type passed" : ""}`);
  }
};
JitsiConference.prototype.avModerationReject = function(mediaType, id) {
  if (this.room && this.isModerator() && (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.AUDIO || mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_49__.MediaType.VIDEO)) {
    const participant = this.getParticipantById(id);
    if (!participant) {
      return;
    }
    this.room.getAVModeration().reject(mediaType, participant.getJid());
  } else {
    logger.warn(`AV moderation reject skipped , ${this.room ? "" : "not in a room, "}${this.isModerator() ? "" : "participant is not a moderator, "}${this.room && this.isModerator() ? "wrong media type passed" : ""}`);
  }
};
JitsiConference.prototype.getBreakoutRooms = function() {
  var _a;
  return (_a = this.room) === null || _a === void 0 ? void 0 : _a.getBreakoutRooms();
};
JitsiConference.prototype.getMetadataHandler = function() {
  var _a;
  return (_a = this.room) === null || _a === void 0 ? void 0 : _a.getMetadataHandler();
};


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiConferenceErrors.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiConferenceErrors.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AUTHENTICATION_REQUIRED: () => (/* binding */ AUTHENTICATION_REQUIRED),
/* harmony export */   CHAT_ERROR: () => (/* binding */ CHAT_ERROR),
/* harmony export */   CONFERENCE_ACCESS_DENIED: () => (/* binding */ CONFERENCE_ACCESS_DENIED),
/* harmony export */   CONFERENCE_DESTROYED: () => (/* binding */ CONFERENCE_DESTROYED),
/* harmony export */   CONFERENCE_MAX_USERS: () => (/* binding */ CONFERENCE_MAX_USERS),
/* harmony export */   CONFERENCE_RESTARTED: () => (/* binding */ CONFERENCE_RESTARTED),
/* harmony export */   CONNECTION_ERROR: () => (/* binding */ CONNECTION_ERROR),
/* harmony export */   DISPLAY_NAME_REQUIRED: () => (/* binding */ DISPLAY_NAME_REQUIRED),
/* harmony export */   FOCUS_DISCONNECTED: () => (/* binding */ FOCUS_DISCONNECTED),
/* harmony export */   FOCUS_LEFT: () => (/* binding */ FOCUS_LEFT),
/* harmony export */   GRACEFUL_SHUTDOWN: () => (/* binding */ GRACEFUL_SHUTDOWN),
/* harmony export */   ICE_FAILED: () => (/* binding */ ICE_FAILED),
/* harmony export */   INCOMPATIBLE_SERVER_VERSIONS: () => (/* binding */ INCOMPATIBLE_SERVER_VERSIONS),
/* harmony export */   JitsiConferenceErrors: () => (/* binding */ JitsiConferenceErrors),
/* harmony export */   MEMBERS_ONLY_ERROR: () => (/* binding */ MEMBERS_ONLY_ERROR),
/* harmony export */   NOT_ALLOWED_ERROR: () => (/* binding */ NOT_ALLOWED_ERROR),
/* harmony export */   OFFER_ANSWER_FAILED: () => (/* binding */ OFFER_ANSWER_FAILED),
/* harmony export */   PASSWORD_NOT_SUPPORTED: () => (/* binding */ PASSWORD_NOT_SUPPORTED),
/* harmony export */   PASSWORD_REQUIRED: () => (/* binding */ PASSWORD_REQUIRED),
/* harmony export */   REDIRECTED: () => (/* binding */ REDIRECTED),
/* harmony export */   RESERVATION_ERROR: () => (/* binding */ RESERVATION_ERROR),
/* harmony export */   SETTINGS_ERROR: () => (/* binding */ SETTINGS_ERROR),
/* harmony export */   VIDEOBRIDGE_NOT_AVAILABLE: () => (/* binding */ VIDEOBRIDGE_NOT_AVAILABLE)
/* harmony export */ });

var JitsiConferenceErrors;
(function(JitsiConferenceErrors2) {
  JitsiConferenceErrors2["AUTHENTICATION_REQUIRED"] = "conference.authenticationRequired";
  JitsiConferenceErrors2["CHAT_ERROR"] = "conference.chatError";
  JitsiConferenceErrors2["SETTINGS_ERROR"] = "conference.settingsError";
  JitsiConferenceErrors2["CONFERENCE_DESTROYED"] = "conference.destroyed";
  JitsiConferenceErrors2["CONFERENCE_MAX_USERS"] = "conference.max_users";
  JitsiConferenceErrors2["CONNECTION_ERROR"] = "conference.connectionError";
  JitsiConferenceErrors2["CONFERENCE_RESTARTED"] = "conference.restarted";
  JitsiConferenceErrors2["NOT_ALLOWED_ERROR"] = "conference.connectionError.notAllowed";
  JitsiConferenceErrors2["MEMBERS_ONLY_ERROR"] = "conference.connectionError.membersOnly";
  JitsiConferenceErrors2["CONFERENCE_ACCESS_DENIED"] = "conference.connectionError.accessDenied";
  JitsiConferenceErrors2["DISPLAY_NAME_REQUIRED"] = "conference.display_name_required";
  JitsiConferenceErrors2["FOCUS_DISCONNECTED"] = "conference.focusDisconnected";
  JitsiConferenceErrors2["FOCUS_LEFT"] = "conference.focusLeft";
  JitsiConferenceErrors2["GRACEFUL_SHUTDOWN"] = "conference.gracefulShutdown";
  JitsiConferenceErrors2["ICE_FAILED"] = "conference.iceFailed";
  JitsiConferenceErrors2["INCOMPATIBLE_SERVER_VERSIONS"] = "conference.incompatible_server_versions";
  JitsiConferenceErrors2["OFFER_ANSWER_FAILED"] = "conference.offerAnswerFailed";
  JitsiConferenceErrors2["PASSWORD_NOT_SUPPORTED"] = "conference.passwordNotSupported";
  JitsiConferenceErrors2["PASSWORD_REQUIRED"] = "conference.passwordRequired";
  JitsiConferenceErrors2["REDIRECTED"] = "conference.redirected";
  JitsiConferenceErrors2["RESERVATION_ERROR"] = "conference.reservationError";
  JitsiConferenceErrors2["VIDEOBRIDGE_NOT_AVAILABLE"] = "conference.videobridgeNotAvailable";
})(JitsiConferenceErrors || (JitsiConferenceErrors = {}));
;
const AUTHENTICATION_REQUIRED = JitsiConferenceErrors.AUTHENTICATION_REQUIRED;
const CHAT_ERROR = JitsiConferenceErrors.CHAT_ERROR;
const SETTINGS_ERROR = JitsiConferenceErrors.SETTINGS_ERROR;
const CONFERENCE_DESTROYED = JitsiConferenceErrors.CONFERENCE_DESTROYED;
const CONFERENCE_MAX_USERS = JitsiConferenceErrors.CONFERENCE_MAX_USERS;
const CONNECTION_ERROR = JitsiConferenceErrors.CONNECTION_ERROR;
const CONFERENCE_RESTARTED = JitsiConferenceErrors.CONFERENCE_RESTARTED;
const NOT_ALLOWED_ERROR = JitsiConferenceErrors.NOT_ALLOWED_ERROR;
const MEMBERS_ONLY_ERROR = JitsiConferenceErrors.MEMBERS_ONLY_ERROR;
const CONFERENCE_ACCESS_DENIED = JitsiConferenceErrors.CONFERENCE_ACCESS_DENIED;
const DISPLAY_NAME_REQUIRED = JitsiConferenceErrors.DISPLAY_NAME_REQUIRED;
const FOCUS_DISCONNECTED = JitsiConferenceErrors.FOCUS_DISCONNECTED;
const FOCUS_LEFT = JitsiConferenceErrors.FOCUS_LEFT;
const GRACEFUL_SHUTDOWN = JitsiConferenceErrors.GRACEFUL_SHUTDOWN;
const ICE_FAILED = JitsiConferenceErrors.ICE_FAILED;
const INCOMPATIBLE_SERVER_VERSIONS = JitsiConferenceErrors.INCOMPATIBLE_SERVER_VERSIONS;
const OFFER_ANSWER_FAILED = JitsiConferenceErrors.OFFER_ANSWER_FAILED;
const PASSWORD_NOT_SUPPORTED = JitsiConferenceErrors.PASSWORD_NOT_SUPPORTED;
const PASSWORD_REQUIRED = JitsiConferenceErrors.PASSWORD_REQUIRED;
const REDIRECTED = JitsiConferenceErrors.REDIRECTED;
const RESERVATION_ERROR = JitsiConferenceErrors.RESERVATION_ERROR;
const VIDEOBRIDGE_NOT_AVAILABLE = JitsiConferenceErrors.VIDEOBRIDGE_NOT_AVAILABLE;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEventManager.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiConferenceEventManager.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitsiConferenceEventManager)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JitsiConferenceErrors */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceErrors.js");
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./JitsiTrackEvents */ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js");
/* harmony import */ var _modules_statistics_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/statistics/constants */ "../../lib-jitsi-meet/dist/esm/modules/statistics/constants.js");
/* harmony import */ var _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _modules_util_EventEmitterForwarder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/util/EventEmitterForwarder */ "../../lib-jitsi-meet/dist/esm/modules/util/EventEmitterForwarder.js");
/* harmony import */ var _modules_util_EventEmitterForwarder__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_modules_util_EventEmitterForwarder__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _service_authentication_AuthenticationEvents__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./service/authentication/AuthenticationEvents */ "../../lib-jitsi-meet/dist/esm/service/authentication/AuthenticationEvents.js");
/* harmony import */ var _service_authentication_AuthenticationEvents__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_service_authentication_AuthenticationEvents__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");















const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
function JitsiConferenceEventManager(conference) {
  this.conference = conference;
  this.xmppListeners = {};
  conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.TRACK_MUTE_CHANGED, (track) => {
    if (!track.isLocal() || !conference.statistics) {
      return;
    }
    const session = track.isP2P ? conference.p2pJingleSession : conference.jvbJingleSession;
    const tpc = session && session.peerconnection || null;
    conference.statistics.sendMuteEvent(tpc, track.isMuted(), track.getType());
  });
}
JitsiConferenceEventManager.prototype.setupChatRoomListeners = function() {
  const conference = this.conference;
  const chatRoom = conference.room;
  this.chatRoomForwarder = new (_modules_util_EventEmitterForwarder__WEBPACK_IMPORTED_MODULE_7___default())(chatRoom, this.conference.eventEmitter);
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.ICE_RESTARTING, (jingleSession) => {
    if (!jingleSession.isP2P) {
      conference.rtc.closeBridgeChannel();
    }
  });
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.PARTICIPANT_FEATURES_CHANGED, (from, features) => {
    const participant = conference.getParticipantById(strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(from));
    if (participant) {
      participant.setFeatures(features);
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.PARTCIPANT_FEATURES_CHANGED, participant);
    }
  });
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.ICE_RESTART_SUCCESS, (jingleSession, offerIq) => {
    !jingleSession.isP2P && conference._setBridgeChannel(offerIq, jingleSession.peerconnection);
  });
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.AUDIO_MUTED_BY_FOCUS, (actor) => {
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_12__.createRemotelyMutedEvent)(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_8__.MediaType.AUDIO));
    conference.mutedByFocusActor = actor;
    conference.rtc.setAudioMute(true).then(() => {
      conference.isMutedByFocus = true;
      conference.mutedByFocusActor = null;
    }).catch((error) => {
      conference.mutedByFocusActor = null;
      logger.warn("Error while audio muting due to focus request", error);
    });
  });
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.VIDEO_MUTED_BY_FOCUS, (actor) => {
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_12__.createRemotelyMutedEvent)(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_8__.MediaType.VIDEO));
    conference.mutedVideoByFocusActor = actor;
    conference.rtc.setVideoMute(true).then(() => {
      conference.isVideoMutedByFocus = true;
      conference.mutedVideoByFocusActor = null;
    }).catch((error) => {
      conference.mutedVideoByFocusActor = null;
      logger.warn("Error while video muting due to focus request", error);
    });
  });
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.SUBJECT_CHANGED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.SUBJECT_CHANGED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_JOINED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_JOINED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_JOIN_IN_PROGRESS, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_JOIN_IN_PROGRESS);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MEETING_ID_SET, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_UNIQUE_ID_SET);
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_JOINED, () => {
    this.conference._onMucJoined();
    this.conference.isJvbConnectionInterrupted = false;
    Object.keys(chatRoom.connectionTimes).forEach((key) => {
      const event = (0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_12__.createConnectionStageReachedEvent)(`conference_${key}`, { value: chatRoom.connectionTimes[key] });
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendAnalytics(event);
    });
    Object.keys(chatRoom.xmpp.connectionTimes).forEach((key) => {
      const event = (0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_12__.createConnectionStageReachedEvent)(`xmpp_${key}`, { value: chatRoom.xmpp.connectionTimes[key] });
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendAnalytics(event);
    });
  });
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.RENEGOTIATION_FAILED, (e, session) => {
    if (!session.isP2P) {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.OFFER_ANSWER_FAILED, e);
    }
  });
  chatRoom.addListener(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_4__.TRACK_REMOVED, (track) => {
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.TRACK_REMOVED, track);
  });
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.ROOM_JOIN_ERROR, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.CONNECTION_ERROR);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.DISPLAY_NAME_REQUIRED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.DISPLAY_NAME_REQUIRED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.ROOM_CONNECT_ERROR, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.CONNECTION_ERROR);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.NOT_ALLOWED_ERROR);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.MEMBERS_ONLY_ERROR);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.ROOM_MAX_USERS_ERROR, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.CONFERENCE_MAX_USERS);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.PASSWORD_REQUIRED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.PASSWORD_REQUIRED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.AUTHENTICATION_REQUIRED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.AUTHENTICATION_REQUIRED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.REDIRECTED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.REDIRECTED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.BRIDGE_DOWN, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.VIDEOBRIDGE_NOT_AVAILABLE);
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.BRIDGE_DOWN, () => _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_12__.createBridgeDownEvent)()));
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.CONNECTION_RESTARTED, (jingleSession) => {
    conference._onConferenceRestarted(jingleSession);
  });
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.RESERVATION_ERROR, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.RESERVATION_ERROR);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.GRACEFUL_SHUTDOWN, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.GRACEFUL_SHUTDOWN);
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.CONNECTION_ICE_FAILED, (jingleSession) => {
    conference._onIceConnectionFailed(jingleSession);
  });
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_DESTROYED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.CONFERENCE_DESTROYED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.CHAT_ERROR_RECEIVED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_ERROR, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.CHAT_ERROR);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.SETTINGS_ERROR_RECEIVED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_ERROR, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.SETTINGS_ERROR);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.FOCUS_DISCONNECTED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.FOCUS_DISCONNECTED);
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.FOCUS_LEFT, () => {
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_12__.createFocusLeftEvent)());
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.FOCUS_LEFT);
  });
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.SESSION_ACCEPT_TIMEOUT, (jingleSession) => {
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendAnalyticsAndLog((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_12__.createJingleEvent)(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_12__.ACTION_JINGLE_SA_TIMEOUT, { p2p: jingleSession.isP2P }));
  });
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.RECORDER_STATE_CHANGED, (session, jid) => {
    if (jid) {
      const resource = strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(jid);
      const participant = conference.getParticipantById(resource) || resource;
      if (session.getStatus() === "off") {
        session.setTerminator(participant);
      } else if (session.getStatus() === "on") {
        session.setInitiator(participant);
      }
    }
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.RECORDER_STATE_CHANGED, session);
  });
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.TRANSCRIPTION_STATUS_CHANGED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.TRANSCRIPTION_STATUS_CHANGED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.VIDEO_SIP_GW_AVAILABILITY_CHANGED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.VIDEO_SIP_GW_SESSION_STATE_CHANGED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.PHONE_NUMBER_CHANGED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.PHONE_NUMBER_CHANGED);
  chatRoom.setParticipantPropertyListener((node, from) => {
    const participant = conference.getParticipantById(from);
    if (!participant) {
      return;
    }
    participant.setProperty(node.tagName.substring("jitsi_participant_".length), node.value);
  });
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.KICKED, conference.onMemberKicked.bind(conference));
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.SUSPEND_DETECTED, conference.onSuspendDetected.bind(conference));
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_LOCK_CHANGED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.LOCK_STATE_CHANGED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.MEMBERS_ONLY_CHANGED);
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_MEMBER_JOINED, conference.onMemberJoined.bind(conference));
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_LOBBY_MEMBER_JOINED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.LOBBY_USER_JOINED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_LOBBY_MEMBER_UPDATED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.LOBBY_USER_UPDATED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.LOBBY_USER_LEFT);
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_MEMBER_BOT_TYPE_CHANGED, conference._onMemberBotTypeChanged.bind(conference));
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_MEMBER_LEFT, conference.onMemberLeft.bind(conference));
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_LEFT, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_LEFT);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_DENIED_ACCESS, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.CONFERENCE_ACCESS_DENIED);
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.DISPLAY_NAME_CHANGED, conference.onDisplayNameChanged.bind(conference));
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.LOCAL_ROLE_CHANGED, (role) => {
    conference.onLocalRoleChanged(role);
    if (conference.statistics && conference.isModerator()) {
      conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.RECORDER_STATE_CHANGED, (recorderSession) => {
        const logObject = {
          error: recorderSession.getError(),
          id: "recorder_status",
          status: recorderSession.getStatus()
        };
        _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendLog(JSON.stringify(logObject));
      });
    }
  });
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MUC_ROLE_CHANGED, conference.onUserRoleChanged.bind(conference));
  chatRoom.addListener((_service_authentication_AuthenticationEvents__WEBPACK_IMPORTED_MODULE_11___default().IDENTITY_UPDATED), (authEnabled, authIdentity) => {
    conference.authEnabled = authEnabled;
    conference.authIdentity = authIdentity;
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.AUTH_STATUS_CHANGED, authEnabled, authIdentity);
  });
  chatRoom.addListener(
    _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.MESSAGE_RECEIVED,
    (jid, txt, myJid, ts, nick, isGuest) => {
      const id = strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(jid);
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.MESSAGE_RECEIVED, id, txt, ts, nick, isGuest);
    }
  );
  chatRoom.addListener(
    _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.PRIVATE_MESSAGE_RECEIVED,
    (jid, txt, myJid, ts) => {
      const id = strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(jid);
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.PRIVATE_MESSAGE_RECEIVED, id, txt, ts);
    }
  );
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.PRESENCE_STATUS, (jid, status) => {
    const id = strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(jid);
    const participant = conference.getParticipantById(id);
    if (!participant || participant._status === status) {
      return;
    }
    participant._status = status;
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.USER_STATUS_CHANGED, id, status);
  });
  chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.JSON_MESSAGE_RECEIVED, (from, payload) => {
    const id = strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(from);
    const participant = conference.getParticipantById(id);
    if (participant) {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.ENDPOINT_MESSAGE_RECEIVED, participant, payload);
    } else {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.NON_PARTICIPANT_MESSAGE_RECEIVED, id, payload);
    }
  });
  chatRoom.addPresenceListener("startmuted", (data, from) => {
    if (conference.myUserId() === from) {
      return;
    }
    const participant = conference.getParticipantById(from);
    if (!participant || !participant.isModerator()) {
      return;
    }
    const startAudioMuted = data.attributes.audio === "true";
    const startVideoMuted = data.attributes.video === "true";
    let updated = false;
    if (startAudioMuted !== conference.startMutedPolicy.audio) {
      conference.startMutedPolicy.audio = startAudioMuted;
      updated = true;
    }
    if (startVideoMuted !== conference.startMutedPolicy.video) {
      conference.startMutedPolicy.video = startVideoMuted;
      updated = true;
    }
    if (updated) {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.START_MUTED_POLICY_CHANGED, conference.startMutedPolicy);
    }
  });
  if (conference.statistics) {
    chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.CONNECTION_ICE_FAILED, (session) => {
      conference.statistics.sendIceConnectionFailedEvent(session.peerconnection);
    });
    chatRoom.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.ADD_ICE_CANDIDATE_FAILED, (e, pc) => {
      conference.statistics.sendAddIceCandidateFailed(e, pc);
    });
  }
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.BREAKOUT_ROOMS_MOVE_TO_ROOM, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.BREAKOUT_ROOMS_MOVE_TO_ROOM);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.BREAKOUT_ROOMS_UPDATED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.BREAKOUT_ROOMS_UPDATED);
  this.chatRoomForwarder.forward(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.ROOM_METADATA_UPDATED, _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.METADATA_UPDATED);
};
JitsiConferenceEventManager.prototype.setupRTCListeners = function() {
  const conference = this.conference;
  const rtc = conference.rtc;
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].REMOTE_TRACK_ADDED, conference.onRemoteTrackAdded.bind(conference));
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].REMOTE_TRACK_REMOVED, conference.onRemoteTrackRemoved.bind(conference));
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].DOMINANT_SPEAKER_CHANGED, (dominant, previous, silence) => {
    if ((conference.lastDominantSpeaker !== dominant || conference.dominantSpeakerIsSilent !== silence) && conference.room) {
      conference.lastDominantSpeaker = dominant;
      conference.dominantSpeakerIsSilent = silence;
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.DOMINANT_SPEAKER_CHANGED, dominant, previous, silence);
      if (conference.statistics && conference.myUserId() === dominant) {
        conference.statistics.sendDominantSpeakerEvent(conference.room.roomjid, silence);
      }
      if (conference.lastDominantSpeaker !== dominant) {
        if (previous && previous.length) {
          const speakerList = previous.slice(0);
          if (conference.myUserId !== dominant) {
            speakerList.splice(0, 0, dominant);
          }
          if (speakerList.length > _modules_statistics_constants__WEBPACK_IMPORTED_MODULE_5__.SPEAKERS_AUDIO_LEVELS) {
            speakerList.splice(_modules_statistics_constants__WEBPACK_IMPORTED_MODULE_5__.SPEAKERS_AUDIO_LEVELS, speakerList.length - _modules_statistics_constants__WEBPACK_IMPORTED_MODULE_5__.SPEAKERS_AUDIO_LEVELS);
          }
          conference.statistics && conference.statistics.setSpeakerList(speakerList);
        }
      }
    }
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].DATA_CHANNEL_OPEN, () => {
    const now = window.performance.now();
    const key = "data.channel.opened";
    logger.log(`(TIME) ${key}:	`, now);
    conference.room.connectionTimes[key] = now;
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_12__.createConnectionStageReachedEvent)(key, { value: now }));
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.DATA_CHANNEL_OPENED);
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].DATA_CHANNEL_CLOSED, (ev) => {
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.DATA_CHANNEL_CLOSED, ev);
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].VIDEO_SSRCS_REMAPPED, (msg) => {
    for (const session of this.conference.getMediaSessions()) {
      session.processSourceMap(msg, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_8__.MediaType.VIDEO);
    }
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].AUDIO_SSRCS_REMAPPED, (msg) => {
    for (const session of this.conference.getMediaSessions()) {
      session.processSourceMap(msg, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_8__.MediaType.AUDIO);
    }
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].ENDPOINT_MESSAGE_RECEIVED, (from, payload) => {
    const participant = conference.getParticipantById(from);
    if (participant) {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.ENDPOINT_MESSAGE_RECEIVED, participant, payload);
    } else {
      logger.warn(`Ignored ENDPOINT_MESSAGE_RECEIVED for not existing participant: ${from}`, payload);
    }
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].ENDPOINT_STATS_RECEIVED, (from, payload) => {
    const participant = conference.getParticipantById(from);
    if (participant) {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.ENDPOINT_STATS_RECEIVED, participant, payload);
    } else {
      logger.warn(`Ignoring ENDPOINT_STATS_RECEIVED for a non-existant participant: ${from}`);
    }
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].LOCAL_UFRAG_CHANGED, (tpc, ufrag) => {
    if (!tpc.isP2P) {
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendLog(JSON.stringify({
        id: "local_ufrag",
        value: ufrag
      }));
    }
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].REMOTE_UFRAG_CHANGED, (tpc, ufrag) => {
    if (!tpc.isP2P) {
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendLog(JSON.stringify({
        id: "remote_ufrag",
        value: ufrag
      }));
    }
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].CREATE_ANSWER_FAILED, (e, tpc) => {
    conference.statistics.sendCreateAnswerFailed(e, tpc);
    if (!tpc.isP2P) {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.OFFER_ANSWER_FAILED, e);
    }
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].CREATE_OFFER_FAILED, (e, tpc) => {
    conference.statistics.sendCreateOfferFailed(e, tpc);
    if (!tpc.isP2P) {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.OFFER_ANSWER_FAILED, e);
    }
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].SET_LOCAL_DESCRIPTION_FAILED, (e, tpc) => {
    conference.statistics.sendSetLocalDescFailed(e, tpc);
    if (!tpc.isP2P) {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.OFFER_ANSWER_FAILED, e);
    }
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].SET_REMOTE_DESCRIPTION_FAILED, (e, tpc) => {
    conference.statistics.sendSetRemoteDescFailed(e, tpc);
    if (!tpc.isP2P) {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_FAILED, _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_2__.OFFER_ANSWER_FAILED, e);
    }
  });
  rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_9__["default"].LOCAL_TRACK_SSRC_UPDATED, (track, ssrc) => {
    if (track.isVideoTrack() && track.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_10__.VideoType.DESKTOP) {
      conference.statistics.sendScreenSharingEvent(true, ssrc);
    }
  });
};
JitsiConferenceEventManager.prototype.removeXMPPListeners = function() {
  const conference = this.conference;
  Object.keys(this.xmppListeners).forEach((eventName) => {
    conference.xmpp.removeListener(eventName, this.xmppListeners[eventName]);
  });
  this.xmppListeners = {};
};
JitsiConferenceEventManager.prototype.setupXMPPListeners = function() {
  const conference = this.conference;
  this._addConferenceXMPPListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.CALL_INCOMING, conference.onIncomingCall.bind(conference));
  this._addConferenceXMPPListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.CALL_ACCEPTED, conference.onCallAccepted.bind(conference));
  this._addConferenceXMPPListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.TRANSPORT_INFO, conference.onTransportInfo.bind(conference));
  this._addConferenceXMPPListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.CALL_ENDED, conference.onCallEnded.bind(conference));
  this._addConferenceXMPPListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.START_MUTED_FROM_FOCUS, (audioMuted, videoMuted) => {
    if (conference.options.config.ignoreStartMuted) {
      return;
    }
    conference.startAudioMuted = audioMuted;
    conference.startVideoMuted = videoMuted;
    if (audioMuted) {
      conference.isMutedByFocus = true;
    }
    if (videoMuted) {
      conference.isVideoMutedByFocus = true;
    }
    conference.getLocalTracks().forEach((track) => {
      switch (track.getType()) {
        case _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_8__.MediaType.AUDIO:
          conference.startAudioMuted && track.mute();
          break;
        case _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_8__.MediaType.VIDEO:
          conference.startVideoMuted && track.mute();
          break;
      }
    });
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.STARTED_MUTED);
  });
  this._addConferenceXMPPListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.CONFERENCE_TIMESTAMP_RECEIVED, (createdTimestamp) => {
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_CREATED_TIMESTAMP, createdTimestamp);
  });
  this._addConferenceXMPPListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.AV_MODERATION_CHANGED, (value, mediaType, actorJid) => {
    const actorParticipant = conference.getParticipants().find((p) => p.getJid() === actorJid);
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.AV_MODERATION_CHANGED, {
      enabled: value,
      mediaType,
      actor: actorParticipant
    });
  });
  this._addConferenceXMPPListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.AV_MODERATION_PARTICIPANT_APPROVED, (mediaType, jid) => {
    const participant = conference.getParticipantById(strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(jid));
    if (participant) {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.AV_MODERATION_PARTICIPANT_APPROVED, {
        participant,
        mediaType
      });
    }
  });
  this._addConferenceXMPPListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.AV_MODERATION_PARTICIPANT_REJECTED, (mediaType, jid) => {
    const participant = conference.getParticipantById(strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(jid));
    if (participant) {
      conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.AV_MODERATION_PARTICIPANT_REJECTED, {
        participant,
        mediaType
      });
    }
  });
  this._addConferenceXMPPListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.AV_MODERATION_APPROVED, (value) => conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.AV_MODERATION_APPROVED, { mediaType: value }));
  this._addConferenceXMPPListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_13__.XMPPEvents.AV_MODERATION_REJECTED, (value) => {
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.AV_MODERATION_REJECTED, { mediaType: value });
  });
};
JitsiConferenceEventManager.prototype._addConferenceXMPPListener = function(eventName, listener) {
  this.xmppListeners[eventName] = listener;
  this.conference.xmpp.addListener(eventName, listener);
};
JitsiConferenceEventManager.prototype.setupStatisticsListeners = function() {
  const conference = this.conference;
  if (!conference.statistics) {
    return;
  }
  conference.statistics.addAudioLevelListener((tpc, ssrc, level, isLocal) => {
    conference.rtc.setAudioLevel(tpc, ssrc, level, isLocal);
  });
  conference.statistics.addBeforeDisposedListener(() => {
    conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.BEFORE_STATISTICS_DISPOSED);
  });
  if (!conference.options.config.startSilent) {
    conference.statistics.addByteSentStatsListener((tpc, stats) => {
      conference.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_8__.MediaType.AUDIO).forEach((track) => {
        const ssrc = tpc.getLocalSSRC(track);
        if (!ssrc || !stats.hasOwnProperty(ssrc)) {
          return;
        }
        track.onByteSentStatsReceived(tpc, stats[ssrc]);
      });
    });
  }
};


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AUDIO_INPUT_STATE_CHANGE: () => (/* binding */ AUDIO_INPUT_STATE_CHANGE),
/* harmony export */   AUDIO_UNMUTE_PERMISSIONS_CHANGED: () => (/* binding */ AUDIO_UNMUTE_PERMISSIONS_CHANGED),
/* harmony export */   AUTH_STATUS_CHANGED: () => (/* binding */ AUTH_STATUS_CHANGED),
/* harmony export */   AV_MODERATION_APPROVED: () => (/* binding */ AV_MODERATION_APPROVED),
/* harmony export */   AV_MODERATION_CHANGED: () => (/* binding */ AV_MODERATION_CHANGED),
/* harmony export */   AV_MODERATION_PARTICIPANT_APPROVED: () => (/* binding */ AV_MODERATION_PARTICIPANT_APPROVED),
/* harmony export */   AV_MODERATION_PARTICIPANT_REJECTED: () => (/* binding */ AV_MODERATION_PARTICIPANT_REJECTED),
/* harmony export */   AV_MODERATION_REJECTED: () => (/* binding */ AV_MODERATION_REJECTED),
/* harmony export */   BEFORE_STATISTICS_DISPOSED: () => (/* binding */ BEFORE_STATISTICS_DISPOSED),
/* harmony export */   BOT_TYPE_CHANGED: () => (/* binding */ BOT_TYPE_CHANGED),
/* harmony export */   BREAKOUT_ROOMS_MOVE_TO_ROOM: () => (/* binding */ BREAKOUT_ROOMS_MOVE_TO_ROOM),
/* harmony export */   BREAKOUT_ROOMS_UPDATED: () => (/* binding */ BREAKOUT_ROOMS_UPDATED),
/* harmony export */   CONFERENCE_CREATED_TIMESTAMP: () => (/* binding */ CONFERENCE_CREATED_TIMESTAMP),
/* harmony export */   CONFERENCE_ERROR: () => (/* binding */ CONFERENCE_ERROR),
/* harmony export */   CONFERENCE_FAILED: () => (/* binding */ CONFERENCE_FAILED),
/* harmony export */   CONFERENCE_JOINED: () => (/* binding */ CONFERENCE_JOINED),
/* harmony export */   CONFERENCE_JOIN_IN_PROGRESS: () => (/* binding */ CONFERENCE_JOIN_IN_PROGRESS),
/* harmony export */   CONFERENCE_LEFT: () => (/* binding */ CONFERENCE_LEFT),
/* harmony export */   CONFERENCE_UNIQUE_ID_SET: () => (/* binding */ CONFERENCE_UNIQUE_ID_SET),
/* harmony export */   CONNECTION_ESTABLISHED: () => (/* binding */ CONNECTION_ESTABLISHED),
/* harmony export */   CONNECTION_INTERRUPTED: () => (/* binding */ CONNECTION_INTERRUPTED),
/* harmony export */   CONNECTION_RESTORED: () => (/* binding */ CONNECTION_RESTORED),
/* harmony export */   DATA_CHANNEL_CLOSED: () => (/* binding */ DATA_CHANNEL_CLOSED),
/* harmony export */   DATA_CHANNEL_OPENED: () => (/* binding */ DATA_CHANNEL_OPENED),
/* harmony export */   DISPLAY_NAME_CHANGED: () => (/* binding */ DISPLAY_NAME_CHANGED),
/* harmony export */   DOMINANT_SPEAKER_CHANGED: () => (/* binding */ DOMINANT_SPEAKER_CHANGED),
/* harmony export */   DTMF_SUPPORT_CHANGED: () => (/* binding */ DTMF_SUPPORT_CHANGED),
/* harmony export */   E2EE_VERIFICATION_AVAILABLE: () => (/* binding */ E2EE_VERIFICATION_AVAILABLE),
/* harmony export */   E2EE_VERIFICATION_COMPLETED: () => (/* binding */ E2EE_VERIFICATION_COMPLETED),
/* harmony export */   E2EE_VERIFICATION_READY: () => (/* binding */ E2EE_VERIFICATION_READY),
/* harmony export */   ENDPOINT_MESSAGE_RECEIVED: () => (/* binding */ ENDPOINT_MESSAGE_RECEIVED),
/* harmony export */   ENDPOINT_STATS_RECEIVED: () => (/* binding */ ENDPOINT_STATS_RECEIVED),
/* harmony export */   FORWARDED_SOURCES_CHANGED: () => (/* binding */ FORWARDED_SOURCES_CHANGED),
/* harmony export */   JVB121_STATUS: () => (/* binding */ JVB121_STATUS),
/* harmony export */   JitsiConferenceEvents: () => (/* binding */ JitsiConferenceEvents),
/* harmony export */   KICKED: () => (/* binding */ KICKED),
/* harmony export */   LAST_N_ENDPOINTS_CHANGED: () => (/* binding */ LAST_N_ENDPOINTS_CHANGED),
/* harmony export */   LOBBY_USER_JOINED: () => (/* binding */ LOBBY_USER_JOINED),
/* harmony export */   LOBBY_USER_LEFT: () => (/* binding */ LOBBY_USER_LEFT),
/* harmony export */   LOBBY_USER_UPDATED: () => (/* binding */ LOBBY_USER_UPDATED),
/* harmony export */   LOCK_STATE_CHANGED: () => (/* binding */ LOCK_STATE_CHANGED),
/* harmony export */   MEMBERS_ONLY_CHANGED: () => (/* binding */ MEMBERS_ONLY_CHANGED),
/* harmony export */   MESSAGE_RECEIVED: () => (/* binding */ MESSAGE_RECEIVED),
/* harmony export */   METADATA_UPDATED: () => (/* binding */ METADATA_UPDATED),
/* harmony export */   NOISY_MIC: () => (/* binding */ NOISY_MIC),
/* harmony export */   NON_PARTICIPANT_MESSAGE_RECEIVED: () => (/* binding */ NON_PARTICIPANT_MESSAGE_RECEIVED),
/* harmony export */   NO_AUDIO_INPUT: () => (/* binding */ NO_AUDIO_INPUT),
/* harmony export */   P2P_STATUS: () => (/* binding */ P2P_STATUS),
/* harmony export */   PARTCIPANT_FEATURES_CHANGED: () => (/* binding */ PARTCIPANT_FEATURES_CHANGED),
/* harmony export */   PARTICIPANT_KICKED: () => (/* binding */ PARTICIPANT_KICKED),
/* harmony export */   PARTICIPANT_PROPERTY_CHANGED: () => (/* binding */ PARTICIPANT_PROPERTY_CHANGED),
/* harmony export */   PARTICIPANT_SOURCE_UPDATED: () => (/* binding */ PARTICIPANT_SOURCE_UPDATED),
/* harmony export */   PHONE_NUMBER_CHANGED: () => (/* binding */ PHONE_NUMBER_CHANGED),
/* harmony export */   PRIVATE_MESSAGE_RECEIVED: () => (/* binding */ PRIVATE_MESSAGE_RECEIVED),
/* harmony export */   PROPERTIES_CHANGED: () => (/* binding */ PROPERTIES_CHANGED),
/* harmony export */   RECORDER_STATE_CHANGED: () => (/* binding */ RECORDER_STATE_CHANGED),
/* harmony export */   SERVER_REGION_CHANGED: () => (/* binding */ SERVER_REGION_CHANGED),
/* harmony export */   STARTED_MUTED: () => (/* binding */ STARTED_MUTED),
/* harmony export */   START_MUTED_POLICY_CHANGED: () => (/* binding */ START_MUTED_POLICY_CHANGED),
/* harmony export */   SUBJECT_CHANGED: () => (/* binding */ SUBJECT_CHANGED),
/* harmony export */   SUSPEND_DETECTED: () => (/* binding */ SUSPEND_DETECTED),
/* harmony export */   TALK_WHILE_MUTED: () => (/* binding */ TALK_WHILE_MUTED),
/* harmony export */   TRACK_ADDED: () => (/* binding */ TRACK_ADDED),
/* harmony export */   TRACK_AUDIO_LEVEL_CHANGED: () => (/* binding */ TRACK_AUDIO_LEVEL_CHANGED),
/* harmony export */   TRACK_MUTE_CHANGED: () => (/* binding */ TRACK_MUTE_CHANGED),
/* harmony export */   TRACK_REMOVED: () => (/* binding */ TRACK_REMOVED),
/* harmony export */   TRACK_UNMUTE_REJECTED: () => (/* binding */ TRACK_UNMUTE_REJECTED),
/* harmony export */   TRANSCRIPTION_STATUS_CHANGED: () => (/* binding */ TRANSCRIPTION_STATUS_CHANGED),
/* harmony export */   USER_JOINED: () => (/* binding */ USER_JOINED),
/* harmony export */   USER_LEFT: () => (/* binding */ USER_LEFT),
/* harmony export */   USER_ROLE_CHANGED: () => (/* binding */ USER_ROLE_CHANGED),
/* harmony export */   USER_STATUS_CHANGED: () => (/* binding */ USER_STATUS_CHANGED),
/* harmony export */   VIDEO_SIP_GW_AVAILABILITY_CHANGED: () => (/* binding */ VIDEO_SIP_GW_AVAILABILITY_CHANGED),
/* harmony export */   VIDEO_SIP_GW_SESSION_STATE_CHANGED: () => (/* binding */ VIDEO_SIP_GW_SESSION_STATE_CHANGED),
/* harmony export */   VIDEO_UNMUTE_PERMISSIONS_CHANGED: () => (/* binding */ VIDEO_UNMUTE_PERMISSIONS_CHANGED),
/* harmony export */   _MEDIA_SESSION_ACTIVE_CHANGED: () => (/* binding */ _MEDIA_SESSION_ACTIVE_CHANGED),
/* harmony export */   _MEDIA_SESSION_STARTED: () => (/* binding */ _MEDIA_SESSION_STARTED)
/* harmony export */ });

var JitsiConferenceEvents;
(function(JitsiConferenceEvents2) {
  JitsiConferenceEvents2["AUDIO_INPUT_STATE_CHANGE"] = "conference.audio_input_state_changed";
  JitsiConferenceEvents2["AUDIO_UNMUTE_PERMISSIONS_CHANGED"] = "conference.audio_unmute_permissions_changed";
  JitsiConferenceEvents2["AUTH_STATUS_CHANGED"] = "conference.auth_status_changed";
  JitsiConferenceEvents2["BEFORE_STATISTICS_DISPOSED"] = "conference.beforeStatisticsDisposed";
  JitsiConferenceEvents2["CONFERENCE_ERROR"] = "conference.error";
  JitsiConferenceEvents2["CONFERENCE_FAILED"] = "conference.failed";
  JitsiConferenceEvents2["CONFERENCE_JOIN_IN_PROGRESS"] = "conference.join_in_progress";
  JitsiConferenceEvents2["CONFERENCE_JOINED"] = "conference.joined";
  JitsiConferenceEvents2["CONFERENCE_LEFT"] = "conference.left";
  JitsiConferenceEvents2["CONFERENCE_UNIQUE_ID_SET"] = "conference.unique_id_set";
  JitsiConferenceEvents2["CONNECTION_ESTABLISHED"] = "conference.connectionEstablished";
  JitsiConferenceEvents2["CONNECTION_INTERRUPTED"] = "conference.connectionInterrupted";
  JitsiConferenceEvents2["CONNECTION_RESTORED"] = "conference.connectionRestored";
  JitsiConferenceEvents2["DATA_CHANNEL_OPENED"] = "conference.dataChannelOpened";
  JitsiConferenceEvents2["DATA_CHANNEL_CLOSED"] = "conference.dataChannelClosed";
  JitsiConferenceEvents2["DISPLAY_NAME_CHANGED"] = "conference.displayNameChanged";
  JitsiConferenceEvents2["DOMINANT_SPEAKER_CHANGED"] = "conference.dominantSpeaker";
  JitsiConferenceEvents2["CONFERENCE_CREATED_TIMESTAMP"] = "conference.createdTimestamp";
  JitsiConferenceEvents2["DTMF_SUPPORT_CHANGED"] = "conference.dtmfSupportChanged";
  JitsiConferenceEvents2["ENDPOINT_MESSAGE_RECEIVED"] = "conference.endpoint_message_received";
  JitsiConferenceEvents2["ENDPOINT_STATS_RECEIVED"] = "conference.endpoint_stats_received";
  JitsiConferenceEvents2["JVB121_STATUS"] = "conference.jvb121Status";
  JitsiConferenceEvents2["KICKED"] = "conference.kicked";
  JitsiConferenceEvents2["PARTICIPANT_KICKED"] = "conference.participant_kicked";
  JitsiConferenceEvents2["LAST_N_ENDPOINTS_CHANGED"] = "conference.lastNEndpointsChanged";
  JitsiConferenceEvents2["FORWARDED_SOURCES_CHANGED"] = "conference.forwardedSourcesChanged";
  JitsiConferenceEvents2["LOCK_STATE_CHANGED"] = "conference.lock_state_changed";
  JitsiConferenceEvents2["SERVER_REGION_CHANGED"] = "conference.server_region_changed";
  JitsiConferenceEvents2["_MEDIA_SESSION_STARTED"] = "conference.media_session.started";
  JitsiConferenceEvents2["_MEDIA_SESSION_ACTIVE_CHANGED"] = "conference.media_session.active_changed";
  JitsiConferenceEvents2["MEMBERS_ONLY_CHANGED"] = "conference.membersOnlyChanged";
  JitsiConferenceEvents2["MESSAGE_RECEIVED"] = "conference.messageReceived";
  JitsiConferenceEvents2["NO_AUDIO_INPUT"] = "conference.no_audio_input";
  JitsiConferenceEvents2["NOISY_MIC"] = "conference.noisy_mic";
  JitsiConferenceEvents2["NON_PARTICIPANT_MESSAGE_RECEIVED"] = "conference.non_participant_message_received";
  JitsiConferenceEvents2["PRIVATE_MESSAGE_RECEIVED"] = "conference.privateMessageReceived";
  JitsiConferenceEvents2["PARTCIPANT_FEATURES_CHANGED"] = "conference.partcipant_features_changed";
  JitsiConferenceEvents2["PARTICIPANT_PROPERTY_CHANGED"] = "conference.participant_property_changed";
  JitsiConferenceEvents2["PARTICIPANT_SOURCE_UPDATED"] = "conference.participant_source_updated";
  JitsiConferenceEvents2["P2P_STATUS"] = "conference.p2pStatus";
  JitsiConferenceEvents2["PHONE_NUMBER_CHANGED"] = "conference.phoneNumberChanged";
  JitsiConferenceEvents2["PROPERTIES_CHANGED"] = "conference.propertiesChanged";
  JitsiConferenceEvents2["RECORDER_STATE_CHANGED"] = "conference.recorderStateChanged";
  JitsiConferenceEvents2["VIDEO_SIP_GW_AVAILABILITY_CHANGED"] = "conference.videoSIPGWAvailabilityChanged";
  JitsiConferenceEvents2["VIDEO_SIP_GW_SESSION_STATE_CHANGED"] = "conference.videoSIPGWSessionStateChanged";
  JitsiConferenceEvents2["START_MUTED_POLICY_CHANGED"] = "conference.start_muted_policy_changed";
  JitsiConferenceEvents2["STARTED_MUTED"] = "conference.started_muted";
  JitsiConferenceEvents2["SUBJECT_CHANGED"] = "conference.subjectChanged";
  JitsiConferenceEvents2["SUSPEND_DETECTED"] = "conference.suspendDetected";
  JitsiConferenceEvents2["TALK_WHILE_MUTED"] = "conference.talk_while_muted";
  JitsiConferenceEvents2["TRACK_ADDED"] = "conference.trackAdded";
  JitsiConferenceEvents2["TRACK_AUDIO_LEVEL_CHANGED"] = "conference.audioLevelsChanged";
  JitsiConferenceEvents2["TRACK_MUTE_CHANGED"] = "conference.trackMuteChanged";
  JitsiConferenceEvents2["TRACK_REMOVED"] = "conference.trackRemoved";
  JitsiConferenceEvents2["TRACK_UNMUTE_REJECTED"] = "conference.trackUnmuteRejected";
  JitsiConferenceEvents2["TRANSCRIPTION_STATUS_CHANGED"] = "conference.transcriptionStatusChanged";
  JitsiConferenceEvents2["USER_JOINED"] = "conference.userJoined";
  JitsiConferenceEvents2["USER_LEFT"] = "conference.userLeft";
  JitsiConferenceEvents2["USER_ROLE_CHANGED"] = "conference.roleChanged";
  JitsiConferenceEvents2["USER_STATUS_CHANGED"] = "conference.statusChanged";
  JitsiConferenceEvents2["VIDEO_UNMUTE_PERMISSIONS_CHANGED"] = "conference.video_unmute_permissions_changed";
  JitsiConferenceEvents2["BOT_TYPE_CHANGED"] = "conference.bot_type_changed";
  JitsiConferenceEvents2["LOBBY_USER_JOINED"] = "conference.lobby.userJoined";
  JitsiConferenceEvents2["LOBBY_USER_UPDATED"] = "conference.lobby.userUpdated";
  JitsiConferenceEvents2["LOBBY_USER_LEFT"] = "conference.lobby.userLeft";
  JitsiConferenceEvents2["AV_MODERATION_APPROVED"] = "conference.av_moderation.approved";
  JitsiConferenceEvents2["AV_MODERATION_REJECTED"] = "conference.av_moderation.rejected";
  JitsiConferenceEvents2["AV_MODERATION_CHANGED"] = "conference.av_moderation.changed";
  JitsiConferenceEvents2["AV_MODERATION_PARTICIPANT_APPROVED"] = "conference.av_moderation.participant.approved";
  JitsiConferenceEvents2["AV_MODERATION_PARTICIPANT_REJECTED"] = "conference.av_moderation.participant.rejected";
  JitsiConferenceEvents2["BREAKOUT_ROOMS_MOVE_TO_ROOM"] = "conference.breakout-rooms.move-to-room";
  JitsiConferenceEvents2["BREAKOUT_ROOMS_UPDATED"] = "conference.breakout-rooms.updated";
  JitsiConferenceEvents2["METADATA_UPDATED"] = "conference.metadata.updated";
  JitsiConferenceEvents2["E2EE_VERIFICATION_AVAILABLE"] = "conference.e2ee.verification.available";
  JitsiConferenceEvents2["E2EE_VERIFICATION_READY"] = "conference.e2ee.verification.ready";
  JitsiConferenceEvents2["E2EE_VERIFICATION_COMPLETED"] = "conference.e2ee.verification.completed";
})(JitsiConferenceEvents || (JitsiConferenceEvents = {}));
;
const AUDIO_INPUT_STATE_CHANGE = JitsiConferenceEvents.AUDIO_INPUT_STATE_CHANGE;
const AUDIO_UNMUTE_PERMISSIONS_CHANGED = JitsiConferenceEvents.AUDIO_UNMUTE_PERMISSIONS_CHANGED;
const AUTH_STATUS_CHANGED = JitsiConferenceEvents.AUTH_STATUS_CHANGED;
const BEFORE_STATISTICS_DISPOSED = JitsiConferenceEvents.BEFORE_STATISTICS_DISPOSED;
const CONFERENCE_ERROR = JitsiConferenceEvents.CONFERENCE_ERROR;
const CONFERENCE_FAILED = JitsiConferenceEvents.CONFERENCE_FAILED;
const CONFERENCE_JOIN_IN_PROGRESS = JitsiConferenceEvents.CONFERENCE_JOIN_IN_PROGRESS;
const CONFERENCE_JOINED = JitsiConferenceEvents.CONFERENCE_JOINED;
const CONFERENCE_LEFT = JitsiConferenceEvents.CONFERENCE_LEFT;
const CONFERENCE_UNIQUE_ID_SET = JitsiConferenceEvents.CONFERENCE_UNIQUE_ID_SET;
const CONNECTION_ESTABLISHED = JitsiConferenceEvents.CONNECTION_ESTABLISHED;
const CONNECTION_INTERRUPTED = JitsiConferenceEvents.CONNECTION_INTERRUPTED;
const CONNECTION_RESTORED = JitsiConferenceEvents.CONNECTION_RESTORED;
const DATA_CHANNEL_OPENED = JitsiConferenceEvents.DATA_CHANNEL_OPENED;
const DATA_CHANNEL_CLOSED = JitsiConferenceEvents.DATA_CHANNEL_CLOSED;
const DISPLAY_NAME_CHANGED = JitsiConferenceEvents.DISPLAY_NAME_CHANGED;
const DOMINANT_SPEAKER_CHANGED = JitsiConferenceEvents.DOMINANT_SPEAKER_CHANGED;
const CONFERENCE_CREATED_TIMESTAMP = JitsiConferenceEvents.CONFERENCE_CREATED_TIMESTAMP;
const DTMF_SUPPORT_CHANGED = JitsiConferenceEvents.DTMF_SUPPORT_CHANGED;
const ENDPOINT_MESSAGE_RECEIVED = JitsiConferenceEvents.ENDPOINT_MESSAGE_RECEIVED;
const ENDPOINT_STATS_RECEIVED = JitsiConferenceEvents.ENDPOINT_STATS_RECEIVED;
const E2EE_VERIFICATION_AVAILABLE = JitsiConferenceEvents.E2EE_VERIFICATION_AVAILABLE;
const E2EE_VERIFICATION_READY = JitsiConferenceEvents.E2EE_VERIFICATION_READY;
const E2EE_VERIFICATION_COMPLETED = JitsiConferenceEvents.E2EE_VERIFICATION_COMPLETED;
const JVB121_STATUS = JitsiConferenceEvents.JVB121_STATUS;
const KICKED = JitsiConferenceEvents.KICKED;
const PARTICIPANT_KICKED = JitsiConferenceEvents.PARTICIPANT_KICKED;
const PARTICIPANT_SOURCE_UPDATED = JitsiConferenceEvents.PARTICIPANT_SOURCE_UPDATED;
const LAST_N_ENDPOINTS_CHANGED = JitsiConferenceEvents.LAST_N_ENDPOINTS_CHANGED;
const FORWARDED_SOURCES_CHANGED = JitsiConferenceEvents.FORWARDED_SOURCES_CHANGED;
const LOCK_STATE_CHANGED = JitsiConferenceEvents.LOCK_STATE_CHANGED;
const SERVER_REGION_CHANGED = JitsiConferenceEvents.SERVER_REGION_CHANGED;
const _MEDIA_SESSION_STARTED = JitsiConferenceEvents._MEDIA_SESSION_STARTED;
const _MEDIA_SESSION_ACTIVE_CHANGED = JitsiConferenceEvents._MEDIA_SESSION_ACTIVE_CHANGED;
const MEMBERS_ONLY_CHANGED = JitsiConferenceEvents.MEMBERS_ONLY_CHANGED;
const MESSAGE_RECEIVED = JitsiConferenceEvents.MESSAGE_RECEIVED;
const NO_AUDIO_INPUT = JitsiConferenceEvents.NO_AUDIO_INPUT;
const NOISY_MIC = JitsiConferenceEvents.NOISY_MIC;
const NON_PARTICIPANT_MESSAGE_RECEIVED = JitsiConferenceEvents.NON_PARTICIPANT_MESSAGE_RECEIVED;
const PRIVATE_MESSAGE_RECEIVED = JitsiConferenceEvents.PRIVATE_MESSAGE_RECEIVED;
const PARTCIPANT_FEATURES_CHANGED = JitsiConferenceEvents.PARTCIPANT_FEATURES_CHANGED;
const PARTICIPANT_PROPERTY_CHANGED = JitsiConferenceEvents.PARTICIPANT_PROPERTY_CHANGED;
const P2P_STATUS = JitsiConferenceEvents.P2P_STATUS;
const PHONE_NUMBER_CHANGED = JitsiConferenceEvents.PHONE_NUMBER_CHANGED;
const PROPERTIES_CHANGED = JitsiConferenceEvents.PROPERTIES_CHANGED;
const RECORDER_STATE_CHANGED = JitsiConferenceEvents.RECORDER_STATE_CHANGED;
const VIDEO_SIP_GW_AVAILABILITY_CHANGED = JitsiConferenceEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED;
const VIDEO_SIP_GW_SESSION_STATE_CHANGED = JitsiConferenceEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED;
const START_MUTED_POLICY_CHANGED = JitsiConferenceEvents.START_MUTED_POLICY_CHANGED;
const STARTED_MUTED = JitsiConferenceEvents.STARTED_MUTED;
const SUBJECT_CHANGED = JitsiConferenceEvents.SUBJECT_CHANGED;
const SUSPEND_DETECTED = JitsiConferenceEvents.SUSPEND_DETECTED;
const TALK_WHILE_MUTED = JitsiConferenceEvents.TALK_WHILE_MUTED;
const TRACK_ADDED = JitsiConferenceEvents.TRACK_ADDED;
const TRACK_AUDIO_LEVEL_CHANGED = JitsiConferenceEvents.TRACK_AUDIO_LEVEL_CHANGED;
const TRACK_MUTE_CHANGED = JitsiConferenceEvents.TRACK_MUTE_CHANGED;
const TRACK_REMOVED = JitsiConferenceEvents.TRACK_REMOVED;
const TRACK_UNMUTE_REJECTED = JitsiConferenceEvents.TRACK_UNMUTE_REJECTED;
const TRANSCRIPTION_STATUS_CHANGED = JitsiConferenceEvents.TRANSCRIPTION_STATUS_CHANGED;
const USER_JOINED = JitsiConferenceEvents.USER_JOINED;
const USER_LEFT = JitsiConferenceEvents.USER_LEFT;
const USER_ROLE_CHANGED = JitsiConferenceEvents.USER_ROLE_CHANGED;
const USER_STATUS_CHANGED = JitsiConferenceEvents.USER_STATUS_CHANGED;
const VIDEO_UNMUTE_PERMISSIONS_CHANGED = JitsiConferenceEvents.VIDEO_UNMUTE_PERMISSIONS_CHANGED;
const BOT_TYPE_CHANGED = JitsiConferenceEvents.BOT_TYPE_CHANGED;
const LOBBY_USER_JOINED = JitsiConferenceEvents.LOBBY_USER_JOINED;
const LOBBY_USER_UPDATED = JitsiConferenceEvents.LOBBY_USER_UPDATED;
const LOBBY_USER_LEFT = JitsiConferenceEvents.LOBBY_USER_LEFT;
const AV_MODERATION_APPROVED = JitsiConferenceEvents.AV_MODERATION_APPROVED;
const AV_MODERATION_REJECTED = JitsiConferenceEvents.AV_MODERATION_REJECTED;
const AV_MODERATION_CHANGED = JitsiConferenceEvents.AV_MODERATION_CHANGED;
const AV_MODERATION_PARTICIPANT_APPROVED = JitsiConferenceEvents.AV_MODERATION_PARTICIPANT_APPROVED;
const AV_MODERATION_PARTICIPANT_REJECTED = JitsiConferenceEvents.AV_MODERATION_PARTICIPANT_REJECTED;
const BREAKOUT_ROOMS_MOVE_TO_ROOM = JitsiConferenceEvents.BREAKOUT_ROOMS_MOVE_TO_ROOM;
const BREAKOUT_ROOMS_UPDATED = JitsiConferenceEvents.BREAKOUT_ROOMS_UPDATED;
const METADATA_UPDATED = JitsiConferenceEvents.METADATA_UPDATED;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiConnection.js":
/*!********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiConnection.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitsiConnection)
/* harmony export */ });
/* harmony import */ var _JitsiConference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JitsiConference */ "../../lib-jitsi-meet/dist/esm/JitsiConference.js");
/* harmony import */ var _JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JitsiConnectionEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConnectionEvents.js");
/* harmony import */ var _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _modules_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/xmpp/xmpp */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/xmpp.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");






function JitsiConnection(appID, token, options) {
  this.appID = appID;
  this.token = token;
  this.options = options;
  this.xmpp = new _modules_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_3__["default"](options, token);
  this.addEventListener(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_FAILED, (errType, msg, credentials, details) => {
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_2__["default"].sendAnalyticsAndLog((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__.createConnectionFailedEvent)(errType, msg, details));
  });
  this.addEventListener(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_DISCONNECTED, (msg) => {
    if (msg) {
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_2__["default"].sendAnalytics(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__.CONNECTION_DISCONNECTED, { message: msg });
    }
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_2__["default"].sendLog(JSON.stringify({
      id: _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__.CONNECTION_DISCONNECTED,
      msg
    }));
  });
}
JitsiConnection.prototype.connect = function(options = {}) {
  this.xmpp.connect(options.id, options.password);
};
JitsiConnection.prototype.attach = function(options) {
  this.xmpp.attach(options);
};
JitsiConnection.prototype.disconnect = function(...args) {
  return this.xmpp.disconnect(...args);
};
JitsiConnection.prototype.getJid = function() {
  return this.xmpp.getJid();
};
JitsiConnection.prototype.setToken = function(token) {
  this.token = token;
};
JitsiConnection.prototype.initJitsiConference = function(name, options) {
  return new _JitsiConference__WEBPACK_IMPORTED_MODULE_0__["default"]({
    name,
    config: options,
    connection: this
  });
};
JitsiConnection.prototype.addEventListener = function(event, listener) {
  this.xmpp.addListener(event, listener);
};
JitsiConnection.prototype.removeEventListener = function(event, listener) {
  this.xmpp.removeListener(event, listener);
};
JitsiConnection.prototype.getConnectionTimes = function() {
  return this.xmpp.connectionTimes;
};
JitsiConnection.prototype.addFeature = function(feature, submit = false) {
  this.xmpp.caps.addFeature(feature, submit, true);
};
JitsiConnection.prototype.removeFeature = function(feature, submit = false) {
  this.xmpp.caps.removeFeature(feature, submit, true);
};
JitsiConnection.prototype.getLogs = function() {
  const data = this.xmpp.getJingleLog();
  const metadata = {};
  metadata.time = new Date();
  metadata.url = window.location.href;
  metadata.ua = navigator.userAgent;
  const log = this.xmpp.getXmppLog();
  if (log) {
    metadata.xmpp = log;
  }
  data.metadata = metadata;
  return data;
};


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiConnectionErrors.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiConnectionErrors.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CONNECTION_DROPPED_ERROR: () => (/* binding */ CONNECTION_DROPPED_ERROR),
/* harmony export */   JitsiConnectionErrors: () => (/* binding */ JitsiConnectionErrors),
/* harmony export */   OTHER_ERROR: () => (/* binding */ OTHER_ERROR),
/* harmony export */   PASSWORD_REQUIRED: () => (/* binding */ PASSWORD_REQUIRED),
/* harmony export */   SERVER_ERROR: () => (/* binding */ SERVER_ERROR)
/* harmony export */ });

var JitsiConnectionErrors;
(function(JitsiConnectionErrors2) {
  JitsiConnectionErrors2["CONNECTION_DROPPED_ERROR"] = "connection.droppedError";
  JitsiConnectionErrors2["OTHER_ERROR"] = "connection.otherError";
  JitsiConnectionErrors2["PASSWORD_REQUIRED"] = "connection.passwordRequired";
  JitsiConnectionErrors2["SERVER_ERROR"] = "connection.serverError";
})(JitsiConnectionErrors || (JitsiConnectionErrors = {}));
;
const CONNECTION_DROPPED_ERROR = JitsiConnectionErrors.CONNECTION_DROPPED_ERROR;
const OTHER_ERROR = JitsiConnectionErrors.OTHER_ERROR;
const PASSWORD_REQUIRED = JitsiConnectionErrors.PASSWORD_REQUIRED;
const SERVER_ERROR = JitsiConnectionErrors.SERVER_ERROR;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiConnectionEvents.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiConnectionEvents.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CONNECTION_DISCONNECTED: () => (/* binding */ CONNECTION_DISCONNECTED),
/* harmony export */   CONNECTION_ESTABLISHED: () => (/* binding */ CONNECTION_ESTABLISHED),
/* harmony export */   CONNECTION_FAILED: () => (/* binding */ CONNECTION_FAILED),
/* harmony export */   DISPLAY_NAME_REQUIRED: () => (/* binding */ DISPLAY_NAME_REQUIRED),
/* harmony export */   JitsiConnectionEvents: () => (/* binding */ JitsiConnectionEvents),
/* harmony export */   WRONG_STATE: () => (/* binding */ WRONG_STATE)
/* harmony export */ });

var JitsiConnectionEvents;
(function(JitsiConnectionEvents2) {
  JitsiConnectionEvents2["CONNECTION_DISCONNECTED"] = "connection.connectionDisconnected";
  JitsiConnectionEvents2["CONNECTION_ESTABLISHED"] = "connection.connectionEstablished";
  JitsiConnectionEvents2["CONNECTION_FAILED"] = "connection.connectionFailed";
  JitsiConnectionEvents2["WRONG_STATE"] = "connection.wrongState";
  JitsiConnectionEvents2["DISPLAY_NAME_REQUIRED"] = "connection.display_name_required";
})(JitsiConnectionEvents || (JitsiConnectionEvents = {}));
;
const CONNECTION_DISCONNECTED = JitsiConnectionEvents.CONNECTION_DISCONNECTED;
const CONNECTION_ESTABLISHED = JitsiConnectionEvents.CONNECTION_ESTABLISHED;
const CONNECTION_FAILED = JitsiConnectionEvents.CONNECTION_FAILED;
const WRONG_STATE = JitsiConnectionEvents.WRONG_STATE;
const DISPLAY_NAME_REQUIRED = JitsiConnectionEvents.DISPLAY_NAME_REQUIRED;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiMediaDevices.js":
/*!**********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiMediaDevices.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiMediaDevicesEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JitsiMediaDevicesEvents */ "../../lib-jitsi-meet/dist/esm/JitsiMediaDevicesEvents.js");
/* harmony import */ var _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/RTC/RTC */ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTC.js");
/* harmony import */ var _modules_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");








const AUDIO_PERMISSION_NAME = "microphone";
const PERMISSION_GRANTED_STATUS = "granted";
const VIDEO_PERMISSION_NAME = "camera";
class JitsiMediaDevices {
  constructor() {
    this._eventEmitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())();
    this._permissions = {};
    _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].DEVICE_LIST_CHANGED, (devices) => this._eventEmitter.emit(_JitsiMediaDevicesEvents__WEBPACK_IMPORTED_MODULE_1__.DEVICE_LIST_CHANGED, devices));
    _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].DEVICE_LIST_AVAILABLE, (devices) => this._logOutputDevice(this.getAudioOutputDevice(), devices));
    _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].PERMISSIONS_CHANGED, (permissions) => this._handlePermissionsChange(permissions));
    this._permissionsApiSupported = new Promise((resolve) => {
      if (!navigator.permissions) {
        resolve(false);
        return;
      }
      const self = this;
      const promises = [];
      promises.push(navigator.permissions.query({ name: VIDEO_PERMISSION_NAME }).then((status) => {
        this._handlePermissionsChange({
          [_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO]: this._parsePermissionState(status)
        });
        status.onchange = function() {
          try {
            self._handlePermissionsChange({
              [_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO]: self._parsePermissionState(this)
            });
          } catch (error) {
          }
        };
        return true;
      }).catch(() => false));
      promises.push(navigator.permissions.query({ name: AUDIO_PERMISSION_NAME }).then((status) => {
        this._handlePermissionsChange({
          [_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO]: this._parsePermissionState(status)
        });
        status.onchange = function() {
          try {
            self._handlePermissionsChange({
              [_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO]: self._parsePermissionState(this)
            });
          } catch (error) {
          }
        };
        return true;
      }).catch(() => false));
      Promise.all(promises).then((results) => resolve(results.every((supported) => supported)));
    });
  }
  _parsePermissionState(permissionStatus = {}) {
    const status = permissionStatus.state || permissionStatus.status;
    if (typeof status !== "string") {
      throw new TypeError();
    }
    return status === PERMISSION_GRANTED_STATUS;
  }
  _handlePermissionsChange(permissions) {
    const hasPermissionsChanged = [_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO].some((type) => type in permissions && permissions[type] !== this._permissions[type]);
    if (hasPermissionsChanged) {
      this._permissions = Object.assign(Object.assign({}, this._permissions), permissions);
      this._eventEmitter.emit(_JitsiMediaDevicesEvents__WEBPACK_IMPORTED_MODULE_1__.PERMISSIONS_CHANGED, this._permissions);
      if (this._permissions[_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO] || this._permissions[_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO]) {
        this.enumerateDevices(() => {
        });
      }
    }
  }
  _logOutputDevice(deviceID, devices) {
    const device = devices.find((d) => d.kind === "audiooutput" && d.deviceId === deviceID);
    if (device) {
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_4__["default"].sendActiveDeviceListEvent(_modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].getEventDataForActiveDevice(device));
    }
  }
  enumerateDevices(callback) {
    _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].enumerateDevices(callback);
  }
  isDeviceListAvailable() {
    return _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].isDeviceListAvailable();
  }
  isDeviceChangeAvailable(deviceType) {
    return _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].isDeviceChangeAvailable(deviceType);
  }
  isDevicePermissionGranted(type) {
    return new Promise((resolve) => {
      if (type in this._permissions) {
        resolve(this._permissions[type]);
        return;
      }
      this._permissionsApiSupported.then((supported) => {
        if (!supported) {
          resolve(false);
          return;
        }
        const promises = [];
        switch (type) {
          case _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO:
            promises.push(navigator.permissions.query({
              name: VIDEO_PERMISSION_NAME
            }));
            break;
          case _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO:
            promises.push(navigator.permissions.query({
              name: AUDIO_PERMISSION_NAME
            }));
            break;
          default:
            promises.push(navigator.permissions.query({
              name: VIDEO_PERMISSION_NAME
            }));
            promises.push(navigator.permissions.query({
              name: AUDIO_PERMISSION_NAME
            }));
        }
        Promise.all(promises).then((results) => resolve(results.every((permissionStatus) => {
          try {
            return this._parsePermissionState(permissionStatus);
          } catch (_a) {
            return false;
          }
        })), () => resolve(false));
      });
    });
  }
  isMultipleAudioInputSupported() {
    return !(_modules_browser__WEBPACK_IMPORTED_MODULE_3__["default"].isFirefox() && _modules_browser__WEBPACK_IMPORTED_MODULE_3__["default"].isVersionLessThan("101") || _modules_browser__WEBPACK_IMPORTED_MODULE_3__["default"].isIosBrowser());
  }
  getAudioOutputDevice() {
    return _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].getAudioOutputDevice();
  }
  setAudioOutputDevice(deviceId) {
    const availableDevices = _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].getCurrentlyAvailableMediaDevices();
    if (availableDevices.length > 0) {
      this._logOutputDevice(deviceId, _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].getCurrentlyAvailableMediaDevices());
    }
    return _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].setAudioOutputDevice(deviceId);
  }
  addEventListener(event, handler) {
    this._eventEmitter.addListener(event, handler);
  }
  removeEventListener(event, handler) {
    this._eventEmitter.removeListener(event, handler);
  }
  emitEvent(event, ...args) {
    this._eventEmitter.emit(event, ...args);
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new JitsiMediaDevices());


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiMediaDevicesEvents.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiMediaDevicesEvents.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEVICE_LIST_CHANGED: () => (/* binding */ DEVICE_LIST_CHANGED),
/* harmony export */   JitsiMediaDevicesEvents: () => (/* binding */ JitsiMediaDevicesEvents),
/* harmony export */   PERMISSIONS_CHANGED: () => (/* binding */ PERMISSIONS_CHANGED),
/* harmony export */   PERMISSION_PROMPT_IS_SHOWN: () => (/* binding */ PERMISSION_PROMPT_IS_SHOWN),
/* harmony export */   SLOW_GET_USER_MEDIA: () => (/* binding */ SLOW_GET_USER_MEDIA)
/* harmony export */ });

var JitsiMediaDevicesEvents;
(function(JitsiMediaDevicesEvents2) {
  JitsiMediaDevicesEvents2["DEVICE_LIST_CHANGED"] = "mediaDevices.devicechange";
  JitsiMediaDevicesEvents2["PERMISSIONS_CHANGED"] = "rtc.permissions_changed";
  JitsiMediaDevicesEvents2["PERMISSION_PROMPT_IS_SHOWN"] = "mediaDevices.permissionPromptIsShown";
  JitsiMediaDevicesEvents2["SLOW_GET_USER_MEDIA"] = "mediaDevices.slowGetUserMedia";
})(JitsiMediaDevicesEvents || (JitsiMediaDevicesEvents = {}));
;
const DEVICE_LIST_CHANGED = JitsiMediaDevicesEvents.DEVICE_LIST_CHANGED;
const PERMISSIONS_CHANGED = JitsiMediaDevicesEvents.PERMISSIONS_CHANGED;
const PERMISSION_PROMPT_IS_SHOWN = JitsiMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN;
const SLOW_GET_USER_MEDIA = JitsiMediaDevicesEvents.SLOW_GET_USER_MEDIA;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiMeetJS.js":
/*!****************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiMeetJS.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JitsiConferenceErrors */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceErrors.js");
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _JitsiConnection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./JitsiConnection */ "../../lib-jitsi-meet/dist/esm/JitsiConnection.js");
/* harmony import */ var _JitsiConnectionErrors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./JitsiConnectionErrors */ "../../lib-jitsi-meet/dist/esm/JitsiConnectionErrors.js");
/* harmony import */ var _JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./JitsiConnectionEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConnectionEvents.js");
/* harmony import */ var _JitsiMediaDevices__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./JitsiMediaDevices */ "../../lib-jitsi-meet/dist/esm/JitsiMediaDevices.js");
/* harmony import */ var _JitsiMediaDevicesEvents__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./JitsiMediaDevicesEvents */ "../../lib-jitsi-meet/dist/esm/JitsiMediaDevicesEvents.js");
/* harmony import */ var _JitsiTrackError__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./JitsiTrackError */ "../../lib-jitsi-meet/dist/esm/JitsiTrackError.js");
/* harmony import */ var _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./JitsiTrackErrors */ "../../lib-jitsi-meet/dist/esm/JitsiTrackErrors.js");
/* harmony import */ var _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./JitsiTrackEvents */ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js");
/* harmony import */ var _JitsiTranscriptionStatus__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./JitsiTranscriptionStatus */ "../../lib-jitsi-meet/dist/esm/JitsiTranscriptionStatus.js");
/* harmony import */ var _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/RTC/RTC */ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTC.js");
/* harmony import */ var _modules_RTC_JitsiTrack__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/RTC/JitsiTrack */ "../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiTrack.js");
/* harmony import */ var _modules_RTC_JitsiLocalTrack__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./modules/RTC/JitsiLocalTrack */ "../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiLocalTrack.js");
/* harmony import */ var _modules_RTC_JitsiRemoteTrack__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./modules/RTC/JitsiRemoteTrack */ "../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiRemoteTrack.js");
/* harmony import */ var _modules_browser__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./modules/browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _modules_connectivity_NetworkInfo__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./modules/connectivity/NetworkInfo */ "../../lib-jitsi-meet/dist/esm/modules/connectivity/NetworkInfo.js");
/* harmony import */ var _modules_connectivity_TrackStreamingStatus__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./modules/connectivity/TrackStreamingStatus */ "../../lib-jitsi-meet/dist/esm/modules/connectivity/TrackStreamingStatus.js");
/* harmony import */ var _modules_detection_ActiveDeviceDetector__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./modules/detection/ActiveDeviceDetector */ "../../lib-jitsi-meet/dist/esm/modules/detection/ActiveDeviceDetector.js");
/* harmony import */ var _modules_detection_DetectionEvents__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./modules/detection/DetectionEvents */ "../../lib-jitsi-meet/dist/esm/modules/detection/DetectionEvents.js");
/* harmony import */ var _modules_detection_TrackVADEmitter__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./modules/detection/TrackVADEmitter */ "../../lib-jitsi-meet/dist/esm/modules/detection/TrackVADEmitter.js");
/* harmony import */ var _modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./modules/flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");
/* harmony import */ var _modules_proxyconnection_ProxyConnectionService__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./modules/proxyconnection/ProxyConnectionService */ "../../lib-jitsi-meet/dist/esm/modules/proxyconnection/ProxyConnectionService.js");
/* harmony import */ var _modules_recording_recordingConstants__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./modules/recording/recordingConstants */ "../../lib-jitsi-meet/dist/esm/modules/recording/recordingConstants.js");
/* harmony import */ var _modules_settings_Settings__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./modules/settings/Settings */ "../../lib-jitsi-meet/dist/esm/modules/settings/Settings.js");
/* harmony import */ var _modules_statistics_LocalStatsCollector__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./modules/statistics/LocalStatsCollector */ "../../lib-jitsi-meet/dist/esm/modules/statistics/LocalStatsCollector.js");
/* harmony import */ var _modules_statistics_PrecallTest__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./modules/statistics/PrecallTest */ "../../lib-jitsi-meet/dist/esm/modules/statistics/PrecallTest.js");
/* harmony import */ var _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./modules/statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _modules_util_AuthUtil__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./modules/util/AuthUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/AuthUtil.js");
/* harmony import */ var _modules_util_AuthUtil__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(_modules_util_AuthUtil__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var _modules_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./modules/util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _modules_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(_modules_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var _modules_util_ScriptUtil__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./modules/util/ScriptUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/ScriptUtil.js");
/* harmony import */ var _modules_util_ScriptUtil__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(_modules_util_ScriptUtil__WEBPACK_IMPORTED_MODULE_31__);
/* harmony import */ var _modules_videosipgw_VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./modules/videosipgw/VideoSIPGWConstants */ "../../lib-jitsi-meet/dist/esm/modules/videosipgw/VideoSIPGWConstants.js");
/* harmony import */ var _modules_webaudio_AudioMixer__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./modules/webaudio/AudioMixer */ "../../lib-jitsi-meet/dist/esm/modules/webaudio/AudioMixer.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./service/connectivity/ConnectionQualityEvents */ "../../lib-jitsi-meet/dist/esm/service/connectivity/ConnectionQualityEvents.js");
/* harmony import */ var _service_e2eping_E2ePingEvents__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./service/e2eping/E2ePingEvents */ "../../lib-jitsi-meet/dist/esm/service/e2eping/E2ePingEvents.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");

var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};






































const logger = _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default().getLogger(__filename);
const USER_MEDIA_SLOW_PROMISE_TIMEOUT = 1e3;
function getAnalyticsAttributesFromOptions(options) {
  const attributes = {};
  attributes["audio_requested"] = options.devices.includes("audio");
  attributes["video_requested"] = options.devices.includes("video");
  attributes["screen_sharing_requested"] = options.devices.includes("desktop");
  if (attributes.video_requested) {
    attributes.resolution = options.resolution;
  }
  return attributes;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  version: "{#COMMIT_HASH#}",
  JitsiConnection: _JitsiConnection__WEBPACK_IMPORTED_MODULE_3__["default"],
  ProxyConnectionService: _modules_proxyconnection_ProxyConnectionService__WEBPACK_IMPORTED_MODULE_23__["default"],
  constants: {
    recording: _modules_recording_recordingConstants__WEBPACK_IMPORTED_MODULE_24__["default"],
    sipVideoGW: _modules_videosipgw_VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_32__,
    transcriptionStatus: _JitsiTranscriptionStatus__WEBPACK_IMPORTED_MODULE_11__,
    trackStreamingStatus: _modules_connectivity_TrackStreamingStatus__WEBPACK_IMPORTED_MODULE_18__.TrackStreamingStatus
  },
  events: {
    conference: _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__,
    connection: _JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__,
    detection: _modules_detection_DetectionEvents__WEBPACK_IMPORTED_MODULE_20__,
    track: _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_10__,
    mediaDevices: _JitsiMediaDevicesEvents__WEBPACK_IMPORTED_MODULE_7__,
    connectionQuality: _service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_35__,
    e2eping: _service_e2eping_E2ePingEvents__WEBPACK_IMPORTED_MODULE_36__
  },
  errors: {
    conference: _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_1__,
    connection: _JitsiConnectionErrors__WEBPACK_IMPORTED_MODULE_4__,
    track: _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_9__
  },
  errorTypes: {
    JitsiTrackError: _JitsiTrackError__WEBPACK_IMPORTED_MODULE_8__["default"]
  },
  logLevels: (_jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default().levels),
  mediaDevices: _JitsiMediaDevices__WEBPACK_IMPORTED_MODULE_6__["default"],
  analytics: _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].analytics,
  init(options = {}) {
    logger.info(`This appears to be ${_modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].getName()}, ver: ${_modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].getVersion()}`);
    _modules_settings_Settings__WEBPACK_IMPORTED_MODULE_25__["default"].init(options.externalStorage);
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].init(options);
    const flags = options.flags || {};
    _modules_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_22__["default"].init(flags);
    if (!window.connectionTimes) {
      window.connectionTimes = {};
    }
    if (options.enableAnalyticsLogging !== true) {
      logger.warn("Analytics disabled, disposing.");
      this.analytics.dispose();
    }
    if (options.enableWindowOnErrorHandler) {
      _modules_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_30___default().addHandler(this.getGlobalOnErrorHandler.bind(this));
    }
    if (this.version) {
      const logObject = {
        id: "component_version",
        component: "lib-jitsi-meet",
        version: this.version
      };
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].sendLog(JSON.stringify(logObject));
    }
    return _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_12__["default"].init(options);
  },
  isDesktopSharingEnabled() {
    return _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_12__["default"].isDesktopSharingEnabled();
  },
  isWebRtcSupported() {
    return _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_12__["default"].isWebRtcSupported();
  },
  setLogLevel(level) {
    _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default().setLogLevel(level);
  },
  setLogLevelById(level, id) {
    _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default().setLogLevelById(level, id);
  },
  addGlobalLogTransport(globalTransport) {
    _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default().addGlobalTransport(globalTransport);
  },
  removeGlobalLogTransport(globalTransport) {
    _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default().removeGlobalTransport(globalTransport);
  },
  setGlobalLogOptions(options) {
    _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default().setGlobalOptions(options);
  },
  createLocalTracks(options = {}, oldfirePermissionPromptIsShownEvent) {
    let promiseFulfilled = false;
    const { firePermissionPromptIsShownEvent, fireSlowPromiseEvent } = options, restOptions = __rest(options, ["firePermissionPromptIsShownEvent", "fireSlowPromiseEvent"]);
    const firePermissionPrompt = firePermissionPromptIsShownEvent || oldfirePermissionPromptIsShownEvent;
    if (firePermissionPrompt && !_modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_12__["default"].arePermissionsGrantedForAvailableDevices()) {
      _JitsiMediaDevices__WEBPACK_IMPORTED_MODULE_6__["default"].emitEvent(_JitsiMediaDevicesEvents__WEBPACK_IMPORTED_MODULE_7__.PERMISSION_PROMPT_IS_SHOWN, _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"].getName());
    } else if (fireSlowPromiseEvent) {
      window.setTimeout(() => {
        if (!promiseFulfilled) {
          _JitsiMediaDevices__WEBPACK_IMPORTED_MODULE_6__["default"].emitEvent(_JitsiMediaDevicesEvents__WEBPACK_IMPORTED_MODULE_7__.SLOW_GET_USER_MEDIA);
        }
      }, USER_MEDIA_SLOW_PROMISE_TIMEOUT);
    }
    if (!window.connectionTimes) {
      window.connectionTimes = {};
    }
    window.connectionTimes["obtainPermissions.start"] = window.performance.now();
    return _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_12__["default"].obtainAudioAndVideoPermissions(restOptions).then((tracks) => {
      promiseFulfilled = true;
      window.connectionTimes["obtainPermissions.end"] = window.performance.now();
      _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_37__.createGetUserMediaEvent)("success", getAnalyticsAttributesFromOptions(restOptions)));
      if (this.isCollectingLocalStats()) {
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          if (track.getType() === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_34__.MediaType.AUDIO) {
            _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].startLocalStats(track, track.setAudioLevel.bind(track));
          }
        }
      }
      const currentlyAvailableMediaDevices = _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_12__["default"].getCurrentlyAvailableMediaDevices();
      if (currentlyAvailableMediaDevices) {
        for (let i = 0; i < tracks.length; i++) {
          const track = tracks[i];
          track._setRealDeviceIdFromDeviceList(currentlyAvailableMediaDevices);
        }
      }
      return tracks;
    }).catch((error) => {
      promiseFulfilled = true;
      if (error.name === _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_9__.SCREENSHARING_USER_CANCELED) {
        const logObject = {
          id: "screensharing_user_canceled",
          message: error.message
        };
        _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].sendLog(JSON.stringify(logObject));
        _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_37__.createGetUserMediaEvent)("warning", {
          reason: "extension install user canceled"
        }));
      } else if (error.name === _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_9__.NOT_FOUND) {
        const logObject = {
          id: "usermedia_missing_device",
          status: error.gum.devices
        };
        _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].sendLog(JSON.stringify(logObject));
        const attributes = getAnalyticsAttributesFromOptions(options);
        attributes.reason = "device not found";
        attributes.devices = error.gum.devices.join(".");
        _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_37__.createGetUserMediaEvent)("error", attributes));
      } else {
        _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].sendGetUserMediaFailed(error);
        const attributes = getAnalyticsAttributesFromOptions(options);
        attributes.reason = error.name;
        _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_37__.createGetUserMediaEvent)("error", attributes));
      }
      window.connectionTimes["obtainPermissions.end"] = window.performance.now();
      return Promise.reject(error);
    });
  },
  createTrackVADEmitter(localAudioDeviceId, sampleRate, vadProcessor) {
    return _modules_detection_TrackVADEmitter__WEBPACK_IMPORTED_MODULE_21__["default"].create(localAudioDeviceId, sampleRate, vadProcessor);
  },
  createAudioMixer() {
    return new _modules_webaudio_AudioMixer__WEBPACK_IMPORTED_MODULE_33__["default"]();
  },
  getActiveAudioDevice() {
    return (0,_modules_detection_ActiveDeviceDetector__WEBPACK_IMPORTED_MODULE_19__["default"])();
  },
  isDeviceListAvailable() {
    logger.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceListAvailable instead");
    return this.mediaDevices.isDeviceListAvailable();
  },
  isDeviceChangeAvailable(deviceType) {
    logger.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead");
    return this.mediaDevices.isDeviceChangeAvailable(deviceType);
  },
  isMultipleAudioInputSupported() {
    return this.mediaDevices.isMultipleAudioInputSupported();
  },
  isCollectingLocalStats() {
    return _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].audioLevelsEnabled && _modules_statistics_LocalStatsCollector__WEBPACK_IMPORTED_MODULE_26__["default"].isLocalStatsSupported();
  },
  enumerateDevices(callback) {
    logger.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.enumerateDevices instead");
    this.mediaDevices.enumerateDevices(callback);
  },
  getGlobalOnErrorHandler(message, source, lineno, colno, error) {
    logger.error(`UnhandledError: ${message}`, `Script: ${source}`, `Line: ${lineno}`, `Column: ${colno}`, "StackTrace: ", error);
    _modules_statistics_statistics__WEBPACK_IMPORTED_MODULE_28__["default"].reportGlobalError(error);
  },
  setNetworkInfo({ isOnline }) {
    _modules_connectivity_NetworkInfo__WEBPACK_IMPORTED_MODULE_17__["default"].updateNetworkInfo({ isOnline });
  },
  precallTest: _modules_statistics_PrecallTest__WEBPACK_IMPORTED_MODULE_27__["default"],
  util: {
    AuthUtil: (_modules_util_AuthUtil__WEBPACK_IMPORTED_MODULE_29___default()),
    ScriptUtil: (_modules_util_ScriptUtil__WEBPACK_IMPORTED_MODULE_31___default()),
    browser: _modules_browser__WEBPACK_IMPORTED_MODULE_16__["default"],
    RTC: _modules_RTC_RTC__WEBPACK_IMPORTED_MODULE_12__["default"],
    JitsiTrack: _modules_RTC_JitsiTrack__WEBPACK_IMPORTED_MODULE_13__["default"],
    JitsiLocalTrack: _modules_RTC_JitsiLocalTrack__WEBPACK_IMPORTED_MODULE_14__["default"],
    JitsiRemoteTrack: _modules_RTC_JitsiRemoteTrack__WEBPACK_IMPORTED_MODULE_15__["default"]
  }
});


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiParticipant.js":
/*!*********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiParticipant.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitsiParticipant)
/* harmony export */ });
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");




class JitsiParticipant {
  constructor(jid, conference, displayName, hidden, statsID, status, identity, isReplacing, isReplaced) {
    this._jid = jid;
    this._id = strophe_js__WEBPACK_IMPORTED_MODULE_0__.Strophe.getResourceFromJid(jid);
    this._conference = conference;
    this._displayName = displayName;
    this._supportsDTMF = false;
    this._tracks = [];
    this._role = "none";
    this._status = status;
    this._hidden = hidden;
    this._statsID = statsID;
    this._properties = {};
    this._identity = identity;
    this._isReplacing = isReplacing;
    this._isReplaced = isReplaced;
    this._features = /* @__PURE__ */ new Set();
    this._sources = /* @__PURE__ */ new Map();
  }
  _isMediaTypeMuted(mediaType) {
    return this.getTracks().reduce((muted, track) => muted && (track.getType() !== mediaType || track.isMuted()), true);
  }
  _setSources(mediaType, muted, sourceName, videoType) {
    let sourceByMediaType = this._sources.get(mediaType);
    const sourceInfo = {
      muted,
      videoType
    };
    if (sourceByMediaType === null || sourceByMediaType === void 0 ? void 0 : sourceByMediaType.size) {
      sourceByMediaType.set(sourceName, sourceInfo);
      return;
    }
    sourceByMediaType = /* @__PURE__ */ new Map();
    sourceByMediaType.set(sourceName, sourceInfo);
    this._sources.set(mediaType, sourceByMediaType);
  }
  getBotType() {
    return this._botType;
  }
  getConference() {
    return this._conference;
  }
  getConnectionJid() {
    return this._connectionJid;
  }
  getDisplayName() {
    return this._displayName;
  }
  getFeatures() {
    return Promise.resolve(this._features);
  }
  getId() {
    return this._id;
  }
  getJid() {
    return this._jid;
  }
  getProperty(name) {
    return this._properties[name];
  }
  getRole() {
    return this._role;
  }
  getSources() {
    return this._sources;
  }
  getStatsID() {
    return this._statsID;
  }
  getStatus() {
    return this._status;
  }
  getTracks() {
    return this._tracks.slice();
  }
  getTracksByMediaType(mediaType) {
    return this.getTracks().filter((track) => track.getType() === mediaType);
  }
  hasFeature(feature) {
    return this._features.has(feature);
  }
  isAudioMuted() {
    return this._isMediaTypeMuted(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.AUDIO);
  }
  isHidden() {
    return this._hidden;
  }
  isHiddenFromRecorder() {
    var _a, _b;
    return ((_b = (_a = this._identity) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b["hidden-from-recorder"]) === "true";
  }
  isModerator() {
    return this._role === "moderator";
  }
  isReplaced() {
    return this._isReplaced;
  }
  isReplacing() {
    return this._isReplacing;
  }
  isVideoMuted() {
    return this._isMediaTypeMuted(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO);
  }
  setBotType(newBotType) {
    this._botType = newBotType;
  }
  setConnectionJid(newJid) {
    this._connectionJid = newJid;
  }
  setFeatures(newFeatures) {
    this._features = newFeatures || /* @__PURE__ */ new Set();
  }
  setIsReplaced(newIsReplaced) {
    this._isReplaced = newIsReplaced;
  }
  setIsReplacing(newIsReplacing) {
    this._isReplacing = newIsReplacing;
  }
  setProperty(name, value) {
    const oldValue = this._properties[name];
    if (value !== oldValue) {
      this._properties[name] = value;
      this._conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.PARTICIPANT_PROPERTY_CHANGED, this, name, oldValue, value);
    }
  }
  setRole(newRole) {
    this._role = newRole;
  }
  supportsDTMF() {
    return this._supportsDTMF;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiTrackError.js":
/*!********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiTrackError.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JitsiTrackErrors */ "../../lib-jitsi-meet/dist/esm/JitsiTrackErrors.js");


const TRACK_ERROR_TO_MESSAGE_MAP = {};
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_RESOLUTION] = "Video resolution is not supported: ";
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.SCREENSHARING_USER_CANCELED] = "User canceled screen sharing prompt";
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.SCREENSHARING_GENERIC_ERROR] = "Unknown error from screensharing";
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.ELECTRON_DESKTOP_PICKER_ERROR] = "Unkown error from desktop picker";
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.ELECTRON_DESKTOP_PICKER_NOT_FOUND] = "Failed to detect desktop picker";
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.GENERAL] = "Generic getUserMedia error";
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.PERMISSION_DENIED] = "User denied permission to use device(s): ";
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.NOT_FOUND] = "Requested device(s) was/were not found: ";
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.CONSTRAINT_FAILED] = "Constraint could not be satisfied: ";
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.TIMEOUT] = "Could not start media source. Timeout occured!";
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.TRACK_IS_DISPOSED] = "Track has been already disposed";
TRACK_ERROR_TO_MESSAGE_MAP[_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.TRACK_NO_STREAM_FOUND] = "Track does not have an associated Media Stream";
function JitsiTrackError(error, options, devices) {
  if (typeof error === "object" && typeof error.name !== "undefined") {
    this.gum = {
      error,
      constraints: options,
      devices: devices && Array.isArray(devices) ? devices.slice(0) : void 0
    };
    switch (error.name) {
      case "NotAllowedError":
      case "PermissionDeniedError":
      case "SecurityError":
        this.name = _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.PERMISSION_DENIED;
        this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + (this.gum.devices || []).join(", ");
        break;
      case "DevicesNotFoundError":
      case "NotFoundError":
        this.name = _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.NOT_FOUND;
        this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + (this.gum.devices || []).join(", ");
        break;
      case "ConstraintNotSatisfiedError":
      case "OverconstrainedError": {
        const constraintName = error.constraintName || error.constraint;
        if (options && options.video && (!devices || devices.indexOf("video") > -1) && (constraintName === "minWidth" || constraintName === "maxWidth" || constraintName === "minHeight" || constraintName === "maxHeight" || constraintName === "width" || constraintName === "height" || constraintName === "deviceId")) {
          this.name = _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_RESOLUTION;
          this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + getResolutionFromFailedConstraint(constraintName, options);
        } else {
          this.name = _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.CONSTRAINT_FAILED;
          this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + error.constraintName;
        }
        break;
      }
      default:
        this.name = _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_0__.GENERAL;
        this.message = error.message || TRACK_ERROR_TO_MESSAGE_MAP[this.name];
        break;
    }
  } else if (typeof error === "string") {
    if (TRACK_ERROR_TO_MESSAGE_MAP[error]) {
      this.name = error;
      this.message = options || TRACK_ERROR_TO_MESSAGE_MAP[error];
    } else {
      this.message = error;
    }
  } else {
    throw new Error("Invalid arguments");
  }
  this.stack = error.stack || new Error().stack;
}
JitsiTrackError.prototype = Object.create(Error.prototype);
JitsiTrackError.prototype.constructor = JitsiTrackError;
function getResolutionFromFailedConstraint(failedConstraintName, constraints) {
  if (constraints && constraints.video && constraints.video.mandatory) {
    switch (failedConstraintName) {
      case "width":
        return constraints.video.mandatory.minWidth;
      case "height":
        return constraints.video.mandatory.minHeight;
      default:
        return constraints.video.mandatory[failedConstraintName] || "";
    }
  }
  return "";
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (JitsiTrackError);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiTrackErrors.js":
/*!*********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiTrackErrors.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CONSTRAINT_FAILED: () => (/* binding */ CONSTRAINT_FAILED),
/* harmony export */   ELECTRON_DESKTOP_PICKER_ERROR: () => (/* binding */ ELECTRON_DESKTOP_PICKER_ERROR),
/* harmony export */   ELECTRON_DESKTOP_PICKER_NOT_FOUND: () => (/* binding */ ELECTRON_DESKTOP_PICKER_NOT_FOUND),
/* harmony export */   GENERAL: () => (/* binding */ GENERAL),
/* harmony export */   JitsiTrackErrors: () => (/* binding */ JitsiTrackErrors),
/* harmony export */   NOT_FOUND: () => (/* binding */ NOT_FOUND),
/* harmony export */   PERMISSION_DENIED: () => (/* binding */ PERMISSION_DENIED),
/* harmony export */   SCREENSHARING_GENERIC_ERROR: () => (/* binding */ SCREENSHARING_GENERIC_ERROR),
/* harmony export */   SCREENSHARING_USER_CANCELED: () => (/* binding */ SCREENSHARING_USER_CANCELED),
/* harmony export */   TIMEOUT: () => (/* binding */ TIMEOUT),
/* harmony export */   TRACK_IS_DISPOSED: () => (/* binding */ TRACK_IS_DISPOSED),
/* harmony export */   TRACK_NO_STREAM_FOUND: () => (/* binding */ TRACK_NO_STREAM_FOUND),
/* harmony export */   UNSUPPORTED_RESOLUTION: () => (/* binding */ UNSUPPORTED_RESOLUTION)
/* harmony export */ });

var JitsiTrackErrors;
(function(JitsiTrackErrors2) {
  JitsiTrackErrors2["CONSTRAINT_FAILED"] = "gum.constraint_failed";
  JitsiTrackErrors2["ELECTRON_DESKTOP_PICKER_ERROR"] = "gum.electron_desktop_picker_error";
  JitsiTrackErrors2["ELECTRON_DESKTOP_PICKER_NOT_FOUND"] = "gum.electron_desktop_picker_not_found";
  JitsiTrackErrors2["GENERAL"] = "gum.general";
  JitsiTrackErrors2["NOT_FOUND"] = "gum.not_found";
  JitsiTrackErrors2["PERMISSION_DENIED"] = "gum.permission_denied";
  JitsiTrackErrors2["SCREENSHARING_GENERIC_ERROR"] = "gum.screensharing_generic_error";
  JitsiTrackErrors2["SCREENSHARING_USER_CANCELED"] = "gum.screensharing_user_canceled";
  JitsiTrackErrors2["TIMEOUT"] = "gum.timeout";
  JitsiTrackErrors2["TRACK_IS_DISPOSED"] = "track.track_is_disposed";
  JitsiTrackErrors2["TRACK_NO_STREAM_FOUND"] = "track.no_stream_found";
  JitsiTrackErrors2["UNSUPPORTED_RESOLUTION"] = "gum.unsupported_resolution";
})(JitsiTrackErrors || (JitsiTrackErrors = {}));
const CONSTRAINT_FAILED = JitsiTrackErrors.CONSTRAINT_FAILED;
const ELECTRON_DESKTOP_PICKER_ERROR = JitsiTrackErrors.ELECTRON_DESKTOP_PICKER_ERROR;
const ELECTRON_DESKTOP_PICKER_NOT_FOUND = JitsiTrackErrors.ELECTRON_DESKTOP_PICKER_NOT_FOUND;
const GENERAL = JitsiTrackErrors.GENERAL;
const NOT_FOUND = JitsiTrackErrors.NOT_FOUND;
const PERMISSION_DENIED = JitsiTrackErrors.PERMISSION_DENIED;
const SCREENSHARING_GENERIC_ERROR = JitsiTrackErrors.SCREENSHARING_GENERIC_ERROR;
const SCREENSHARING_USER_CANCELED = JitsiTrackErrors.SCREENSHARING_USER_CANCELED;
const TIMEOUT = JitsiTrackErrors.TIMEOUT;
const TRACK_IS_DISPOSED = JitsiTrackErrors.TRACK_IS_DISPOSED;
const TRACK_NO_STREAM_FOUND = JitsiTrackErrors.TRACK_NO_STREAM_FOUND;
const UNSUPPORTED_RESOLUTION = JitsiTrackErrors.UNSUPPORTED_RESOLUTION;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js":
/*!*********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JitsiTrackEvents: () => (/* binding */ JitsiTrackEvents),
/* harmony export */   LOCAL_TRACK_STOPPED: () => (/* binding */ LOCAL_TRACK_STOPPED),
/* harmony export */   NO_AUDIO_INPUT: () => (/* binding */ NO_AUDIO_INPUT),
/* harmony export */   NO_DATA_FROM_SOURCE: () => (/* binding */ NO_DATA_FROM_SOURCE),
/* harmony export */   TRACK_AUDIO_LEVEL_CHANGED: () => (/* binding */ TRACK_AUDIO_LEVEL_CHANGED),
/* harmony export */   TRACK_AUDIO_OUTPUT_CHANGED: () => (/* binding */ TRACK_AUDIO_OUTPUT_CHANGED),
/* harmony export */   TRACK_MUTE_CHANGED: () => (/* binding */ TRACK_MUTE_CHANGED),
/* harmony export */   TRACK_OWNER_CHANGED: () => (/* binding */ TRACK_OWNER_CHANGED),
/* harmony export */   TRACK_REMOVED: () => (/* binding */ TRACK_REMOVED),
/* harmony export */   TRACK_STREAMING_STATUS_CHANGED: () => (/* binding */ TRACK_STREAMING_STATUS_CHANGED),
/* harmony export */   TRACK_VIDEOTYPE_CHANGED: () => (/* binding */ TRACK_VIDEOTYPE_CHANGED)
/* harmony export */ });

var JitsiTrackEvents;
(function(JitsiTrackEvents2) {
  JitsiTrackEvents2["LOCAL_TRACK_STOPPED"] = "track.stopped";
  JitsiTrackEvents2["TRACK_AUDIO_LEVEL_CHANGED"] = "track.audioLevelsChanged";
  JitsiTrackEvents2["TRACK_AUDIO_OUTPUT_CHANGED"] = "track.audioOutputChanged";
  JitsiTrackEvents2["TRACK_MUTE_CHANGED"] = "track.trackMuteChanged";
  JitsiTrackEvents2["TRACK_VIDEOTYPE_CHANGED"] = "track.videoTypeChanged";
  JitsiTrackEvents2["NO_DATA_FROM_SOURCE"] = "track.no_data_from_source";
  JitsiTrackEvents2["NO_AUDIO_INPUT"] = "track.no_audio_input";
  JitsiTrackEvents2["TRACK_STREAMING_STATUS_CHANGED"] = "track.streaming_status_changed";
  JitsiTrackEvents2["TRACK_OWNER_CHANGED"] = "track.owner_changed";
  JitsiTrackEvents2["TRACK_REMOVED"] = "track.removed";
})(JitsiTrackEvents || (JitsiTrackEvents = {}));
;
const LOCAL_TRACK_STOPPED = JitsiTrackEvents.LOCAL_TRACK_STOPPED;
const TRACK_AUDIO_LEVEL_CHANGED = JitsiTrackEvents.TRACK_AUDIO_LEVEL_CHANGED;
const TRACK_AUDIO_OUTPUT_CHANGED = JitsiTrackEvents.TRACK_AUDIO_OUTPUT_CHANGED;
const TRACK_MUTE_CHANGED = JitsiTrackEvents.TRACK_MUTE_CHANGED;
const TRACK_VIDEOTYPE_CHANGED = JitsiTrackEvents.TRACK_VIDEOTYPE_CHANGED;
const NO_DATA_FROM_SOURCE = JitsiTrackEvents.NO_DATA_FROM_SOURCE;
const NO_AUDIO_INPUT = JitsiTrackEvents.NO_AUDIO_INPUT;
const TRACK_STREAMING_STATUS_CHANGED = JitsiTrackEvents.TRACK_STREAMING_STATUS_CHANGED;
const TRACK_OWNER_CHANGED = JitsiTrackEvents.TRACK_OWNER_CHANGED;
const TRACK_REMOVED = JitsiTrackEvents.TRACK_REMOVED;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/JitsiTranscriptionStatus.js":
/*!*****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/JitsiTranscriptionStatus.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JitsiTranscriptionStatus: () => (/* binding */ JitsiTranscriptionStatus),
/* harmony export */   OFF: () => (/* binding */ OFF),
/* harmony export */   ON: () => (/* binding */ ON)
/* harmony export */ });

var JitsiTranscriptionStatus;
(function(JitsiTranscriptionStatus2) {
  JitsiTranscriptionStatus2["ON"] = "on";
  JitsiTranscriptionStatus2["OFF"] = "off";
})(JitsiTranscriptionStatus || (JitsiTranscriptionStatus = {}));
const ON = JitsiTranscriptionStatus.ON;
const OFF = JitsiTranscriptionStatus.OFF;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/authenticateAndUpgradeRole.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/authenticateAndUpgradeRole.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ authenticateAndUpgradeRole)
/* harmony export */ });
/* harmony import */ var _JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JitsiConnectionEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConnectionEvents.js");
/* harmony import */ var _modules_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/xmpp/xmpp */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/xmpp.js");



function authenticateAndUpgradeRole({
  id,
  password,
  onCreateResource,
  onLoginSuccessful
}) {
  let canceled = false;
  let rejectPromise;
  let xmpp = new _modules_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_1__["default"](this.connection.options);
  const process = new Promise((resolve, reject) => {
    rejectPromise = reject;
    xmpp.addListener(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_DISCONNECTED, () => {
      xmpp = void 0;
    });
    xmpp.addListener(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_ESTABLISHED, () => {
      if (canceled) {
        return;
      }
      onLoginSuccessful && onLoginSuccessful();
      const room = xmpp.createRoom(this.options.name, this.options.config, onCreateResource);
      room.moderator.authenticate().then(() => {
        xmpp && xmpp.disconnect();
        if (canceled) {
          return;
        }
        this.room.moderator.sendConferenceRequest().finally(resolve);
      }).catch(({ error, message }) => {
        xmpp.disconnect();
        reject({
          authenticationError: error,
          message
        });
      });
    });
    xmpp.addListener(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_FAILED, (connectionError, message, credentials) => {
      reject({
        connectionError,
        credentials,
        message
      });
      xmpp = void 0;
    });
    canceled || xmpp.connect(id, password);
  });
  process.cancel = () => {
    canceled = true;
    rejectPromise({});
    xmpp && xmpp.disconnect();
  };
  return process;
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/RTC/BridgeChannel.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/RTC/BridgeChannel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BridgeChannel)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _statistics_statistics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_4__);






const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class BridgeChannel {
  constructor(peerconnection, wsUrl, emitter, conference) {
    if (!peerconnection && !wsUrl) {
      throw new TypeError("At least peerconnection or wsUrl must be given");
    } else if (peerconnection && wsUrl) {
      throw new TypeError("Just one of peerconnection or wsUrl must be given");
    }
    if (peerconnection) {
      logger.debug("constructor() with peerconnection");
    } else {
      logger.debug(`constructor() with wsUrl:"${wsUrl}"`);
    }
    this._channel = null;
    this._conference = conference;
    this._connected = void 0;
    this._eventEmitter = emitter;
    this._mode = null;
    this._areRetriesEnabled = false;
    this._closedFromClient = false;
    if (peerconnection) {
      const datachannel = peerconnection.createDataChannel("JVB data channel", {
        protocol: "http://jitsi.org/protocols/colibri"
      });
      this._handleChannel(datachannel);
      this._mode = "datachannel";
    } else if (wsUrl) {
      this._areRetriesEnabled = true;
      this._wsUrl = wsUrl;
      this._initWebSocket();
    }
  }
  _initWebSocket() {
    const ws = new WebSocket(this._wsUrl);
    this._handleChannel(ws);
    this._mode = "websocket";
  }
  _startConnectionRetries() {
    let timeoutS = 1;
    const reload = () => {
      const isConnecting = this._channel && (this._channel.readyState === "connecting" || this._channel.readyState === WebSocket.CONNECTING);
      if (isConnecting) {
        this._retryTimeout = setTimeout(reload, timeoutS * 1e3);
        return;
      }
      if (this.isOpen()) {
        return;
      }
      this._initWebSocket(this._wsUrl);
      timeoutS = Math.min(timeoutS * 2, 60);
      this._retryTimeout = setTimeout(reload, timeoutS * 1e3);
    };
    this._retryTimeout = setTimeout(reload, timeoutS * 1e3);
  }
  _stopConnectionRetries() {
    if (this._retryTimeout) {
      clearTimeout(this._retryTimeout);
      this._retryTimeout = void 0;
    }
  }
  _retryWebSocketConnection(closeEvent) {
    if (!this._areRetriesEnabled) {
      return;
    }
    const { code, reason } = closeEvent;
    _statistics_statistics__WEBPACK_IMPORTED_MODULE_3__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_2__.createBridgeChannelClosedEvent)(code, reason));
    this._areRetriesEnabled = false;
    this._eventEmitter.once(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].DATA_CHANNEL_OPEN, () => {
      this._stopConnectionRetries();
      this._areRetriesEnabled = true;
    });
    this._startConnectionRetries();
  }
  get mode() {
    return this._mode;
  }
  close() {
    this._closedFromClient = true;
    this._stopConnectionRetries();
    this._areRetriesEnabled = false;
    if (this._channel) {
      try {
        this._channel.close();
      } catch (error) {
      }
      this._channel = null;
    }
  }
  isOpen() {
    return this._channel && (this._channel.readyState === "open" || this._channel.readyState === WebSocket.OPEN);
  }
  sendEndpointStatsMessage(payload) {
    this._send(Object.assign({ colibriClass: "EndpointStats" }, payload));
  }
  sendMessage(to, payload) {
    this._send({
      colibriClass: "EndpointMessage",
      msgPayload: payload,
      to
    });
  }
  sendSetLastNMessage(value) {
    logger.log(`Sending lastN=${value}.`);
    this._send({
      colibriClass: "LastNChangedEvent",
      lastN: value
    });
  }
  sendReceiverVideoConstraintsMessage(constraints) {
    logger.log(`Sending ReceiverVideoConstraints with ${JSON.stringify(constraints)}`);
    this._send(Object.assign({ colibriClass: "ReceiverVideoConstraints" }, constraints));
  }
  sendSourceVideoTypeMessage(sourceName, videoType) {
    logger.info(`Sending SourceVideoTypeMessage with video type ${sourceName}: ${videoType}`);
    this._send({
      colibriClass: "SourceVideoTypeMessage",
      sourceName,
      videoType
    });
  }
  _handleChannel(channel) {
    const emitter = this._eventEmitter;
    channel.onopen = () => {
      logger.info(`${this._mode} channel opened`);
      this._connected = true;
      emitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].DATA_CHANNEL_OPEN);
    };
    channel.onerror = (event) => {
      if (this._mode !== "websocket") {
        logger.error(`Channel error: ${event.message}`);
      }
    };
    channel.onmessage = ({ data }) => {
      let obj;
      try {
        obj = JSON.parse(data);
      } catch (error) {
        _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_4___default().callErrorHandler(error);
        logger.error("Failed to parse channel message as JSON: ", data, error);
        return;
      }
      const colibriClass = obj.colibriClass;
      switch (colibriClass) {
        case "DominantSpeakerEndpointChangeEvent": {
          const { dominantSpeakerEndpoint, previousSpeakers = [], silence } = obj;
          logger.debug(`Dominant speaker: ${dominantSpeakerEndpoint}, previous speakers: ${previousSpeakers}`);
          emitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].DOMINANT_SPEAKER_CHANGED, dominantSpeakerEndpoint, previousSpeakers, silence);
          break;
        }
        case "EndpointConnectivityStatusChangeEvent": {
          const endpoint = obj.endpoint;
          const isActive = obj.active === "true";
          logger.info(`Endpoint connection status changed: ${endpoint} active=${isActive}`);
          emitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].ENDPOINT_CONN_STATUS_CHANGED, endpoint, isActive);
          break;
        }
        case "EndpointMessage": {
          emitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].ENDPOINT_MESSAGE_RECEIVED, obj.from, obj.msgPayload);
          break;
        }
        case "EndpointStats": {
          emitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].ENDPOINT_STATS_RECEIVED, obj.from, obj);
          break;
        }
        case "ForwardedSources": {
          const forwardedSources = obj.forwardedSources;
          logger.info(`New forwarded sources: ${forwardedSources}`);
          emitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].FORWARDED_SOURCES_CHANGED, forwardedSources);
          break;
        }
        case "SenderSourceConstraints": {
          if (typeof obj.sourceName === "string" && typeof obj.maxHeight === "number") {
            logger.info(`SenderSourceConstraints: ${obj.sourceName} - ${obj.maxHeight}`);
            emitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].SENDER_VIDEO_CONSTRAINTS_CHANGED, obj);
          } else {
            logger.error(`Invalid SenderSourceConstraints: ${obj.sourceName} - ${obj.maxHeight}`);
          }
          break;
        }
        case "ServerHello": {
          logger.info(`Received ServerHello, version=${obj.version}.`);
          break;
        }
        case "VideoSourcesMap": {
          logger.info(`Received VideoSourcesMap: ${JSON.stringify(obj.mappedSources)}`);
          emitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].VIDEO_SSRCS_REMAPPED, obj);
          break;
        }
        case "AudioSourcesMap": {
          logger.info(`Received AudioSourcesMap: ${JSON.stringify(obj.mappedSources)}`);
          emitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].AUDIO_SSRCS_REMAPPED, obj);
          break;
        }
        default: {
          logger.debug("Channel JSON-formatted message: ", obj);
          emitter.emit(`rtc.datachannel.${colibriClass}`, obj);
        }
      }
    };
    channel.onclose = (event) => {
      logger.debug(`Channel closed by ${this._closedFromClient ? "client" : "server"}`);
      if (channel !== this._channel) {
        logger.debug("Skip close handler, channel instance is not equal to stored one");
        return;
      }
      const isGracefulClose = this._closedFromClient || event.code === 1001 && this._conference.getParticipantCount() === 1;
      if (!isGracefulClose) {
        const { code, reason } = event;
        logger.error(`Channel closed: ${code} ${reason}`);
        if (this._mode === "websocket") {
          this._retryWebSocketConnection(event);
          if (this._connected !== false) {
            emitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].DATA_CHANNEL_CLOSED, {
              code,
              reason
            });
          }
        }
      }
      this._connected = false;
      this._channel = null;
    };
    this._channel = channel;
  }
  _send(jsonObject) {
    const channel = this._channel;
    if (!this.isOpen()) {
      logger.error("Bridge Channel send: no opened channel.");
      throw new Error("No opened channel");
    }
    channel.send(JSON.stringify(jsonObject));
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/RTC/CodecSelection.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/RTC/CodecSelection.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodecSelection: () => (/* binding */ CodecSelection)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/CodecMimeType */ "../../lib-jitsi-meet/dist/esm/service/RTC/CodecMimeType.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");






const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const DESKTOP_VIDEO_CODEC_ORDER = [_service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].VP9, _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].VP8, _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].H264];
const MOBILE_P2P_VIDEO_CODEC_ORDER = [_service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].H264, _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].VP8, _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].VP9];
const MOBILE_VIDEO_CODEC_ORDER = [_service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].VP8, _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].VP9, _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].H264];
class CodecSelection {
  constructor(conference, options) {
    this.conference = conference;
    this.options = options;
    this.codecPreferenceOrder = {};
    for (const connectionType of Object.keys(options)) {
      let { disabledCodec, preferredCodec, preferenceOrder } = options[connectionType];
      const supportedCodecs = new Set(this._getSupportedVideoCodecs(connectionType));
      let selectedOrder = Array.from(supportedCodecs);
      if (preferenceOrder) {
        preferenceOrder = preferenceOrder.map((codec) => codec.toLowerCase());
        selectedOrder = preferenceOrder.filter((codec) => supportedCodecs.has(codec));
      } else if (preferredCodec || disabledCodec) {
        disabledCodec = disabledCodec === null || disabledCodec === void 0 ? void 0 : disabledCodec.toLowerCase();
        preferredCodec = preferredCodec === null || preferredCodec === void 0 ? void 0 : preferredCodec.toLowerCase();
        if (disabledCodec && disabledCodec !== _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].VP8) {
          selectedOrder = selectedOrder.filter((codec) => codec !== disabledCodec);
        }
        const index = selectedOrder.findIndex((codec) => codec === preferredCodec);
        if (preferredCodec && index !== -1) {
          selectedOrder.splice(index, 1);
          selectedOrder.unshift(preferredCodec);
        }
      }
      if (!_browser__WEBPACK_IMPORTED_MODULE_4__["default"].supportsVP9() || this.conference.isE2EEEnabled()) {
        const index = selectedOrder.findIndex((codec) => codec === _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].VP9);
        if (index !== -1) {
          selectedOrder.splice(index, 1);
          if (!this.conference.isE2EEEnabled()) {
            selectedOrder.push(_service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].VP9);
          }
        }
      }
      logger.info(`Codec preference order for ${connectionType} connection is ${selectedOrder}`);
      this.codecPreferenceOrder[connectionType] = selectedOrder;
    }
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__._MEDIA_SESSION_STARTED, (session) => this._selectPreferredCodec(session));
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.USER_JOINED, () => this._selectPreferredCodec());
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.USER_LEFT, () => this._selectPreferredCodec());
  }
  _getSupportedVideoCodecs(connectionType) {
    const videoCodecMimeTypes = _browser__WEBPACK_IMPORTED_MODULE_4__["default"].isMobileDevice() && connectionType === "p2p" ? MOBILE_P2P_VIDEO_CODEC_ORDER : _browser__WEBPACK_IMPORTED_MODULE_4__["default"].isMobileDevice() ? MOBILE_VIDEO_CODEC_ORDER : DESKTOP_VIDEO_CODEC_ORDER;
    return videoCodecMimeTypes.filter((codec) => {
      var _a, _b, _c, _d;
      return ((_d = (_c = (_b = (_a = window.RTCRtpReceiver) === null || _a === void 0 ? void 0 : _a.getCapabilities) === null || _b === void 0 ? void 0 : _b.call(_a, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO)) === null || _c === void 0 ? void 0 : _c.codecs) !== null && _d !== void 0 ? _d : []).some((supportedCodec) => supportedCodec.mimeType.toLowerCase() === `${_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO}/${codec}`);
    });
  }
  _maybeFilterJvbCodecs() {
    if (this.conference.isE2EEEnabled()) {
      return this.codecPreferenceOrder.jvb.filter((codec) => codec !== _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].VP9);
    }
    return this.codecPreferenceOrder.jvb;
  }
  _selectPreferredCodec(mediaSession) {
    const session = mediaSession ? mediaSession : this.conference.jvbJingleSession;
    if (!session) {
      return;
    }
    const currentCodecOrder = session.peerconnection.getConfiguredVideoCodecs();
    const localPreferredCodecOrder = session === this.conference.jvbJingleSession ? this._maybeFilterJvbCodecs() : this.codecPreferenceOrder.p2p;
    const remoteParticipants = this.conference.getParticipants().map((participant) => participant.getId());
    const remoteCodecsPerParticipant = remoteParticipants === null || remoteParticipants === void 0 ? void 0 : remoteParticipants.map((remote) => {
      var _a;
      const peerMediaInfo = session._signalingLayer.getPeerMediaInfo(remote, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO);
      return peerMediaInfo ? (_a = peerMediaInfo.codecList) !== null && _a !== void 0 ? _a : [peerMediaInfo.codecType] : [];
    });
    const selectedCodecOrder = localPreferredCodecOrder.reduce((acc, localCodec) => {
      let codecNotSupportedByRemote = false;
      if (!session.isP2P) {
        for (const remoteCodecs of remoteCodecsPerParticipant) {
          codecNotSupportedByRemote = codecNotSupportedByRemote || !remoteCodecs.find((participantCodec) => participantCodec === localCodec);
        }
      }
      if (!codecNotSupportedByRemote) {
        acc.push(localCodec);
      }
      return acc;
    }, []);
    if (!selectedCodecOrder.length) {
      logger.warn("Invalid codec list generated because of a user joining/leaving the call");
      return;
    }
    if (!selectedCodecOrder.every((val, index) => val === currentCodecOrder[index])) {
      session.setVideoCodecs(selectedCodecOrder);
    }
  }
  getCodecPreferenceList(connectionType) {
    return this.codecPreferenceOrder[connectionType];
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiLocalTrack.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiLocalTrack.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitsiLocalTrack)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiTrackError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiTrackError */ "../../lib-jitsi-meet/dist/esm/JitsiTrackError.js");
/* harmony import */ var _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../JitsiTrackErrors */ "../../lib-jitsi-meet/dist/esm/JitsiTrackErrors.js");
/* harmony import */ var _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../JitsiTrackEvents */ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js");
/* harmony import */ var _service_RTC_CameraFacingMode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/RTC/CameraFacingMode */ "../../lib-jitsi-meet/dist/esm/service/RTC/CameraFacingMode.js");
/* harmony import */ var _service_RTC_CameraFacingMode__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_service_RTC_CameraFacingMode__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");
/* harmony import */ var _statistics_statistics__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _JitsiTrack__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./JitsiTrack */ "../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiTrack.js");
/* harmony import */ var _RTCUtils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./RTCUtils */ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTCUtils.js");

var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};














const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class JitsiLocalTrack extends _JitsiTrack__WEBPACK_IMPORTED_MODULE_12__["default"] {
  constructor({ deviceId, facingMode, mediaType, resolution, rtcId, sourceId, sourceType, stream, track, videoType, effects = [] }) {
    super(
      null,
      stream,
      track,
      () => this.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_3__.LOCAL_TRACK_STOPPED, this),
      mediaType,
      videoType
    );
    this._setEffectInProgress = false;
    const effect = effects.find((e) => e.isEnabled(this));
    if (effect) {
      this._startStreamEffect(effect);
    }
    const displaySurface = videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.DESKTOP ? track.getSettings().displaySurface : null;
    this.metadata = Object.assign({ timestamp: Date.now() }, displaySurface ? { displaySurface } : {});
    this.rtcId = rtcId;
    this.sourceId = sourceId;
    this.sourceType = sourceType !== null && sourceType !== void 0 ? sourceType : displaySurface;
    this.resolution = track.getSettings().height;
    this.maxEnabledResolution = resolution;
    this._constraints = track.getConstraints();
    if (!Object.keys(this._constraints).length && videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.CAMERA) {
      this._constraints = {
        height: track.getSettings().height,
        width: track.getSettings().width
      };
    }
    this.deviceId = deviceId;
    this._prevSetMuted = Promise.resolve();
    this._facingMode = facingMode;
    this._trackEnded = false;
    this._hasSentData = false;
    this._testDataSent = true;
    this._realDeviceId = this.deviceId === "" ? void 0 : this.deviceId;
    this._sourceName = null;
    this._trackMutedTS = 0;
    this._onDeviceListWillChange = (devices) => {
      const oldRealDeviceId = this._realDeviceId;
      this._setRealDeviceIdFromDeviceList(devices);
      if (typeof this.getTrack().readyState === "undefined" && typeof this._realDeviceId !== "undefined" && !devices.find((d) => d.deviceId === this._realDeviceId) || typeof oldRealDeviceId !== "undefined" && typeof this._realDeviceId === "undefined") {
        this._trackEnded = true;
      }
    };
    if (this.isAudioTrack() && _RTCUtils__WEBPACK_IMPORTED_MODULE_13__["default"].isDeviceChangeAvailable("output")) {
      this._onAudioOutputDeviceChanged = this.setAudioOutput.bind(this);
      _RTCUtils__WEBPACK_IMPORTED_MODULE_13__["default"].addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged);
    }
    _RTCUtils__WEBPACK_IMPORTED_MODULE_13__["default"].addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange);
    this._initNoDataFromSourceHandlers();
  }
  _addStreamToConferenceAsUnmute() {
    if (!this.conference) {
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      this.conference._addLocalTrackToPc(this).then(resolve, (error) => reject(new Error(error)));
    });
  }
  _fireNoDataFromSourceEvent() {
    const value = !this.isReceivingData();
    this.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_3__.NO_DATA_FROM_SOURCE, value);
    _statistics_statistics__WEBPACK_IMPORTED_MODULE_11__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_8__.createNoDataFromSourceEvent)(this.getType(), value));
    _statistics_statistics__WEBPACK_IMPORTED_MODULE_11__["default"].sendLog(JSON.stringify({
      name: _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_3__.NO_DATA_FROM_SOURCE,
      log: value
    }));
  }
  _initNoDataFromSourceHandlers() {
    if (!this._isNoDataFromSourceEventsEnabled()) {
      return;
    }
    this._setHandler("track_mute", () => {
      this._trackMutedTS = window.performance.now();
      this._fireNoDataFromSourceEvent();
    });
    this._setHandler("track_unmute", () => {
      this._fireNoDataFromSourceEvent();
      _statistics_statistics__WEBPACK_IMPORTED_MODULE_11__["default"].sendAnalyticsAndLog(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_8__.TRACK_UNMUTED, {
        "media_type": this.getType(),
        "track_type": "local",
        value: window.performance.now() - this._trackMutedTS
      });
    });
    if (this.isVideoTrack() && this.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.CAMERA) {
      this._setHandler("track_ended", () => {
        if (!this.isReceivingData()) {
          this._fireNoDataFromSourceEvent();
        }
      });
    }
  }
  _isNoDataFromSourceEventsEnabled() {
    return !this.isVideoTrack() || this.videoType !== _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.DESKTOP;
  }
  _queueSetMuted(muted) {
    const setMuted = this._setMuted.bind(this, muted);
    this._prevSetMuted = this._prevSetMuted.then(setMuted, setMuted);
    return this._prevSetMuted;
  }
  _removeStreamFromConferenceAsMute(successCallback, errorCallback) {
    if (!this.conference) {
      successCallback();
      return;
    }
    this.conference._removeLocalTrackFromPc(this).then(successCallback, (error) => errorCallback(new Error(error)));
  }
  _sendMuteStatus(mute) {
    if (this.conference) {
      this.conference._setTrackMuteStatus(this.getType(), this, mute) && this.conference.room.sendPresence();
    }
  }
  _setMuted(muted) {
    if (this.isMuted() === muted && !(this.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.DESKTOP && _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_10__["default"].isMultiStreamSendSupportEnabled())) {
      return Promise.resolve();
    }
    if (this.disposed) {
      return Promise.reject(new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_1__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_2__.TRACK_IS_DISPOSED));
    }
    let promise = Promise.resolve();
    const logMuteInfo = () => logger.info(`Mute ${this}: ${muted}`);
    const doesVideoMuteByStreamRemove = _browser__WEBPACK_IMPORTED_MODULE_9__["default"].isReactNative() ? this.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.DESKTOP : _browser__WEBPACK_IMPORTED_MODULE_9__["default"].doesVideoMuteByStreamRemove();
    if (this.isAudioTrack() || this.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.DESKTOP && !_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_10__["default"].isMultiStreamSendSupportEnabled() || !doesVideoMuteByStreamRemove) {
      logMuteInfo();
      if (this._streamEffect && this._streamEffect.setMuted) {
        this._streamEffect.setMuted(muted);
      } else if (this.track) {
        this.track.enabled = !muted;
      }
    } else if (muted) {
      promise = new Promise((resolve, reject) => {
        logMuteInfo();
        this._removeStreamFromConferenceAsMute(() => {
          if (this._streamEffect) {
            this._stopStreamEffect();
          }
          this._unregisterHandlers();
          this.stopStream();
          this._setStream(null);
          resolve();
        }, reject);
      });
    } else {
      logMuteInfo();
      const streamOptions = {
        cameraDeviceId: this.getDeviceId(),
        devices: [_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO],
        effects: this._streamEffect ? [this._streamEffect] : [],
        facingMode: this.getCameraFacingMode()
      };
      promise = _RTCUtils__WEBPACK_IMPORTED_MODULE_13__["default"].obtainAudioAndVideoPermissions(Object.assign({}, streamOptions, { constraints: { video: this._constraints } }));
      promise = promise.then((streamsInfo) => {
        const streamInfo = streamsInfo.find((info) => info.track.kind === this.getType());
        if (streamInfo) {
          this._setStream(streamInfo.stream);
          this.track = streamInfo.track;
          if (this.videoType !== streamInfo.videoType) {
            logger.warn(`${this}: video type has changed after unmute!`, this.videoType, streamInfo.videoType);
            this.videoType = streamInfo.videoType;
          }
        } else {
          throw new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_1__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_2__.TRACK_NO_STREAM_FOUND);
        }
        if (this._streamEffect) {
          this._startStreamEffect(this._streamEffect);
        }
        this.containers.map((cont) => _RTCUtils__WEBPACK_IMPORTED_MODULE_13__["default"].attachMediaStream(cont, this.stream));
        return this._addStreamToConferenceAsUnmute();
      });
    }
    return promise.then(() => {
      this._sendMuteStatus(muted);
      this.isVideoTrack() && this.conference && this.conference._sendBridgeVideoTypeMessage(this);
      this.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_3__.TRACK_MUTE_CHANGED, this);
    });
  }
  _setRealDeviceIdFromDeviceList(devices) {
    const track = this.getTrack();
    const kind = `${track.kind}input`;
    let device = devices.find((d) => d.kind === kind && d.label === track.label && d.deviceId === this.deviceId);
    if (!device && this._realDeviceId === "default") {
      const label = (track.label || "").replace("Default - ", "");
      device = devices.find((d) => d.kind === kind && d.label === label);
    }
    if (device) {
      this._realDeviceId = device.deviceId;
    } else {
      this._realDeviceId = void 0;
    }
  }
  _setStream(stream) {
    super._setStream(stream);
    if (stream) {
      this.storedMSID = this.getMSID();
      logger.debug(`Setting new MSID: ${this.storedMSID} on ${this}`);
    } else {
      logger.debug(`Setting 'null' stream on ${this}`);
    }
  }
  _startStreamEffect(effect) {
    this._streamEffect = effect;
    this._originalStream = this.stream;
    this._setStream(this._streamEffect.startEffect(this._originalStream));
    this.track = this.stream.getTracks()[0];
  }
  _stopStreamEffect() {
    if (this._streamEffect) {
      this._streamEffect.stopEffect();
      this._setStream(this._originalStream);
      this._originalStream = null;
      this.track = this.stream ? this.stream.getTracks()[0] : null;
    }
  }
  _switchCamera() {
    if (this.isVideoTrack() && this.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.CAMERA && typeof this.track._switchCamera === "function") {
      this.track._switchCamera();
      this._facingMode = this._facingMode === (_service_RTC_CameraFacingMode__WEBPACK_IMPORTED_MODULE_4___default().ENVIRONMENT) ? (_service_RTC_CameraFacingMode__WEBPACK_IMPORTED_MODULE_4___default().USER) : (_service_RTC_CameraFacingMode__WEBPACK_IMPORTED_MODULE_4___default().ENVIRONMENT);
    }
  }
  _switchStreamEffect(effect) {
    if (this._streamEffect) {
      this._stopStreamEffect();
      this._streamEffect = void 0;
    }
    if (effect) {
      this._startStreamEffect(effect);
    }
  }
  dispose() {
    const _super = Object.create(null, {
      dispose: { get: () => super.dispose }
    });
    return __awaiter(this, void 0, void 0, function* () {
      if (this._streamEffect) {
        yield this.setEffect();
      }
      if (this.conference) {
        yield this.conference.removeTrack(this);
      }
      if (this.stream) {
        this.stopStream();
        this.detach();
      }
      _RTCUtils__WEBPACK_IMPORTED_MODULE_13__["default"].removeListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange);
      if (this._onAudioOutputDeviceChanged) {
        _RTCUtils__WEBPACK_IMPORTED_MODULE_13__["default"].removeListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged);
      }
      return _super.dispose.call(this);
    });
  }
  getCameraFacingMode() {
    var _a, _b;
    if (this.isVideoTrack() && this.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.CAMERA) {
      const trackSettings = (_b = (_a = this.track).getSettings) === null || _b === void 0 ? void 0 : _b.call(_a);
      if (trackSettings && "facingMode" in trackSettings) {
        return trackSettings.facingMode;
      }
      if (typeof this._facingMode !== "undefined") {
        return this._facingMode;
      }
      return (_service_RTC_CameraFacingMode__WEBPACK_IMPORTED_MODULE_4___default().USER);
    }
    return void 0;
  }
  getDeviceId() {
    return this._realDeviceId || this.deviceId;
  }
  getDuration() {
    return Date.now() / 1e3 - this.metadata.timestamp / 1e3;
  }
  getParticipantId() {
    return this.conference && this.conference.myUserId();
  }
  getSourceName() {
    return this._sourceName;
  }
  isEnded() {
    if (this.isVideoTrack() && this.isMuted()) {
      return this._trackEnded;
    }
    return this.getTrack().readyState === "ended" || this._trackEnded;
  }
  isLocal() {
    return true;
  }
  isMuted() {
    if (!this.stream) {
      return true;
    }
    if (this.isVideoTrack() && !this.isActive()) {
      return true;
    }
    if (this._streamEffect && this._streamEffect.isMuted) {
      return this._streamEffect.isMuted();
    }
    return !this.track || !this.track.enabled;
  }
  isReceivingData() {
    if (this.isVideoTrack() && (this.isMuted() || this._stopStreamInProgress || this.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.DESKTOP)) {
      return true;
    }
    if (!this.stream) {
      return false;
    }
    const stream = this._effectEnabled ? this._originalStream : this.stream;
    return stream.getTracks().some((track) => (!("readyState" in track) || track.readyState === "live") && (!("muted" in track) || track.muted !== true));
  }
  mute() {
    return this._queueSetMuted(true);
  }
  onByteSentStatsReceived(tpc, bytesSent) {
    if (bytesSent > 0) {
      this._hasSentData = true;
    }
    const iceConnectionState = tpc.getConnectionState();
    if (this._testDataSent && iceConnectionState === "connected") {
      setTimeout(() => {
        if (!this._hasSentData) {
          logger.warn(`${this} 'bytes sent' <= 0:                         ${bytesSent}`);
          _statistics_statistics__WEBPACK_IMPORTED_MODULE_11__["default"].analytics.sendEvent(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_8__.NO_BYTES_SENT, { "media_type": this.getType() });
        }
      }, 3e3);
      this._testDataSent = false;
    }
  }
  setConference(conference) {
    this.conference = conference;
    for (let i = 0; i < this.containers.length; i++) {
      this._maybeFireTrackAttached(this.containers[i]);
    }
  }
  setEffect(effect) {
    if (typeof this._streamEffect === "undefined" && typeof effect === "undefined") {
      return Promise.resolve();
    }
    if (typeof effect !== "undefined" && !effect.isEnabled(this)) {
      return Promise.reject(new Error("Incompatible effect instance!"));
    }
    if (this._setEffectInProgress === true) {
      return Promise.reject(new Error("setEffect already in progress!"));
    }
    if (this.isMuted() && !this.isAudioTrack()) {
      this._streamEffect = effect;
      return Promise.resolve();
    }
    const conference = this.conference;
    if (!conference) {
      this._switchStreamEffect(effect);
      if (this.isVideoTrack()) {
        this.containers.forEach((cont) => _RTCUtils__WEBPACK_IMPORTED_MODULE_13__["default"].attachMediaStream(cont, this.stream));
      }
      return Promise.resolve();
    }
    this._setEffectInProgress = true;
    return conference._removeLocalTrackFromPc(this).then(() => {
      this._switchStreamEffect(effect);
      if (this.isVideoTrack()) {
        this.containers.forEach((cont) => _RTCUtils__WEBPACK_IMPORTED_MODULE_13__["default"].attachMediaStream(cont, this.stream));
      }
      return conference._addLocalTrackToPc(this);
    }).then(() => {
      this._setEffectInProgress = false;
    }).catch((error) => {
      this._setEffectInProgress = false;
      this._switchStreamEffect();
      logger.error("Failed to switch to the new stream!", error);
      throw error;
    });
  }
  setSourceName(name) {
    this._sourceName = name;
  }
  stopStream() {
    this._stopStreamInProgress = true;
    try {
      _RTCUtils__WEBPACK_IMPORTED_MODULE_13__["default"].stopMediaStream(this.stream);
    } finally {
      this._stopStreamInProgress = false;
    }
  }
  toString() {
    return `LocalTrack[${this.rtcId},${this.getType()}]`;
  }
  unmute() {
    return this._queueSetMuted(false);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiRemoteTrack.js":
/*!*********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiRemoteTrack.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitsiRemoteTrack)
/* harmony export */ });
/* harmony import */ var _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../JitsiTrackEvents */ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _connectivity_TrackStreamingStatus__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../connectivity/TrackStreamingStatus */ "../../lib-jitsi-meet/dist/esm/modules/connectivity/TrackStreamingStatus.js");
/* harmony import */ var _statistics_statistics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _JitsiTrack__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./JitsiTrack */ "../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiTrack.js");







const logger = (__webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js").getLogger)(__filename);
const RTCEvents = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
let ttfmTrackerAudioAttached = false;
let ttfmTrackerVideoAttached = false;
const containerEvents = ["abort", "canplaythrough", "ended", "error"];
class JitsiRemoteTrack extends _JitsiTrack__WEBPACK_IMPORTED_MODULE_5__["default"] {
  constructor(rtc, conference, ownerEndpointId, stream, track, mediaType, videoType, ssrc, muted, isP2P, sourceName) {
    super(conference, stream, track, () => {
    }, mediaType, videoType);
    this.rtc = rtc;
    if (typeof ssrc !== "number") {
      throw new TypeError(`SSRC ${ssrc} is not a number`);
    }
    this.ssrc = ssrc;
    this.ownerEndpointId = ownerEndpointId;
    this.muted = muted;
    this.isP2P = isP2P;
    this._sourceName = sourceName;
    this._trackStreamingStatus = null;
    this._trackStreamingStatusImpl = null;
    this._enteredForwardedSourcesTimestamp = null;
    this.addEventListener = this.on = this._addEventListener.bind(this);
    this.removeEventListener = this.off = this._removeEventListener.bind(this);
    logger.debug(`New remote track created: ${this}`);
    this.hasBeenMuted = muted;
    if (this.rtc && this.track) {
      this._bindTrackHandlers();
    }
    this._containerHandlers = {};
    containerEvents.forEach((event) => {
      this._containerHandlers[event] = this._containerEventHandler.bind(this, event);
    });
  }
  _bindTrackHandlers() {
    this.track.addEventListener("mute", () => this._onTrackMute());
    this.track.addEventListener("unmute", () => this._onTrackUnmute());
    this.track.addEventListener("ended", () => {
      logger.debug(`"onended" event(${Date.now()}): ${this}`);
    });
  }
  _addEventListener(event, handler) {
    super.addListener(event, handler);
    if (event === _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_0__.TRACK_STREAMING_STATUS_CHANGED && this.listenerCount(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_0__.TRACK_STREAMING_STATUS_CHANGED) && !this._trackStreamingStatusImpl) {
      this._initTrackStreamingStatus();
      logger.debug(`Initializing track streaming status: ${this._sourceName}`);
    }
  }
  _removeEventListener(event, handler) {
    super.removeListener(event, handler);
    if (event === _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_0__.TRACK_STREAMING_STATUS_CHANGED && !this.listenerCount(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_0__.TRACK_STREAMING_STATUS_CHANGED)) {
      this._disposeTrackStreamingStatus();
      logger.debug(`Disposing track streaming status: ${this._sourceName}`);
    }
  }
  _onTrackMute() {
    logger.debug(`"onmute" event(${Date.now()}): ${this}`);
    if (this.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_1__.VideoType.DESKTOP) {
      logger.debug("Ignoring mute event on desktop tracks.");
      return;
    }
    this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_MUTE, this);
  }
  _onTrackUnmute() {
    logger.debug(`"onunmute" event(${Date.now()}): ${this}`);
    this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_UNMUTE, this);
  }
  dispose() {
    this._disposeTrackStreamingStatus();
    return super.dispose();
  }
  setMute(value) {
    if (this.muted === value) {
      return;
    }
    if (value) {
      this.hasBeenMuted = true;
    }
    if (this.stream) {
      this.stream.muted = value;
    }
    this.muted = value;
    this.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_0__.TRACK_MUTE_CHANGED, this);
  }
  isMuted() {
    return this.muted;
  }
  getParticipantId() {
    return this.ownerEndpointId;
  }
  isLocal() {
    return false;
  }
  getSSRC() {
    return this.ssrc;
  }
  getSourceName() {
    return this._sourceName;
  }
  setOwner(owner) {
    this.ownerEndpointId = owner;
    this.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_0__.TRACK_OWNER_CHANGED, owner);
  }
  setSourceName(name) {
    this._sourceName = name;
  }
  _setVideoType(type) {
    if (this.videoType === type) {
      return;
    }
    this.videoType = type;
    this.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_0__.TRACK_VIDEOTYPE_CHANGED, type);
  }
  _playCallback() {
    if (!this.conference.room) {
      return;
    }
    const type = this.isVideoTrack() ? "video" : "audio";
    const now = window.performance.now();
    logger.info(`(TIME) Render ${type}:	`, now);
    this.conference.getConnectionTimes()[`${type}.render`] = now;
    const gumStart = window.connectionTimes["obtainPermissions.start"];
    const gumEnd = window.connectionTimes["obtainPermissions.end"];
    const gumDuration = !isNaN(gumEnd) && !isNaN(gumStart) ? gumEnd - gumStart : 0;
    const ttfm = now - (this.conference.getConnectionTimes()["session.initiate"] - this.conference.getConnectionTimes()["muc.joined"]) - gumDuration;
    this.conference.getConnectionTimes()[`${type}.ttfm`] = ttfm;
    logger.info(`(TIME) TTFM ${type}:	`, ttfm);
    _statistics_statistics__WEBPACK_IMPORTED_MODULE_4__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_2__.createTtfmEvent)({
      "media_type": type,
      muted: this.hasBeenMuted,
      value: ttfm
    }));
  }
  _attachTTFMTracker(container) {
    if (ttfmTrackerAudioAttached && this.isAudioTrack() || ttfmTrackerVideoAttached && this.isVideoTrack()) {
      return;
    }
    if (this.isAudioTrack()) {
      ttfmTrackerAudioAttached = true;
    }
    if (this.isVideoTrack()) {
      ttfmTrackerVideoAttached = true;
    }
    container.addEventListener("canplay", this._playCallback.bind(this));
  }
  _onTrackAttach(container) {
    containerEvents.forEach((event) => {
      container.addEventListener(event, this._containerHandlers[event]);
    });
  }
  _onTrackDetach(container) {
    containerEvents.forEach((event) => {
      container.removeEventListener(event, this._containerHandlers[event]);
    });
  }
  _containerEventHandler(type) {
    logger.debug(`${type} handler was called for a container with attached ${this}`);
  }
  _getStatus() {
    const { enabled, muted, readyState } = this.track;
    return `readyState: ${readyState}, muted: ${muted}, enabled: ${enabled}`;
  }
  _initTrackStreamingStatus() {
    const config = this.conference.options.config;
    this._trackStreamingStatus = _connectivity_TrackStreamingStatus__WEBPACK_IMPORTED_MODULE_3__.TrackStreamingStatus.ACTIVE;
    this._trackStreamingStatusImpl = new _connectivity_TrackStreamingStatus__WEBPACK_IMPORTED_MODULE_3__["default"](this.rtc, this.conference, this, {
      p2pRtcMuteTimeout: config._p2pConnStatusRtcMuteTimeout,
      rtcMuteTimeout: config._peerConnStatusRtcMuteTimeout,
      outOfForwardedSourcesTimeout: config._peerConnStatusOutOfLastNTimeout
    });
    this._trackStreamingStatusImpl.init();
    !this._trackStreamingStatusImpl.isVideoTrackFrozen() && this.rtc.eventEmitter.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_0__.TRACK_STREAMING_STATUS_CHANGED, this, this._trackStreamingStatus);
  }
  _disposeTrackStreamingStatus() {
    if (this._trackStreamingStatusImpl) {
      this._trackStreamingStatusImpl.dispose();
      this._trackStreamingStatusImpl = null;
      this._trackStreamingStatus = null;
    }
  }
  _setTrackStreamingStatus(status) {
    this._trackStreamingStatus = status;
  }
  getTrackStreamingStatus() {
    return this._trackStreamingStatus;
  }
  _clearEnteredForwardedSourcesTimestamp() {
    this._enteredForwardedSourcesTimestamp = null;
  }
  _setEnteredForwardedSourcesTimestamp(timestamp) {
    this._enteredForwardedSourcesTimestamp = timestamp;
  }
  _getEnteredForwardedSourcesTimestamp() {
    return this._enteredForwardedSourcesTimestamp;
  }
  toString() {
    return `RemoteTrack[userID: ${this.getParticipantId()}, type: ${this.getType()}, ssrc: ${this.getSSRC()}, p2p: ${this.isP2P}, sourceName: ${this._sourceName}, status: {${this._getStatus()}}]`;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiTrack.js":
/*!***************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiTrack.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitsiTrack)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../JitsiTrackEvents */ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _RTCUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RTCUtils */ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTCUtils.js");







const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const trackHandler2Prop = {
  "track_mute": "onmute",
  "track_unmute": "onunmute",
  "track_ended": "onended"
};
class JitsiTrack extends (events__WEBPACK_IMPORTED_MODULE_1___default()) {
  constructor(conference, stream, track, streamInactiveHandler, trackMediaType, videoType) {
    super();
    this.addEventListener = this.addListener;
    this.removeEventListener = this.off = this.removeListener;
    this.containers = [];
    this.conference = conference;
    this.audioLevel = -1;
    this.type = trackMediaType;
    this.track = track;
    this.videoType = videoType;
    this.handlers = /* @__PURE__ */ new Map();
    this.disposed = false;
    this._streamInactiveHandler = streamInactiveHandler;
    this._setStream(stream);
  }
  _addMediaStreamInactiveHandler(handler) {
    if (_browser__WEBPACK_IMPORTED_MODULE_4__["default"].isFirefox()) {
      this.track.onended = handler;
    } else {
      this.stream.oninactive = handler;
    }
  }
  _attachTTFMTracker(container) {
  }
  _maybeFireTrackAttached(container) {
    if (this.conference && container) {
      this.conference._onTrackAttach(this, container);
    }
  }
  _onTrackAttach(container) {
  }
  _onTrackDetach(container) {
  }
  _setHandler(type, handler) {
    if (!trackHandler2Prop.hasOwnProperty(type)) {
      logger.error(`Invalid handler type ${type}`);
      return;
    }
    if (handler) {
      this.handlers.set(type, handler);
    } else {
      this.handlers.delete(type);
    }
    if (this.stream) {
      for (const track of this.stream.getTracks()) {
        track[trackHandler2Prop[type]] = handler;
      }
    }
  }
  _setStream(stream) {
    if (this.stream === stream) {
      return;
    }
    this.stream = stream;
    if (this.stream) {
      for (const type of this.handlers.keys()) {
        this._setHandler(type, this.handlers.get(type));
      }
      if (this._streamInactiveHandler) {
        this._addMediaStreamInactiveHandler(this._streamInactiveHandler);
      }
    }
  }
  _unregisterHandlers() {
    if (!this.stream) {
      logger.warn(`${this}: unable to unregister handlers - no stream object`);
      return;
    }
    for (const type of this.handlers.keys()) {
      for (const videoTrack of this.stream.getVideoTracks()) {
        videoTrack[trackHandler2Prop[type]] = void 0;
      }
    }
    if (this._streamInactiveHandler) {
      this._addMediaStreamInactiveHandler(void 0);
    }
  }
  attach(container) {
    if (this.stream) {
      this._onTrackAttach(container);
      _RTCUtils__WEBPACK_IMPORTED_MODULE_5__["default"].attachMediaStream(container, this.stream);
    }
    this.containers.push(container);
    this._maybeFireTrackAttached(container);
    this._attachTTFMTracker(container);
  }
  detach(container) {
    for (let cs = this.containers, i = cs.length - 1; i >= 0; --i) {
      const c = cs[i];
      if (!container) {
        this._onTrackDetach(c);
        _RTCUtils__WEBPACK_IMPORTED_MODULE_5__["default"].attachMediaStream(c, null);
      }
      if (!container || c === container) {
        cs.splice(i, 1);
      }
    }
    if (container) {
      this._onTrackDetach(container);
      _RTCUtils__WEBPACK_IMPORTED_MODULE_5__["default"].attachMediaStream(container, null);
    }
  }
  dispose() {
    this.removeAllListeners();
    this.disposed = true;
    return Promise.resolve();
  }
  getId() {
    return this.getStreamId();
  }
  getMSID() {
    const streamId = this.getStreamId();
    const trackId = this.getTrackId();
    return streamId && trackId ? `${streamId} ${trackId}` : null;
  }
  getOriginalStream() {
    return this.stream;
  }
  getSourceName() {
  }
  getStreamId() {
    return this.stream ? this.stream.id : null;
  }
  getTrack() {
    return this.track;
  }
  getTrackLabel() {
    return this.track.label;
  }
  getTrackId() {
    return this.track ? this.track.id : null;
  }
  getType() {
    return this.type;
  }
  getUsageLabel() {
    if (this.isAudioTrack()) {
      return "mic";
    }
    return this.videoType ? this.videoType : "default";
  }
  getVideoType() {
    return this.videoType;
  }
  isActive() {
    if (typeof this.stream.active !== "undefined") {
      return this.stream.active;
    }
    return true;
  }
  isAudioTrack() {
    return this.getType() === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.AUDIO;
  }
  isLocal() {
    throw new Error("Not implemented by subclass");
  }
  isLocalAudioTrack() {
    return this.isAudioTrack() && this.isLocal();
  }
  isVideoTrack() {
    return this.getType() === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO;
  }
  isWebRTCTrackMuted() {
    return this.track && this.track.muted;
  }
  setAudioLevel(audioLevel, tpc) {
    let newAudioLevel = audioLevel;
    if (_browser__WEBPACK_IMPORTED_MODULE_4__["default"].supportsReceiverStats() && typeof tpc !== "undefined" && this.isMuted()) {
      newAudioLevel = 0;
    }
    if (this.audioLevel !== newAudioLevel) {
      this.audioLevel = newAudioLevel;
      this.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__.TRACK_AUDIO_LEVEL_CHANGED, newAudioLevel, tpc);
    } else if (this.audioLevel === 0 && newAudioLevel === 0 && this.isLocal() && !this.isWebRTCTrackMuted()) {
      this.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__.NO_AUDIO_INPUT, newAudioLevel);
    }
  }
  setAudioOutput(audioOutputDeviceId) {
    if (!_RTCUtils__WEBPACK_IMPORTED_MODULE_5__["default"].isDeviceChangeAvailable("output")) {
      return Promise.reject(new Error("Audio output device change is not supported"));
    }
    if (this.isVideoTrack()) {
      return Promise.resolve();
    }
    return Promise.all(this.containers.map((element) => element.setSinkId(audioOutputDeviceId).catch((error) => {
      logger.warn("Failed to change audio output device on element. Default or previously set audio output device will be used.", element, error);
      throw error;
    }))).then(() => {
      this.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__.TRACK_AUDIO_OUTPUT_CHANGED, audioOutputDeviceId);
    });
  }
  setSourceName(name) {
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTC.js":
/*!********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/RTC/RTC.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RTC)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");
/* harmony import */ var _util_MathUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/MathUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/MathUtil.js");
/* harmony import */ var _BridgeChannel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BridgeChannel */ "../../lib-jitsi-meet/dist/esm/modules/RTC/BridgeChannel.js");
/* harmony import */ var _JitsiLocalTrack__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./JitsiLocalTrack */ "../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiLocalTrack.js");
/* harmony import */ var _RTCUtils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./RTCUtils */ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTCUtils.js");
/* harmony import */ var _TraceablePeerConnection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TraceablePeerConnection */ "../../lib-jitsi-meet/dist/esm/modules/RTC/TraceablePeerConnection.js");













const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
let peerConnectionIdCounter = 0;
let rtcTrackIdCounter = 0;
function _createLocalTracks(mediaStreamMetaData = []) {
  return mediaStreamMetaData.map((metaData) => {
    const { sourceId, sourceType, stream, track, videoType, effects } = metaData;
    const { deviceId, facingMode } = track.getSettings();
    rtcTrackIdCounter = (0,_util_MathUtil__WEBPACK_IMPORTED_MODULE_7__.safeCounterIncrement)(rtcTrackIdCounter);
    return new _JitsiLocalTrack__WEBPACK_IMPORTED_MODULE_9__["default"]({
      deviceId,
      facingMode,
      mediaType: track.kind,
      rtcId: rtcTrackIdCounter,
      sourceId,
      sourceType,
      stream,
      track,
      videoType: videoType || null,
      effects
    });
  });
}
class RTC extends _util_Listenable__WEBPACK_IMPORTED_MODULE_6__["default"] {
  constructor(conference, options = {}) {
    super();
    this.conference = conference;
    this.peerConnections = /* @__PURE__ */ new Map();
    this.localTracks = [];
    this.options = options;
    this._channel = null;
    this._lastN = void 0;
    this._forwardedSources = null;
    this._forwardedSourcesChangeListener = this._onForwardedSourcesChanged.bind(this);
    this._onDeviceListChanged = this._onDeviceListChanged.bind(this);
    this._updateAudioOutputForAudioTracks = this._updateAudioOutputForAudioTracks.bind(this);
    if (_RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].isDeviceChangeAvailable("output")) {
      _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks);
      _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].DEVICE_LIST_CHANGED, this._onDeviceListChanged);
    }
  }
  destroy() {
    _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].removeListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks);
    _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].removeListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].DEVICE_LIST_CHANGED, this._onDeviceListChanged);
    if (this._channelOpenListener) {
      this.removeListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].DATA_CHANNEL_OPEN, this._channelOpenListener);
    }
  }
  static createLocalTracks(tracksInfo) {
    return _createLocalTracks(tracksInfo);
  }
  static obtainAudioAndVideoPermissions(options) {
    return _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].obtainAudioAndVideoPermissions(options).then((tracksInfo) => _createLocalTracks(tracksInfo));
  }
  initializeBridgeChannel(peerconnection, wsUrl) {
    this._channel = new _BridgeChannel__WEBPACK_IMPORTED_MODULE_8__["default"](peerconnection, wsUrl, this.eventEmitter, this.conference);
    this._channelOpenListener = () => {
      const logError = (error, msgType, value) => {
        _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_5___default().callErrorHandler(error);
        logger.error(`Cannot send ${msgType}(${JSON.stringify(value)}) endpoint message`, error);
      };
      if (this._receiverVideoConstraints) {
        try {
          this._channel.sendReceiverVideoConstraintsMessage(this._receiverVideoConstraints);
        } catch (error) {
          logError(error, "ReceiverVideoConstraints", this._receiverVideoConstraints);
        }
      }
      if (typeof this._lastN !== "undefined" && this._lastN !== -1) {
        try {
          this._channel.sendSetLastNMessage(this._lastN);
        } catch (error) {
          logError(error, "LastNChangedEvent", this._lastN);
        }
      }
    };
    this.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].DATA_CHANNEL_OPEN, this._channelOpenListener);
    this.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].FORWARDED_SOURCES_CHANGED, this._forwardedSourcesChangeListener);
  }
  _onDeviceListChanged() {
    this._updateAudioOutputForAudioTracks(_RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].getAudioOutputDevice());
  }
  _onForwardedSourcesChanged(forwardedSources = []) {
    const oldForwardedSources = this._forwardedSources || [];
    let leavingForwardedSources = [];
    let enteringForwardedSources = [];
    const timestamp = Date.now();
    this._forwardedSources = forwardedSources;
    leavingForwardedSources = oldForwardedSources.filter((sourceName) => !this.isInForwardedSources(sourceName));
    enteringForwardedSources = forwardedSources.filter((sourceName) => oldForwardedSources.indexOf(sourceName) === -1);
    logger.debug(`Fowarded sources changed leaving=${leavingForwardedSources}, entering=${enteringForwardedSources} at ${timestamp}`);
    this.conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.FORWARDED_SOURCES_CHANGED, leavingForwardedSources, enteringForwardedSources, timestamp);
  }
  onCallEnded() {
    if (this._channel) {
      if (this._channel && this._channel.mode === "websocket") {
        this._channel.close();
      }
      this._channel = null;
    }
  }
  setDesktopSharingFrameRate(maxFps) {
    _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].setDesktopSharingFrameRate(maxFps);
  }
  setReceiverVideoConstraints(constraints) {
    this._receiverVideoConstraints = constraints;
    if (this._channel && this._channel.isOpen()) {
      this._channel.sendReceiverVideoConstraintsMessage(constraints);
    }
  }
  sendSourceVideoType(sourceName, videoType) {
    if (this._channel && this._channel.isOpen()) {
      this._channel.sendSourceVideoTypeMessage(sourceName, videoType);
    }
  }
  static addListener(eventType, listener) {
    _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].addListener(eventType, listener);
  }
  static removeListener(eventType, listener) {
    _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].removeListener(eventType, listener);
  }
  static init(options = {}) {
    this.options = options;
    return _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].init(this.options);
  }
  createPeerConnection(signaling, pcConfig, isP2P, options) {
    const pcConstraints = JSON.parse(JSON.stringify(_RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].pcConstraints));
    if (options.enableInsertableStreams) {
      logger.debug("E2EE - setting insertable streams constraints");
      pcConfig.encodedInsertableStreams = true;
    }
    const supportsSdpSemantics = _browser__WEBPACK_IMPORTED_MODULE_4__["default"].isChromiumBased() && !options.usesUnifiedPlan;
    if (supportsSdpSemantics) {
      logger.debug("WebRTC application is running in plan-b mode");
      pcConfig.sdpSemantics = "plan-b";
    }
    if (options.forceTurnRelay) {
      pcConfig.iceTransportPolicy = "relay";
    }
    pcConfig.bundlePolicy = "max-bundle";
    peerConnectionIdCounter = (0,_util_MathUtil__WEBPACK_IMPORTED_MODULE_7__.safeCounterIncrement)(peerConnectionIdCounter);
    const newConnection = new _TraceablePeerConnection__WEBPACK_IMPORTED_MODULE_11__["default"](this, peerConnectionIdCounter, signaling, pcConfig, pcConstraints, isP2P, options);
    this.peerConnections.set(newConnection.id, newConnection);
    return newConnection;
  }
  _removePeerConnection(traceablePeerConnection) {
    const id = traceablePeerConnection.id;
    if (this.peerConnections.has(id)) {
      this.peerConnections.delete(id);
      return true;
    }
    return false;
  }
  addLocalTrack(track) {
    if (!track) {
      throw new Error("track must not be null nor undefined");
    }
    this.localTracks.push(track);
    track.conference = this.conference;
  }
  getForwardedSources() {
    return this._forwardedSources;
  }
  getLocalVideoTrack() {
    const localVideo = this.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO);
    return localVideo.length ? localVideo[0] : void 0;
  }
  getLocalVideoTracks() {
    return this.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO);
  }
  getLocalAudioTrack() {
    const localAudio = this.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.AUDIO);
    return localAudio.length ? localAudio[0] : void 0;
  }
  getLocalEndpointId() {
    return this.conference.myUserId();
  }
  getLocalTracks(mediaType) {
    let tracks = this.localTracks.slice();
    if (mediaType !== void 0) {
      tracks = tracks.filter((track) => track.getType() === mediaType);
    }
    return tracks;
  }
  getRemoteTracks(mediaType) {
    let remoteTracks = [];
    for (const tpc of this.peerConnections.values()) {
      const pcRemoteTracks = tpc.getRemoteTracks(void 0, mediaType);
      if (pcRemoteTracks) {
        remoteTracks = remoteTracks.concat(pcRemoteTracks);
      }
    }
    return remoteTracks;
  }
  setAudioMute(value) {
    const mutePromises = [];
    this.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.AUDIO).forEach((audioTrack) => {
      mutePromises.push(value ? audioTrack.mute() : audioTrack.unmute());
    });
    return Promise.all(mutePromises);
  }
  setVideoMute(value) {
    const mutePromises = [];
    this.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO).forEach((videoTrack) => {
      mutePromises.push(value ? videoTrack.mute() : videoTrack.unmute());
    });
    return Promise.all(mutePromises);
  }
  removeLocalTrack(track) {
    const pos = this.localTracks.indexOf(track);
    if (pos === -1) {
      return;
    }
    this.localTracks.splice(pos, 1);
  }
  static attachMediaStream(elSelector, stream) {
    return _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].attachMediaStream(elSelector, stream);
  }
  static isDeviceListAvailable() {
    return _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].isDeviceListAvailable();
  }
  static isDeviceChangeAvailable(deviceType) {
    return _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].isDeviceChangeAvailable(deviceType);
  }
  static isWebRtcSupported() {
    return _browser__WEBPACK_IMPORTED_MODULE_4__["default"].isSupported();
  }
  static getAudioOutputDevice() {
    return _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].getAudioOutputDevice();
  }
  static getCurrentlyAvailableMediaDevices() {
    return _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].getCurrentlyAvailableMediaDevices();
  }
  static arePermissionsGrantedForAvailableDevices() {
    return _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].arePermissionsGrantedForAvailableDevices();
  }
  static getEventDataForActiveDevice(device) {
    return _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].getEventDataForActiveDevice(device);
  }
  static setAudioOutputDevice(deviceId) {
    return _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].setAudioOutputDevice(deviceId);
  }
  static isUserStream(stream) {
    return RTC.isUserStreamById(stream.id);
  }
  static isUserStreamById(streamId) {
    return streamId && streamId !== "mixedmslabel" && streamId !== "default";
  }
  static enumerateDevices(callback) {
    _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].enumerateDevices(callback);
  }
  static stopMediaStream(mediaStream) {
    _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].stopMediaStream(mediaStream);
  }
  static isDesktopSharingEnabled() {
    return _RTCUtils__WEBPACK_IMPORTED_MODULE_10__["default"].isDesktopSharingEnabled();
  }
  closeBridgeChannel() {
    if (this._channel) {
      this._channel.close();
      this._channel = null;
    }
  }
  setAudioLevel(tpc, ssrc, audioLevel, isLocal) {
    const track = tpc.getTrackBySSRC(ssrc);
    if (!track) {
      return;
    } else if (!track.isAudioTrack()) {
      logger.warn(`Received audio level for non-audio track: ${ssrc}`);
      return;
    } else if (track.isLocal() !== isLocal) {
      logger.error(`${track} was expected to ${isLocal ? "be" : "not be"} local`);
    }
    track.setAudioLevel(audioLevel, tpc);
  }
  sendChannelMessage(to, payload) {
    if (this._channel) {
      this._channel.sendMessage(to, payload);
    } else {
      throw new Error("Channel support is disabled!");
    }
  }
  sendEndpointStatsMessage(payload) {
    if (this._channel && this._channel.isOpen()) {
      this._channel.sendEndpointStatsMessage(payload);
    }
  }
  setLastN(value) {
    if (this._lastN !== value) {
      this._lastN = value;
      if (this._channel && this._channel.isOpen()) {
        this._channel.sendSetLastNMessage(value);
      }
      this.eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].LASTN_VALUE_CHANGED, value);
    }
  }
  isInForwardedSources(sourceName) {
    return !this._forwardedSources || this._forwardedSources.indexOf(sourceName) > -1;
  }
  _updateAudioOutputForAudioTracks(deviceId) {
    const remoteAudioTracks = this.getRemoteTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.AUDIO);
    for (const track of remoteAudioTracks) {
      track.setAudioOutput(deviceId);
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTCUtils.js":
/*!*************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/RTC/RTCUtils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash.clonedeep */ "../../lib-jitsi-meet/node_modules/lodash.clonedeep/index.js");
/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! webrtc-adapter */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/adapter_core.js");
/* harmony import */ var _JitsiTrackError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../JitsiTrackError */ "../../lib-jitsi-meet/dist/esm/JitsiTrackError.js");
/* harmony import */ var _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../JitsiTrackErrors */ "../../lib-jitsi-meet/dist/esm/JitsiTrackErrors.js");
/* harmony import */ var _service_RTC_CameraFacingMode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../service/RTC/CameraFacingMode */ "../../lib-jitsi-meet/dist/esm/service/RTC/CameraFacingMode.js");
/* harmony import */ var _service_RTC_CameraFacingMode__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_service_RTC_CameraFacingMode__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _service_RTC_Resolutions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../service/RTC/Resolutions */ "../../lib-jitsi-meet/dist/esm/service/RTC/Resolutions.js");
/* harmony import */ var _service_RTC_Resolutions__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_service_RTC_Resolutions__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _statistics_statistics__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");
/* harmony import */ var _ScreenObtainer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ScreenObtainer */ "../../lib-jitsi-meet/dist/esm/modules/RTC/ScreenObtainer.js");

var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
















const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const eventEmitter = new (events__WEBPACK_IMPORTED_MODULE_1___default())();
const AVAILABLE_DEVICES_POLL_INTERVAL_TIME = 3e3;
const DEFAULT_CONSTRAINTS = {
  video: {
    height: {
      ideal: 720,
      max: 720,
      min: 180
    },
    width: {
      ideal: 1280,
      max: 1280,
      min: 320
    }
  }
};
let audioOutputDeviceId = "default";
let audioOutputChanged = false;
let disableAP = false;
let disableAEC = false;
let disableNS = false;
let disableAGC = false;
let stereo = null;
const featureDetectionAudioEl = document.createElement("audio");
const isAudioOutputDeviceChangeAvailable = typeof featureDetectionAudioEl.setSinkId !== "undefined";
let availableDevices = [];
let availableDevicesPollTimer;
function emptyFuncton() {
}
function getConstraints(um = [], options = {}) {
  const constraints = lodash_clonedeep__WEBPACK_IMPORTED_MODULE_2___default()(options.constraints || DEFAULT_CONSTRAINTS);
  if (um.indexOf("video") >= 0) {
    if ((_service_RTC_Resolutions__WEBPACK_IMPORTED_MODULE_8___default())[options.resolution]) {
      const r = (_service_RTC_Resolutions__WEBPACK_IMPORTED_MODULE_8___default())[options.resolution];
      constraints.video.height = { ideal: r.height };
      constraints.video.width = { ideal: r.width };
    }
    if (!constraints.video) {
      constraints.video = {};
    }
    if (_browser__WEBPACK_IMPORTED_MODULE_11__["default"].isWebKitBased()) {
      if (constraints.video.height && constraints.video.height.ideal) {
        constraints.video.height = { ideal: constraints.video.height.ideal };
      } else {
        logger.warn("Ideal camera height missing, camera may not start properly");
      }
      if (constraints.video.width && constraints.video.width.ideal) {
        constraints.video.width = { ideal: constraints.video.width.ideal };
      } else {
        logger.warn("Ideal camera width missing, camera may not start properly");
      }
    }
    if (options.cameraDeviceId) {
      constraints.video.deviceId = options.cameraDeviceId;
    } else {
      const facingMode = options.facingMode || (_service_RTC_CameraFacingMode__WEBPACK_IMPORTED_MODULE_6___default().USER);
      constraints.video.facingMode = facingMode;
    }
  } else {
    constraints.video = false;
  }
  if (um.indexOf("audio") >= 0) {
    if (!constraints.audio || typeof constraints.audio === "boolean") {
      constraints.audio = {};
    }
    constraints.audio = {
      autoGainControl: !disableAGC && !disableAP,
      deviceId: options.micDeviceId,
      echoCancellation: !disableAEC && !disableAP,
      noiseSuppression: !disableNS && !disableAP
    };
    if (stereo) {
      Object.assign(constraints.audio, { channelCount: 2 });
    }
  } else {
    constraints.audio = false;
  }
  return constraints;
}
function updateGrantedPermissions(um, stream) {
  const audioTracksReceived = Boolean(stream) && stream.getAudioTracks().length > 0;
  const videoTracksReceived = Boolean(stream) && stream.getVideoTracks().length > 0;
  const grantedPermissions = {};
  if (um.indexOf("video") !== -1) {
    grantedPermissions.video = videoTracksReceived;
  }
  if (um.indexOf("audio") !== -1) {
    grantedPermissions.audio = audioTracksReceived;
  }
  eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_7__["default"].PERMISSIONS_CHANGED, grantedPermissions);
}
function compareAvailableMediaDevices(newDevices) {
  if (newDevices.length !== availableDevices.length) {
    return true;
  }
  return newDevices.map(mediaDeviceInfoToJSON).sort().join("") !== availableDevices.map(mediaDeviceInfoToJSON).sort().join("");
  function mediaDeviceInfoToJSON(info) {
    return JSON.stringify({
      kind: info.kind,
      deviceId: info.deviceId,
      groupId: info.groupId,
      label: info.label,
      facing: info.facing
    });
  }
}
function sendDeviceListToAnalytics(deviceList) {
  const audioInputDeviceCount = deviceList.filter((d) => d.kind === "audioinput").length;
  const audioOutputDeviceCount = deviceList.filter((d) => d.kind === "audiooutput").length;
  const videoInputDeviceCount = deviceList.filter((d) => d.kind === "videoinput").length;
  const videoOutputDeviceCount = deviceList.filter((d) => d.kind === "videooutput").length;
  deviceList.forEach((device) => {
    const attributes = {
      "audio_input_device_count": audioInputDeviceCount,
      "audio_output_device_count": audioOutputDeviceCount,
      "video_input_device_count": videoInputDeviceCount,
      "video_output_device_count": videoOutputDeviceCount,
      "device_id": device.deviceId,
      "device_group_id": device.groupId,
      "device_kind": device.kind,
      "device_label": device.label
    };
    _statistics_statistics__WEBPACK_IMPORTED_MODULE_12__["default"].sendAnalytics(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_10__.AVAILABLE_DEVICE, attributes);
  });
}
function updateKnownDevices(pds) {
  if (compareAvailableMediaDevices(pds)) {
    onMediaDevicesListChanged(pds);
  }
}
function onMediaDevicesListChanged(devicesReceived) {
  availableDevices = devicesReceived.slice(0);
  logger.info("list of media devices has changed:", availableDevices);
  sendDeviceListToAnalytics(availableDevices);
  eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_7__["default"].DEVICE_LIST_WILL_CHANGE, availableDevices);
  eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_7__["default"].DEVICE_LIST_CHANGED, availableDevices);
}
class RTCUtils extends _util_Listenable__WEBPACK_IMPORTED_MODULE_14__["default"] {
  constructor() {
    super(eventEmitter);
  }
  init(options = {}) {
    var _a;
    if (typeof options.disableAEC === "boolean") {
      disableAEC = options.disableAEC;
      logger.info(`Disable AEC: ${disableAEC}`);
    }
    if (typeof options.disableNS === "boolean") {
      disableNS = options.disableNS;
      logger.info(`Disable NS: ${disableNS}`);
    }
    if (typeof options.disableAP === "boolean") {
      disableAP = options.disableAP;
      logger.info(`Disable AP: ${disableAP}`);
    }
    if (typeof options.disableAGC === "boolean") {
      disableAGC = options.disableAGC;
      logger.info(`Disable AGC: ${disableAGC}`);
    }
    if (typeof ((_a = options.audioQuality) === null || _a === void 0 ? void 0 : _a.stereo) === "boolean") {
      stereo = options.audioQuality.stereo;
      logger.info(`Stereo: ${stereo}`);
    }
    window.clearInterval(availableDevicesPollTimer);
    availableDevicesPollTimer = void 0;
    if (!_browser__WEBPACK_IMPORTED_MODULE_11__["default"].isReactNative()) {
      this.attachMediaStream = wrapAttachMediaStream((element, stream) => {
        if (element) {
          element.srcObject = stream;
        }
      });
    }
    this.pcConstraints = {};
    _ScreenObtainer__WEBPACK_IMPORTED_MODULE_15__["default"].init(options);
    if (this.isDeviceListAvailable()) {
      this.enumerateDevices((ds) => {
        availableDevices = ds.slice(0);
        logger.debug("Available devices: ", availableDevices);
        sendDeviceListToAnalytics(availableDevices);
        eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_7__["default"].DEVICE_LIST_AVAILABLE, availableDevices);
        if (_browser__WEBPACK_IMPORTED_MODULE_11__["default"].supportsDeviceChangeEvent()) {
          navigator.mediaDevices.addEventListener("devicechange", () => this.enumerateDevices(emptyFuncton));
        } else {
          availableDevicesPollTimer = window.setInterval(() => this.enumerateDevices(emptyFuncton), AVAILABLE_DEVICES_POLL_INTERVAL_TIME);
        }
      });
    }
  }
  enumerateDevices(callback) {
    navigator.mediaDevices.enumerateDevices().then((devices) => {
      updateKnownDevices(devices);
      callback(devices);
    }).catch((error) => {
      logger.warn(`Failed to  enumerate devices. ${error}`);
      updateKnownDevices([]);
      callback([]);
    });
  }
  _getUserMedia(umDevices, constraints = {}, timeout = 0) {
    return new Promise((resolve, reject) => {
      let gumTimeout, timeoutExpired = false;
      if (typeof timeout === "number" && !isNaN(timeout) && timeout > 0) {
        gumTimeout = setTimeout(() => {
          timeoutExpired = true;
          gumTimeout = void 0;
          reject(new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_4__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_5__.TIMEOUT));
        }, timeout);
      }
      navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
        logger.log("onUserMediaSuccess");
        updateGrantedPermissions(umDevices, stream);
        if (!timeoutExpired) {
          if (typeof gumTimeout !== "undefined") {
            clearTimeout(gumTimeout);
          }
          resolve(stream);
        }
      }).catch((error) => {
        logger.warn(`Failed to get access to local media. ${error} ${JSON.stringify(constraints)}`);
        const jitsiError = new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_4__["default"](error, constraints, umDevices);
        if (!timeoutExpired) {
          if (typeof gumTimeout !== "undefined") {
            clearTimeout(gumTimeout);
          }
          reject(jitsiError);
        }
        if (jitsiError.name === _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_5__.PERMISSION_DENIED) {
          updateGrantedPermissions(umDevices, void 0);
        }
      });
    });
  }
  _getDesktopMedia(options) {
    if (!_ScreenObtainer__WEBPACK_IMPORTED_MODULE_15__["default"].isSupported()) {
      return Promise.reject(new Error("Desktop sharing is not supported!"));
    }
    return new Promise((resolve, reject) => {
      _ScreenObtainer__WEBPACK_IMPORTED_MODULE_15__["default"].obtainStream((stream) => {
        resolve(stream);
      }, (error) => {
        reject(error);
      }, options);
    });
  }
  _getMissingTracks(requestedDevices = [], stream) {
    const missingDevices = [];
    const audioDeviceRequested = requestedDevices.includes("audio");
    const audioTracksReceived = stream && stream.getAudioTracks().length > 0;
    if (audioDeviceRequested && !audioTracksReceived) {
      missingDevices.push("audio");
    }
    const videoDeviceRequested = requestedDevices.includes("video");
    const videoTracksReceived = stream && stream.getVideoTracks().length > 0;
    if (videoDeviceRequested && !videoTracksReceived) {
      missingDevices.push("video");
    }
    return missingDevices;
  }
  obtainAudioAndVideoPermissions(options) {
    const { timeout } = options, otherOptions = __rest(options, ["timeout"]);
    const mediaStreamsMetaData = [];
    const maybeRequestDesktopDevice = function() {
      const umDevices = otherOptions.devices || [];
      const isDesktopDeviceRequested = umDevices.indexOf("desktop") !== -1;
      if (!isDesktopDeviceRequested) {
        return Promise.resolve();
      }
      const { desktopSharingSourceDevice, desktopSharingSources } = otherOptions;
      if (desktopSharingSourceDevice) {
        const matchingDevice = availableDevices && availableDevices.find((device) => device.kind === "videoinput" && (device.deviceId === desktopSharingSourceDevice || device.label === desktopSharingSourceDevice));
        if (!matchingDevice) {
          return Promise.reject(new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_4__["default"]({ name: "ConstraintNotSatisfiedError" }, {}, [desktopSharingSourceDevice]));
        }
        const requestedDevices = ["video"];
        const constraints = {
          video: {
            deviceId: matchingDevice.deviceId
          }
        };
        return this._getUserMedia(requestedDevices, constraints, timeout).then((stream) => {
          return {
            sourceType: "device",
            stream
          };
        });
      }
      return this._getDesktopMedia({ desktopSharingSources });
    }.bind(this);
    const maybeCreateAndAddDesktopTrack = function(desktopStream) {
      if (!desktopStream) {
        return;
      }
      const { stream, sourceId, sourceType } = desktopStream;
      const desktopAudioTracks = stream.getAudioTracks();
      if (desktopAudioTracks.length) {
        const desktopAudioStream = new MediaStream(desktopAudioTracks);
        mediaStreamsMetaData.push({
          stream: desktopAudioStream,
          sourceId,
          sourceType,
          track: desktopAudioStream.getAudioTracks()[0]
        });
      }
      const desktopVideoTracks = stream.getVideoTracks();
      if (desktopVideoTracks.length) {
        const desktopVideoStream = new MediaStream(desktopVideoTracks);
        mediaStreamsMetaData.push({
          stream: desktopVideoStream,
          sourceId,
          sourceType,
          track: desktopVideoStream.getVideoTracks()[0],
          videoType: _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.DESKTOP
        });
      }
    };
    const maybeRequestCaptureDevices = function() {
      const umDevices = otherOptions.devices || ["audio", "video"];
      const requestedCaptureDevices = umDevices.filter((device) => device === "audio" || device === "video");
      if (!requestedCaptureDevices.length) {
        return Promise.resolve();
      }
      const constraints = getConstraints(requestedCaptureDevices, otherOptions);
      logger.info("Got media constraints: ", JSON.stringify(constraints));
      return this._getUserMedia(requestedCaptureDevices, constraints, timeout);
    }.bind(this);
    const maybeCreateAndAddAVTracks = function(avStream) {
      if (!avStream) {
        return;
      }
      const audioTracks = avStream.getAudioTracks();
      if (audioTracks.length) {
        const audioStream = new MediaStream(audioTracks);
        mediaStreamsMetaData.push({
          stream: audioStream,
          track: audioStream.getAudioTracks()[0],
          effects: otherOptions.effects
        });
      }
      const videoTracks = avStream.getVideoTracks();
      if (videoTracks.length) {
        const videoStream = new MediaStream(videoTracks);
        mediaStreamsMetaData.push({
          stream: videoStream,
          track: videoStream.getVideoTracks()[0],
          videoType: _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.CAMERA,
          effects: otherOptions.effects
        });
      }
    };
    return maybeRequestDesktopDevice().then(maybeCreateAndAddDesktopTrack).then(maybeRequestCaptureDevices).then(maybeCreateAndAddAVTracks).then(() => mediaStreamsMetaData).catch((error) => {
      mediaStreamsMetaData.forEach(({ stream }) => {
        this.stopMediaStream(stream);
      });
      return Promise.reject(error);
    });
  }
  isDeviceListAvailable() {
    return Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);
  }
  isDeviceChangeAvailable(deviceType) {
    if (deviceType === "output" || deviceType === "audiooutput") {
      return isAudioOutputDeviceChangeAvailable;
    }
    return true;
  }
  stopMediaStream(mediaStream) {
    if (!mediaStream) {
      return;
    }
    mediaStream.getTracks().forEach((track) => {
      if (track.stop) {
        track.stop();
      }
    });
    if (mediaStream.stop) {
      mediaStream.stop();
    }
    if (mediaStream.release) {
      mediaStream.release();
    }
  }
  isDesktopSharingEnabled() {
    return _ScreenObtainer__WEBPACK_IMPORTED_MODULE_15__["default"].isSupported();
  }
  setAudioOutputDevice(deviceId) {
    if (!this.isDeviceChangeAvailable("output")) {
      return Promise.reject(new Error("Audio output device change is not supported"));
    }
    return featureDetectionAudioEl.setSinkId(deviceId).then(() => {
      audioOutputDeviceId = deviceId;
      audioOutputChanged = true;
      logger.log(`Audio output device set to ${deviceId}`);
      eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_7__["default"].AUDIO_OUTPUT_DEVICE_CHANGED, deviceId);
    });
  }
  setDesktopSharingFrameRate(maxFps) {
    _ScreenObtainer__WEBPACK_IMPORTED_MODULE_15__["default"].setDesktopSharingFrameRate(maxFps);
  }
  getAudioOutputDevice() {
    return audioOutputDeviceId;
  }
  getCurrentlyAvailableMediaDevices() {
    return availableDevices;
  }
  arePermissionsGrantedForAvailableDevices() {
    return availableDevices.some((device) => Boolean(device.label));
  }
  getEventDataForActiveDevice(device) {
    const deviceList = [];
    const deviceData = {
      "deviceId": device.deviceId,
      "kind": device.kind,
      "label": device.label,
      "groupId": device.groupId
    };
    deviceList.push(deviceData);
    return { deviceList };
  }
}
const rtcUtils = new RTCUtils();
function wrapAttachMediaStream(origAttachMediaStream) {
  return function(element, stream) {
    const res = origAttachMediaStream.apply(rtcUtils, arguments);
    if (stream && rtcUtils.isDeviceChangeAvailable("output") && stream.getAudioTracks && stream.getAudioTracks().length && audioOutputChanged) {
      element.setSinkId(rtcUtils.getAudioOutputDevice()).catch(function(ex) {
        const err = new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_4__["default"](ex, null, ["audiooutput"]);
        _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_13___default().callUnhandledRejectionHandler({
          promise: this,
          reason: err
        });
        logger.warn("Failed to set audio output device for the element. Default audio output device will be used instead", element, err);
      });
    }
    return res;
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rtcUtils);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/RTC/ScreenObtainer.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/RTC/ScreenObtainer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SS_DEFAULT_FRAME_RATE: () => (/* binding */ SS_DEFAULT_FRAME_RATE),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _JitsiTrackError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../JitsiTrackError */ "../../lib-jitsi-meet/dist/esm/JitsiTrackError.js");
/* harmony import */ var _JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiTrackErrors */ "../../lib-jitsi-meet/dist/esm/JitsiTrackErrors.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");




const logger = (__webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js").getLogger)(__filename);
const SS_DEFAULT_FRAME_RATE = 5;
const ScreenObtainer = {
  obtainStream: null,
  init(options = {}) {
    this.options = options;
    this.obtainStream = this._createObtainStreamMethod();
    if (!this.obtainStream) {
      logger.info("Desktop sharing disabled");
    }
  },
  _createObtainStreamMethod() {
    if (_browser__WEBPACK_IMPORTED_MODULE_2__["default"].isNWJS()) {
      return (onSuccess, onFailure) => {
        window.JitsiMeetNW.obtainDesktopStream(onSuccess, (error, constraints) => {
          let jitsiError;
          if (error && error.name === "InvalidStateError") {
            jitsiError = new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_0__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_1__.SCREENSHARING_USER_CANCELED);
          } else {
            jitsiError = new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_0__["default"](error, constraints, ["desktop"]);
          }
          typeof onFailure === "function" && onFailure(jitsiError);
        });
      };
    } else if (_browser__WEBPACK_IMPORTED_MODULE_2__["default"].isElectron()) {
      return this.obtainScreenOnElectron;
    } else if (_browser__WEBPACK_IMPORTED_MODULE_2__["default"].isReactNative() && _browser__WEBPACK_IMPORTED_MODULE_2__["default"].supportsGetDisplayMedia()) {
      return this.obtainScreenFromGetDisplayMediaRN;
    } else if (_browser__WEBPACK_IMPORTED_MODULE_2__["default"].supportsGetDisplayMedia()) {
      return this.obtainScreenFromGetDisplayMedia;
    }
    logger.log("Screen sharing not supported on ", _browser__WEBPACK_IMPORTED_MODULE_2__["default"].getName());
    return null;
  },
  _getAudioConstraints() {
    const { audioQuality } = this.options;
    const audio = (audioQuality === null || audioQuality === void 0 ? void 0 : audioQuality.stereo) ? {
      autoGainControl: false,
      channelCount: 2,
      echoCancellation: false,
      noiseSuppression: false
    } : true;
    return audio;
  },
  isSupported() {
    return this.obtainStream !== null;
  },
  obtainScreenOnElectron(onSuccess, onFailure, options = {}) {
    if (window.JitsiMeetScreenObtainer && window.JitsiMeetScreenObtainer.openDesktopPicker) {
      const { desktopSharingFrameRate, desktopSharingResolution, desktopSharingSources } = this.options;
      window.JitsiMeetScreenObtainer.openDesktopPicker({
        desktopSharingSources: options.desktopSharingSources || desktopSharingSources || ["screen", "window"]
      }, (streamId, streamType, screenShareAudio = false) => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (streamId) {
          let audioConstraints = false;
          if (screenShareAudio) {
            audioConstraints = {};
            const optionalConstraints = this._getAudioConstraints();
            if (typeof optionalConstraints !== "boolean") {
              audioConstraints = {
                optional: optionalConstraints
              };
            }
            if (streamType === "screen") {
              audioConstraints.mandatory = {
                chromeMediaSource: "desktop"
              };
            }
          }
          const constraints = {
            audio: audioConstraints,
            video: {
              mandatory: {
                chromeMediaSource: "desktop",
                chromeMediaSourceId: streamId,
                minFrameRate: (_a = desktopSharingFrameRate === null || desktopSharingFrameRate === void 0 ? void 0 : desktopSharingFrameRate.min) !== null && _a !== void 0 ? _a : SS_DEFAULT_FRAME_RATE,
                maxFrameRate: (_b = desktopSharingFrameRate === null || desktopSharingFrameRate === void 0 ? void 0 : desktopSharingFrameRate.max) !== null && _b !== void 0 ? _b : SS_DEFAULT_FRAME_RATE,
                minWidth: (_c = desktopSharingResolution === null || desktopSharingResolution === void 0 ? void 0 : desktopSharingResolution.width) === null || _c === void 0 ? void 0 : _c.min,
                minHeight: (_d = desktopSharingResolution === null || desktopSharingResolution === void 0 ? void 0 : desktopSharingResolution.height) === null || _d === void 0 ? void 0 : _d.min,
                maxWidth: (_f = (_e = desktopSharingResolution === null || desktopSharingResolution === void 0 ? void 0 : desktopSharingResolution.width) === null || _e === void 0 ? void 0 : _e.max) !== null && _f !== void 0 ? _f : window.screen.width,
                maxHeight: (_h = (_g = desktopSharingResolution === null || desktopSharingResolution === void 0 ? void 0 : desktopSharingResolution.height) === null || _g === void 0 ? void 0 : _g.max) !== null && _h !== void 0 ? _h : window.screen.height
              }
            }
          };
          navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
            this.setContentHint(stream);
            onSuccess({
              stream,
              sourceId: streamId,
              sourceType: streamType
            });
          }).catch((err) => onFailure(err));
        } else {
          onFailure(new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_0__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_1__.SCREENSHARING_USER_CANCELED));
        }
      }, (err) => onFailure(new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_0__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_1__.ELECTRON_DESKTOP_PICKER_ERROR, err)));
    } else {
      onFailure(new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_0__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_1__.ELECTRON_DESKTOP_PICKER_NOT_FOUND));
    }
  },
  obtainScreenFromGetDisplayMedia(callback, errorCallback) {
    let getDisplayMedia;
    if (navigator.getDisplayMedia) {
      getDisplayMedia = navigator.getDisplayMedia.bind(navigator);
    } else {
      getDisplayMedia = navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices);
    }
    const audio = this._getAudioConstraints();
    let video = {};
    const { desktopSharingFrameRate } = this.options;
    if (typeof desktopSharingFrameRate === "object") {
      video.frameRate = desktopSharingFrameRate;
    }
    video.frameRate && delete video.frameRate.min;
    if (_browser__WEBPACK_IMPORTED_MODULE_2__["default"].isChromiumBased()) {
      _browser__WEBPACK_IMPORTED_MODULE_2__["default"].isVersionGreaterThan(106) && (video.surfaceSwitching = "include");
      if (!((desktopSharingFrameRate === null || desktopSharingFrameRate === void 0 ? void 0 : desktopSharingFrameRate.max) > SS_DEFAULT_FRAME_RATE)) {
        video.height = 99999;
        video.width = 99999;
      }
    }
    if (Object.keys(video).length === 0) {
      video = true;
    }
    const constraints = {
      video,
      audio,
      cursor: "always"
    };
    logger.info("Using getDisplayMedia for screen sharing", constraints);
    getDisplayMedia(constraints).then((stream) => {
      this.setContentHint(stream);
      callback({
        stream,
        sourceId: stream.id
      });
    }).catch((error) => {
      const errorDetails = {
        errorName: error && error.name,
        errorMsg: error && error.message,
        errorStack: error && error.stack
      };
      logger.error("getDisplayMedia error", constraints, errorDetails);
      if (errorDetails.errorMsg && errorDetails.errorMsg.indexOf("denied by system") !== -1) {
        errorCallback(new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_0__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_1__.PERMISSION_DENIED));
        return;
      }
      errorCallback(new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_0__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_1__.SCREENSHARING_USER_CANCELED));
    });
  },
  obtainScreenFromGetDisplayMediaRN(callback, errorCallback) {
    logger.info("Using getDisplayMedia for screen sharing");
    navigator.mediaDevices.getDisplayMedia({ video: true }).then((stream) => {
      this.setContentHint(stream);
      callback({
        stream,
        sourceId: stream.id
      });
    }).catch(() => {
      errorCallback(new _JitsiTrackError__WEBPACK_IMPORTED_MODULE_0__["default"](_JitsiTrackErrors__WEBPACK_IMPORTED_MODULE_1__.SCREENSHARING_USER_CANCELED));
    });
  },
  setContentHint(stream) {
    const { desktopSharingFrameRate } = this.options;
    const desktopTrack = stream.getVideoTracks()[0];
    if ("contentHint" in desktopTrack) {
      desktopTrack.contentHint = (desktopSharingFrameRate === null || desktopSharingFrameRate === void 0 ? void 0 : desktopSharingFrameRate.max) > SS_DEFAULT_FRAME_RATE ? "motion" : "detail";
    } else {
      logger.warn("MediaStreamTrack contentHint attribute not supported");
    }
  },
  setDesktopSharingFrameRate(maxFps) {
    logger.info(`Setting the desktop capture rate to ${maxFps}`);
    this.options.desktopSharingFrameRate = {
      min: SS_DEFAULT_FRAME_RATE,
      max: maxFps
    };
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ScreenObtainer);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/RTC/TPCUtils.js":
/*!*************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/RTC/TPCUtils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HD_BITRATE: () => (/* binding */ HD_BITRATE),
/* harmony export */   HD_SCALE_FACTOR: () => (/* binding */ HD_SCALE_FACTOR),
/* harmony export */   LD_SCALE_FACTOR: () => (/* binding */ LD_SCALE_FACTOR),
/* harmony export */   SD_SCALE_FACTOR: () => (/* binding */ SD_SCALE_FACTOR),
/* harmony export */   SIM_LAYER_RIDS: () => (/* binding */ SIM_LAYER_RIDS),
/* harmony export */   TPCUtils: () => (/* binding */ TPCUtils)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var sdp_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sdp-transform */ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/index.js");
/* harmony import */ var _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/MediaDirection */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaDirection.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/RTC/SignalingLayer */ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingLayer.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");









const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const DESKTOP_SHARE_RATE = 5e5;
const LD_BITRATE = 2e5;
const SD_BITRATE = 7e5;
const SIM_LAYER_1_RID = "1";
const SIM_LAYER_2_RID = "2";
const SIM_LAYER_3_RID = "3";
const HD_BITRATE = 25e5;
const HD_SCALE_FACTOR = 1;
const LD_SCALE_FACTOR = 4;
const SD_SCALE_FACTOR = 2;
const SIM_LAYER_RIDS = [SIM_LAYER_1_RID, SIM_LAYER_2_RID, SIM_LAYER_3_RID];
class TPCUtils {
  constructor(peerconnection) {
    var _a, _b, _c;
    this.pc = peerconnection;
    const bitrateSettings = (_b = (_a = this.pc.options) === null || _a === void 0 ? void 0 : _a.videoQuality) === null || _b === void 0 ? void 0 : _b.maxBitratesVideo;
    const standardBitrates = {
      low: LD_BITRATE,
      standard: SD_BITRATE,
      high: HD_BITRATE,
      ssHigh: HD_BITRATE
    };
    this.videoBitrates = bitrateSettings !== null && bitrateSettings !== void 0 ? bitrateSettings : standardBitrates;
    this.encodingBitrates = (_c = this.videoBitrates.VP8) !== null && _c !== void 0 ? _c : this.videoBitrates;
  }
  _getStreamEncodings(localTrack) {
    if (this.pc.isSimulcastOn() && localTrack.isVideoTrack()) {
      return this._getVideoStreamEncodings(localTrack.getVideoType());
    }
    return localTrack.isVideoTrack() ? [{
      active: this.pc.videoTransferActive,
      maxBitrate: this.videoBitrates.high
    }] : [{ active: this.pc.audioTransferActive }];
  }
  _getVideoStreamEncodings(videoType) {
    const maxVideoBitrate = videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__.VideoType.DESKTOP && this.encodingBitrates.ssHigh ? this.encodingBitrates.ssHigh : this.encodingBitrates.high;
    return [
      {
        active: this.pc.videoTransferActive,
        maxBitrate: _browser__WEBPACK_IMPORTED_MODULE_6__["default"].isFirefox() ? maxVideoBitrate : this.encodingBitrates.low,
        rid: SIM_LAYER_1_RID,
        scaleResolutionDownBy: _browser__WEBPACK_IMPORTED_MODULE_6__["default"].isFirefox() ? HD_SCALE_FACTOR : LD_SCALE_FACTOR
      },
      {
        active: this.pc.videoTransferActive,
        maxBitrate: this.encodingBitrates.standard,
        rid: SIM_LAYER_2_RID,
        scaleResolutionDownBy: SD_SCALE_FACTOR
      },
      {
        active: this.pc.videoTransferActive,
        maxBitrate: _browser__WEBPACK_IMPORTED_MODULE_6__["default"].isFirefox() ? this.encodingBitrates.low : maxVideoBitrate,
        rid: SIM_LAYER_3_RID,
        scaleResolutionDownBy: _browser__WEBPACK_IMPORTED_MODULE_6__["default"].isFirefox() ? LD_SCALE_FACTOR : HD_SCALE_FACTOR
      }
    ];
  }
  ensureCorrectOrderOfSsrcs(description) {
    const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_1__.parse(description.sdp);
    parsedSdp.media.forEach((mLine) => {
      if (mLine.type === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.AUDIO) {
        return;
      }
      if (!mLine.ssrcGroups || !mLine.ssrcGroups.length) {
        return;
      }
      let reorderedSsrcs = [];
      const ssrcs = /* @__PURE__ */ new Set();
      mLine.ssrcGroups.map((group) => group.ssrcs.split(" ").filter(Boolean).forEach((ssrc) => ssrcs.add(ssrc)));
      ssrcs.forEach((ssrc) => {
        const sources = mLine.ssrcs.filter((source) => source.id.toString() === ssrc);
        reorderedSsrcs = reorderedSsrcs.concat(sources);
      });
      mLine.ssrcs = reorderedSsrcs;
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp_transform__WEBPACK_IMPORTED_MODULE_1__.write(parsedSdp)
    });
  }
  findTransceiver(mediaType, localTrack = null) {
    const transceiver = (localTrack === null || localTrack === void 0 ? void 0 : localTrack.track) && localTrack.getOriginalStream() ? this.pc.peerconnection.getTransceivers().find((t) => {
      var _a, _b;
      return ((_b = (_a = t.sender) === null || _a === void 0 ? void 0 : _a.track) === null || _b === void 0 ? void 0 : _b.id) === localTrack.getTrackId();
    }) : this.pc.peerconnection.getTransceivers().find((t) => {
      var _a, _b;
      return ((_b = (_a = t.receiver) === null || _a === void 0 ? void 0 : _a.track) === null || _b === void 0 ? void 0 : _b.kind) === mediaType;
    });
    return transceiver;
  }
  insertUnifiedPlanSimulcastReceive(desc) {
    if (_browser__WEBPACK_IMPORTED_MODULE_6__["default"].usesSdpMungingForSimulcast()) {
      return desc;
    }
    const sdp = sdp_transform__WEBPACK_IMPORTED_MODULE_1__.parse(desc.sdp);
    const idx = sdp.media.findIndex((mline) => mline.type === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO);
    if (sdp.media[idx].rids && (sdp.media[idx].simulcast_03 || sdp.media[idx].simulcast)) {
      sdp.media.forEach((mline, i) => {
        if (mline.type === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO && i !== idx) {
          sdp.media[i].rids = void 0;
          sdp.media[i].simulcast = void 0;
          sdp.media[i].simulcast_03 = void 0;
        }
      });
      return new RTCSessionDescription({
        type: desc.type,
        sdp: sdp_transform__WEBPACK_IMPORTED_MODULE_1__.write(sdp)
      });
    }
    sdp.media[idx].rids = [
      {
        id: SIM_LAYER_1_RID,
        direction: "recv"
      },
      {
        id: SIM_LAYER_2_RID,
        direction: "recv"
      },
      {
        id: SIM_LAYER_3_RID,
        direction: "recv"
      }
    ];
    const simulcastLine = _browser__WEBPACK_IMPORTED_MODULE_6__["default"].isFirefox() && _browser__WEBPACK_IMPORTED_MODULE_6__["default"].isVersionGreaterThan(71) ? `recv ${SIM_LAYER_RIDS.join(";")}` : `recv rid=${SIM_LAYER_RIDS.join(";")}`;
    sdp.media[idx].simulcast_03 = {
      value: simulcastLine
    };
    return new RTCSessionDescription({
      type: desc.type,
      sdp: sdp_transform__WEBPACK_IMPORTED_MODULE_1__.write(sdp)
    });
  }
  addTrack(localTrack, isInitiator) {
    const track = localTrack.getTrack();
    if (isInitiator) {
      const streams = [];
      if (localTrack.getOriginalStream()) {
        streams.push(localTrack.getOriginalStream());
      }
      const transceiverInit = {
        direction: _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_2__.MediaDirection.SENDRECV,
        streams,
        sendEncodings: []
      };
      if (!_browser__WEBPACK_IMPORTED_MODULE_6__["default"].isFirefox()) {
        transceiverInit.sendEncodings = this._getStreamEncodings(localTrack);
      }
      this.pc.peerconnection.addTransceiver(track, transceiverInit);
    } else {
      this.pc.peerconnection.addTrack(track);
    }
  }
  calculateEncodingsActiveState(localVideoTrack, newHeight) {
    const localTrack = localVideoTrack.getTrack();
    const { height } = localTrack.getSettings();
    const videoStreamEncodings = this._getVideoStreamEncodings(localVideoTrack.getVideoType());
    const encodingsState = videoStreamEncodings.map((encoding) => height / encoding.scaleResolutionDownBy).map((frameHeight, idx) => {
      var _a;
      let active = localVideoTrack.getVideoType() === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__.VideoType.CAMERA ? newHeight > 0 && ((_a = videoStreamEncodings[idx]) === null || _a === void 0 ? void 0 : _a.scaleResolutionDownBy) === LD_SCALE_FACTOR ? true : frameHeight <= newHeight : true;
      if (localVideoTrack.getVideoType() === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__.VideoType.DESKTOP && this.pc._capScreenshareBitrate && this.pc.usesUnifiedPlan() && !_browser__WEBPACK_IMPORTED_MODULE_6__["default"].isWebKitBased() && videoStreamEncodings[idx].scaleResolutionDownBy !== HD_SCALE_FACTOR) {
        active = false;
      }
      return active;
    });
    return encodingsState;
  }
  calculateEncodingsBitrates(localVideoTrack) {
    var _a, _b;
    const videoType = localVideoTrack.getVideoType();
    const desktopShareBitrate = ((_b = (_a = this.pc.options) === null || _a === void 0 ? void 0 : _a.videoQuality) === null || _b === void 0 ? void 0 : _b.desktopBitrate) || DESKTOP_SHARE_RATE;
    const lowFpsScreenshare = localVideoTrack.getVideoType() === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__.VideoType.DESKTOP && this.pc._capScreenshareBitrate && !_browser__WEBPACK_IMPORTED_MODULE_6__["default"].isWebKitBased();
    const encodingsBitrates = this._getVideoStreamEncodings(localVideoTrack.getVideoType()).map((encoding) => {
      const bitrate = lowFpsScreenshare ? desktopShareBitrate : videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__.VideoType.DESKTOP && _browser__WEBPACK_IMPORTED_MODULE_6__["default"].isChromiumBased() && !this.pc.usesUnifiedPlan() ? void 0 : encoding.maxBitrate;
      return bitrate;
    });
    return encodingsBitrates;
  }
  getConfiguredEncodeResolution(localVideoTrack) {
    var _a;
    const localTrack = localVideoTrack.getTrack();
    const { height } = localTrack.getSettings();
    const videoSender = this.pc.findSenderForTrack(localVideoTrack.getTrack());
    let maxHeight = 0;
    if (!videoSender) {
      return null;
    }
    const parameters = videoSender.getParameters();
    if (!((_a = parameters === null || parameters === void 0 ? void 0 : parameters.encodings) === null || _a === void 0 ? void 0 : _a.length)) {
      return null;
    }
    const hasIncorrectConfig = this.pc._capScreenshareBitrate ? parameters.encodings.every((encoding) => encoding.active) : parameters.encodings.some((encoding) => !encoding.active);
    if (localVideoTrack.getVideoType() === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__.VideoType.DESKTOP && hasIncorrectConfig) {
      return null;
    }
    for (const encoding in parameters.encodings) {
      if (parameters.encodings[encoding].active) {
        const scaleResolutionDownBy = this.pc.isSimulcastOn() ? this._getVideoStreamEncodings(localVideoTrack.getVideoType())[encoding].scaleResolutionDownBy : parameters.encodings[encoding].scaleResolutionDownBy;
        maxHeight = Math.max(maxHeight, height / scaleResolutionDownBy);
      }
    }
    return maxHeight;
  }
  replaceTrack(oldTrack, newTrack) {
    var _a, _b, _c;
    const mediaType = (_a = newTrack === null || newTrack === void 0 ? void 0 : newTrack.getType()) !== null && _a !== void 0 ? _a : oldTrack === null || oldTrack === void 0 ? void 0 : oldTrack.getType();
    const localTracks = this.pc.getLocalTracks(mediaType);
    const track = (_b = newTrack === null || newTrack === void 0 ? void 0 : newTrack.getTrack()) !== null && _b !== void 0 ? _b : null;
    const isNewLocalSource = _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_7__["default"].isMultiStreamSendSupportEnabled() && (localTracks === null || localTracks === void 0 ? void 0 : localTracks.length) && !oldTrack && newTrack && !localTracks.find((t) => t === newTrack);
    let transceiver;
    if (oldTrack && !oldTrack.isMuted()) {
      transceiver = this.pc.peerconnection.getTransceivers().find((t) => t.sender.track === oldTrack.getTrack());
    } else if (isNewLocalSource) {
      transceiver = this.pc.peerconnection.getTransceivers().find((t) => t.receiver.track.kind === mediaType && t.direction === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_2__.MediaDirection.RECVONLY && (this.pc.isP2P && t.currentDirection === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_2__.MediaDirection.RECVONLY || t.currentDirection === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_2__.MediaDirection.INACTIVE && !t.stopped));
    } else {
      transceiver = this.pc.peerconnection.getTransceivers().find((t) => t.receiver.track.kind === mediaType);
      const sourceName = (_c = newTrack === null || newTrack === void 0 ? void 0 : newTrack.getSourceName()) !== null && _c !== void 0 ? _c : oldTrack === null || oldTrack === void 0 ? void 0 : oldTrack.getSourceName();
      if (sourceName) {
        const trackIndex = (0,_service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_4__.getSourceIndexFromSourceName)(sourceName);
        if (this.pc.isP2P) {
          transceiver = this.pc.peerconnection.getTransceivers().filter((t) => t.receiver.track.kind === mediaType)[trackIndex];
        } else if (oldTrack) {
          const transceiverMid = this.pc._localTrackTransceiverMids.get(oldTrack.rtcId);
          transceiver = this.pc.peerconnection.getTransceivers().find((t) => t.mid === transceiverMid);
        } else if (trackIndex) {
          transceiver = this.pc.peerconnection.getTransceivers().filter((t) => t.receiver.track.kind === mediaType && t.direction !== _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_2__.MediaDirection.RECVONLY)[trackIndex];
        }
      }
    }
    if (!transceiver) {
      return Promise.reject(new Error(`Replace track failed - no transceiver for old: ${oldTrack}, new: ${newTrack}`));
    }
    logger.debug(`${this.pc} Replacing ${oldTrack} with ${newTrack}`);
    return transceiver.sender.replaceTrack(track).then(() => Promise.resolve(transceiver));
  }
  setEncodings(track) {
    var _a, _b;
    const mediaType = track.getType();
    const transceiver = this.findTransceiver(mediaType, track);
    const parameters = (_a = transceiver === null || transceiver === void 0 ? void 0 : transceiver.sender) === null || _a === void 0 ? void 0 : _a.getParameters();
    if (!((_b = parameters === null || parameters === void 0 ? void 0 : parameters.encodings) === null || _b === void 0 ? void 0 : _b.length)) {
      return Promise.resolve();
    }
    parameters.encodings = this._getStreamEncodings(track);
    const promise = transceiver.sender.setParameters(parameters);
    if (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO) {
      return this.pc._updateVideoSenderParameters(promise);
    }
    return promise;
  }
  setMediaTransferActive(enable) {
    var _a;
    logger.info(`${this.pc} ${enable ? "Resuming" : "Suspending"} media transfer.`);
    const senders = this.pc.peerconnection.getSenders().filter((s) => Boolean(s.track));
    const promises = [];
    for (const sender of senders) {
      const parameters = sender.getParameters();
      if ((_a = parameters === null || parameters === void 0 ? void 0 : parameters.encodings) === null || _a === void 0 ? void 0 : _a.length) {
        for (const encoding of parameters.encodings) {
          encoding.active = enable;
        }
      }
      const setActivePromise = sender.setParameters(parameters);
      if (sender.track.kind === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO) {
        promises.push(this.pc._updateVideoSenderParameters(setActivePromise));
      } else {
        promises.push(setActivePromise);
      }
    }
    return Promise.allSettled(promises).then((settledResult) => {
      const errors = settledResult.filter((result) => result.status === "rejected").map((result) => result.reason);
      if (errors.length) {
        return Promise.reject(new Error(`Failed to change encodings on the RTCRtpSenders${errors.join(" ")}`));
      }
      return Promise.resolve();
    });
  }
  setVideoTransferActive(active) {
    const transceivers = this.pc.peerconnection.getTransceivers().filter((t) => t.receiver && t.receiver.track && t.receiver.track.kind === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO);
    logger.info(`${this.pc} ${active ? "Enabling" : "Suspending"} video media transfer.`);
    transceivers.forEach((transceiver) => {
      const localTrackMids = Array.from(this.pc._localTrackTransceiverMids);
      const direction = active ? localTrackMids.find((mids) => mids[1] === transceiver.mid) ? _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_2__.MediaDirection.SENDRECV : _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_2__.MediaDirection.RECVONLY : _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_2__.MediaDirection.INACTIVE;
      logger.debug(`Setting direction to ${direction} on mid=${transceiver.mid}`);
      transceiver.direction = direction;
    });
  }
  updateEncodingsResolution(localVideoTrack, parameters) {
    if (!(_browser__WEBPACK_IMPORTED_MODULE_6__["default"].isWebKitBased() && parameters.encodings && Array.isArray(parameters.encodings))) {
      return;
    }
    const allEqualEncodings = (encodings) => encodings.every((encoding) => typeof encoding.scaleResolutionDownBy !== "undefined" && encoding.scaleResolutionDownBy === encodings[0].scaleResolutionDownBy);
    if (allEqualEncodings(parameters.encodings)) {
      const videoStreamEncodings = this._getVideoStreamEncodings(localVideoTrack.getVideoType());
      parameters.encodings.forEach((encoding, idx) => {
        encoding.scaleResolutionDownBy = videoStreamEncodings[idx].scaleResolutionDownBy;
      });
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/RTC/TraceablePeerConnection.js":
/*!****************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/RTC/TraceablePeerConnection.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TraceablePeerConnection)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jitsi_sdp_interop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jitsi/sdp-interop */ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/lib/index.js");
/* harmony import */ var sdp_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sdp-transform */ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/index.js");
/* harmony import */ var _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/CodecMimeType */ "../../lib-jitsi-meet/dist/esm/service/RTC/CodecMimeType.js");
/* harmony import */ var _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/RTC/MediaDirection */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaDirection.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../service/RTC/SignalingEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingEvents.js");
/* harmony import */ var _service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../service/RTC/SignalingLayer */ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingLayer.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _RTC_ScreenObtainer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../RTC/ScreenObtainer */ "../../lib-jitsi-meet/dist/esm/modules/RTC/ScreenObtainer.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");
/* harmony import */ var _sdp_LocalSdpMunger__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../sdp/LocalSdpMunger */ "../../lib-jitsi-meet/dist/esm/modules/sdp/LocalSdpMunger.js");
/* harmony import */ var _sdp_RtxModifier__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../sdp/RtxModifier */ "../../lib-jitsi-meet/dist/esm/modules/sdp/RtxModifier.js");
/* harmony import */ var _sdp_SDP__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../sdp/SDP */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SDP.js");
/* harmony import */ var _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../sdp/SDPUtil */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SDPUtil.js");
/* harmony import */ var _sdp_SdpConsistency__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../sdp/SdpConsistency */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SdpConsistency.js");
/* harmony import */ var _sdp_SdpSimulcast__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../sdp/SdpSimulcast */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SdpSimulcast.js");
/* harmony import */ var _sdp_SdpTransformUtil__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../sdp/SdpTransformUtil */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SdpTransformUtil.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _JitsiRemoteTrack__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./JitsiRemoteTrack */ "../../lib-jitsi-meet/dist/esm/modules/RTC/JitsiRemoteTrack.js");
/* harmony import */ var _RTC__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./RTC */ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTC.js");
/* harmony import */ var _TPCUtils__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./TPCUtils */ "../../lib-jitsi-meet/dist/esm/modules/RTC/TPCUtils.js");

























const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const DEGRADATION_PREFERENCE_CAMERA = "maintain-framerate";
const DEGRADATION_PREFERENCE_DESKTOP = "maintain-resolution";
function TraceablePeerConnection(rtc, id, signalingLayer, pcConfig, constraints, isP2P, options) {
  this.audioTransferActive = !(options.startSilent === true);
  this._dtmfSender = void 0;
  this._dtmfTonesQueue = [];
  this.videoTransferActive = true;
  this.rtc = rtc;
  this.id = id;
  this.isP2P = isP2P;
  this.remoteTracks = /* @__PURE__ */ new Map();
  this.localTracks = /* @__PURE__ */ new Map();
  this._addedStreams = [];
  this.localSSRCs = /* @__PURE__ */ new Map();
  this.remoteSSRCs = /* @__PURE__ */ new Set();
  this.remoteSources = /* @__PURE__ */ new Map();
  this.localUfrag = null;
  this.remoteUfrag = null;
  this._dtlsTransport = null;
  this.signalingLayer = signalingLayer;
  this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this);
  this.signalingLayer.on(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_7__.PEER_VIDEO_TYPE_CHANGED, this._peerVideoTypeChanged);
  this._peerMutedChanged = this._peerMutedChanged.bind(this);
  this.signalingLayer.on(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_7__.PEER_MUTED_CHANGED, this._peerMutedChanged);
  this.options = options;
  this.signalingLayer.on(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_7__.SOURCE_MUTED_CHANGED, (sourceName, isMuted) => this._sourceMutedChanged(sourceName, isMuted));
  this.signalingLayer.on(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_7__.SOURCE_VIDEO_TYPE_CHANGED, (sourceName, videoType) => this._sourceVideoTypeChanged(sourceName, videoType));
  const safeConstraints = constraints || {};
  safeConstraints.optional = safeConstraints.optional || [];
  if (Array.isArray(safeConstraints.optional)) {
    safeConstraints.optional.push({ rtcStatsSFUP2P: this.isP2P });
  } else {
    logger.warn("Optional param is not an array, rtcstats p2p data is omitted.");
  }
  this.peerconnection = new RTCPeerConnection(pcConfig, safeConstraints);
  this.tpcUtils = new _TPCUtils__WEBPACK_IMPORTED_MODULE_23__.TPCUtils(this);
  this.updateLog = [];
  this.stats = {};
  this.statsinterval = null;
  this._capScreenshareBitrate = this.options.capScreenshareBitrate;
  this._usesUnifiedPlan = options.usesUnifiedPlan;
  this.codecSettings = this.options.codecSettings;
  this._usesTransceiverCodecPreferences = _browser__WEBPACK_IMPORTED_MODULE_11__["default"].supportsCodecPreferences() && this._usesUnifiedPlan;
  this._usesTransceiverCodecPreferences && logger.info("Using RTCRtpTransceiver#setCodecPreferences for codec selection");
  if (this._usesUnifiedPlan) {
    this._hasHadAudioTrack = false;
    this._hasHadVideoTrack = false;
  }
  this.maxstats = options.maxstats;
  this.interop = new _jitsi_sdp_interop__WEBPACK_IMPORTED_MODULE_1__.Interop();
  if (this._usesUnifiedPlan) {
    this.simulcast = new _sdp_SdpSimulcast__WEBPACK_IMPORTED_MODULE_18__["default"]({ numOfLayers: _TPCUtils__WEBPACK_IMPORTED_MODULE_23__.SIM_LAYER_RIDS.length });
  } else {
    const Simulcast = __webpack_require__(/*! @jitsi/sdp-simulcast */ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-simulcast/lib/index.js");
    this.simulcast = new Simulcast({
      numOfLayers: _TPCUtils__WEBPACK_IMPORTED_MODULE_23__.SIM_LAYER_RIDS.length,
      explodeRemoteSimulcast: false,
      usesUnifiedPlan: false
    });
  }
  this.sdpConsistency = new _sdp_SdpConsistency__WEBPACK_IMPORTED_MODULE_17__["default"](this.toString());
  this.localSdpMunger = new _sdp_LocalSdpMunger__WEBPACK_IMPORTED_MODULE_13__["default"](this, this.rtc.getLocalEndpointId());
  this.eventEmitter = rtc.eventEmitter;
  this.rtxModifier = new _sdp_RtxModifier__WEBPACK_IMPORTED_MODULE_14__["default"]();
  this._senderVideoMaxHeight = 2160;
  this._senderMaxHeights = /* @__PURE__ */ new Map();
  this._localTrackTransceiverMids = /* @__PURE__ */ new Map();
  this.trace = (what, info) => {
    logger.debug(what, info);
    this.updateLog.push({
      time: new Date(),
      type: what,
      value: info || ""
    });
  };
  this.onicecandidate = null;
  this.peerconnection.onicecandidate = (event) => {
    this.trace("onicecandidate", JSON.stringify(event.candidate, null, " "));
    if (this.onicecandidate !== null) {
      this.onicecandidate(event);
    }
  };
  if (this._usesUnifiedPlan) {
    this.onTrack = (evt) => {
      const stream = evt.streams[0];
      this._remoteTrackAdded(stream, evt.track, evt.transceiver);
      stream.addEventListener("removetrack", (e) => {
        this._remoteTrackRemoved(stream, e.track);
      });
    };
    this.peerconnection.addEventListener("track", this.onTrack);
  } else {
    this.peerconnection.onaddstream = (event) => this._remoteStreamAdded(event.stream);
    this.peerconnection.onremovestream = (event) => this._remoteStreamRemoved(event.stream);
  }
  this.onsignalingstatechange = null;
  this.peerconnection.onsignalingstatechange = (event) => {
    this.trace("onsignalingstatechange", this.signalingState);
    if (this.onsignalingstatechange !== null) {
      this.onsignalingstatechange(event);
    }
  };
  this.oniceconnectionstatechange = null;
  this.peerconnection.oniceconnectionstatechange = (event) => {
    this.trace("oniceconnectionstatechange", this.iceConnectionState);
    if (this.oniceconnectionstatechange !== null) {
      this.oniceconnectionstatechange(event);
    }
  };
  this.onnegotiationneeded = null;
  this.peerconnection.onnegotiationneeded = (event) => {
    this.trace("onnegotiationneeded");
    if (this.onnegotiationneeded !== null) {
      this.onnegotiationneeded(event);
    }
  };
  this.onconnectionstatechange = null;
  this.peerconnection.onconnectionstatechange = (event) => {
    this.trace("onconnectionstatechange", this.connectionState);
    if (this.onconnectionstatechange !== null) {
      this.onconnectionstatechange(event);
    }
  };
  this.ondatachannel = null;
  this.peerconnection.ondatachannel = (event) => {
    this.trace("ondatachannel");
    if (this.ondatachannel !== null) {
      this.ondatachannel(event);
    }
  };
  if (this.maxstats) {
    this.statsinterval = window.setInterval(() => {
      this.getStats().then((stats) => {
        if (typeof (stats === null || stats === void 0 ? void 0 : stats.result) === "function") {
          const results = stats.result();
          for (let i = 0; i < results.length; ++i) {
            const res = results[i];
            res.names().forEach((name) => {
              this._processStat(res, name, res.stat(name));
            });
          }
        } else {
          stats.forEach((r) => this._processStat(r, "", r));
        }
      });
    }, 1e3);
  }
  this._lastVideoSenderUpdatePromise = Promise.resolve();
  logger.info(`Create new ${this}`);
}
TraceablePeerConnection.prototype._processStat = function(report, name, statValue) {
  const id = `${report.id}-${name}`;
  let s = this.stats[id];
  const now = new Date();
  if (!s) {
    this.stats[id] = s = {
      startTime: now,
      endTime: now,
      values: [],
      times: []
    };
  }
  s.values.push(statValue);
  s.times.push(now.getTime());
  if (s.values.length > this.maxstats) {
    s.values.shift();
    s.times.shift();
  }
  s.endTime = now;
};
const dumpSDP = function(description) {
  if (typeof description === "undefined" || description === null) {
    return "";
  }
  return `type: ${description.type}\r
${description.sdp}`;
};
TraceablePeerConnection.prototype.getConnectionState = function() {
  const state = this.peerconnection.iceConnectionState;
  if (state === "completed") {
    return "connected";
  }
  return state;
};
TraceablePeerConnection.prototype.getDesiredMediaDirection = function(mediaType, isAddOperation = false) {
  const hasLocalSource = this.hasAnyTracksOfType(mediaType);
  if (this._usesUnifiedPlan) {
    return isAddOperation ? hasLocalSource ? _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDRECV : _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDONLY : hasLocalSource ? _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.RECVONLY : _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.INACTIVE;
  }
  const mediaTransferActive = mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO ? this.audioTransferActive : this.videoTransferActive;
  if (mediaTransferActive) {
    return hasLocalSource ? _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDRECV : _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.RECVONLY;
  }
  return _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.INACTIVE;
};
TraceablePeerConnection.prototype._getDesktopTrackMid = function() {
  const desktopTrack = this.getLocalVideoTracks().find((track) => track.getVideoType() === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.DESKTOP);
  if (desktopTrack) {
    return Number(this._localTrackTransceiverMids.get(desktopTrack.rtcId));
  }
  return null;
};
TraceablePeerConnection.prototype._getReceiversByEndpointIds = function(endpoints, mediaType) {
  let remoteTracks = [];
  let receivers = [];
  for (const endpoint of endpoints) {
    remoteTracks = remoteTracks.concat(this.getRemoteTracks(endpoint, mediaType));
  }
  const remoteTrackIds = remoteTracks.map((remote) => {
    var _a;
    return (_a = remote.track) === null || _a === void 0 ? void 0 : _a.id;
  });
  receivers = this.peerconnection.getReceivers().filter((receiver) => receiver.track && receiver.track.kind === mediaType && remoteTrackIds.find((trackId) => trackId === receiver.track.id));
  return receivers;
};
TraceablePeerConnection.prototype.isSimulcastOn = function() {
  return !this.options.disableSimulcast;
};
TraceablePeerConnection.prototype._peerVideoTypeChanged = function(endpointId, videoType) {
  if (!endpointId) {
    logger.error(`${this} No endpointID on peerVideoTypeChanged`);
    return;
  }
  const videoTrack = this.getRemoteTracks(endpointId, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO);
  if (videoTrack.length) {
    videoTrack[0]._setVideoType(videoType);
  }
};
TraceablePeerConnection.prototype._peerMutedChanged = function(endpointId, mediaType, isMuted) {
  if (!endpointId) {
    logger.error(`${this} On peerMuteChanged - no endpoint ID`);
    return;
  }
  const track = this.getRemoteTracks(endpointId, mediaType);
  if (track.length) {
    track[0].setMute(isMuted);
  }
};
TraceablePeerConnection.prototype._sourceMutedChanged = function(sourceName, isMuted) {
  const track = this.getRemoteTracks().find((t) => t.getSourceName() === sourceName);
  if (!track) {
    if (_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_12__["default"].isSsrcRewritingSupported()) {
      logger.debug(`Remote track not found for source=${sourceName}, mute update failed!`);
    }
    return;
  }
  track.setMute(isMuted);
};
TraceablePeerConnection.prototype._sourceVideoTypeChanged = function(sourceName, videoType) {
  const track = this.getRemoteTracks().find((t) => t.getSourceName() === sourceName);
  if (!track) {
    return;
  }
  track._setVideoType(videoType);
};
TraceablePeerConnection.prototype.getAudioLevels = function(speakerList = []) {
  const audioLevels = {};
  const audioReceivers = speakerList.length ? this._getReceiversByEndpointIds(speakerList, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO) : this.peerconnection.getReceivers().filter((receiver) => receiver.track && receiver.track.kind === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO && receiver.track.enabled);
  audioReceivers.forEach((remote) => {
    const ssrc = remote.getSynchronizationSources();
    if (ssrc && ssrc.length) {
      audioLevels[ssrc[0].source] = ssrc[0].audioLevel;
    }
  });
  return audioLevels;
};
TraceablePeerConnection.prototype.doesTrueSimulcast = function() {
  return this.isSimulcastOn() && this.getConfiguredVideoCodec() === _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_3__["default"].VP8;
};
TraceablePeerConnection.prototype.getLocalVideoSSRCs = function(localTrack) {
  var _a, _b, _c;
  const ssrcs = [];
  if (!localTrack || !localTrack.isVideoTrack()) {
    return ssrcs;
  }
  const ssrcGroup = this.isSimulcastOn() ? "SIM" : "FID";
  return ((_c = (_b = (_a = this.localSSRCs.get(localTrack.rtcId)) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.find((group) => group.semantics === ssrcGroup)) === null || _c === void 0 ? void 0 : _c.ssrcs) || ssrcs;
};
TraceablePeerConnection.prototype.getLocalTracks = function(mediaType) {
  let tracks = Array.from(this.localTracks.values());
  if (mediaType !== void 0) {
    tracks = tracks.filter((track) => track.getType() === mediaType);
  }
  return tracks;
};
TraceablePeerConnection.prototype.getLocalVideoTracks = function() {
  return this.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO);
};
TraceablePeerConnection.prototype.hasAnyTracksOfType = function(mediaType) {
  if (!mediaType) {
    throw new Error('"mediaType" is required');
  }
  return this.getLocalTracks(mediaType).length > 0;
};
TraceablePeerConnection.prototype.getRemoteTracks = function(endpointId, mediaType) {
  let remoteTracks = [];
  const endpoints = endpointId ? [endpointId] : this.remoteTracks.keys();
  for (const endpoint of endpoints) {
    const endpointTracksByMediaType = this.remoteTracks.get(endpoint);
    if (endpointTracksByMediaType) {
      for (const trackMediaType of endpointTracksByMediaType.keys()) {
        if (!mediaType || mediaType === trackMediaType) {
          remoteTracks = remoteTracks.concat(Array.from(endpointTracksByMediaType.get(trackMediaType)));
        }
      }
    }
  }
  return remoteTracks;
};
TraceablePeerConnection.prototype.getRemoteSourceInfoByParticipant = function(id) {
  const removeSsrcInfo = [];
  const remoteTracks = this.getRemoteTracks(id);
  if (!(remoteTracks === null || remoteTracks === void 0 ? void 0 : remoteTracks.length)) {
    return removeSsrcInfo;
  }
  const primarySsrcs = remoteTracks.map((track) => track.getSSRC());
  const sdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_15__["default"](this.remoteDescription.sdp);
  primarySsrcs.forEach((ssrc, idx) => {
    for (const media of sdp.media) {
      let lines = "";
      let ssrcLines = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].findLines(media, `a=ssrc:${ssrc}`);
      if (ssrcLines.length) {
        if (!removeSsrcInfo[idx]) {
          removeSsrcInfo[idx] = "";
        }
        const fidLines = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].findLines(media, `a=ssrc-group:FID ${ssrc}`);
        if (fidLines.length) {
          const secondarySsrc = fidLines[0].split(" ")[2];
          lines += `${fidLines[0]}\r
`;
          ssrcLines = ssrcLines.concat(_sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].findLines(media, `a=ssrc:${secondarySsrc}`));
        }
        removeSsrcInfo[idx] += `${ssrcLines.join("\r\n")}\r
`;
        removeSsrcInfo[idx] += lines;
      }
    }
  });
  return removeSsrcInfo;
};
TraceablePeerConnection.prototype.getTargetVideoBitrates = function() {
  const currentCodec = this.getConfiguredVideoCodec();
  return this.tpcUtils.videoBitrates[currentCodec.toUpperCase()] || this.tpcUtils.videoBitrates;
};
TraceablePeerConnection.prototype.getTrackBySSRC = function(ssrc) {
  if (typeof ssrc !== "number") {
    throw new Error(`SSRC ${ssrc} is not a number`);
  }
  for (const localTrack of this.localTracks.values()) {
    if (this.getLocalSSRC(localTrack) === ssrc) {
      return localTrack;
    }
  }
  for (const remoteTrack of this.getRemoteTracks()) {
    if (remoteTrack.getSSRC() === ssrc) {
      return remoteTrack;
    }
  }
  return null;
};
TraceablePeerConnection.prototype.getSsrcByTrackId = function(id) {
  const findTrackById = (track) => track.getTrack().id === id;
  const localTrack = this.getLocalTracks().find(findTrackById);
  if (localTrack) {
    return this.getLocalSSRC(localTrack);
  }
  const remoteTrack = this.getRemoteTracks().find(findTrackById);
  if (remoteTrack) {
    return remoteTrack.getSSRC();
  }
  return null;
};
TraceablePeerConnection.prototype._remoteStreamAdded = function(stream) {
  const streamId = stream.id;
  if (!_RTC__WEBPACK_IMPORTED_MODULE_22__["default"].isUserStreamById(streamId)) {
    return;
  }
  if (_browser__WEBPACK_IMPORTED_MODULE_11__["default"].isChromiumBased()) {
    stream.onaddtrack = (event) => {
      this._remoteTrackAdded(stream, event.track);
    };
    stream.onremovetrack = (event) => {
      this._remoteTrackRemoved(stream, event.track);
    };
  }
  const streamAudioTracks = stream.getAudioTracks();
  for (const audioTrack of streamAudioTracks) {
    this._remoteTrackAdded(stream, audioTrack);
  }
  const streamVideoTracks = stream.getVideoTracks();
  for (const videoTrack of streamVideoTracks) {
    this._remoteTrackAdded(stream, videoTrack);
  }
};
TraceablePeerConnection.prototype._remoteTrackAdded = function(stream, track, transceiver = null) {
  const streamId = stream.id;
  const mediaType = track.kind;
  if (!this.isP2P && !_RTC__WEBPACK_IMPORTED_MODULE_22__["default"].isUserStreamById(streamId)) {
    return;
  }
  logger.info(`${this} Received track event for remote stream[id=${streamId},type=${mediaType}]`);
  if (!mediaType) {
    _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_20__.callErrorHandler(new Error(`MediaType undefined for remote track, stream id: ${streamId}, track creation failed!`));
    return;
  }
  const remoteSDP = this._usesUnifiedPlan ? new _sdp_SDP__WEBPACK_IMPORTED_MODULE_15__["default"](this.peerconnection.remoteDescription.sdp) : new _sdp_SDP__WEBPACK_IMPORTED_MODULE_15__["default"](this.remoteDescription.sdp);
  let mediaLine;
  if (this._usesUnifiedPlan) {
    if (transceiver === null || transceiver === void 0 ? void 0 : transceiver.mid) {
      const mid = transceiver.mid;
      mediaLine = remoteSDP.media.find((mls) => _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].findLine(mls, `a=mid:${mid}`));
    } else {
      mediaLine = remoteSDP.media.find((mls) => {
        const msid = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].findLine(mls, "a=msid:");
        return typeof msid === "string" && streamId === msid.substring(7).split(" ")[0];
      });
    }
  } else {
    mediaLine = remoteSDP.media.find((mls) => mls.startsWith(`m=${mediaType}`));
  }
  if (!mediaLine) {
    _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_20__.callErrorHandler(new Error(`Matching media line not found in remote SDP for remote stream[id=${streamId},type=${mediaType}],track creation failed!`));
    return;
  }
  let ssrcLines = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].findLines(mediaLine, "a=ssrc:");
  ssrcLines = ssrcLines.filter((line) => line.indexOf(`msid:${streamId}`) !== -1);
  if (!ssrcLines.length) {
    _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_20__.callErrorHandler(new Error(`No SSRC lines found in remote SDP for remote stream[msid=${streamId},type=${mediaType}]track creation failed!`));
    return;
  }
  const ssrcStr = ssrcLines[0].substring(7).split(" ")[0];
  const trackSsrc = Number(ssrcStr);
  const ownerEndpointId = this.signalingLayer.getSSRCOwner(trackSsrc);
  if (isNaN(trackSsrc) || trackSsrc < 0) {
    _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_20__.callErrorHandler(new Error(`Invalid SSRC for remote stream[ssrc=${trackSsrc},id=${streamId},type=${mediaType}]track creation failed!`));
    return;
  }
  if (!ownerEndpointId) {
    _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_20__.callErrorHandler(new Error(`No SSRC owner known for remote stream[ssrc=${trackSsrc},id=${streamId},type=${mediaType}]track creation failed!`));
    return;
  }
  const sourceName = this.signalingLayer.getTrackSourceName(trackSsrc);
  const peerMediaInfo = this.signalingLayer.getPeerMediaInfo(ownerEndpointId, mediaType, sourceName);
  let muted = true;
  let videoType = mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO ? _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.CAMERA : void 0;
  if (peerMediaInfo) {
    muted = peerMediaInfo.muted;
    videoType = peerMediaInfo.videoType;
  } else {
    logger.info(`${this}: no source-info available for ${ownerEndpointId}:${sourceName}, assuming default state`);
  }
  this._createRemoteTrack(ownerEndpointId, stream, track, mediaType, videoType, trackSsrc, muted, sourceName);
};
TraceablePeerConnection.prototype._createRemoteTrack = function(ownerEndpointId, stream, track, mediaType, videoType, ssrc, muted, sourceName) {
  logger.info(`${this} creating remote track[endpoint=${ownerEndpointId},ssrc=${ssrc},type=${mediaType},sourceName=${sourceName}]`);
  let remoteTracksMap = this.remoteTracks.get(ownerEndpointId);
  if (!remoteTracksMap) {
    remoteTracksMap = /* @__PURE__ */ new Map();
    remoteTracksMap.set(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO, /* @__PURE__ */ new Set());
    remoteTracksMap.set(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO, /* @__PURE__ */ new Set());
    this.remoteTracks.set(ownerEndpointId, remoteTracksMap);
  }
  const userTracksByMediaType = remoteTracksMap.get(mediaType);
  if ((userTracksByMediaType === null || userTracksByMediaType === void 0 ? void 0 : userTracksByMediaType.size) && Array.from(userTracksByMediaType).find((jitsiTrack) => jitsiTrack.getTrack() === track)) {
    logger.info(`${this} ignored duplicated track event for track[endpoint=${ownerEndpointId},type=${mediaType}]`);
    return;
  }
  const remoteTrack = new _JitsiRemoteTrack__WEBPACK_IMPORTED_MODULE_21__["default"](this.rtc, this.rtc.conference, ownerEndpointId, stream, track, mediaType, videoType, ssrc, muted, this.isP2P, sourceName);
  userTracksByMediaType.add(remoteTrack);
  this.eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].REMOTE_TRACK_ADDED, remoteTrack, this);
};
TraceablePeerConnection.prototype._remoteStreamRemoved = function(stream) {
  if (!_RTC__WEBPACK_IMPORTED_MODULE_22__["default"].isUserStream(stream)) {
    logger.info(`Ignored remote 'stream removed' event for stream[id=${stream.id}]`);
    return;
  }
  const streamVideoTracks = stream.getVideoTracks();
  for (const videoTrack of streamVideoTracks) {
    this._remoteTrackRemoved(stream, videoTrack);
  }
  const streamAudioTracks = stream.getAudioTracks();
  for (const audioTrack of streamAudioTracks) {
    this._remoteTrackRemoved(stream, audioTrack);
  }
};
TraceablePeerConnection.prototype._remoteTrackRemoved = function(stream, track) {
  const streamId = stream.id;
  const trackId = track === null || track === void 0 ? void 0 : track.id;
  if (!_RTC__WEBPACK_IMPORTED_MODULE_22__["default"].isUserStreamById(streamId)) {
    return;
  }
  if (!streamId) {
    _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_20__.callErrorHandler(new Error(`${this} remote track removal failed - no stream ID`));
    return;
  }
  if (!trackId) {
    _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_20__.callErrorHandler(new Error(`${this} remote track removal failed - no track ID`));
    return;
  }
  const toBeRemoved = this.getRemoteTracks().find((remoteTrack) => remoteTrack.getStreamId() === streamId && remoteTrack.getTrackId() === trackId);
  if (!toBeRemoved) {
    _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_20__.callErrorHandler(new Error(`${this} remote track removal failed - track not found`));
    return;
  }
  this._removeRemoteTrack(toBeRemoved);
};
TraceablePeerConnection.prototype.removeRemoteTracks = function(owner) {
  let removedTracks = [];
  const remoteTracksByMedia = this.remoteTracks.get(owner);
  if (remoteTracksByMedia) {
    removedTracks = removedTracks.concat(Array.from(remoteTracksByMedia.get(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO)));
    removedTracks = removedTracks.concat(Array.from(remoteTracksByMedia.get(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO)));
    this.remoteTracks.delete(owner);
  }
  logger.debug(`${this} removed remote tracks[endpoint=${owner},count=${removedTracks.length}`);
  return removedTracks;
};
TraceablePeerConnection.prototype._removeRemoteTrack = function(toBeRemoved) {
  var _a;
  logger.info(`${this} Removing remote track stream[id=${toBeRemoved.getStreamId()},trackId=${toBeRemoved.getTrackId()}]`);
  toBeRemoved.dispose();
  const participantId = toBeRemoved.getParticipantId();
  if (!participantId && _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_12__["default"].isSsrcRewritingSupported()) {
    return;
  }
  const userTracksByMediaType = this.remoteTracks.get(participantId);
  if (!userTracksByMediaType) {
    logger.error(`${this} removeRemoteTrack: no remote tracks map for endpoint=${participantId}`);
  } else if (!((_a = userTracksByMediaType.get(toBeRemoved.getType())) === null || _a === void 0 ? void 0 : _a.delete(toBeRemoved))) {
    logger.error(`${this} Failed to remove ${toBeRemoved} - type mapping messed up ?`);
  }
  this.eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].REMOTE_TRACK_REMOVED, toBeRemoved);
};
TraceablePeerConnection.prototype._extractSSRCMap = function(desc) {
  const ssrcMap = /* @__PURE__ */ new Map();
  const groupsMap = /* @__PURE__ */ new Map();
  if (typeof desc !== "object" || desc === null || typeof desc.sdp !== "string") {
    logger.warn("An empty description was passed as an argument");
    return ssrcMap;
  }
  const session = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(desc.sdp);
  if (!Array.isArray(session.media)) {
    return ssrcMap;
  }
  let media = session.media;
  if (this._usesUnifiedPlan) {
    media = media.filter((mline) => mline.direction === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDONLY || mline.direction === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDRECV);
  } else {
    media = [];
    [_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO].forEach((mediaType) => {
      const mLine = session.media.find((m) => m.type === mediaType);
      mLine && media.push(mLine);
    });
  }
  let index = 0;
  for (const mLine of media) {
    if (!Array.isArray(mLine.ssrcs)) {
      continue;
    }
    if (Array.isArray(mLine.ssrcGroups)) {
      for (const group of mLine.ssrcGroups) {
        if (typeof group.semantics !== "undefined" && typeof group.ssrcs !== "undefined") {
          const groupSSRCs = group.ssrcs.split(" ").map((ssrcStr) => parseInt(ssrcStr, 10));
          const primarySSRC = groupSSRCs[0];
          group.ssrcs = groupSSRCs;
          if (!groupsMap.has(primarySSRC)) {
            groupsMap.set(primarySSRC, []);
          }
          groupsMap.get(primarySSRC).push(group);
        }
      }
      const simGroup = mLine.ssrcGroups.find((group) => group.semantics === "SIM");
      if (!simGroup) {
        const groupSsrcs = mLine.ssrcGroups.map((group) => group.ssrcs[0]);
        groupsMap.get(groupSsrcs[0]).push({
          semantics: "SIM",
          ssrcs: groupSsrcs
        });
      }
    }
    let ssrcs = mLine.ssrcs;
    ssrcs = this._usesUnifiedPlan ? ssrcs.filter((s) => s.attribute === "cname") : ssrcs.filter((s) => s.attribute === "msid");
    for (const ssrc of ssrcs) {
      const key = this._usesUnifiedPlan ? `${mLine.type}-${index}` : ssrc.value;
      const ssrcNumber = ssrc.id;
      let ssrcInfo = ssrcMap.get(key);
      if (!ssrcInfo) {
        ssrcInfo = {
          ssrcs: [],
          groups: [],
          msid: key
        };
        ssrcMap.set(key, ssrcInfo);
      }
      ssrcInfo.ssrcs.push(ssrcNumber);
      if (groupsMap.has(ssrcNumber)) {
        const ssrcGroups = groupsMap.get(ssrcNumber);
        for (const group of ssrcGroups) {
          ssrcInfo.groups.push(group);
        }
      }
    }
    mLine.type === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO && index++;
  }
  return ssrcMap;
};
const normalizePlanB = function(desc) {
  if (typeof desc !== "object" || desc === null || typeof desc.sdp !== "string") {
    logger.warn("An empty description was passed as an argument");
    return desc;
  }
  const transform2 = __webpack_require__(/*! sdp-transform */ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/index.js");
  const session = transform2.parse(desc.sdp);
  if (typeof session !== "undefined" && typeof session.media !== "undefined" && Array.isArray(session.media)) {
    session.media.forEach((mLine) => {
      const firstSsrcs = [];
      const newSsrcLines = [];
      if (typeof mLine.ssrcGroups !== "undefined" && Array.isArray(mLine.ssrcGroups)) {
        mLine.ssrcGroups.forEach((group) => {
          if (typeof group.semantics !== "undefined" && group.semantics === "FID") {
            if (typeof group.ssrcs !== "undefined") {
              firstSsrcs.push(Number(group.ssrcs.split(" ")[0]));
            }
          }
        });
      }
      if (Array.isArray(mLine.ssrcs)) {
        let i;
        for (i = 0; i < mLine.ssrcs.length; i++) {
          if (typeof mLine.ssrcs[i] === "object" && typeof mLine.ssrcs[i].id !== "undefined" && firstSsrcs.indexOf(mLine.ssrcs[i].id) >= 0) {
            newSsrcLines.push(mLine.ssrcs[i]);
            delete mLine.ssrcs[i];
          }
        }
        for (i = 0; i < mLine.ssrcs.length; i++) {
          if (typeof mLine.ssrcs[i] !== "undefined") {
            newSsrcLines.push(mLine.ssrcs[i]);
          }
        }
        mLine.ssrcs = replaceDefaultUnifiedPlanMsid(newSsrcLines);
      }
    });
  }
  const resStr = transform2.write(session);
  return new RTCSessionDescription({
    type: desc.type,
    sdp: resStr
  });
};
function replaceDefaultUnifiedPlanMsid(ssrcLines = []) {
  if (!_browser__WEBPACK_IMPORTED_MODULE_11__["default"].isChrome() || !_browser__WEBPACK_IMPORTED_MODULE_11__["default"].isVersionGreaterThan(70)) {
    return ssrcLines;
  }
  let filteredLines = [...ssrcLines];
  const problematicSsrcIds = ssrcLines.filter((ssrcLine) => ssrcLine.attribute === "mslabel" && ssrcLine.value === "-").map((ssrcLine) => ssrcLine.id);
  problematicSsrcIds.forEach((ssrcId) => {
    const cnameLine = filteredLines.find((line) => line.id === ssrcId && line.attribute === "cname");
    cnameLine.value = `${_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.RECVONLY}-${ssrcId}`;
    filteredLines = filteredLines.filter((line) => line.id !== ssrcId);
    filteredLines.push(cnameLine);
  });
  return filteredLines;
}
const enforceSendRecv = function(localDescription, options) {
  var _a, _b;
  if (!localDescription) {
    throw new Error("No local description passed in.");
  }
  const transformer = new _sdp_SdpTransformUtil__WEBPACK_IMPORTED_MODULE_19__.SdpTransformWrap(localDescription.sdp);
  const audioMedia = (_a = transformer.selectMedia(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO)) === null || _a === void 0 ? void 0 : _a[0];
  let changed = false;
  if (audioMedia && audioMedia.direction !== _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDRECV) {
    if (options.startSilent) {
      audioMedia.direction = _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.INACTIVE;
    } else {
      audioMedia.direction = _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDRECV;
    }
    changed = true;
  }
  const videoMedia = (_b = transformer.selectMedia(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO)) === null || _b === void 0 ? void 0 : _b[0];
  if (videoMedia && videoMedia.direction !== _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDRECV) {
    videoMedia.direction = _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDRECV;
    changed = true;
  }
  if (changed) {
    return new RTCSessionDescription({
      type: localDescription.type,
      sdp: transformer.toRawSDP()
    });
  }
  return localDescription;
};
TraceablePeerConnection.prototype.getLocalSSRC = function(localTrack) {
  const ssrcInfo = this._getSSRC(localTrack.rtcId);
  return ssrcInfo && ssrcInfo.ssrcs[0];
};
TraceablePeerConnection.prototype._injectSsrcGroupForUnifiedSimulcast = function(desc) {
  const sdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(desc.sdp);
  const video = sdp.media.find((mline) => mline.type === "video");
  video.ssrcGroups = video.ssrcGroups || [];
  const fidGroups = video.ssrcGroups.filter((group) => group.semantics === "FID");
  if (video.simulcast || video.simulcast_03) {
    const ssrcs = [];
    if (fidGroups && fidGroups.length) {
      fidGroups.forEach((group) => {
        ssrcs.push(group.ssrcs.split(" ")[0]);
      });
    } else {
      video.ssrcs.forEach((ssrc) => {
        if (ssrc.attribute === "msid") {
          ssrcs.push(ssrc.id);
        }
      });
    }
    if (video.ssrcGroups.find((group) => group.semantics === "SIM")) {
      return desc;
    }
    for (let i = 0; i < ssrcs.length; i += 3) {
      const simSsrcs = ssrcs.slice(i, i + 3);
      video.ssrcGroups.push({
        semantics: "SIM",
        ssrcs: simSsrcs.join(" ")
      });
    }
  }
  return new RTCSessionDescription({
    type: desc.type,
    sdp: sdp_transform__WEBPACK_IMPORTED_MODULE_2__.write(sdp)
  });
};
const getters = {
  signalingState() {
    return this.peerconnection.signalingState;
  },
  iceConnectionState() {
    return this.peerconnection.iceConnectionState;
  },
  connectionState() {
    return this.peerconnection.connectionState;
  },
  localDescription() {
    let desc = this.peerconnection.localDescription;
    if (!desc) {
      logger.debug(`${this} getLocalDescription no localDescription found`);
      return {};
    }
    this.trace("getLocalDescription::preTransform", dumpSDP(desc));
    if (this._usesUnifiedPlan && !this.isP2P) {
      desc = this.interop.toPlanB(desc);
      this.trace("getLocalDescription::postTransform (Plan B)", dumpSDP(desc));
      desc = this._injectSsrcGroupForUnifiedSimulcast(desc);
      this.trace("getLocalDescription::postTransform (inject ssrc group)", dumpSDP(desc));
    } else if (!this._usesUnifiedPlan) {
      if (_browser__WEBPACK_IMPORTED_MODULE_11__["default"].doesVideoMuteByStreamRemove()) {
        desc = this.localSdpMunger.maybeAddMutedLocalVideoTracksToSDP(desc);
        logger.debug("getLocalDescription::postTransform (munge local SDP)", desc);
      }
      desc = enforceSendRecv(desc, this.options);
    }
    desc = this.localSdpMunger.transformStreamIdentifiers(desc);
    return desc;
  },
  remoteDescription() {
    let desc = this.peerconnection.remoteDescription;
    if (!desc) {
      logger.debug(`${this} getRemoteDescription no remoteDescription found`);
      return {};
    }
    this.trace("getRemoteDescription::preTransform", dumpSDP(desc));
    if (this._usesUnifiedPlan) {
      if (this.isP2P) {
        desc = this._adjustRemoteMediaDirection(desc);
      } else {
        desc = this.interop.toPlanB(desc);
        this.trace("getRemoteDescription::postTransform (Plan B)", dumpSDP(desc));
      }
    }
    return desc;
  }
};
Object.keys(getters).forEach((prop) => {
  Object.defineProperty(TraceablePeerConnection.prototype, prop, {
    get: getters[prop]
  });
});
TraceablePeerConnection.prototype._getSSRC = function(rtcId) {
  return this.localSSRCs.get(rtcId);
};
TraceablePeerConnection.prototype.isSharingLowFpsScreen = function() {
  return this._isSharingScreen() && this._capScreenshareBitrate;
};
TraceablePeerConnection.prototype._isSharingScreen = function() {
  const tracks = this.getLocalVideoTracks();
  return Boolean(tracks.find((track) => track.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.DESKTOP));
};
TraceablePeerConnection.prototype._mungeCodecOrder = function(description) {
  if (!this.codecSettings) {
    return description;
  }
  const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(description.sdp);
  const mLines = parsedSdp.media.filter((m) => m.type === this.codecSettings.mediaType);
  if (!mLines.length) {
    return description;
  }
  for (const mLine of mLines) {
    const currentCodecs = this.getConfiguredVideoCodecs();
    for (const codec of currentCodecs) {
      if (codec === _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_3__["default"].H264 && _browser__WEBPACK_IMPORTED_MODULE_11__["default"].isMobileDevice() && this.isP2P) {
        _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].stripCodec(mLine, codec, true);
      }
    }
    for (const codec of this.codecSettings.codecList.slice().reverse()) {
      _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].preferCodec(mLine, codec);
    }
  }
  return new RTCSessionDescription({
    type: description.type,
    sdp: sdp_transform__WEBPACK_IMPORTED_MODULE_2__.write(parsedSdp)
  });
};
TraceablePeerConnection.prototype.addTrack = function(track, isInitiator = false) {
  const rtcId = track.rtcId;
  logger.info(`${this} adding ${track}`);
  if (this.localTracks.has(rtcId)) {
    return Promise.reject(new Error(`${track} is already in ${this}`));
  }
  this.localTracks.set(rtcId, track);
  const webrtcStream = track.getOriginalStream();
  if (this._usesUnifiedPlan) {
    logger.debug(`${this} TPC.addTrack using unified plan`);
    try {
      this.tpcUtils.addTrack(track, isInitiator);
      if (track) {
        if (track.isAudioTrack()) {
          this._hasHadAudioTrack = true;
        } else {
          this._hasHadVideoTrack = true;
        }
      }
    } catch (error) {
      logger.error(`${this} Adding track=${track} failed: ${error === null || error === void 0 ? void 0 : error.message}`);
      return Promise.reject(error);
    }
  } else {
    if (webrtcStream) {
      this._addStream(webrtcStream);
    } else if (!_browser__WEBPACK_IMPORTED_MODULE_11__["default"].doesVideoMuteByStreamRemove() || track.isAudioTrack() || track.isVideoTrack() && !track.isMuted()) {
      return Promise.reject(new Error(`${this} no WebRTC stream for track=${track}`));
    }
    if (_browser__WEBPACK_IMPORTED_MODULE_11__["default"].doesVideoMuteByStreamRemove() && track.isVideoTrack() && track.isMuted()) {
      const ssrcInfo = this.generateNewStreamSSRCInfo(track);
      this.sdpConsistency.setPrimarySsrc(ssrcInfo.ssrcs[0]);
      const simGroup = ssrcInfo.groups.find((groupInfo) => groupInfo.semantics === "SIM");
      if (simGroup) {
        this.simulcast.setSsrcCache(simGroup.ssrcs);
      }
      const fidGroups = ssrcInfo.groups.filter((groupInfo) => groupInfo.semantics === "FID");
      if (fidGroups) {
        const rtxSsrcMapping = /* @__PURE__ */ new Map();
        fidGroups.forEach((fidGroup) => {
          const primarySsrc = fidGroup.ssrcs[0];
          const rtxSsrc = fidGroup.ssrcs[1];
          rtxSsrcMapping.set(primarySsrc, rtxSsrc);
        });
        this.rtxModifier.setSsrcCache(rtxSsrcMapping);
      }
    }
  }
  let promiseChain = Promise.resolve();
  if (_browser__WEBPACK_IMPORTED_MODULE_11__["default"].isFirefox()) {
    promiseChain = promiseChain.then(() => webrtcStream && this.tpcUtils.setEncodings(track));
  }
  return promiseChain;
};
TraceablePeerConnection.prototype.addTrackToPc = function(track) {
  logger.info(`${this} Adding track=${track} to PC`);
  if (!this._assertTrackBelongs("addTrackToPc", track)) {
    return Promise.reject("Track not found on the peerconnection");
  }
  const webRtcStream = track.getOriginalStream();
  if (!webRtcStream) {
    logger.error(`${this} Unable to add track=${track} to PC - no WebRTC stream`);
    return Promise.reject("Stream not found");
  }
  if (this._usesUnifiedPlan) {
    return this.tpcUtils.replaceTrack(null, track).then(() => {
      if (track) {
        if (track.isAudioTrack()) {
          this._hasHadAudioTrack = true;
        } else {
          this._hasHadVideoTrack = true;
        }
      }
      return false;
    });
  }
  this._addStream(webRtcStream);
  return Promise.resolve(true);
};
TraceablePeerConnection.prototype._addStream = function(mediaStream) {
  this.peerconnection.addStream(mediaStream);
  this._addedStreams.push(mediaStream);
};
TraceablePeerConnection.prototype._removeStream = function(mediaStream) {
  this.peerconnection.removeStream(mediaStream);
  this._addedStreams = this._addedStreams.filter((stream) => stream !== mediaStream);
};
TraceablePeerConnection.prototype._assertTrackBelongs = function(methodName, localTrack) {
  const doesBelong = this.localTracks.has(localTrack === null || localTrack === void 0 ? void 0 : localTrack.rtcId);
  if (!doesBelong) {
    logger.error(`${this} ${methodName}: track=${localTrack} does not belong to pc`);
  }
  return doesBelong;
};
TraceablePeerConnection.prototype.getConfiguredVideoCodec = function() {
  var _a;
  const sdp = (_a = this.peerconnection.localDescription) === null || _a === void 0 ? void 0 : _a.sdp;
  const defaultCodec = _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_3__["default"].VP8;
  if (!sdp) {
    return defaultCodec;
  }
  const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(sdp);
  const mLine = parsedSdp.media.find((m) => m.type === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO);
  const codec = mLine.rtp[0].codec;
  if (codec) {
    return Object.values(_service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_3__["default"]).find((value) => value === codec.toLowerCase());
  }
  return defaultCodec;
};
TraceablePeerConnection.prototype.getConfiguredVideoCodecs = function() {
  var _a;
  const sdp = (_a = this.peerconnection.localDescription) === null || _a === void 0 ? void 0 : _a.sdp;
  if (!sdp) {
    return [];
  }
  const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(sdp);
  const mLine = parsedSdp.media.find((m) => m.type === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO);
  const codecs = new Set(mLine.rtp.filter((pt) => pt.codec.toLowerCase() !== "rtx").map((pt) => pt.codec.toLowerCase()));
  return Array.from(codecs);
};
TraceablePeerConnection.prototype.isVideoCodecDisabled = function(codec) {
  var _a;
  const sdp = (_a = this.peerconnection.localDescription) === null || _a === void 0 ? void 0 : _a.sdp;
  if (!sdp) {
    return false;
  }
  const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(sdp);
  const mLine = parsedSdp.media.find((m) => m.type === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO);
  return !mLine.rtp.find((r) => r.codec === codec);
};
TraceablePeerConnection.prototype.setDesktopSharingFrameRate = function(maxFps) {
  const lowFps = maxFps <= _RTC_ScreenObtainer__WEBPACK_IMPORTED_MODULE_10__.SS_DEFAULT_FRAME_RATE;
  this._capScreenshareBitrate = this.isSimulcastOn() && lowFps;
};
TraceablePeerConnection.prototype.setVideoCodecs = function(codecList) {
  if (!this.codecSettings || !(codecList === null || codecList === void 0 ? void 0 : codecList.length)) {
    return;
  }
  this.codecSettings.codecList = codecList;
};
TraceablePeerConnection.prototype.isMediaStreamInPc = function(mediaStream) {
  return this._addedStreams.indexOf(mediaStream) > -1;
};
TraceablePeerConnection.prototype.removeTrack = function(localTrack) {
  const webRtcStream = localTrack.getOriginalStream();
  this.trace("removeStream", localTrack.rtcId, webRtcStream ? webRtcStream.id : void 0);
  if (!this._assertTrackBelongs("removeStream", localTrack)) {
    return;
  }
  this.localTracks.delete(localTrack.rtcId);
  this.localSSRCs.delete(localTrack.rtcId);
  if (webRtcStream) {
    this.peerconnection.removeStream(webRtcStream);
  }
};
TraceablePeerConnection.prototype.findSenderByKind = function(mediaType) {
  if (this.peerconnection.getSenders) {
    return this.peerconnection.getSenders().find((s) => s.track && s.track.kind === mediaType);
  }
};
TraceablePeerConnection.prototype.findReceiverForTrack = function(track) {
  return this.peerconnection.getReceivers().find((r) => r.track === track);
};
TraceablePeerConnection.prototype.findSenderForTrack = function(track) {
  if (this.peerconnection.getSenders) {
    return this.peerconnection.getSenders().find((s) => s.track === track);
  }
};
TraceablePeerConnection.prototype.processLocalSdpForTransceiverInfo = function(localTracks) {
  var _a;
  const localSdp = (_a = this.peerconnection.localDescription) === null || _a === void 0 ? void 0 : _a.sdp;
  if (!localSdp) {
    return;
  }
  [_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO].forEach((mediaType) => {
    const tracks = localTracks.filter((t) => t.getType() === mediaType);
    const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(localSdp);
    const mLines = parsedSdp.media.filter((mline) => mline.type === mediaType);
    tracks.forEach((track, idx) => {
      if (!this._localTrackTransceiverMids.has(track.rtcId)) {
        this._localTrackTransceiverMids.set(track.rtcId, mLines[idx].mid.toString());
      }
    });
  });
};
TraceablePeerConnection.prototype.replaceTrack = function(oldTrack, newTrack) {
  if (!(oldTrack || newTrack)) {
    logger.info(`${this} replaceTrack called with no new track and no old track`);
    return Promise.resolve();
  }
  if (this._usesUnifiedPlan) {
    logger.debug(`${this} TPC.replaceTrack using unified plan`);
    return this.tpcUtils.replaceTrack(oldTrack, newTrack).then((transceiver) => {
      var _a;
      if (oldTrack) {
        this.localTracks.delete(oldTrack.rtcId);
        this._localTrackTransceiverMids.delete(oldTrack.rtcId);
      }
      if (newTrack) {
        if (newTrack.isAudioTrack()) {
          this._hasHadAudioTrack = true;
        } else {
          this._hasHadVideoTrack = true;
        }
        this._localTrackTransceiverMids.set(newTrack.rtcId, (_a = transceiver === null || transceiver === void 0 ? void 0 : transceiver.mid) === null || _a === void 0 ? void 0 : _a.toString());
        this.localTracks.set(newTrack.rtcId, newTrack);
      }
      if (oldTrack && newTrack) {
        const oldTrackSSRC = this.localSSRCs.get(oldTrack.rtcId);
        if (oldTrackSSRC) {
          this.localSSRCs.delete(oldTrack.rtcId);
          this.localSSRCs.set(newTrack.rtcId, oldTrackSSRC);
        }
      }
      if (transceiver) {
        transceiver.direction = newTrack || _browser__WEBPACK_IMPORTED_MODULE_11__["default"].isFirefox() ? _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDRECV : _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.RECVONLY;
      }
      const configureEncodingsPromise = _browser__WEBPACK_IMPORTED_MODULE_11__["default"].usesSdpMungingForSimulcast() || !newTrack ? Promise.resolve() : this.tpcUtils.setEncodings(newTrack);
      return configureEncodingsPromise.then(() => this.isP2P);
    });
  }
  logger.debug(`${this} TPC.replaceTrack using plan B`);
  let promiseChain = Promise.resolve();
  if (oldTrack) {
    this.removeTrack(oldTrack);
  }
  if (newTrack) {
    promiseChain = this.addTrack(newTrack);
  }
  return promiseChain.then(() => true);
};
TraceablePeerConnection.prototype.removeTrackFromPc = function(localTrack) {
  const webRtcStream = localTrack.getOriginalStream();
  this.trace("removeTrack", localTrack.rtcId, webRtcStream ? webRtcStream.id : null);
  if (!this._assertTrackBelongs("removeTrack", localTrack)) {
    return Promise.reject("Track not found in the peerconnection");
  }
  if (this._usesUnifiedPlan) {
    return this.tpcUtils.replaceTrack(localTrack, null).then(() => false);
  }
  if (webRtcStream) {
    logger.info(`${this} Removing track=${localTrack} from PC`);
    this._removeStream(webRtcStream);
    return Promise.resolve(true);
  }
  logger.error(`${this} removeTrack - no WebRTC stream for track=${localTrack}`);
  return Promise.reject("Stream not found");
};
TraceablePeerConnection.prototype.createDataChannel = function(label, opts) {
  this.trace("createDataChannel", label, opts);
  return this.peerconnection.createDataChannel(label, opts);
};
TraceablePeerConnection.prototype._ensureSimulcastGroupIsLast = function(localSdp) {
  let sdpStr = localSdp.sdp;
  const videoStartIndex = sdpStr.indexOf("m=video");
  const simStartIndex = sdpStr.indexOf("a=ssrc-group:SIM", videoStartIndex);
  let otherStartIndex = sdpStr.lastIndexOf("a=ssrc-group");
  if (simStartIndex === -1 || otherStartIndex === -1 || otherStartIndex === simStartIndex) {
    return localSdp;
  }
  const simEndIndex = sdpStr.indexOf("\r\n", simStartIndex);
  const simStr = sdpStr.substring(simStartIndex, simEndIndex + 2);
  sdpStr = sdpStr.replace(simStr, "");
  otherStartIndex = sdpStr.lastIndexOf("a=ssrc-group");
  const otherEndIndex = sdpStr.indexOf("\r\n", otherStartIndex);
  const sdpHead = sdpStr.slice(0, otherEndIndex);
  const simStrTrimmed = simStr.trim();
  const sdpTail = sdpStr.slice(otherEndIndex);
  sdpStr = `${sdpHead}\r
${simStrTrimmed}${sdpTail}`;
  return new RTCSessionDescription({
    type: localSdp.type,
    sdp: sdpStr
  });
};
TraceablePeerConnection.prototype._adjustLocalMediaDirection = function(localDescription) {
  var _a, _b;
  const transformer = new _sdp_SdpTransformUtil__WEBPACK_IMPORTED_MODULE_19__.SdpTransformWrap(localDescription.sdp);
  let modifiedDirection = false;
  const audioMedia = (_a = transformer.selectMedia(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO)) === null || _a === void 0 ? void 0 : _a[0];
  if (audioMedia) {
    const desiredAudioDirection = this.getDesiredMediaDirection(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO);
    if (audioMedia.direction !== desiredAudioDirection) {
      audioMedia.direction = desiredAudioDirection;
      logger.info(`${this} Adjusted local audio direction to ${desiredAudioDirection}`);
      modifiedDirection = true;
    }
  } else {
    logger.warn(`${this} No "audio" media found in the local description`);
  }
  const videoMedia = (_b = transformer.selectMedia(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO)) === null || _b === void 0 ? void 0 : _b[0];
  if (videoMedia) {
    const desiredVideoDirection = this.getDesiredMediaDirection(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO);
    if (videoMedia.direction !== desiredVideoDirection) {
      videoMedia.direction = desiredVideoDirection;
      logger.info(`${this} Adjusted local video direction to ${desiredVideoDirection}`);
      modifiedDirection = true;
    }
  } else {
    logger.warn(`${this} No "video" media found in the local description`);
  }
  if (modifiedDirection) {
    return new RTCSessionDescription({
      type: localDescription.type,
      sdp: transformer.toRawSDP()
    });
  }
  return localDescription;
};
TraceablePeerConnection.prototype._adjustRemoteMediaDirection = function(remoteDescription) {
  const transformer = new _sdp_SdpTransformUtil__WEBPACK_IMPORTED_MODULE_19__.SdpTransformWrap(remoteDescription.sdp);
  [_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO].forEach((mediaType) => {
    const media = transformer.selectMedia(mediaType);
    const localSources = this.getLocalTracks(mediaType).length;
    const remoteSources = this.getRemoteTracks(null, mediaType).length;
    media.forEach((mLine, idx) => {
      if (localSources && localSources === remoteSources) {
        mLine.direction = _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDRECV;
      } else if (!localSources && !remoteSources) {
        mLine.direction = _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.INACTIVE;
      } else if (!localSources) {
        mLine.direction = _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDONLY;
      } else if (!remoteSources) {
        mLine.direction = _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.RECVONLY;
      } else if (localSources > remoteSources) {
        mLine.direction = idx ? _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.RECVONLY : _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDRECV;
      } else {
        mLine.direction = idx ? _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDONLY : _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDRECV;
      }
    });
  });
  return new RTCSessionDescription({
    type: remoteDescription.type,
    sdp: transformer.toRawSDP()
  });
};
TraceablePeerConnection.prototype._mungeOpus = function(description) {
  const { audioQuality } = this.options;
  if (!(audioQuality === null || audioQuality === void 0 ? void 0 : audioQuality.enableOpusDtx) && !(audioQuality === null || audioQuality === void 0 ? void 0 : audioQuality.stereo) && !(audioQuality === null || audioQuality === void 0 ? void 0 : audioQuality.opusMaxAverageBitrate)) {
    return description;
  }
  const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(description.sdp);
  const mLines = parsedSdp.media;
  for (const mLine of mLines) {
    if (mLine.type === "audio") {
      const { payload } = mLine.rtp.find((protocol) => protocol.codec === _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_3__["default"].OPUS);
      if (!payload) {
        continue;
      }
      let fmtpOpus = mLine.fmtp.find((protocol) => protocol.payload === payload);
      if (!fmtpOpus) {
        fmtpOpus = {
          payload,
          config: ""
        };
      }
      const fmtpConfig = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parseParams(fmtpOpus.config);
      let sdpChanged = false;
      if (audioQuality === null || audioQuality === void 0 ? void 0 : audioQuality.stereo) {
        fmtpConfig.stereo = 1;
        sdpChanged = true;
      }
      if (audioQuality === null || audioQuality === void 0 ? void 0 : audioQuality.opusMaxAverageBitrate) {
        fmtpConfig.maxaveragebitrate = audioQuality.opusMaxAverageBitrate;
        sdpChanged = true;
      }
      if (!_browser__WEBPACK_IMPORTED_MODULE_11__["default"].isFirefox() && (audioQuality === null || audioQuality === void 0 ? void 0 : audioQuality.enableOpusDtx)) {
        fmtpConfig.usedtx = 1;
        sdpChanged = true;
      }
      if (!sdpChanged) {
        continue;
      }
      let mungedConfig = "";
      for (const key of Object.keys(fmtpConfig)) {
        mungedConfig += `${key}=${fmtpConfig[key]}; `;
      }
      fmtpOpus.config = mungedConfig.trim();
    }
  }
  return new RTCSessionDescription({
    type: description.type,
    sdp: sdp_transform__WEBPACK_IMPORTED_MODULE_2__.write(parsedSdp)
  });
};
TraceablePeerConnection.prototype._mungeInactive = function(description) {
  const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(description.sdp);
  const mLines = parsedSdp.media;
  for (const mLine of mLines) {
    mLine.direction = _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.INACTIVE;
    mLine.ssrcs = void 0;
    mLine.ssrcGroups = void 0;
  }
  return new RTCSessionDescription({
    type: description.type,
    sdp: sdp_transform__WEBPACK_IMPORTED_MODULE_2__.write(parsedSdp)
  });
};
TraceablePeerConnection.prototype._initializeDtlsTransport = function() {
  if (!this.peerconnection.getSenders || this._dtlsTransport) {
    return;
  }
  const senders = this.peerconnection.getSenders();
  if (senders.length !== 0 && senders[0].transport) {
    this._dtlsTransport = senders[0].transport;
    this._dtlsTransport.onerror = (error) => {
      logger.error(`${this} DtlsTransport error: ${error}`);
    };
    this._dtlsTransport.onstatechange = () => {
      this.trace("dtlsTransport.onstatechange", this._dtlsTransport.state);
    };
  }
};
TraceablePeerConnection.prototype._setVp9MaxBitrates = function(description, isLocalSdp = false) {
  if (!this.codecSettings) {
    return description;
  }
  const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(description.sdp);
  const direction = isLocalSdp ? _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.RECVONLY : _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_4__.MediaDirection.SENDONLY;
  const mLines = parsedSdp.media.filter((m) => m.type === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO && m.direction !== direction);
  for (const mLine of mLines) {
    if (this.codecSettings.codecList[0] === _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_3__["default"].VP9) {
      const bitrates = this.tpcUtils.videoBitrates.VP9 || this.tpcUtils.videoBitrates;
      const hdBitrate = bitrates.high ? bitrates.high : _TPCUtils__WEBPACK_IMPORTED_MODULE_23__.HD_BITRATE;
      const ssHdBitrate = bitrates.ssHigh ? bitrates.ssHigh : _TPCUtils__WEBPACK_IMPORTED_MODULE_23__.HD_BITRATE;
      const mid = mLine.mid;
      const isSharingScreen = _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_12__["default"].isMultiStreamSendSupportEnabled() ? mid === this._getDesktopTrackMid() : this._isSharingScreen();
      const limit = Math.floor((isSharingScreen ? ssHdBitrate : hdBitrate) / 1e3);
      mLine.bandwidth = [{
        type: "AS",
        limit
      }];
    } else {
      mLine.bandwidth = void 0;
    }
  }
  return new RTCSessionDescription({
    type: description.type,
    sdp: sdp_transform__WEBPACK_IMPORTED_MODULE_2__.write(parsedSdp)
  });
};
TraceablePeerConnection.prototype.configureSenderVideoEncodings = function(localVideoTrack = null) {
  if (!(this.videoTransferActive && this.audioTransferActive)) {
    return this.tpcUtils.setMediaTransferActive(false);
  }
  if (localVideoTrack) {
    return this.setSenderVideoConstraints(this._senderMaxHeights.get(localVideoTrack.getSourceName()), localVideoTrack);
  }
  const promises = [];
  for (const track of this.getLocalVideoTracks()) {
    promises.push(this.setSenderVideoConstraints(this._senderMaxHeights.get(track.getSourceName()), track));
  }
  return Promise.allSettled(promises);
};
TraceablePeerConnection.prototype.setLocalDescription = function(description) {
  let localDescription = description;
  this.trace("setLocalDescription::preTransform", dumpSDP(localDescription));
  localDescription = this._mungeOpus(localDescription);
  if (!this._usesUnifiedPlan) {
    localDescription = this._adjustLocalMediaDirection(localDescription);
    localDescription = this._ensureSimulcastGroupIsLast(localDescription);
  }
  localDescription = this._mungeCodecOrder(localDescription);
  localDescription = this._setVp9MaxBitrates(localDescription, true);
  this.trace("setLocalDescription::postTransform", dumpSDP(localDescription));
  return new Promise((resolve, reject) => {
    this.peerconnection.setLocalDescription(localDescription).then(() => {
      this.trace("setLocalDescriptionOnSuccess");
      const localUfrag = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].getUfrag(localDescription.sdp);
      if (localUfrag !== this.localUfrag) {
        this.localUfrag = localUfrag;
        this.eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].LOCAL_UFRAG_CHANGED, this, localUfrag);
      }
      this._initializeDtlsTransport();
      resolve();
    }, (err) => {
      this.trace("setLocalDescriptionOnFailure", err);
      this.eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].SET_LOCAL_DESCRIPTION_FAILED, err, this);
      reject(err);
    });
  });
};
TraceablePeerConnection.prototype.setRemoteDescription = function(description) {
  let remoteDescription = description;
  this.trace("setRemoteDescription::preTransform", dumpSDP(description));
  remoteDescription = this._mungeOpus(remoteDescription);
  if (this._usesUnifiedPlan) {
    if (!this.isP2P) {
      const currentDescription = this.peerconnection.remoteDescription;
      remoteDescription = this.interop.toUnifiedPlan(remoteDescription, currentDescription);
      this.trace("setRemoteDescription::postTransform (Unified)", dumpSDP(remoteDescription));
    }
    if (this.isSimulcastOn()) {
      remoteDescription = this.tpcUtils.insertUnifiedPlanSimulcastReceive(remoteDescription);
      this.trace("setRemoteDescription::postTransform (sim receive)", dumpSDP(remoteDescription));
    }
    remoteDescription = this.tpcUtils.ensureCorrectOrderOfSsrcs(remoteDescription);
    this.trace("setRemoteDescription::postTransform (correct ssrc order)", dumpSDP(remoteDescription));
  } else {
    if (this.isSimulcastOn()) {
      remoteDescription = this.simulcast.mungeRemoteDescription(remoteDescription, true);
      this.trace("setRemoteDescription::postTransform (simulcast)", dumpSDP(remoteDescription));
    }
    remoteDescription = normalizePlanB(remoteDescription);
  }
  remoteDescription = this._mungeCodecOrder(remoteDescription);
  remoteDescription = this._setVp9MaxBitrates(remoteDescription);
  this.trace("setRemoteDescription::postTransform (munge codec order)", dumpSDP(remoteDescription));
  return new Promise((resolve, reject) => {
    this.peerconnection.setRemoteDescription(remoteDescription).then(() => {
      this.trace("setRemoteDescriptionOnSuccess");
      const remoteUfrag = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].getUfrag(remoteDescription.sdp);
      if (remoteUfrag !== this.remoteUfrag) {
        this.remoteUfrag = remoteUfrag;
        this.eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].REMOTE_UFRAG_CHANGED, this, remoteUfrag);
      }
      this._initializeDtlsTransport();
      resolve();
    }, (err) => {
      this.trace("setRemoteDescriptionOnFailure", err);
      this.eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].SET_REMOTE_DESCRIPTION_FAILED, err, this);
      reject(err);
    });
  });
};
TraceablePeerConnection.prototype.setSenderVideoConstraints = function(frameHeight, localVideoTrack) {
  var _a, _b;
  if (frameHeight < 0) {
    throw new Error(`Invalid frameHeight: ${frameHeight}`);
  }
  if (!localVideoTrack) {
    throw new Error("Local video track is missing");
  }
  const sourceName = localVideoTrack.getSourceName();
  if (!this.videoTransferActive || localVideoTrack.isMuted()) {
    this._senderMaxHeights.set(sourceName, frameHeight);
    return Promise.resolve();
  }
  const configuredResolution = this.tpcUtils.getConfiguredEncodeResolution(localVideoTrack);
  if (localVideoTrack.getVideoType() === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.CAMERA && configuredResolution === frameHeight || localVideoTrack.getVideoType() === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.DESKTOP && frameHeight > 0 && configuredResolution === ((_b = (_a = localVideoTrack.getTrack()) === null || _a === void 0 ? void 0 : _a.getSettings()) === null || _b === void 0 ? void 0 : _b.height)) {
    return Promise.resolve();
  }
  this._senderMaxHeights.set(sourceName, frameHeight);
  return this._updateVideoSenderParameters(this._updateVideoSenderEncodings(frameHeight, localVideoTrack));
};
TraceablePeerConnection.prototype._updateVideoSenderParameters = function(promise) {
  const nextPromise = this._lastVideoSenderUpdatePromise.finally(() => promise);
  this._lastVideoSenderUpdatePromise = nextPromise;
  return nextPromise;
};
TraceablePeerConnection.prototype._updateVideoSenderEncodings = function(frameHeight, localVideoTrack) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const videoSender = this.findSenderForTrack(localVideoTrack.getTrack());
  if (!videoSender) {
    return Promise.resolve();
  }
  const parameters = videoSender.getParameters();
  if (!((_a = parameters === null || parameters === void 0 ? void 0 : parameters.encodings) === null || _a === void 0 ? void 0 : _a.length)) {
    return Promise.resolve();
  }
  const isSharingLowFpsScreen = localVideoTrack.getVideoType() === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.DESKTOP && this._capScreenshareBitrate;
  const preference = isSharingLowFpsScreen ? DEGRADATION_PREFERENCE_DESKTOP : DEGRADATION_PREFERENCE_CAMERA;
  parameters.degradationPreference = preference;
  logger.info(`${this} Setting degradation preference [preference=${preference},track=${localVideoTrack}`);
  this.encodingsEnabledState = this.tpcUtils.calculateEncodingsActiveState(localVideoTrack, frameHeight);
  const maxBitrates = this.tpcUtils.calculateEncodingsBitrates(localVideoTrack);
  const videoType = localVideoTrack.getVideoType();
  if (this.isSimulcastOn()) {
    for (const encoding in parameters.encodings) {
      if (parameters.encodings.hasOwnProperty(encoding)) {
        parameters.encodings[encoding].active = this.encodingsEnabledState[encoding];
        _browser__WEBPACK_IMPORTED_MODULE_11__["default"].isFirefox() && (parameters.encodings[encoding].degradationPreference = preference);
        if (this.getConfiguredVideoCodec() === _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_3__["default"].VP8 && (((_c = (_b = this.options) === null || _b === void 0 ? void 0 : _b.videoQuality) === null || _c === void 0 ? void 0 : _c.maxBitratesVideo) || isSharingLowFpsScreen || this._usesUnifiedPlan)) {
          parameters.encodings[encoding].maxBitrate = maxBitrates[encoding];
        }
      }
    }
    this.tpcUtils.updateEncodingsResolution(localVideoTrack, parameters);
  } else if (frameHeight > 0) {
    let scaleFactor = _TPCUtils__WEBPACK_IMPORTED_MODULE_23__.HD_SCALE_FACTOR;
    if (videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.CAMERA && localVideoTrack.resolution > frameHeight) {
      scaleFactor = Math.floor(localVideoTrack.resolution / frameHeight);
    }
    parameters.encodings[0].active = true;
    parameters.encodings[0].scaleResolutionDownBy = scaleFactor;
    _browser__WEBPACK_IMPORTED_MODULE_11__["default"].isFirefox() && (parameters.encodings[0].degradationPreference = preference);
    if (this.getConfiguredVideoCodec() === _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_3__["default"].VP8 && ((_e = (_d = this.options) === null || _d === void 0 ? void 0 : _d.videoQuality) === null || _e === void 0 ? void 0 : _e.maxBitratesVideo)) {
      let bitrate = (_f = this.getTargetVideoBitrates()) === null || _f === void 0 ? void 0 : _f.high;
      if (videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.CAMERA) {
        bitrate = (_h = (_g = this.tpcUtils._getVideoStreamEncodings(localVideoTrack.getVideoType()).find((layer) => layer.scaleResolutionDownBy === scaleFactor)) === null || _g === void 0 ? void 0 : _g.maxBitrate) !== null && _h !== void 0 ? _h : bitrate;
      }
      parameters.encodings[0].maxBitrate = bitrate;
    } else {
      parameters.encodings[0].maxBitrate = void 0;
    }
  } else {
    parameters.encodings[0].active = false;
  }
  logger.info(`${this} setting max height=${frameHeight},encodings=${JSON.stringify(parameters.encodings)}`);
  return videoSender.setParameters(parameters).then(() => {
    localVideoTrack.maxEnabledResolution = frameHeight;
    this.eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, localVideoTrack);
  });
};
TraceablePeerConnection.prototype.setVideoTransferActive = function(active) {
  logger.debug(`${this} video transfer active: ${active}`);
  const changed = this.videoTransferActive !== active;
  this.videoTransferActive = active;
  if (this._usesUnifiedPlan) {
    this.tpcUtils.setVideoTransferActive(active);
    return false;
  }
  return changed;
};
TraceablePeerConnection.prototype.sendTones = function(tones, duration = 200, interToneGap = 200) {
  if (!this._dtmfSender) {
    if (this.peerconnection.getSenders) {
      const rtpSender = this.peerconnection.getSenders().find((s) => s.dtmf);
      this._dtmfSender = rtpSender && rtpSender.dtmf;
      this._dtmfSender && logger.info(`${this} initialized DTMFSender using getSenders`);
    }
    if (!this._dtmfSender) {
      const localAudioTrack = Array.from(this.localTracks.values()).find((t) => t.isAudioTrack());
      if (this.peerconnection.createDTMFSender && localAudioTrack) {
        this._dtmfSender = this.peerconnection.createDTMFSender(localAudioTrack.getTrack());
      }
      this._dtmfSender && logger.info(`${this} initialized DTMFSender using deprecated createDTMFSender`);
    }
    if (this._dtmfSender) {
      this._dtmfSender.ontonechange = this._onToneChange.bind(this);
    }
  }
  if (this._dtmfSender) {
    if (this._dtmfSender.toneBuffer) {
      this._dtmfTonesQueue.push({
        tones,
        duration,
        interToneGap
      });
      return;
    }
    this._dtmfSender.insertDTMF(tones, duration, interToneGap);
  } else {
    logger.warn(`${this} sendTones - failed to select DTMFSender`);
  }
};
TraceablePeerConnection.prototype._onToneChange = function(event) {
  if (this._dtmfSender && event.tone === "" && this._dtmfTonesQueue.length) {
    const { tones, duration, interToneGap } = this._dtmfTonesQueue.shift();
    this._dtmfSender.insertDTMF(tones, duration, interToneGap);
  }
};
TraceablePeerConnection.prototype.generateRecvonlySsrc = function() {
  const newSSRC = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].generateSsrc();
  logger.info(`${this} generated new recvonly SSRC=${newSSRC}`);
  this.sdpConsistency.setPrimarySsrc(newSSRC);
};
TraceablePeerConnection.prototype.clearRecvonlySsrc = function() {
  logger.info(`${this} Clearing primary video SSRC!`);
  this.sdpConsistency.clearVideoSsrcCache();
};
TraceablePeerConnection.prototype.close = function() {
  this.trace("stop");
  this.signalingLayer.off(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_7__.PEER_MUTED_CHANGED, this._peerMutedChanged);
  this.signalingLayer.off(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_7__.PEER_VIDEO_TYPE_CHANGED, this._peerVideoTypeChanged);
  this._usesUnifiedPlan && this.peerconnection.removeEventListener("track", this.onTrack);
  for (const peerTracks of this.remoteTracks.values()) {
    for (const remoteTracks of peerTracks.values()) {
      for (const remoteTrack of remoteTracks) {
        this._removeRemoteTrack(remoteTrack);
      }
    }
  }
  this.remoteTracks.clear();
  this._addedStreams = [];
  this._dtmfSender = null;
  this._dtmfTonesQueue = [];
  if (!this.rtc._removePeerConnection(this)) {
    logger.error(`${this} RTC._removePeerConnection returned false`);
  }
  if (this.statsinterval !== null) {
    window.clearInterval(this.statsinterval);
    this.statsinterval = null;
  }
  logger.info(`${this} Closing peerconnection`);
  this.peerconnection.close();
};
TraceablePeerConnection.prototype.createAnswer = function(constraints) {
  return this._createOfferOrAnswer(false, constraints);
};
TraceablePeerConnection.prototype.createOffer = function(constraints) {
  return this._createOfferOrAnswer(true, constraints);
};
TraceablePeerConnection.prototype._createOfferOrAnswer = function(isOffer, constraints) {
  var _a;
  const logName = isOffer ? "Offer" : "Answer";
  this.trace(`create${logName}`, JSON.stringify(constraints, null, " "));
  const handleSuccess = (resultSdp, resolveFn, rejectFn) => {
    try {
      this.trace(`create${logName}OnSuccess::preTransform`, dumpSDP(resultSdp));
      if (!this._usesUnifiedPlan) {
        if (!this.hasAnyTracksOfType(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO) && !this.sdpConsistency.hasPrimarySsrcCached()) {
          this.generateRecvonlySsrc();
        }
        resultSdp = new RTCSessionDescription({
          type: resultSdp.type,
          sdp: this.sdpConsistency.makeVideoPrimarySsrcsConsistent(resultSdp.sdp)
        });
        this.trace(`create${logName}OnSuccess::postTransform (make primary audio/video ssrcs consistent)`, dumpSDP(resultSdp));
      }
      const localVideoTrack = this.getLocalVideoTracks()[0];
      if (this.isSimulcastOn() && _browser__WEBPACK_IMPORTED_MODULE_11__["default"].usesSdpMungingForSimulcast() && ((localVideoTrack === null || localVideoTrack === void 0 ? void 0 : localVideoTrack.getVideoType()) === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.CAMERA || this._usesUnifiedPlan)) {
        resultSdp = this.simulcast.mungeLocalDescription(resultSdp);
        this.trace(`create${logName} OnSuccess::postTransform (simulcast)`, dumpSDP(resultSdp));
      }
      if (!this.options.disableRtx && _browser__WEBPACK_IMPORTED_MODULE_11__["default"].usesSdpMungingForSimulcast()) {
        resultSdp = new RTCSessionDescription({
          type: resultSdp.type,
          sdp: this.rtxModifier.modifyRtxSsrcs(resultSdp.sdp)
        });
        this.trace(`create${logName}OnSuccess::postTransform (rtx modifier)`, dumpSDP(resultSdp));
      }
      const ssrcMap = this._extractSSRCMap(resultSdp);
      this._processLocalSSRCsMap(ssrcMap);
      resolveFn(resultSdp);
    } catch (e) {
      this.trace(`create${logName}OnError`, e);
      this.trace(`create${logName}OnError`, dumpSDP(resultSdp));
      logger.error(`${this} create${logName}OnError`, e, dumpSDP(resultSdp));
      rejectFn(e);
    }
  };
  const handleFailure = (err, rejectFn) => {
    this.trace(`create${logName}OnFailure`, err);
    const eventType = isOffer ? _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].CREATE_OFFER_FAILED : _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].CREATE_ANSWER_FAILED;
    this.eventEmitter.emit(eventType, err, this);
    rejectFn(err);
  };
  if (this._usesTransceiverCodecPreferences && this.codecSettings) {
    const { codecList, mediaType } = this.codecSettings;
    const transceivers = this.peerconnection.getTransceivers().filter((t) => {
      var _a2, _b;
      return t.receiver && ((_b = (_a2 = t.receiver) === null || _a2 === void 0 ? void 0 : _a2.track) === null || _b === void 0 ? void 0 : _b.kind) === mediaType;
    });
    let capabilities = (_a = RTCRtpReceiver.getCapabilities(mediaType)) === null || _a === void 0 ? void 0 : _a.codecs;
    if (transceivers.length && capabilities) {
      capabilities = capabilities.filter((caps) => codecList.find((codec) => `${mediaType}/${codec}` === caps.mimeType.toLowerCase()));
      for (const codec of codecList.slice().reverse()) {
        capabilities.sort((caps) => {
          return caps.mimeType.toLowerCase() === `${mediaType}/${codec}` ? -1 : 1;
        });
      }
      if (_browser__WEBPACK_IMPORTED_MODULE_11__["default"].isChromiumBased() && mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO) {
        capabilities = capabilities.filter((caps) => caps.mimeType.toLowerCase() !== `${_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO}/${_service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_3__["default"].ULPFEC}`);
      }
      for (const transceiver of transceivers) {
        transceiver.setCodecPreferences(capabilities);
      }
    }
  }
  return new Promise((resolve, reject) => {
    let oaPromise;
    if (isOffer) {
      oaPromise = this.peerconnection.createOffer(constraints);
    } else {
      oaPromise = this.peerconnection.createAnswer(constraints);
    }
    oaPromise.then((sdp) => handleSuccess(sdp, resolve, reject), (error) => handleFailure(error, reject));
  });
};
TraceablePeerConnection.prototype._extractPrimarySSRC = function(ssrcObj) {
  if (ssrcObj && ssrcObj.groups && ssrcObj.groups.length) {
    return ssrcObj.groups[0].ssrcs[0];
  } else if (ssrcObj && ssrcObj.ssrcs && ssrcObj.ssrcs.length) {
    return ssrcObj.ssrcs[0];
  }
  return null;
};
TraceablePeerConnection.prototype._processLocalSSRCsMap = function(ssrcMap) {
  for (const track of this.localTracks.values()) {
    const sourceName = track.getSourceName();
    const sourceIndex = (0,_service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_8__.getSourceIndexFromSourceName)(sourceName);
    const sourceIdentifier = this._usesUnifiedPlan ? `${track.getType()}-${sourceIndex}` : track.storedMSID;
    if (ssrcMap.has(sourceIdentifier)) {
      const newSSRC = ssrcMap.get(sourceIdentifier);
      if (!newSSRC) {
        logger.error(`${this} No SSRC found for stream=${sourceIdentifier}`);
        return;
      }
      const oldSSRC = this.localSSRCs.get(track.rtcId);
      const newSSRCNum = this._extractPrimarySSRC(newSSRC);
      const oldSSRCNum = this._extractPrimarySSRC(oldSSRC);
      if (newSSRCNum !== oldSSRCNum) {
        oldSSRCNum && logger.error(`${this} Overwriting SSRC for track=${track}] with ssrc=${newSSRC}`);
        this.localSSRCs.set(track.rtcId, newSSRC);
        this.eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_6__["default"].LOCAL_TRACK_SSRC_UPDATED, track, newSSRCNum);
      }
    } else if (!track.isVideoTrack() && !track.isMuted()) {
      logger.warn(`${this} No SSRCs found in the local SDP for track=${track}, stream=${sourceIdentifier}`);
    }
  }
};
TraceablePeerConnection.prototype.addRemoteSsrc = function(ssrc) {
  const existing = this.remoteSSRCs.has(ssrc);
  if (!existing) {
    this.remoteSSRCs.add(ssrc);
  }
  return !existing;
};
TraceablePeerConnection.prototype.addIceCandidate = function(candidate) {
  this.trace("addIceCandidate", JSON.stringify({
    candidate: candidate.candidate,
    sdpMid: candidate.sdpMid,
    sdpMLineIndex: candidate.sdpMLineIndex,
    usernameFragment: candidate.usernameFragment
  }, null, " "));
  return this.peerconnection.addIceCandidate(candidate);
};
TraceablePeerConnection.prototype.getActiveSimulcastStreams = function() {
  var _a;
  let activeStreams = 1;
  if (this.isSimulcastOn() && this.encodingsEnabledState) {
    activeStreams = (_a = this.encodingsEnabledState.filter((stream) => Boolean(stream))) === null || _a === void 0 ? void 0 : _a.length;
  } else if (this.isSimulcastOn()) {
    activeStreams = _TPCUtils__WEBPACK_IMPORTED_MODULE_23__.SIM_LAYER_RIDS.length;
  }
  return activeStreams;
};
TraceablePeerConnection.prototype.getStats = function() {
  return this.peerconnection.getStats();
};
TraceablePeerConnection.prototype.generateNewStreamSSRCInfo = function(track) {
  const rtcId = track.rtcId;
  let ssrcInfo = this._getSSRC(rtcId);
  if (ssrcInfo) {
    logger.error(`${this} Overwriting local SSRCs for track id=${rtcId}`);
  }
  if (this.isSimulcastOn() && (track.getVideoType() === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_9__.VideoType.CAMERA || !this.isSharingLowFpsScreen())) {
    ssrcInfo = {
      ssrcs: [],
      groups: []
    };
    for (let i = 0; i < _TPCUtils__WEBPACK_IMPORTED_MODULE_23__.SIM_LAYER_RIDS.length; i++) {
      ssrcInfo.ssrcs.push(_sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].generateSsrc());
    }
    ssrcInfo.groups.push({
      ssrcs: ssrcInfo.ssrcs.slice(),
      semantics: "SIM"
    });
  } else {
    ssrcInfo = {
      ssrcs: [_sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].generateSsrc()],
      groups: []
    };
  }
  if (!this.options.disableRtx) {
    const currNumSsrcs = ssrcInfo.ssrcs.length;
    for (let i = 0; i < currNumSsrcs; ++i) {
      const primarySsrc = ssrcInfo.ssrcs[i];
      const rtxSsrc = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_16__["default"].generateSsrc();
      ssrcInfo.ssrcs.push(rtxSsrc);
      ssrcInfo.groups.push({
        ssrcs: [primarySsrc, rtxSsrc],
        semantics: "FID"
      });
    }
  }
  ssrcInfo.msid = track.storedMSID;
  this.localSSRCs.set(rtcId, ssrcInfo);
  return ssrcInfo;
};
TraceablePeerConnection.prototype.usesUnifiedPlan = function() {
  return this._usesUnifiedPlan;
};
TraceablePeerConnection.prototype.toString = function() {
  return `TPC[id=${this.id},type=${this.isP2P ? "P2P" : "JVB"}]`;
};


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/browser/BrowserCapabilities.js":
/*!****************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/browser/BrowserCapabilities.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BrowserCapabilities)
/* harmony export */ });
/* harmony import */ var _jitsi_js_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/js-utils */ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/index.js");


const MIN_REQUIRED_CHROME_VERSION = 72;
const MIN_REQUIRED_SAFARI_VERSION = 14;
const MIN_REQUIRED_IOS_VERSION = 14;
class BrowserCapabilities extends _jitsi_js_utils__WEBPACK_IMPORTED_MODULE_0__.BrowserDetection {
  doesVideoMuteByStreamRemove() {
    return this.isChromiumBased() || this.isWebKitBased() || this.isFirefox();
  }
  isAndroidBrowser() {
    const { userAgent } = navigator;
    return !this.isReactNative() && userAgent.match(/Android/i);
  }
  isChromiumBased() {
    return (this.isChrome() || this.isElectron() || this.isNWJS() || this.isOpera()) && !this.isWebKitBased();
  }
  isIosBrowser() {
    const { userAgent, maxTouchPoints, platform } = navigator;
    return Boolean(userAgent.match(/iP(ad|hone|od)/i)) || maxTouchPoints && maxTouchPoints > 2 && /MacIntel/.test(platform);
  }
  isMobileDevice() {
    return this.isAndroidBrowser() || this.isIosBrowser() || this.isReactNative();
  }
  isWebKitBased() {
    return this._bowser.isEngine("webkit") && typeof navigator.mediaDevices !== "undefined" && typeof navigator.mediaDevices.getUserMedia !== "undefined" && typeof window.RTCRtpTransceiver !== "undefined" && Object.keys(RTCRtpTransceiver.prototype).indexOf("currentDirection") > -1;
  }
  isTwa() {
    return "matchMedia" in window && window.matchMedia("(display-mode:standalone)").matches;
  }
  isSupported() {
    if (this.isSafari() && this._getSafariVersion() < MIN_REQUIRED_SAFARI_VERSION) {
      return false;
    }
    return this.isChromiumBased() && this._getChromiumBasedVersion() >= MIN_REQUIRED_CHROME_VERSION || this.isFirefox() || this.isReactNative() || this.isWebKitBased();
  }
  isSupportedAndroidBrowser() {
    return this.isChromiumBased() || this.isFirefox();
  }
  isSupportedIOSBrowser() {
    return this._getIOSVersion() >= MIN_REQUIRED_IOS_VERSION;
  }
  isUserInteractionRequiredForUnmute() {
    return this.isFirefox() && this.isVersionLessThan("68");
  }
  supportsVideoMuteOnConnInterrupted() {
    return this.isChromiumBased() || this.isReactNative();
  }
  supportsBandwidthStatistics() {
    return !this.isFirefox() && !this.isWebKitBased();
  }
  supportsCodecPreferences() {
    return Boolean(window.RTCRtpTransceiver && "setCodecPreferences" in window.RTCRtpTransceiver.prototype && window.RTCRtpReceiver && typeof window.RTCRtpReceiver.getCapabilities !== "undefined") && !this.isWebKitBased();
  }
  supportsDeviceChangeEvent() {
    return navigator.mediaDevices && typeof navigator.mediaDevices.ondevicechange !== "undefined" && typeof navigator.mediaDevices.addEventListener !== "undefined";
  }
  supportsPerformanceObserver() {
    return typeof window.PerformanceObserver !== "undefined" && PerformanceObserver.supportedEntryTypes.indexOf("longtask") > -1;
  }
  supportsReceiverStats() {
    return typeof window.RTCRtpReceiver !== "undefined" && Object.keys(RTCRtpReceiver.prototype).indexOf("getSynchronizationSources") > -1;
  }
  supportsRTTStatistics() {
    return !this.isFirefox();
  }
  supportsTrackBasedStats() {
    return this.isChromiumBased() && this.isVersionLessThan(112);
  }
  supportsVP9() {
    return this.isChromiumBased() || this.isReactNative();
  }
  usesSdpMungingForSimulcast() {
    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
  }
  usesRidsForSimulcast() {
    return false;
  }
  supportsGetDisplayMedia() {
    return typeof navigator.getDisplayMedia !== "undefined" || typeof navigator.mediaDevices !== "undefined" && typeof navigator.mediaDevices.getDisplayMedia !== "undefined";
  }
  supportsEncodedTransform() {
    return Boolean(window.RTCRtpScriptTransform);
  }
  supportsInsertableStreams() {
    if (!(typeof window.RTCRtpSender !== "undefined" && window.RTCRtpSender.prototype.createEncodedStreams)) {
      return false;
    }
    const stream = new ReadableStream();
    try {
      window.postMessage(stream, "*", [stream]);
      return true;
    } catch (_a) {
      return false;
    }
  }
  supportsAudioRed() {
    return Boolean(window.RTCRtpSender && window.RTCRtpSender.getCapabilities && window.RTCRtpSender.getCapabilities("audio").codecs.some((codec) => codec.mimeType === "audio/red") && window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("audio").codecs.some((codec) => codec.mimeType === "audio/red"));
  }
  supportsUnifiedPlan() {
    return !(this.isElectron() && this._getChromiumBasedVersion() < 96);
  }
  supportsVADDetection() {
    return this.isChromiumBased();
  }
  supportsRTX() {
    return !(this.isFirefox() && this.isVersionLessThan("96"));
  }
  _getChromiumBasedVersion() {
    if (this.isChromiumBased()) {
      if (this.isNWJS()) {
        return Number.parseInt(process.versions.chromium, 10);
      }
      const ua = navigator.userAgent;
      if (ua.match(/Chrome/)) {
        const version = Number.parseInt(ua.match(/Chrome\/([\d.]+)/)[1], 10);
        return version;
      }
    }
    return -1;
  }
  _getSafariVersion() {
    if (this.isSafari()) {
      return Number.parseInt(this.getVersion(), 10);
    }
    return -1;
  }
  _getIOSVersion() {
    if (this.isWebKitBased()) {
      return Number.parseInt(this.getVersion(), 10);
    }
    return -1;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/browser/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _BrowserCapabilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BrowserCapabilities */ "../../lib-jitsi-meet/dist/esm/modules/browser/BrowserCapabilities.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new _BrowserCapabilities__WEBPACK_IMPORTED_MODULE_0__["default"]());


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/connectivity/ConnectionQuality.js":
/*!*******************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/connectivity/ConnectionQuality.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ConnectionQuality)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/CodecMimeType */ "../../lib-jitsi-meet/dist/esm/service/RTC/CodecMimeType.js");
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/connectivity/ConnectionQualityEvents */ "../../lib-jitsi-meet/dist/esm/service/connectivity/ConnectionQualityEvents.js");






const Resolutions = __webpack_require__(/*! ../../service/RTC/Resolutions */ "../../lib-jitsi-meet/dist/esm/service/RTC/Resolutions.js");
const { VideoType } = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
const { XMPPEvents } = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const STATS_MESSAGE_TYPE = "stats";
const kSimulcastFormats = [
  {
    width: 1920,
    height: 1080,
    layers: 3,
    target: "high"
  },
  {
    width: 1280,
    height: 720,
    layers: 3,
    target: "high"
  },
  {
    width: 960,
    height: 540,
    layers: 3,
    target: "standard"
  },
  {
    width: 640,
    height: 360,
    layers: 2,
    target: "standard"
  },
  {
    width: 480,
    height: 270,
    layers: 2,
    target: "low"
  },
  {
    width: 320,
    height: 180,
    layers: 1,
    target: "low"
  }
];
const MAX_TARGET_BITRATE = 2500;
let startBitrate = 800;
function getTarget(simulcast, resolution, millisSinceStart, videoQualitySettings) {
  let target = 0;
  let height = Math.min(resolution.height, resolution.width);
  let simulcastFormat = kSimulcastFormats.find((f) => f.height <= height);
  if (simulcastFormat && simulcast && videoQualitySettings.codec === _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_2__["default"].VP8) {
    for (height = simulcastFormat.height; height >= 180; height /= 2) {
      const targetHeight = height;
      simulcastFormat = kSimulcastFormats.find((f) => f.height === targetHeight);
      if (simulcastFormat) {
        target += videoQualitySettings[simulcastFormat.target];
      } else {
        break;
      }
    }
  } else if (simulcastFormat) {
    target = videoQualitySettings[simulcastFormat.target];
  }
  return Math.min(target / 1e3, rampUp(Math.max(0, millisSinceStart - 1e3)));
}
function rampUp(millisSinceStart) {
  if (millisSinceStart > 6e4) {
    return Number.MAX_SAFE_INTEGER;
  }
  return startBitrate * Math.pow(1.08, millisSinceStart / 1e3);
}
class ConnectionQuality {
  constructor(conference, eventEmitter, options) {
    var _a;
    this.eventEmitter = eventEmitter;
    this._conference = conference;
    this._localStats = {
      connectionQuality: 100,
      jvbRTT: void 0
    };
    this._lastConnectionQualityUpdate = -1;
    this._options = options;
    this._remoteStats = {};
    this._timeIceConnected = -1;
    this._timeVideoUnmuted = -1;
    if (((_a = this._options.config) === null || _a === void 0 ? void 0 : _a.startBitrate) > 0) {
      startBitrate = this._options.config.startBitrate;
    }
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_INTERRUPTED, () => {
      this._updateLocalConnectionQuality(0);
      this.eventEmitter.emit(_service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_4__.LOCAL_STATS_UPDATED, this._localStats);
      this._broadcastLocalStats();
    });
    conference.room.addListener(XMPPEvents.ICE_CONNECTION_STATE_CHANGED, (jingleSession, newState) => {
      if (!jingleSession.isP2P && newState === "connected") {
        this._timeIceConnected = window.performance.now();
      }
    });
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.ENDPOINT_MESSAGE_RECEIVED, (participant, payload) => {
      if (payload.type === STATS_MESSAGE_TYPE) {
        this._updateRemoteStats(participant.getId(), payload.values);
      }
    });
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.ENDPOINT_STATS_RECEIVED, (participant, payload) => {
      this._updateRemoteStats(participant.getId(), payload);
    });
    if (!this._options.config.disableLocalStats) {
      conference.statistics.addConnectionStatsListener(this._updateLocalStats.bind(this));
    }
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.TRACK_MUTE_CHANGED, (track) => {
      if (track.isVideoTrack()) {
        if (track.isMuted()) {
          this._timeVideoUnmuted = -1;
        } else {
          this._maybeUpdateUnmuteTime();
        }
      }
    });
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.TRACK_ADDED, (track) => {
      if (track.isVideoTrack() && !track.isMuted()) {
        this._maybeUpdateUnmuteTime();
      }
    });
    conference.rtc.on(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, (track) => {
      this._localStats.maxEnabledResolution = track.maxEnabledResolution;
    });
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.SERVER_REGION_CHANGED, (serverRegion) => {
      this._localStats.serverRegion = serverRegion;
    });
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.PROPERTIES_CHANGED, (properties) => {
      this._localStats.bridgeCount = Number((properties || {})["bridge-count"]);
    });
  }
  _maybeUpdateUnmuteTime() {
    if (this._timeVideoUnmuted < 0) {
      this._timeVideoUnmuted = window.performance.now();
    }
  }
  _calculateConnectionQuality(videoType, isMuted, resolutionName) {
    var _a, _b;
    const resolution = Resolutions[resolutionName];
    let quality = 100;
    let packetLoss;
    if (this._localStats.packetLoss) {
      packetLoss = this._localStats.packetLoss.upload;
      if (isMuted) {
        packetLoss *= 0.5;
      }
    }
    if (isMuted || !resolution || videoType === VideoType.DESKTOP || this._timeIceConnected < 0 || this._timeVideoUnmuted < 0) {
      if (packetLoss === void 0) {
        logger.error("Cannot calculate connection quality, unknown packet loss.");
        quality = 100;
      } else if (packetLoss <= 2) {
        quality = 100;
      } else if (packetLoss <= 4) {
        quality = 70;
      } else if (packetLoss <= 6) {
        quality = 50;
      } else if (packetLoss <= 8) {
        quality = 30;
      } else if (packetLoss <= 12) {
        quality = 10;
      } else {
        quality = 0;
      }
    } else {
      const activeTPC = this._conference.getActivePeerConnection();
      if (activeTPC) {
        const isSimulcastOn = activeTPC.isSimulcastOn();
        const videoQualitySettings = activeTPC.getTargetVideoBitrates();
        videoQualitySettings.codec = activeTPC.getConfiguredVideoCodec();
        const millisSinceStart = window.performance.now() - Math.max(this._timeVideoUnmuted, this._timeIceConnected);
        const statsInterval = (_b = (_a = this._options.config) === null || _a === void 0 ? void 0 : _a.pcStatsInterval) !== null && _b !== void 0 ? _b : 1e4;
        let target = getTarget(isSimulcastOn, resolution, millisSinceStart, videoQualitySettings);
        target = Math.min(target, MAX_TARGET_BITRATE);
        if (millisSinceStart > statsInterval) {
          quality = 100 * this._localStats.bitrate.upload / target;
        }
      }
      if (packetLoss && packetLoss >= 10) {
        quality = Math.min(quality, 30);
      }
    }
    if (this._lastConnectionQualityUpdate > 0) {
      const maxIncreasePerSecond = 2;
      const prevConnectionQuality = this._localStats.connectionQuality;
      const diffSeconds = (window.performance.now() - this._lastConnectionQualityUpdate) / 1e3;
      quality = Math.min(quality, prevConnectionQuality + diffSeconds * maxIncreasePerSecond);
    }
    return Math.min(100, quality);
  }
  _updateLocalConnectionQuality(value) {
    this._localStats.connectionQuality = value;
    this._lastConnectionQualityUpdate = window.performance.now();
  }
  _broadcastLocalStats() {
    const data = {
      bitrate: this._localStats.bitrate,
      packetLoss: this._localStats.packetLoss,
      connectionQuality: this._localStats.connectionQuality,
      jvbRTT: this._localStats.jvbRTT,
      serverRegion: this._localStats.serverRegion,
      maxEnabledResolution: this._localStats.maxEnabledResolution,
      avgAudioLevels: this._localStats.localAvgAudioLevels
    };
    try {
      this._conference.sendEndpointStatsMessage(data);
    } catch (err) {
    }
  }
  _updateLocalStats(tpc, data) {
    if (!tpc.isP2P) {
      const jvbRTT = data.transport && data.transport.length && data.transport[0].rtt;
      this._localStats.jvbRTT = jvbRTT ? jvbRTT : void 0;
    }
    if (tpc !== this._conference.getActivePeerConnection()) {
      return;
    }
    let key;
    const updateLocalConnectionQuality = !this._conference.isConnectionInterrupted();
    const localVideoTrack = this._conference.getLocalVideoTrack();
    const videoType = localVideoTrack ? localVideoTrack.videoType : void 0;
    const isMuted = localVideoTrack ? localVideoTrack.isMuted() : true;
    const resolution = localVideoTrack ? Math.min(localVideoTrack.resolution, localVideoTrack.maxEnabledResolution) : null;
    if (!isMuted) {
      this._maybeUpdateUnmuteTime();
    }
    for (key in data) {
      if (data.hasOwnProperty(key)) {
        this._localStats[key] = data[key];
      }
    }
    if (updateLocalConnectionQuality) {
      this._updateLocalConnectionQuality(this._calculateConnectionQuality(videoType, isMuted, resolution));
    }
    this.eventEmitter.emit(_service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_4__.LOCAL_STATS_UPDATED, this._localStats);
    this._broadcastLocalStats();
  }
  _updateRemoteStats(id, data) {
    this._remoteStats[id] = {
      bitrate: data.bitrate,
      packetLoss: data.packetLoss,
      connectionQuality: data.connectionQuality,
      jvbRTT: data.jvbRTT,
      serverRegion: data.serverRegion,
      maxEnabledResolution: data.maxEnabledResolution,
      avgAudioLevels: data.avgAudioLevels
    };
    this.eventEmitter.emit(_service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_4__.REMOTE_STATS_UPDATED, id, this._remoteStats[id]);
  }
  getStats() {
    return this._localStats;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/connectivity/IceFailedHandling.js":
/*!*******************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/connectivity/IceFailedHandling.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IceFailedHandling)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceErrors */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceErrors.js");
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");




const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class IceFailedHandling {
  constructor(conference) {
    this._conference = conference;
  }
  _actOnIceFailed() {
    if (!this._conference.room) {
      return;
    }
    const { enableForcedReload, enableIceRestart } = this._conference.options.config;
    const explicitlyDisabled = typeof enableIceRestart !== "undefined" && !enableIceRestart;
    const supportsRestartByTerminate = this._conference.room.supportsRestartByTerminate();
    const useTerminateForRestart = supportsRestartByTerminate && !enableIceRestart;
    logger.info(`ICE failed, enableForcedReload: ${enableForcedReload}, enableIceRestart: ${enableIceRestart}, supports restart by terminate: ${supportsRestartByTerminate}`);
    if (explicitlyDisabled || !enableIceRestart && !supportsRestartByTerminate || enableForcedReload) {
      logger.info("ICE failed, but ICE restarts are disabled");
      const reason = enableForcedReload ? _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_1__.CONFERENCE_RESTARTED : _JitsiConferenceErrors__WEBPACK_IMPORTED_MODULE_1__.ICE_FAILED;
      this._conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.CONFERENCE_FAILED, reason);
      return;
    }
    const jvbConnection = this._conference.jvbJingleSession;
    const jvbConnIceState = jvbConnection && jvbConnection.getIceConnectionState();
    if (!jvbConnection) {
      logger.warn("Not sending ICE failed - no JVB connection");
    } else if (jvbConnIceState === "connected") {
      logger.info("ICE connection restored - not sending ICE failed");
    } else {
      logger.info(`Sending ICE failed - the connection did not recover, ICE state: ${jvbConnIceState}, use 'session-terminate': ${useTerminateForRestart}`);
      if (useTerminateForRestart) {
        this._conference.jvbJingleSession.terminate(() => {
          logger.info("session-terminate for ice restart - done");
        }, (error) => {
          logger.error(`session-terminate for ice restart - error: ${error.message}`);
        }, {
          reason: "connectivity-error",
          reasonDescription: "ICE FAILED",
          requestRestart: true,
          sendSessionTerminate: true
        });
      } else {
        this._conference.jvbJingleSession.sendIceFailedNotification();
      }
    }
  }
  start() {
    this._conference.xmpp.ping(65e3).then(() => {
      if (!this._canceled) {
        this._iceFailedTimeout = window.setTimeout(() => {
          this._iceFailedTimeout = void 0;
          this._actOnIceFailed();
        }, 2e3);
      }
    }, (error) => {
      logger.error("PING error/timeout - not sending ICE failed", error);
    });
  }
  cancel() {
    this._canceled = true;
    window.clearTimeout(this._iceFailedTimeout);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/connectivity/NetworkInfo.js":
/*!*************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/connectivity/NetworkInfo.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NETWORK_INFO_EVENT: () => (/* binding */ NETWORK_INFO_EVENT),
/* harmony export */   NetworkInfo: () => (/* binding */ NetworkInfo),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");



const NETWORK_INFO_EVENT = "NETWORK_INFO_CHANGED";
const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class NetworkInfo extends _util_Listenable__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();
    this._current = {
      isOnline: true
    };
  }
  updateNetworkInfo({ isOnline }) {
    logger.debug("updateNetworkInfo", { isOnline });
    this._current = {
      isOnline: isOnline === true
    };
    this.eventEmitter.emit(NETWORK_INFO_EVENT, this._current);
  }
  isOnline() {
    return this._current.isOnline === true;
  }
}
const networkInfo = new NetworkInfo();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (networkInfo);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/connectivity/TrackStreamingStatus.js":
/*!**********************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/connectivity/TrackStreamingStatus.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TrackStreamingStatus: () => (/* binding */ TrackStreamingStatus),
/* harmony export */   TrackStreamingStatusImpl: () => (/* binding */ TrackStreamingStatusImpl),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../JitsiTrackEvents */ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js");
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _statistics_statistics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");








var TrackStreamingStatus;
(function(TrackStreamingStatus2) {
  TrackStreamingStatus2["ACTIVE"] = "active";
  TrackStreamingStatus2["INACTIVE"] = "inactive";
  TrackStreamingStatus2["INTERRUPTED"] = "interrupted";
  TrackStreamingStatus2["RESTORING"] = "restoring";
})(TrackStreamingStatus || (TrackStreamingStatus = {}));
const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const DEFAULT_NOT_IN_FORWARDED_SOURCES_TIMEOUT = 500;
const DEFAULT_P2P_RTC_MUTE_TIMEOUT = 2500;
const DEFAULT_RTC_MUTE_TIMEOUT = 1e4;
const DEFAULT_RESTORING_TIMEOUT = 1e4;
class TrackStreamingStatusImpl {
  constructor(rtc, conference, track, options) {
    this.rtc = rtc;
    this.conference = conference;
    this.track = track;
    this.restoringTimer = null;
    this.rtcMutedTimestamp = null;
    this.streamingStatusMap = {};
    this.trackTimer = null;
    this.outOfForwardedSourcesTimeout = typeof options.outOfForwardedSourcesTimeout === "number" ? options.outOfForwardedSourcesTimeout : DEFAULT_NOT_IN_FORWARDED_SOURCES_TIMEOUT;
    this.p2pRtcMuteTimeout = typeof options.p2pRtcMuteTimeout === "number" ? options.p2pRtcMuteTimeout : DEFAULT_P2P_RTC_MUTE_TIMEOUT;
    this.rtcMuteTimeout = typeof options.rtcMuteTimeout === "number" ? options.rtcMuteTimeout : DEFAULT_RTC_MUTE_TIMEOUT;
    logger.info(`RtcMuteTimeout set to: ${this.rtcMuteTimeout}`);
  }
  static _getNewStateForJvbMode(isInForwardedSources, isRestoringTimedout, isVideoMuted, isVideoTrackFrozen) {
    if (isVideoMuted) {
      return TrackStreamingStatus.ACTIVE;
    }
    if (_browser__WEBPACK_IMPORTED_MODULE_5__["default"].supportsVideoMuteOnConnInterrupted()) {
      if (!isVideoTrackFrozen) {
        return TrackStreamingStatus.ACTIVE;
      } else if (isInForwardedSources) {
        return isRestoringTimedout ? TrackStreamingStatus.INTERRUPTED : TrackStreamingStatus.RESTORING;
      }
      return TrackStreamingStatus.INACTIVE;
    }
    return isInForwardedSources ? TrackStreamingStatus.ACTIVE : TrackStreamingStatus.INACTIVE;
  }
  static _getNewStateForP2PMode(isVideoMuted, isVideoTrackFrozen) {
    if (!_browser__WEBPACK_IMPORTED_MODULE_5__["default"].supportsVideoMuteOnConnInterrupted()) {
      return TrackStreamingStatus.ACTIVE;
    }
    return isVideoMuted || !isVideoTrackFrozen ? TrackStreamingStatus.ACTIVE : TrackStreamingStatus.INTERRUPTED;
  }
  _getVideoFrozenTimeout() {
    const sourceName = this.track.getSourceName();
    return this.rtc.isInForwardedSources(sourceName) ? this.rtcMuteTimeout : this.conference.isP2PActive() ? this.p2pRtcMuteTimeout : this.outOfForwardedSourcesTimeout;
  }
  init() {
    this._onP2PStatus = this.figureOutStreamingStatus.bind(this);
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.JitsiConferenceEvents.P2P_STATUS, this._onP2PStatus);
    this._onUserLeft = this.onUserLeft.bind(this);
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.JitsiConferenceEvents.USER_LEFT, this._onUserLeft);
    if (_browser__WEBPACK_IMPORTED_MODULE_5__["default"].supportsVideoMuteOnConnInterrupted()) {
      this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this);
      this.rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].REMOTE_TRACK_MUTE, this._onTrackRtcMuted);
      this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this);
      this.rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted);
      this._onSignallingMuteChanged = this.onSignallingMuteChanged.bind(this);
      this.track.on(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__.TRACK_MUTE_CHANGED, this._onSignallingMuteChanged);
      this._onTrackVideoTypeChanged = this.onTrackVideoTypeChanged.bind(this);
      this.track.on(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__.TRACK_VIDEOTYPE_CHANGED, this._onTrackVideoTypeChanged);
    }
    this._onForwardedSourcesChanged = this.onForwardedSourcesChanged.bind(this);
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.JitsiConferenceEvents.FORWARDED_SOURCES_CHANGED, this._onForwardedSourcesChanged);
    this._onLastNValueChanged = this.figureOutStreamingStatus.bind(this);
    this.rtc.on(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].LASTN_VALUE_CHANGED, this._onLastNValueChanged);
  }
  dispose() {
    if (_browser__WEBPACK_IMPORTED_MODULE_5__["default"].supportsVideoMuteOnConnInterrupted()) {
      this.rtc.removeListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].REMOTE_TRACK_MUTE, this._onTrackRtcMuted);
      this.rtc.removeListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted);
      this.track.off(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__.TRACK_MUTE_CHANGED, this._onSignallingMuteChanged);
      this.track.off(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__.TRACK_VIDEOTYPE_CHANGED, this._onTrackVideoTypeChanged);
    }
    this.conference.off(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.JitsiConferenceEvents.FORWARDED_SOURCES_CHANGED, this._onForwardedSourcesChanged);
    this.conference.off(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.JitsiConferenceEvents.P2P_STATUS, this._onP2PStatus);
    this.conference.off(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.JitsiConferenceEvents.USER_LEFT, this._onUserLeft);
    this.rtc.removeListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_3__["default"].LASTN_VALUE_CHANGED, this._onLastNValueChanged);
    this.clearTimeout();
    this.clearRtcMutedTimestamp();
    this.maybeSendTrackStreamingStatusEvent(Date.now());
    this.figureOutStreamingStatus();
  }
  _changeStreamingStatus(newStatus) {
    if (this.track.getTrackStreamingStatus() !== newStatus) {
      const sourceName = this.track.getSourceName();
      this.track._setTrackStreamingStatus(newStatus);
      logger.debug(`Emit track streaming status(${Date.now()}) ${sourceName}: ${newStatus}`);
      _statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendLog(JSON.stringify({
        id: "track.streaming.status",
        track: sourceName,
        status: newStatus
      }));
      this.track.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__.TRACK_STREAMING_STATUS_CHANGED, this.track, newStatus);
    }
  }
  clearTimeout() {
    if (this.trackTimer) {
      window.clearTimeout(this.trackTimer);
      this.trackTimer = null;
    }
  }
  clearRtcMutedTimestamp() {
    this.rtcMutedTimestamp = null;
  }
  isVideoTrackFrozen() {
    if (!_browser__WEBPACK_IMPORTED_MODULE_5__["default"].supportsVideoMuteOnConnInterrupted()) {
      return false;
    }
    const isVideoRTCMuted = this.track.isWebRTCTrackMuted();
    const rtcMutedTimestamp = this.rtcMutedTimestamp;
    const timeout = this._getVideoFrozenTimeout();
    return isVideoRTCMuted && typeof rtcMutedTimestamp === "number" && Date.now() - rtcMutedTimestamp >= timeout;
  }
  figureOutStreamingStatus() {
    const sourceName = this.track.getSourceName();
    const inP2PMode = this.conference.isP2PActive();
    const isRestoringTimedOut = this._isRestoringTimedout();
    const audioOnlyMode = this.conference.getLastN() === 0;
    const isVideoMuted = this.track.isMuted() || audioOnlyMode;
    const isVideoTrackFrozen = this.isVideoTrackFrozen();
    const isInForwardedSources = this.rtc.isInForwardedSources(sourceName);
    const newState = inP2PMode ? TrackStreamingStatusImpl._getNewStateForP2PMode(isVideoMuted, isVideoTrackFrozen) : TrackStreamingStatusImpl._getNewStateForJvbMode(isInForwardedSources, isRestoringTimedOut, isVideoMuted, isVideoTrackFrozen);
    if (newState !== TrackStreamingStatus.RESTORING) {
      this._clearRestoringTimer();
    }
    logger.debug(`Figure out conn status for ${sourceName}, is video muted: ${isVideoMuted} video track frozen: ${isVideoTrackFrozen} p2p mode: ${inP2PMode} is in forwarded sources: ${isInForwardedSources} currentStatus => newStatus: ${this.track.getTrackStreamingStatus()} => ${newState}`);
    const oldStreamingStatus = this.streamingStatusMap || {};
    if (!("p2p" in oldStreamingStatus) || !("streamingStatus" in oldStreamingStatus) || oldStreamingStatus.p2p !== inP2PMode || oldStreamingStatus.streamingStatus !== newState) {
      const nowMs = Date.now();
      this.maybeSendTrackStreamingStatusEvent(nowMs);
      this.streamingStatusMap = Object.assign(Object.assign({}, oldStreamingStatus), { streamingStatus: newState, p2p: inP2PMode, startedMs: nowMs });
      if (!("videoType" in this.streamingStatusMap)) {
        this.streamingStatusMap.videoType = this.track.getVideoType();
      }
    }
    this._changeStreamingStatus(newState);
  }
  maybeSendTrackStreamingStatusEvent(nowMs) {
    const trackStreamingStatus = this.streamingStatusMap;
    if (trackStreamingStatus && "startedMs" in trackStreamingStatus && "videoType" in trackStreamingStatus && "streamingStatus" in trackStreamingStatus && "p2p" in trackStreamingStatus) {
      trackStreamingStatus.value = nowMs - trackStreamingStatus.startedMs;
      _statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__.createTrackStreamingStatusEvent)(trackStreamingStatus));
    }
  }
  onForwardedSourcesChanged(leavingForwardedSources = [], enteringForwardedSources = [], timestamp) {
    const sourceName = this.track.getSourceName();
    if (!_browser__WEBPACK_IMPORTED_MODULE_5__["default"].supportsVideoMuteOnConnInterrupted()) {
      this.figureOutStreamingStatus();
    }
    if (leavingForwardedSources.includes(sourceName)) {
      this.track._clearEnteredForwardedSourcesTimestamp();
      this._clearRestoringTimer();
      _browser__WEBPACK_IMPORTED_MODULE_5__["default"].supportsVideoMuteOnConnInterrupted() && this.figureOutStreamingStatus();
    }
    if (enteringForwardedSources.includes(sourceName)) {
      this.track._setEnteredForwardedSourcesTimestamp(timestamp);
      _browser__WEBPACK_IMPORTED_MODULE_5__["default"].supportsVideoMuteOnConnInterrupted() && this.figureOutStreamingStatus();
    }
  }
  _clearRestoringTimer() {
    const rTimer = this.restoringTimer;
    if (rTimer) {
      clearTimeout(rTimer);
      this.restoringTimer = null;
    }
  }
  _isRestoringTimedout() {
    const enteredForwardedSourcesTimestamp = this.track._getEnteredForwardedSourcesTimestamp();
    if (enteredForwardedSourcesTimestamp && Date.now() - enteredForwardedSourcesTimestamp >= DEFAULT_RESTORING_TIMEOUT) {
      return true;
    }
    const rTimer = this.restoringTimer;
    if (!rTimer) {
      this.restoringTimer = setTimeout(() => this.figureOutStreamingStatus(), DEFAULT_RESTORING_TIMEOUT);
    }
    return false;
  }
  _isCurrentTrack(track) {
    return track.getSourceName() === this.track.getSourceName();
  }
  onUserLeft(id) {
    if (this.track.getParticipantId() === id) {
      this.maybeSendTrackStreamingStatusEvent(Date.now());
      this.streamingStatusMap = {};
    }
  }
  onTrackRtcMuted(track) {
    if (!this._isCurrentTrack(track)) {
      return;
    }
    const sourceName = track.getSourceName();
    logger.debug(`Detector track RTC muted: ${sourceName}`, Date.now());
    this.rtcMutedTimestamp = Date.now();
    if (!track.isMuted()) {
      this.clearTimeout();
      const timeout = this._getVideoFrozenTimeout();
      this.trackTimer = window.setTimeout(() => {
        logger.debug(`Set track RTC muted for: ${sourceName} after the timeout of ${timeout} ms`);
        this.clearTimeout();
        this.figureOutStreamingStatus();
      }, timeout);
    }
  }
  onTrackRtcUnmuted(track) {
    if (!this._isCurrentTrack(track)) {
      return;
    }
    const sourceName = this.track.getSourceName();
    logger.debug(`Detector track RTC unmuted: ${sourceName}`, Date.now());
    this.clearTimeout();
    this.clearRtcMutedTimestamp();
    this.figureOutStreamingStatus();
  }
  onSignallingMuteChanged(track) {
    if (!this._isCurrentTrack(track)) {
      return;
    }
    const sourceName = this.track.getSourceName();
    logger.debug(`Detector on track signalling mute changed: ${sourceName}`, track.isMuted());
    this.figureOutStreamingStatus();
  }
  onTrackVideoTypeChanged(type) {
    const nowMs = Date.now();
    this.maybeSendTrackStreamingStatusEvent(nowMs);
    this.streamingStatusMap = Object.assign(Object.assign({}, this.streamingStatusMap || {}), { videoType: type, startedMs: nowMs });
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TrackStreamingStatusImpl);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/detection/ActiveDeviceDetector.js":
/*!*******************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/detection/ActiveDeviceDetector.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getActiveAudioDevice)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiTrackEvents */ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js");
/* harmony import */ var _RTC_RTC__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../RTC/RTC */ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTC.js");
/* harmony import */ var _statistics_statistics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");





const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const DETECTION_TIMEOUT = 3e3;
function getActiveAudioDevice() {
  return new Promise((resolve) => {
    _RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].enumerateDevices((devices) => {
      const audioDevices = devices.filter((device) => device.kind === "audioinput");
      const devicePromiseArray = [];
      for (const micDevice of audioDevices) {
        const devicePromise = _RTC_RTC__WEBPACK_IMPORTED_MODULE_2__["default"].obtainAudioAndVideoPermissions({
          devices: ["audio"],
          micDeviceId: micDevice.deviceId
        }).then((tracks) => {
          const track = tracks[0];
          _statistics_statistics__WEBPACK_IMPORTED_MODULE_3__["default"].startLocalStats(track, track.setAudioLevel.bind(track));
          return track;
        });
        devicePromiseArray.push(devicePromise);
      }
      Promise.allSettled(devicePromiseArray).then((outcomeArray) => {
        const successfulPromises = outcomeArray.filter((p) => p.status === "fulfilled");
        const rejectedPromises = outcomeArray.filter((p) => p.status === "rejected");
        const availableDevices = successfulPromises.map((p) => p.value);
        const rejectReasons = rejectedPromises.map((p) => p.value);
        for (const reason of rejectReasons) {
          logger.error("Failed to acquire audio device with error: ", reason);
        }
        for (const device of availableDevices) {
          device.on(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_1__.TRACK_AUDIO_LEVEL_CHANGED, (audioLevel) => {
            if (audioLevel > 8e-3) {
              stopActiveDevices(availableDevices);
              resolve({
                deviceId: device.deviceId,
                deviceLabel: device.track.label
              });
            }
          });
        }
        setTimeout(() => {
          stopActiveDevices(availableDevices);
          resolve({
            deviceId: "",
            deviceLabel: ""
          });
        }, DETECTION_TIMEOUT);
      });
    });
  });
}
function stopActiveDevices(deviceList) {
  for (const device of deviceList) {
    device.stopStream();
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/detection/DetectionEvents.js":
/*!**************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/detection/DetectionEvents.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AUDIO_INPUT_STATE_CHANGE: () => (/* binding */ AUDIO_INPUT_STATE_CHANGE),
/* harmony export */   DETECTOR_STATE_CHANGE: () => (/* binding */ DETECTOR_STATE_CHANGE),
/* harmony export */   DetectionEvents: () => (/* binding */ DetectionEvents),
/* harmony export */   NO_AUDIO_INPUT: () => (/* binding */ NO_AUDIO_INPUT),
/* harmony export */   VAD_NOISY_DEVICE: () => (/* binding */ VAD_NOISY_DEVICE),
/* harmony export */   VAD_REPORT_PUBLISHED: () => (/* binding */ VAD_REPORT_PUBLISHED),
/* harmony export */   VAD_SCORE_PUBLISHED: () => (/* binding */ VAD_SCORE_PUBLISHED),
/* harmony export */   VAD_TALK_WHILE_MUTED: () => (/* binding */ VAD_TALK_WHILE_MUTED)
/* harmony export */ });

var DetectionEvents;
(function(DetectionEvents2) {
  DetectionEvents2["DETECTOR_STATE_CHANGE"] = "detector_state_change";
  DetectionEvents2["AUDIO_INPUT_STATE_CHANGE"] = "audio_input_state_changed";
  DetectionEvents2["NO_AUDIO_INPUT"] = "no_audio_input_detected";
  DetectionEvents2["VAD_NOISY_DEVICE"] = "detection.vad_noise_device";
  DetectionEvents2["VAD_REPORT_PUBLISHED"] = "vad-report-published";
  DetectionEvents2["VAD_SCORE_PUBLISHED"] = "detection.vad_score_published";
  DetectionEvents2["VAD_TALK_WHILE_MUTED"] = "detection.vad_talk_while_muted";
})(DetectionEvents || (DetectionEvents = {}));
;
const DETECTOR_STATE_CHANGE = DetectionEvents.DETECTOR_STATE_CHANGE;
const AUDIO_INPUT_STATE_CHANGE = DetectionEvents.AUDIO_INPUT_STATE_CHANGE;
const NO_AUDIO_INPUT = DetectionEvents.NO_AUDIO_INPUT;
const VAD_NOISY_DEVICE = DetectionEvents.VAD_NOISY_DEVICE;
const VAD_REPORT_PUBLISHED = DetectionEvents.VAD_REPORT_PUBLISHED;
const VAD_SCORE_PUBLISHED = DetectionEvents.VAD_SCORE_PUBLISHED;
const VAD_TALK_WHILE_MUTED = DetectionEvents.VAD_TALK_WHILE_MUTED;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/detection/NoAudioSignalDetection.js":
/*!*********************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/detection/NoAudioSignalDetection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NoAudioSignalDetection)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../JitsiTrackEvents */ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js");
/* harmony import */ var _DetectionEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DetectionEvents */ "../../lib-jitsi-meet/dist/esm/modules/detection/DetectionEvents.js");





const SILENCE_PERIOD_MS = 4e3;
class NoAudioSignalDetection extends (events__WEBPACK_IMPORTED_MODULE_0___default()) {
  constructor(conference) {
    super();
    this._conference = conference;
    this._timeoutTrigger = null;
    this._hasAudioInput = null;
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.TRACK_ADDED, this._trackAdded.bind(this));
  }
  _clearTriggerTimeout() {
    clearTimeout(this._timeoutTrigger);
    this._timeoutTrigger = null;
  }
  _handleAudioInputStateChange(audioLevel) {
    const status = audioLevel !== 0;
    if (this._hasAudioInput === null || this._hasAudioInput !== status) {
      this._hasAudioInput = status;
      this.emit(_DetectionEvents__WEBPACK_IMPORTED_MODULE_3__.AUDIO_INPUT_STATE_CHANGE, this._hasAudioInput);
    }
  }
  _handleNoAudioInputDetection(audioLevel) {
    if (this._eventFired) {
      return;
    }
    if (audioLevel === 0 && !this._timeoutTrigger) {
      this._timeoutTrigger = setTimeout(() => {
        this._eventFired = true;
        this.emit(_DetectionEvents__WEBPACK_IMPORTED_MODULE_3__.NO_AUDIO_INPUT);
      }, SILENCE_PERIOD_MS);
    } else if (audioLevel !== 0 && this._timeoutTrigger) {
      this._clearTriggerTimeout();
    }
  }
  _audioLevel(tpc, ssrc, audioLevel, isLocal) {
    if (!isLocal || !this._audioTrack) {
      return;
    }
    const localSSRCs = tpc.localSSRCs.get(this._audioTrack.rtcId);
    if (!localSSRCs || !localSSRCs.ssrcs.includes(ssrc)) {
      return;
    }
    this._handleAudioInputStateChange(audioLevel);
    this._handleNoAudioInputDetection(audioLevel);
  }
  _trackAdded(track) {
    if (track.isLocalAudioTrack()) {
      this._audioTrack = track;
      this._eventFired = false;
      this._clearTriggerTimeout();
      track.on(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__.NO_AUDIO_INPUT, (audioLevel) => {
        this._handleNoAudioInputDetection(audioLevel);
      });
      track.on(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_2__.TRACK_AUDIO_LEVEL_CHANGED, (audioLevel) => {
        this._handleNoAudioInputDetection(audioLevel);
        this._handleAudioInputStateChange(audioLevel);
      });
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/detection/P2PDominantSpeakerDetection.js":
/*!**************************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/detection/P2PDominantSpeakerDetection.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ P2PDominantSpeakerDetection)
/* harmony export */ });
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");



const SPEECH_DETECT_THRESHOLD = 0.6;
class P2PDominantSpeakerDetection {
  constructor(conference) {
    this.conference = conference;
    conference.addEventListener(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_0__.TRACK_AUDIO_LEVEL_CHANGED, this._audioLevel.bind(this));
    this.myUserID = this.conference.myUserId();
  }
  _audioLevel(id, audioLevel) {
    if (!this.conference.isP2PActive() || audioLevel <= SPEECH_DETECT_THRESHOLD || id === this.myUserID && this.conference.getLocalAudioTrack().isMuted()) {
      return;
    }
    this.conference.rtc.eventEmitter.emit(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].DOMINANT_SPEAKER_CHANGED, id);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/detection/TrackVADEmitter.js":
/*!**************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/detection/TrackVADEmitter.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TrackVADEmitter)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _RTC_RTC__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../RTC/RTC */ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTC.js");
/* harmony import */ var _webaudio_WebAudioUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webaudio/WebAudioUtils */ "../../lib-jitsi-meet/dist/esm/modules/webaudio/WebAudioUtils.js");
/* harmony import */ var _DetectionEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DetectionEvents */ "../../lib-jitsi-meet/dist/esm/modules/detection/DetectionEvents.js");





class TrackVADEmitter extends (events__WEBPACK_IMPORTED_MODULE_0___default()) {
  constructor(procNodeSampleRate, vadProcessor, jitsiLocalTrack) {
    super();
    this._procNodeSampleRate = procNodeSampleRate;
    this._vadProcessor = vadProcessor;
    this._localTrack = jitsiLocalTrack;
    this._bufferResidue = new Float32Array([]);
    this._audioContext = (0,_webaudio_WebAudioUtils__WEBPACK_IMPORTED_MODULE_2__.createAudioContext)({ sampleRate: vadProcessor.getRequiredPCMFrequency() });
    this._vadSampleSize = vadProcessor.getSampleLength();
    this._onAudioProcess = this._onAudioProcess.bind(this);
    this._initializeAudioContext();
  }
  static create(micDeviceId, procNodeSampleRate, vadProcessor) {
    return _RTC_RTC__WEBPACK_IMPORTED_MODULE_1__["default"].obtainAudioAndVideoPermissions({
      devices: ["audio"],
      micDeviceId
    }).then((localTrack) => {
      if (!localTrack[0]) {
        throw new Error(`Failed to create jitsi local track for device id: ${micDeviceId}`);
      }
      return new TrackVADEmitter(procNodeSampleRate, vadProcessor, localTrack[0]);
    });
  }
  _initializeAudioContext() {
    this._audioSource = this._audioContext.createMediaStreamSource(this._localTrack.stream);
    this._audioProcessingNode = this._audioContext.createScriptProcessor(this._procNodeSampleRate, 1, 1);
  }
  _onAudioProcess(audioEvent) {
    const inData = audioEvent.inputBuffer.getChannelData(0);
    const completeInData = [...this._bufferResidue, ...inData];
    const sampleTimestamp = Date.now();
    let i = 0;
    for (; i + this._vadSampleSize < completeInData.length; i += this._vadSampleSize) {
      const pcmSample = completeInData.slice(i, i + this._vadSampleSize);
      const vadScore = this._vadProcessor.calculateAudioFrameVAD(pcmSample.slice());
      this.emit(_DetectionEvents__WEBPACK_IMPORTED_MODULE_3__.VAD_SCORE_PUBLISHED, {
        timestamp: sampleTimestamp,
        score: vadScore,
        pcmData: pcmSample,
        deviceId: this._localTrack.getDeviceId()
      });
    }
    this._bufferResidue = completeInData.slice(i, completeInData.length);
  }
  _connectAudioGraph() {
    this._audioProcessingNode.onaudioprocess = this._onAudioProcess;
    this._audioSource.connect(this._audioProcessingNode);
    this._audioProcessingNode.connect(this._audioContext.destination);
  }
  _disconnectAudioGraph() {
    this._audioProcessingNode.onaudioprocess = () => {
    };
    this._audioProcessingNode.disconnect();
    this._audioSource.disconnect();
  }
  _cleanupResources() {
    this._disconnectAudioGraph();
    this._localTrack.stopStream();
  }
  getDeviceId() {
    return this._localTrack.getDeviceId();
  }
  getTrackLabel() {
    return this._localTrack.getDeviceLabel();
  }
  start() {
    this._connectAudioGraph();
  }
  stop() {
    this._disconnectAudioGraph();
    this._bufferResidue = [];
  }
  destroy() {
    if (this._destroyed) {
      return;
    }
    this._cleanupResources();
    this._destroyed = true;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/detection/VADAudioAnalyser.js":
/*!***************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/detection/VADAudioAnalyser.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VADAudioAnalyser)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _DetectionEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DetectionEvents */ "../../lib-jitsi-meet/dist/esm/modules/detection/DetectionEvents.js");
/* harmony import */ var _TrackVADEmitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TrackVADEmitter */ "../../lib-jitsi-meet/dist/esm/modules/detection/TrackVADEmitter.js");






const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const VAD_EMITTER_SAMPLE_RATE = 4096;
class VADAudioAnalyser extends events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {
  constructor(conference, createVADProcessor) {
    super();
    this._createVADProcessor = createVADProcessor;
    this._vadEmitter = null;
    this._isVADEmitterRunning = false;
    this._detectionServices = [];
    this._vadInitTracker = Promise.resolve();
    this._processVADScore = this._processVADScore.bind(this);
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.TRACK_ADDED, this._trackAdded.bind(this));
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.TRACK_REMOVED, this._trackRemoved.bind(this));
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.TRACK_MUTE_CHANGED, this._trackMuteChanged.bind(this));
  }
  addVADDetectionService(vadService) {
    this._detectionServices.push(vadService);
    vadService.on(_DetectionEvents__WEBPACK_IMPORTED_MODULE_3__.DETECTOR_STATE_CHANGE, () => {
      const activeDetector = this._detectionServices.filter((detector) => detector.isActive() === true);
      if (!activeDetector.length && this._isVADEmitterRunning) {
        this._stopVADEmitter();
      } else if (!this._isVADEmitterRunning) {
        this._startVADEmitter();
      }
    });
  }
  _startVADEmitter() {
    if (this._vadEmitter) {
      this._vadEmitter.on(_DetectionEvents__WEBPACK_IMPORTED_MODULE_3__.VAD_SCORE_PUBLISHED, this._processVADScore);
      this._vadEmitter.start();
      this._isVADEmitterRunning = true;
    }
  }
  _stopVADEmitter() {
    if (this._vadEmitter) {
      this._vadEmitter.removeListener(_DetectionEvents__WEBPACK_IMPORTED_MODULE_3__.VAD_SCORE_PUBLISHED, this._processVADScore);
      this._vadEmitter.stop();
    }
    this._isVADEmitterRunning = false;
  }
  _processVADScore(vadScore) {
    for (const detector of this._detectionServices) {
      detector.processVADScore(vadScore);
    }
  }
  _changeDetectorsMuteState(isMuted) {
    for (const detector of this._detectionServices) {
      detector.changeMuteState(isMuted);
    }
  }
  _trackAdded(track) {
    if (track.isLocalAudioTrack()) {
      this._vadInitTracker = this._vadInitTracker.then(() => this._createVADProcessor()).then((vadProcessor) => _TrackVADEmitter__WEBPACK_IMPORTED_MODULE_4__["default"].create(track.getDeviceId(), VAD_EMITTER_SAMPLE_RATE, vadProcessor)).then((vadEmitter) => {
        logger.debug("Created VAD emitter for track: ", track.getTrackLabel());
        this._vadEmitter = vadEmitter;
        this._changeDetectorsMuteState(track.isMuted());
      }).catch((error) => {
        logger.warn("Failed to start VADAudioAnalyser", error);
      });
    }
  }
  _trackMuteChanged(track) {
    if (track.isLocalAudioTrack()) {
      this._vadInitTracker = this._vadInitTracker.then(() => {
        this._changeDetectorsMuteState(track.isMuted());
      });
    }
  }
  _trackRemoved(track) {
    if (track.isLocalAudioTrack()) {
      this._vadInitTracker = this._vadInitTracker.then(() => {
        logger.debug("Removing track from VAD detection - ", track.getTrackLabel());
        if (this._vadEmitter) {
          this._stopVADEmitter();
          this._vadEmitter.destroy();
          this._vadEmitter = null;
        }
        for (const detector of this._detectionServices) {
          detector.reset();
        }
      });
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/detection/VADNoiseDetection.js":
/*!****************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/detection/VADNoiseDetection.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VADNoiseDetection)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_MathUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/MathUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/MathUtil.js");
/* harmony import */ var _DetectionEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DetectionEvents */ "../../lib-jitsi-meet/dist/esm/modules/detection/DetectionEvents.js");




const VAD_NOISE_AVG_THRESHOLD = 0.2;
const NOISY_AUDIO_LEVEL_THRESHOLD = 0.04;
const VAD_SCORE_TRIGGER = 0.2;
const AUDIO_LEVEL_SCORE_TRIGGER = 0.02;
const PROCESS_TIME_FRAME_SPAN_MS = 1500;
class VADNoiseDetection extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
  constructor() {
    super();
    this._processing = false;
    this._scoreArray = [];
    this._audioLvlArray = [];
    this._active = false;
    this._calculateNoisyScore = this._calculateNoisyScore.bind(this);
  }
  _calculateNoisyScore() {
    const scoreAvg = (0,_util_MathUtil__WEBPACK_IMPORTED_MODULE_1__.calculateAverage)(this._scoreArray);
    const audioLevelAvg = (0,_util_MathUtil__WEBPACK_IMPORTED_MODULE_1__.calculateAverage)(this._audioLvlArray);
    if (scoreAvg < VAD_NOISE_AVG_THRESHOLD && audioLevelAvg > NOISY_AUDIO_LEVEL_THRESHOLD) {
      this.emit(_DetectionEvents__WEBPACK_IMPORTED_MODULE_2__.VAD_NOISY_DEVICE);
      this._setActiveState(false);
    }
    this.reset();
  }
  _recordValues(vadScore, avgAudioLvl) {
    this._scoreArray.push(vadScore);
    this._audioLvlArray.push(avgAudioLvl);
  }
  _setActiveState(active) {
    this._active = active;
    this.emit(_DetectionEvents__WEBPACK_IMPORTED_MODULE_2__.DETECTOR_STATE_CHANGE, this._active);
  }
  changeMuteState(isMuted) {
    this._setActiveState(!isMuted);
    this.reset();
  }
  isActive() {
    return this._active;
  }
  reset() {
    this._processing = false;
    this._scoreArray = [];
    this._audioLvlArray = [];
    clearTimeout(this._processTimeout);
  }
  processVADScore(vadScore) {
    if (!this._active) {
      return;
    }
    if (this._processing) {
      const posAudioLevels = (0,_util_MathUtil__WEBPACK_IMPORTED_MODULE_1__.filterPositiveValues)(vadScore.pcmData);
      this._recordValues(vadScore.score, (0,_util_MathUtil__WEBPACK_IMPORTED_MODULE_1__.calculateAverage)(posAudioLevels));
      return;
    }
    if (vadScore.score < VAD_SCORE_TRIGGER) {
      const posAudioLevels = (0,_util_MathUtil__WEBPACK_IMPORTED_MODULE_1__.filterPositiveValues)(vadScore.pcmData);
      const avgAudioLvl = (0,_util_MathUtil__WEBPACK_IMPORTED_MODULE_1__.calculateAverage)(posAudioLevels);
      if (avgAudioLvl > AUDIO_LEVEL_SCORE_TRIGGER) {
        this._processing = true;
        this._recordValues(vadScore.score, avgAudioLvl);
        this._processTimeout = setTimeout(this._calculateNoisyScore, PROCESS_TIME_FRAME_SPAN_MS);
      }
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/detection/VADTalkMutedDetection.js":
/*!********************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/detection/VADTalkMutedDetection.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VADTalkMutedDetection)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_MathUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/MathUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/MathUtil.js");
/* harmony import */ var _DetectionEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DetectionEvents */ "../../lib-jitsi-meet/dist/esm/modules/detection/DetectionEvents.js");




const VAD_AVG_THRESHOLD = 0.6;
const VAD_VOICE_LEVEL = 0.9;
const PROCESS_TIME_FRAME_SPAN_MS = 700;
class VADTalkMutedDetection extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
  constructor() {
    super();
    this._processing = false;
    this._scoreArray = [];
    this._active = false;
    this._calculateVADScore = this._calculateVADScore.bind(this);
  }
  _calculateVADScore() {
    const score = (0,_util_MathUtil__WEBPACK_IMPORTED_MODULE_1__.calculateAverage)(this._scoreArray);
    if (score > VAD_AVG_THRESHOLD) {
      this.emit(_DetectionEvents__WEBPACK_IMPORTED_MODULE_2__.VAD_TALK_WHILE_MUTED);
      this._setActiveState(false);
    }
    this.reset();
  }
  _setActiveState(active) {
    this._active = active;
    this.emit(_DetectionEvents__WEBPACK_IMPORTED_MODULE_2__.DETECTOR_STATE_CHANGE, this._active);
  }
  changeMuteState(isMuted) {
    this._setActiveState(isMuted);
    this.reset();
  }
  isActive() {
    return this._active;
  }
  processVADScore(vadScore) {
    if (!this._active) {
      return;
    }
    if (this._processing) {
      this._scoreArray.push(vadScore.score);
      return;
    }
    if (vadScore.score > VAD_VOICE_LEVEL) {
      this._processing = true;
      this._scoreArray.push(vadScore.score);
      this._processTimeout = setTimeout(this._calculateVADScore, PROCESS_TIME_FRAME_SPAN_MS);
    }
  }
  reset() {
    this._processing = false;
    this._scoreArray = [];
    clearTimeout(this._processTimeout);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/e2ee/E2EEContext.js":
/*!*****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/e2ee/E2EEContext.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ E2EEcontext)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);


const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const kJitsiE2EE = Symbol("kJitsiE2EE");
class E2EEcontext {
  constructor({ sharedKey } = {}) {
    let baseUrl = "";
    const ljm = document.querySelector('script[src*="lib-jitsi-meet"]');
    if (ljm) {
      const idx = ljm.src.lastIndexOf("/");
      baseUrl = `${ljm.src.substring(0, idx)}/`;
    }
    let workerUrl = `${baseUrl}lib-jitsi-meet.e2ee-worker.js`;
    if (baseUrl && baseUrl !== "/") {
      const workerBlob = new Blob([`importScripts("${workerUrl}");`], { type: "application/javascript" });
      workerUrl = window.URL.createObjectURL(workerBlob);
    }
    this._worker = new Worker(workerUrl, { name: "E2EE Worker" });
    this._worker.onerror = (e) => logger.error(e);
    this._worker.postMessage({
      operation: "initialize",
      sharedKey
    });
  }
  cleanup(participantId) {
    this._worker.postMessage({
      operation: "cleanup",
      participantId
    });
  }
  cleanupAll() {
    this._worker.postMessage({
      operation: "cleanupAll"
    });
  }
  handleReceiver(receiver, kind, participantId) {
    if (receiver[kJitsiE2EE]) {
      return;
    }
    receiver[kJitsiE2EE] = true;
    if (window.RTCRtpScriptTransform) {
      const options = {
        operation: "decode",
        participantId
      };
      receiver.transform = new RTCRtpScriptTransform(this._worker, options);
    } else {
      const receiverStreams = receiver.createEncodedStreams();
      this._worker.postMessage({
        operation: "decode",
        readableStream: receiverStreams.readable,
        writableStream: receiverStreams.writable,
        participantId
      }, [receiverStreams.readable, receiverStreams.writable]);
    }
  }
  handleSender(sender, kind, participantId) {
    if (sender[kJitsiE2EE]) {
      return;
    }
    sender[kJitsiE2EE] = true;
    if (window.RTCRtpScriptTransform) {
      const options = {
        operation: "encode",
        participantId
      };
      sender.transform = new RTCRtpScriptTransform(this._worker, options);
    } else {
      const senderStreams = sender.createEncodedStreams();
      this._worker.postMessage({
        operation: "encode",
        readableStream: senderStreams.readable,
        writableStream: senderStreams.writable,
        participantId
      }, [senderStreams.readable, senderStreams.writable]);
    }
  }
  setKey(participantId, key, keyIndex) {
    this._worker.postMessage({
      operation: "setKey",
      key,
      keyIndex,
      participantId
    });
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/e2ee/E2EEErrors.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/e2ee/E2EEErrors.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E2EEErrors: () => (/* binding */ E2EEErrors)
/* harmony export */ });

var E2EEErrors;
(function(E2EEErrors2) {
  E2EEErrors2["E2EE_SAS_KEYS_MAC_MISMATCH"] = "e2ee.sas.keys-mac-mismatch";
  E2EEErrors2["E2EE_SAS_MAC_MISMATCH"] = "e2ee.sas.mac-mismatch";
  E2EEErrors2["E2EE_SAS_MISSING_KEY"] = "e2ee.sas.missing-key";
  E2EEErrors2["E2EE_SAS_COMMITMENT_MISMATCHED"] = "e2ee.sas.commitment-mismatched";
  E2EEErrors2["E2EE_SAS_CHANNEL_VERIFICATION_FAILED"] = "e2ee.sas.channel-verification-failed";
  E2EEErrors2["E2EE_SAS_INVALID_SAS_VERIFICATION"] = "e2ee.sas.invalid-sas-verification";
})(E2EEErrors || (E2EEErrors = {}));


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/e2ee/E2EEncryption.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/e2ee/E2EEncryption.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E2EEncryption: () => (/* binding */ E2EEncryption)
/* harmony export */ });
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _ExternallyManagedKeyHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExternallyManagedKeyHandler */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/ExternallyManagedKeyHandler.js");
/* harmony import */ var _ManagedKeyHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ManagedKeyHandler */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/ManagedKeyHandler.js");
/* harmony import */ var _OlmAdapter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OlmAdapter */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/OlmAdapter.js");

var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};




class E2EEncryption {
  constructor(conference) {
    const { e2ee = {} } = conference.options.config;
    this._externallyManaged = e2ee.externallyManagedKey;
    if (this._externallyManaged) {
      this._keyHandler = new _ExternallyManagedKeyHandler__WEBPACK_IMPORTED_MODULE_1__.ExternallyManagedKeyHandler(conference);
    } else {
      this._keyHandler = new _ManagedKeyHandler__WEBPACK_IMPORTED_MODULE_2__.ManagedKeyHandler(conference);
    }
  }
  static isSupported(config) {
    const { e2ee = {} } = config;
    if (!e2ee.externallyManagedKey && !_OlmAdapter__WEBPACK_IMPORTED_MODULE_3__.OlmAdapter.isSupported()) {
      return false;
    }
    return !(config.testing && config.testing.disableE2EE) && (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].supportsInsertableStreams() || config.enableEncodedTransformSupport && _browser__WEBPACK_IMPORTED_MODULE_0__["default"].supportsEncodedTransform());
  }
  isEnabled() {
    return this._keyHandler.isEnabled();
  }
  setEnabled(enabled) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this._keyHandler.setEnabled(enabled);
    });
  }
  setEncryptionKey(keyInfo) {
    this._keyHandler.setKey(keyInfo);
  }
  startVerification(participant) {
    var _a;
    (_a = this._keyHandler.sasVerification) === null || _a === void 0 ? void 0 : _a.startVerification(participant);
  }
  markParticipantVerified(participant, isVerified) {
    var _a;
    (_a = this._keyHandler.sasVerification) === null || _a === void 0 ? void 0 : _a.markParticipantVerified(participant, isVerified);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/e2ee/ExternallyManagedKeyHandler.js":
/*!*********************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/e2ee/ExternallyManagedKeyHandler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExternallyManagedKeyHandler: () => (/* binding */ ExternallyManagedKeyHandler)
/* harmony export */ });
/* harmony import */ var _KeyHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KeyHandler */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/KeyHandler.js");


class ExternallyManagedKeyHandler extends _KeyHandler__WEBPACK_IMPORTED_MODULE_0__.KeyHandler {
  constructor(conference) {
    super(conference, { sharedKey: true });
  }
  setKey(keyInfo) {
    this.e2eeCtx.setKey(void 0, { encryptionKey: keyInfo.encryptionKey }, keyInfo.index);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/e2ee/KeyHandler.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/e2ee/KeyHandler.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyHandler: () => (/* binding */ KeyHandler)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _util_Deferred__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Deferred */ "../../lib-jitsi-meet/dist/esm/modules/util/Deferred.js");
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");
/* harmony import */ var _E2EEContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./E2EEContext */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/E2EEContext.js");

var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};







const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class KeyHandler extends _util_Listenable__WEBPACK_IMPORTED_MODULE_5__["default"] {
  constructor(conference, options = {}) {
    super();
    this.conference = conference;
    this.e2eeCtx = new _E2EEContext__WEBPACK_IMPORTED_MODULE_6__["default"](options);
    this.enabled = false;
    this._enabling = void 0;
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__._MEDIA_SESSION_STARTED, this._onMediaSessionStarted.bind(this));
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.TRACK_ADDED, (track) => track.isLocal() && this._onLocalTrackAdded(track));
    this.conference.rtc.on(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_2__["default"].REMOTE_TRACK_ADDED, (track, tpc) => this._setupReceiverE2EEForTrack(tpc, track));
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.TRACK_MUTE_CHANGED, this._trackMuteChanged.bind(this));
  }
  isEnabled() {
    return this.enabled;
  }
  setEnabled(enabled) {
    return __awaiter(this, void 0, void 0, function* () {
      this._enabling && (yield this._enabling);
      if (enabled === this.enabled) {
        return;
      }
      this._enabling = new _util_Deferred__WEBPACK_IMPORTED_MODULE_4__["default"]();
      this.enabled = enabled;
      if (!enabled) {
        this.e2eeCtx.cleanupAll();
      }
      this._setEnabled && (yield this._setEnabled(enabled));
      this.conference.setLocalParticipantProperty("e2ee.enabled", enabled);
      this.conference._restartMediaSessions();
      this._enabling.resolve();
    });
  }
  setEncryptionKey() {
    throw new Error("Not implemented by subclass");
  }
  _onLocalTrackAdded(track) {
    for (const session of this.conference.getMediaSessions()) {
      this._setupSenderE2EEForTrack(session, track);
    }
  }
  _onMediaSessionStarted(session) {
    const localTracks = this.conference.getLocalTracks();
    for (const track of localTracks) {
      this._setupSenderE2EEForTrack(session, track);
    }
  }
  _setupReceiverE2EEForTrack(tpc, track) {
    if (!this.enabled) {
      return;
    }
    const receiver = tpc.findReceiverForTrack(track.track);
    if (receiver) {
      this.e2eeCtx.handleReceiver(receiver, track.getType(), track.getParticipantId());
    } else {
      logger.warn(`Could not handle E2EE for ${track}: receiver not found in: ${tpc}`);
    }
  }
  _setupSenderE2EEForTrack(session, track) {
    if (!this.enabled) {
      return;
    }
    const pc = session.peerconnection;
    const sender = pc && pc.findSenderForTrack(track.track);
    if (sender) {
      this.e2eeCtx.handleSender(sender, track.getType(), track.getParticipantId());
    } else {
      logger.warn(`Could not handle E2EE for ${track}: sender not found in ${pc}`);
    }
  }
  _trackMuteChanged(track) {
    if (_browser__WEBPACK_IMPORTED_MODULE_3__["default"].doesVideoMuteByStreamRemove() && track.isLocal() && track.isVideoTrack() && !track.isMuted()) {
      for (const session of this.conference.getMediaSessions()) {
        this._setupSenderE2EEForTrack(session, track);
      }
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/e2ee/ManagedKeyHandler.js":
/*!***********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/e2ee/ManagedKeyHandler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ManagedKeyHandler: () => (/* binding */ ManagedKeyHandler)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.debounce */ "../../lib-jitsi-meet/node_modules/lodash.debounce/index.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _KeyHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./KeyHandler */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/KeyHandler.js");
/* harmony import */ var _OlmAdapter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./OlmAdapter */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/OlmAdapter.js");
/* harmony import */ var _crypto_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./crypto-utils */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/crypto-utils.js");

var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};






const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const DEBOUNCE_PERIOD = 5e3;
class ManagedKeyHandler extends _KeyHandler__WEBPACK_IMPORTED_MODULE_3__.KeyHandler {
  constructor(conference) {
    super(conference);
    this._key = void 0;
    this._conferenceJoined = false;
    this._olmAdapter = new _OlmAdapter__WEBPACK_IMPORTED_MODULE_4__.OlmAdapter(conference);
    this._rotateKey = lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(this._rotateKeyImpl, DEBOUNCE_PERIOD);
    this._ratchetKey = lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(this._ratchetKeyImpl, DEBOUNCE_PERIOD);
    this._olmAdapter.on(_OlmAdapter__WEBPACK_IMPORTED_MODULE_4__.OlmAdapter.events.PARTICIPANT_KEY_UPDATED, this._onParticipantKeyUpdated.bind(this));
    this._olmAdapter.on(_OlmAdapter__WEBPACK_IMPORTED_MODULE_4__.OlmAdapter.events.PARTICIPANT_SAS_READY, this._onParticipantSasReady.bind(this));
    this._olmAdapter.on(_OlmAdapter__WEBPACK_IMPORTED_MODULE_4__.OlmAdapter.events.PARTICIPANT_SAS_AVAILABLE, this._onParticipantSasAvailable.bind(this));
    this._olmAdapter.on(_OlmAdapter__WEBPACK_IMPORTED_MODULE_4__.OlmAdapter.events.PARTICIPANT_VERIFICATION_COMPLETED, this._onParticipantVerificationCompleted.bind(this));
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.PARTICIPANT_PROPERTY_CHANGED, this._onParticipantPropertyChanged.bind(this));
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.USER_JOINED, this._onParticipantJoined.bind(this));
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.USER_LEFT, this._onParticipantLeft.bind(this));
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.CONFERENCE_JOINED, () => {
      this._conferenceJoined = true;
    });
  }
  get sasVerification() {
    return this._olmAdapter;
  }
  _setEnabled(enabled) {
    return __awaiter(this, void 0, void 0, function* () {
      if (enabled) {
        yield this._olmAdapter.initSessions();
      } else {
        this._olmAdapter.clearAllParticipantsSessions();
      }
      this._key = enabled ? this._generateKey() : false;
      const index = yield this._olmAdapter.updateKey(this._key);
      this.e2eeCtx.setKey(this.conference.myUserId(), this._key, index);
    });
  }
  _onParticipantPropertyChanged(participant, name, oldValue, newValue) {
    return __awaiter(this, void 0, void 0, function* () {
      switch (name) {
        case "e2ee.idKey":
          logger.debug(`Participant ${participant.getId()} updated their id key: ${newValue}`);
          break;
        case "e2ee.enabled":
          if (!newValue && this.enabled) {
            this._olmAdapter.clearParticipantSession(participant);
          }
          break;
      }
    });
  }
  _onParticipantJoined() {
    if (this._conferenceJoined && this.enabled) {
      this._ratchetKey();
    }
  }
  _onParticipantLeft(id) {
    this.e2eeCtx.cleanup(id);
    if (this.enabled) {
      this._rotateKey();
    }
  }
  _rotateKeyImpl() {
    return __awaiter(this, void 0, void 0, function* () {
      logger.debug("Rotating key");
      this._key = this._generateKey();
      const index = yield this._olmAdapter.updateKey(this._key);
      this.e2eeCtx.setKey(this.conference.myUserId(), this._key, index);
    });
  }
  _ratchetKeyImpl() {
    return __awaiter(this, void 0, void 0, function* () {
      logger.debug("Ratchetting key");
      const material = yield (0,_crypto_utils__WEBPACK_IMPORTED_MODULE_5__.importKey)(this._key);
      const newKey = yield (0,_crypto_utils__WEBPACK_IMPORTED_MODULE_5__.ratchet)(material);
      this._key = new Uint8Array(newKey);
      const index = this._olmAdapter.updateCurrentMediaKey(this._key);
      this.e2eeCtx.setKey(this.conference.myUserId(), this._key, index);
    });
  }
  _onParticipantKeyUpdated(id, key, index) {
    logger.debug(`Participant ${id} updated their key`);
    this.e2eeCtx.setKey(id, key, index);
  }
  _onParticipantSasReady(pId, sas) {
    this.conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.E2EE_VERIFICATION_READY, pId, sas);
  }
  _onParticipantSasAvailable(pId) {
    this.conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.E2EE_VERIFICATION_AVAILABLE, pId);
  }
  _onParticipantVerificationCompleted(pId, success, message) {
    this.conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.E2EE_VERIFICATION_COMPLETED, pId, success, message);
  }
  _generateKey() {
    return window.crypto.getRandomValues(new Uint8Array(32));
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/e2ee/OlmAdapter.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/e2ee/OlmAdapter.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OlmAdapter: () => (/* binding */ OlmAdapter)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! base64-js */ "../../lib-jitsi-meet/node_modules/base64-js/index.js");
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash.isequal */ "../../lib-jitsi-meet/node_modules/lodash.isequal/index.js");
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uuid */ "../../lib-jitsi-meet/node_modules/uuid/wrapper.mjs");
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _util_Deferred__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Deferred */ "../../lib-jitsi-meet/dist/esm/modules/util/Deferred.js");
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");
/* harmony import */ var _xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../xmpp/xmpp */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/xmpp.js");
/* harmony import */ var _E2EEErrors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./E2EEErrors */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/E2EEErrors.js");
/* harmony import */ var _SAS__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SAS */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/SAS.js");

var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};










const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const REQ_TIMEOUT = 5 * 1e3;
const OLM_MESSAGE_TYPE = "olm";
const OLM_MESSAGE_TYPES = {
  ERROR: "error",
  KEY_INFO: "key-info",
  KEY_INFO_ACK: "key-info-ack",
  SESSION_ACK: "session-ack",
  SESSION_INIT: "session-init",
  SAS_START: "sas-start",
  SAS_ACCEPT: "sas-accept",
  SAS_KEY: "sas-key",
  SAS_MAC: "sas-mac"
};
const OLM_SAS_NUM_BYTES = 6;
const OLM_KEY_VERIFICATION_MAC_INFO = "Jitsi-KEY_VERIFICATION_MAC";
const OLM_KEY_VERIFICATION_MAC_KEY_IDS = "Jitsi-KEY_IDS";
const kOlmData = Symbol("OlmData");
const OlmAdapterEvents = {
  PARTICIPANT_E2EE_CHANNEL_READY: "olm.participant_e2ee_channel_ready",
  PARTICIPANT_SAS_AVAILABLE: "olm.participant_sas_available",
  PARTICIPANT_SAS_READY: "olm.participant_sas_ready",
  PARTICIPANT_KEY_UPDATED: "olm.partitipant_key_updated",
  PARTICIPANT_VERIFICATION_COMPLETED: "olm.participant_verification_completed"
};
class OlmAdapter extends _util_Listenable__WEBPACK_IMPORTED_MODULE_5__["default"] {
  constructor(conference) {
    super();
    this._conf = conference;
    this._init = new _util_Deferred__WEBPACK_IMPORTED_MODULE_4__["default"]();
    this._mediaKey = void 0;
    this._mediaKeyIndex = -1;
    this._reqs = /* @__PURE__ */ new Map();
    this._sessionInitialization = void 0;
    if (OlmAdapter.isSupported()) {
      this._bootstrapOlm();
      this._conf.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.ENDPOINT_MESSAGE_RECEIVED, this._onEndpointMessageReceived.bind(this));
      this._conf.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.CONFERENCE_LEFT, this._onConferenceLeft.bind(this));
      this._conf.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.USER_LEFT, this._onParticipantLeft.bind(this));
      this._conf.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_3__.PARTICIPANT_PROPERTY_CHANGED, this._onParticipantPropertyChanged.bind(this));
    } else {
      this._init.reject(new Error("Olm not supported"));
    }
  }
  get myId() {
    return this._conf.myUserId();
  }
  initSessions() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this._sessionInitialization) {
        throw new Error("OlmAdapter initSessions called multiple times");
      } else {
        this._sessionInitialization = new _util_Deferred__WEBPACK_IMPORTED_MODULE_4__["default"]();
        yield this._init;
        const promises = [];
        const localParticipantId = this._conf.myUserId();
        for (const participant of this._conf.getParticipants()) {
          if (participant.hasFeature(_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.FEATURE_E2EE) && localParticipantId < participant.getId()) {
            promises.push(this._sendSessionInit(participant));
          }
        }
        yield Promise.allSettled(promises);
        this._sessionInitialization.resolve();
        this._sessionInitialization = void 0;
      }
    });
  }
  static isSupported() {
    return typeof window.Olm !== "undefined";
  }
  updateKey(key) {
    return __awaiter(this, void 0, void 0, function* () {
      this._mediaKey = key;
      this._mediaKeyIndex++;
      const promises = [];
      for (const participant of this._conf.getParticipants()) {
        const pId = participant.getId();
        const olmData = this._getParticipantOlmData(participant);
        if (!olmData.session) {
          logger.warn(`Tried to send key to participant ${pId} but we have no session`);
          continue;
        }
        const uuid = (0,uuid__WEBPACK_IMPORTED_MODULE_9__.v4)();
        const data = {
          [_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE]: OLM_MESSAGE_TYPE,
          olm: {
            type: OLM_MESSAGE_TYPES.KEY_INFO,
            data: {
              ciphertext: this._encryptKeyInfo(olmData.session),
              uuid
            }
          }
        };
        const d = new _util_Deferred__WEBPACK_IMPORTED_MODULE_4__["default"]();
        d.setRejectTimeout(REQ_TIMEOUT);
        d.catch(() => {
          this._reqs.delete(uuid);
        });
        this._reqs.set(uuid, d);
        promises.push(d);
        this._sendMessage(data, pId);
      }
      yield Promise.allSettled(promises);
      return this._mediaKeyIndex;
    });
  }
  updateCurrentMediaKey(key) {
    this._mediaKey = key;
    return this._mediaKeyIndex;
  }
  clearParticipantSession(participant) {
    const olmData = this._getParticipantOlmData(participant);
    if (olmData.session) {
      olmData.session.free();
      olmData.session = void 0;
    }
  }
  clearAllParticipantsSessions() {
    for (const participant of this._conf.getParticipants()) {
      this.clearParticipantSession(participant);
    }
  }
  markParticipantVerified(participant, isVerified) {
    const olmData = this._getParticipantOlmData(participant);
    const pId = participant.getId();
    if (!isVerified) {
      olmData.sasVerification = void 0;
      logger.warn(`Verification failed for participant ${pId}`);
      this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_VERIFICATION_COMPLETED, pId, false, _E2EEErrors__WEBPACK_IMPORTED_MODULE_7__.E2EEErrors.E2EE_SAS_CHANNEL_VERIFICATION_FAILED);
      return;
    }
    if (!olmData.sasVerification) {
      logger.warn(`Participant ${pId} does not have valid sasVerification`);
      this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_VERIFICATION_COMPLETED, pId, false, _E2EEErrors__WEBPACK_IMPORTED_MODULE_7__.E2EEErrors.E2EE_SAS_INVALID_SAS_VERIFICATION);
      return;
    }
    const { sas, sasMacSent } = olmData.sasVerification;
    if (sas && sas.is_their_key_set() && !sasMacSent) {
      this._sendSasMac(participant);
      olmData.sasVerification.sasMacSent = true;
    }
  }
  _bootstrapOlm() {
    return __awaiter(this, void 0, void 0, function* () {
      logger.debug("Initializing Olm...");
      try {
        yield Olm.init();
        this._olmAccount = new Olm.Account();
        this._olmAccount.create();
        this._idKeys = JSON.parse(this._olmAccount.identity_keys());
        logger.debug(`Olm ${Olm.get_library_version().join(".")} initialized`);
        this._init.resolve();
        this._onIdKeysReady(this._idKeys);
      } catch (e) {
        logger.error("Failed to initialize Olm", e);
        this._init.reject(e);
      }
    });
  }
  startVerification(participant) {
    const pId = participant.getId();
    const olmData = this._getParticipantOlmData(participant);
    if (!olmData.session) {
      logger.warn(`Tried to start verification with participant ${pId} but we have no session`);
      return;
    }
    if (olmData.sasVerification) {
      logger.warn(`There is already a verification in progress with participant ${pId}`);
      return;
    }
    olmData.sasVerification = {
      sas: new Olm.SAS(),
      transactionId: (0,uuid__WEBPACK_IMPORTED_MODULE_9__.v4)()
    };
    const startContent = {
      transactionId: olmData.sasVerification.transactionId
    };
    olmData.sasVerification.startContent = startContent;
    olmData.sasVerification.isInitiator = true;
    const startMessage = {
      [_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE]: OLM_MESSAGE_TYPE,
      olm: {
        type: OLM_MESSAGE_TYPES.SAS_START,
        data: startContent
      }
    };
    this._sendMessage(startMessage, pId);
  }
  _onIdKeysReady(idKeys) {
    logger.debug(`Olm id key ready: ${idKeys}`);
    for (const keyType in idKeys) {
      if (idKeys.hasOwnProperty(keyType)) {
        const key = idKeys[keyType];
        this._conf.setLocalParticipantProperty(`e2ee.idKey.${keyType}`, key);
      }
    }
  }
  _onParticipantE2EEChannelReady(id) {
    logger.debug(`E2EE channel with participant ${id} is ready`);
  }
  _encryptKeyInfo(session) {
    const keyInfo = {};
    if (this._mediaKey !== void 0) {
      keyInfo.key = this._mediaKey ? base64_js__WEBPACK_IMPORTED_MODULE_1__.fromByteArray(this._mediaKey) : false;
      keyInfo.keyIndex = this._mediaKeyIndex;
    }
    return session.encrypt(JSON.stringify(keyInfo));
  }
  _getParticipantOlmData(participant) {
    participant[kOlmData] = participant[kOlmData] || {};
    return participant[kOlmData];
  }
  _onConferenceLeft() {
    return __awaiter(this, void 0, void 0, function* () {
      logger.debug("Conference left");
      yield this._init;
      for (const participant of this._conf.getParticipants()) {
        this._onParticipantLeft(participant.getId(), participant);
      }
      if (this._olmAccount) {
        this._olmAccount.free();
        this._olmAccount = void 0;
      }
    });
  }
  _onEndpointMessageReceived(participant, payload) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      if (payload[_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE] !== OLM_MESSAGE_TYPE) {
        return;
      }
      if (!payload.olm) {
        logger.warn("Incorrectly formatted message");
        return;
      }
      yield this._init;
      const msg = payload.olm;
      const pId = participant.getId();
      const olmData = this._getParticipantOlmData(participant);
      switch (msg.type) {
        case OLM_MESSAGE_TYPES.SESSION_INIT: {
          if (olmData.session) {
            logger.warn(`Participant ${pId} already has a session`);
            this._sendError(participant, "Session already established");
          } else {
            const session = new Olm.Session();
            session.create_outbound(this._olmAccount, msg.data.idKey, msg.data.otKey);
            olmData.session = session;
            const ack = {
              [_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE]: OLM_MESSAGE_TYPE,
              olm: {
                type: OLM_MESSAGE_TYPES.SESSION_ACK,
                data: {
                  ciphertext: this._encryptKeyInfo(session),
                  uuid: msg.data.uuid
                }
              }
            };
            this._sendMessage(ack, pId);
            this._onParticipantE2EEChannelReady(pId);
          }
          break;
        }
        case OLM_MESSAGE_TYPES.SESSION_ACK: {
          if (olmData.session) {
            logger.warn(`Participant ${pId} already has a session`);
            this._sendError(participant, "No session found");
          } else if (msg.data.uuid === olmData.pendingSessionUuid) {
            const { ciphertext } = msg.data;
            const d = this._reqs.get(msg.data.uuid);
            const session = new Olm.Session();
            session.create_inbound(this._olmAccount, ciphertext.body);
            this._olmAccount.remove_one_time_keys(session);
            const data = session.decrypt(ciphertext.type, ciphertext.body);
            olmData.session = session;
            olmData.pendingSessionUuid = void 0;
            this._onParticipantE2EEChannelReady(pId);
            this._reqs.delete(msg.data.uuid);
            d.resolve();
            const json = safeJsonParse(data);
            if (json.key) {
              const key = base64_js__WEBPACK_IMPORTED_MODULE_1__.toByteArray(json.key);
              const keyIndex = json.keyIndex;
              olmData.lastKey = key;
              this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_KEY_UPDATED, pId, key, keyIndex);
            }
          } else {
            logger.warn("Received ACK with the wrong UUID");
            this._sendError(participant, "Invalid UUID");
          }
          break;
        }
        case OLM_MESSAGE_TYPES.ERROR: {
          logger.error(msg.data.error);
          break;
        }
        case OLM_MESSAGE_TYPES.KEY_INFO: {
          if (olmData.session) {
            const { ciphertext } = msg.data;
            const data = olmData.session.decrypt(ciphertext.type, ciphertext.body);
            const json = safeJsonParse(data);
            if (json.key !== void 0 && json.keyIndex !== void 0) {
              const key = json.key ? base64_js__WEBPACK_IMPORTED_MODULE_1__.toByteArray(json.key) : false;
              const keyIndex = json.keyIndex;
              if (!lodash_isequal__WEBPACK_IMPORTED_MODULE_2___default()(olmData.lastKey, key)) {
                olmData.lastKey = key;
                this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_KEY_UPDATED, pId, key, keyIndex);
              }
              const ack = {
                [_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE]: OLM_MESSAGE_TYPE,
                olm: {
                  type: OLM_MESSAGE_TYPES.KEY_INFO_ACK,
                  data: {
                    ciphertext: this._encryptKeyInfo(olmData.session),
                    uuid: msg.data.uuid
                  }
                }
              };
              this._sendMessage(ack, pId);
            }
          } else {
            logger.debug(`Received key info message from ${pId} but we have no session for them!`);
            this._sendError(participant, "No session found while processing key-info");
          }
          break;
        }
        case OLM_MESSAGE_TYPES.KEY_INFO_ACK: {
          if (olmData.session) {
            const { ciphertext } = msg.data;
            const data = olmData.session.decrypt(ciphertext.type, ciphertext.body);
            const json = safeJsonParse(data);
            if (json.key !== void 0 && json.keyIndex !== void 0) {
              const key = json.key ? base64_js__WEBPACK_IMPORTED_MODULE_1__.toByteArray(json.key) : false;
              const keyIndex = json.keyIndex;
              if (!lodash_isequal__WEBPACK_IMPORTED_MODULE_2___default()(olmData.lastKey, key)) {
                olmData.lastKey = key;
                this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_KEY_UPDATED, pId, key, keyIndex);
              }
            }
            const d = this._reqs.get(msg.data.uuid);
            this._reqs.delete(msg.data.uuid);
            d.resolve();
          } else {
            logger.debug(`Received key info ack message from ${pId} but we have no session for them!`);
            this._sendError(participant, "No session found while processing key-info-ack");
          }
          break;
        }
        case OLM_MESSAGE_TYPES.SAS_START: {
          if (!olmData.session) {
            logger.debug(`Received sas init message from ${pId} but we have no session for them!`);
            this._sendError(participant, "No session found while processing sas-init");
            return;
          }
          if ((_a = olmData.sasVerification) === null || _a === void 0 ? void 0 : _a.sas) {
            logger.warn(`SAS already created for participant ${pId}`);
            this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_VERIFICATION_COMPLETED, pId, false, _E2EEErrors__WEBPACK_IMPORTED_MODULE_7__.E2EEErrors.E2EE_SAS_INVALID_SAS_VERIFICATION);
            return;
          }
          const { transactionId } = msg.data;
          const sas = new Olm.SAS();
          olmData.sasVerification = {
            sas,
            transactionId,
            isInitiator: false
          };
          const pubKey = olmData.sasVerification.sas.get_pubkey();
          const commitment = this._computeCommitment(pubKey, msg.data);
          const acceptMessage = {
            [_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE]: OLM_MESSAGE_TYPE,
            olm: {
              type: OLM_MESSAGE_TYPES.SAS_ACCEPT,
              data: {
                transactionId,
                commitment
              }
            }
          };
          this._sendMessage(acceptMessage, pId);
          break;
        }
        case OLM_MESSAGE_TYPES.SAS_ACCEPT: {
          if (!olmData.session) {
            logger.debug(`Received sas accept message from ${pId} but we have no session for them!`);
            this._sendError(participant, "No session found while processing sas-accept");
            return;
          }
          const { commitment, transactionId } = msg.data;
          if (!olmData.sasVerification) {
            logger.warn(`SAS_ACCEPT Participant ${pId} does not have valid sasVerification`);
            this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_VERIFICATION_COMPLETED, pId, false, _E2EEErrors__WEBPACK_IMPORTED_MODULE_7__.E2EEErrors.E2EE_SAS_INVALID_SAS_VERIFICATION);
            return;
          }
          if (olmData.sasVerification.sasCommitment) {
            logger.debug(`Already received sas commitment message from ${pId}!`);
            this._sendError(participant, "Already received sas commitment message from ${pId}!");
            return;
          }
          olmData.sasVerification.sasCommitment = commitment;
          const pubKey = olmData.sasVerification.sas.get_pubkey();
          const keyMessage = {
            [_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE]: OLM_MESSAGE_TYPE,
            olm: {
              type: OLM_MESSAGE_TYPES.SAS_KEY,
              data: {
                key: pubKey,
                transactionId
              }
            }
          };
          this._sendMessage(keyMessage, pId);
          olmData.sasVerification.keySent = true;
          break;
        }
        case OLM_MESSAGE_TYPES.SAS_KEY: {
          if (!olmData.session) {
            logger.debug(`Received sas key message from ${pId} but we have no session for them!`);
            this._sendError(participant, "No session found while processing sas-key");
            return;
          }
          if (!olmData.sasVerification) {
            logger.warn(`SAS_KEY Participant ${pId} does not have valid sasVerification`);
            this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_VERIFICATION_COMPLETED, pId, false, _E2EEErrors__WEBPACK_IMPORTED_MODULE_7__.E2EEErrors.E2EE_SAS_INVALID_SAS_VERIFICATION);
            return;
          }
          const { isInitiator, sas, sasCommitment, startContent, keySent } = olmData.sasVerification;
          if (sas.is_their_key_set()) {
            logger.warn("SAS already has their key!");
            return;
          }
          const { key: theirKey, transactionId } = msg.data;
          if (sasCommitment) {
            const commitment = this._computeCommitment(theirKey, startContent);
            if (sasCommitment !== commitment) {
              this._sendError(participant, "OlmAdapter commitments mismatched");
              this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_VERIFICATION_COMPLETED, pId, false, _E2EEErrors__WEBPACK_IMPORTED_MODULE_7__.E2EEErrors.E2EE_SAS_COMMITMENT_MISMATCHED);
              olmData.sasVerification.free();
              return;
            }
          }
          sas.set_their_key(theirKey);
          const pubKey = sas.get_pubkey();
          const myInfo = `${this.myId}|${pubKey}`;
          const theirInfo = `${pId}|${theirKey}`;
          const info = isInitiator ? `${myInfo}|${theirInfo}` : `${theirInfo}|${myInfo}`;
          const sasBytes = sas.generate_bytes(info, OLM_SAS_NUM_BYTES);
          const generatedSas = (0,_SAS__WEBPACK_IMPORTED_MODULE_8__.generateSas)(sasBytes);
          this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_SAS_READY, pId, generatedSas);
          if (keySent) {
            return;
          }
          const keyMessage = {
            [_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE]: OLM_MESSAGE_TYPE,
            olm: {
              type: OLM_MESSAGE_TYPES.SAS_KEY,
              data: {
                key: pubKey,
                transactionId
              }
            }
          };
          this._sendMessage(keyMessage, pId);
          olmData.sasVerification.keySent = true;
          break;
        }
        case OLM_MESSAGE_TYPES.SAS_MAC: {
          if (!olmData.session) {
            logger.debug(`Received sas mac message from ${pId} but we have no session for them!`);
            this._sendError(participant, "No session found while processing sas-mac");
            return;
          }
          const { keys, mac, transactionId } = msg.data;
          if (!mac || !keys) {
            logger.warn("Invalid SAS MAC message");
            return;
          }
          if (!olmData.sasVerification) {
            logger.warn(`SAS_MAC Participant ${pId} does not have valid sasVerification`);
            return;
          }
          const sas = olmData.sasVerification.sas;
          const baseInfo = `${OLM_KEY_VERIFICATION_MAC_INFO}${pId}${this.myId}${transactionId}`;
          const keysMac = sas.calculate_mac(
            Object.keys(mac).sort().join(","),
            baseInfo + OLM_KEY_VERIFICATION_MAC_KEY_IDS
          );
          if (keysMac !== keys) {
            logger.error("SAS verification error: keys MAC mismatch");
            this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_VERIFICATION_COMPLETED, pId, false, _E2EEErrors__WEBPACK_IMPORTED_MODULE_7__.E2EEErrors.E2EE_SAS_KEYS_MAC_MISMATCH);
            return;
          }
          if (!olmData.ed25519) {
            logger.warn("SAS verification error: Missing ed25519 key");
            this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_VERIFICATION_COMPLETED, pId, false, _E2EEErrors__WEBPACK_IMPORTED_MODULE_7__.E2EEErrors.E2EE_SAS_MISSING_KEY);
            return;
          }
          for (const [keyInfo, computedMac] of Object.entries(mac)) {
            const ourComputedMac = sas.calculate_mac(olmData.ed25519, baseInfo + keyInfo);
            if (computedMac !== ourComputedMac) {
              logger.error("SAS verification error: MAC mismatch");
              this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_VERIFICATION_COMPLETED, pId, false, _E2EEErrors__WEBPACK_IMPORTED_MODULE_7__.E2EEErrors.E2EE_SAS_MAC_MISMATCH);
              return;
            }
          }
          logger.info(`SAS MAC verified for participant ${pId}`);
          this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_VERIFICATION_COMPLETED, pId, true);
          break;
        }
      }
    });
  }
  _onParticipantLeft(id, participant) {
    logger.debug(`Participant ${id} left`);
    this.clearParticipantSession(participant);
  }
  _onParticipantPropertyChanged(participant, name, oldValue, newValue) {
    return __awaiter(this, void 0, void 0, function* () {
      const participantId = participant.getId();
      const olmData = this._getParticipantOlmData(participant);
      switch (name) {
        case "e2ee.enabled":
          if (newValue && this._conf.isE2EEEnabled()) {
            const localParticipantId = this._conf.myUserId();
            const participantFeatures = yield participant.getFeatures();
            if (participantFeatures.has(_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.FEATURE_E2EE) && localParticipantId < participantId) {
              if (this._sessionInitialization) {
                yield this._sessionInitialization;
              }
              yield this._sendSessionInit(participant);
              const uuid = (0,uuid__WEBPACK_IMPORTED_MODULE_9__.v4)();
              const d = new _util_Deferred__WEBPACK_IMPORTED_MODULE_4__["default"]();
              d.setRejectTimeout(REQ_TIMEOUT);
              d.catch(() => {
                this._reqs.delete(uuid);
                olmData.pendingSessionUuid = void 0;
              });
              this._reqs.set(uuid, d);
              const data = {
                [_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE]: OLM_MESSAGE_TYPE,
                olm: {
                  type: OLM_MESSAGE_TYPES.KEY_INFO,
                  data: {
                    ciphertext: this._encryptKeyInfo(olmData.session),
                    uuid
                  }
                }
              };
              this._sendMessage(data, participantId);
            }
          }
          break;
        case "e2ee.idKey.ed25519":
          olmData.ed25519 = newValue;
          this.eventEmitter.emit(OlmAdapterEvents.PARTICIPANT_SAS_AVAILABLE, participantId);
          break;
      }
    });
  }
  _sendError(participant, error) {
    const pId = participant.getId();
    const err = {
      [_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE]: OLM_MESSAGE_TYPE,
      olm: {
        type: OLM_MESSAGE_TYPES.ERROR,
        data: {
          error
        }
      }
    };
    this._sendMessage(err, pId);
  }
  _sendMessage(data, participantId) {
    this._conf.sendMessage(data, participantId);
  }
  _sendSessionInit(participant) {
    const pId = participant.getId();
    const olmData = this._getParticipantOlmData(participant);
    if (olmData.session) {
      logger.warn(`Tried to send session-init to ${pId} but we already have a session`);
      return Promise.reject();
    }
    if (olmData.pendingSessionUuid !== void 0) {
      logger.warn(`Tried to send session-init to ${pId} but we already have a pending session`);
      return Promise.reject();
    }
    this._olmAccount.generate_one_time_keys(1);
    const otKeys = JSON.parse(this._olmAccount.one_time_keys());
    const otKey = Object.values(otKeys.curve25519)[0];
    if (!otKey) {
      return Promise.reject(new Error("No one-time-keys generated"));
    }
    this._olmAccount.mark_keys_as_published();
    const uuid = (0,uuid__WEBPACK_IMPORTED_MODULE_9__.v4)();
    const init = {
      [_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE]: OLM_MESSAGE_TYPE,
      olm: {
        type: OLM_MESSAGE_TYPES.SESSION_INIT,
        data: {
          idKey: this._idKeys.curve25519,
          otKey,
          uuid
        }
      }
    };
    const d = new _util_Deferred__WEBPACK_IMPORTED_MODULE_4__["default"]();
    d.setRejectTimeout(REQ_TIMEOUT);
    d.catch(() => {
      this._reqs.delete(uuid);
      olmData.pendingSessionUuid = void 0;
    });
    this._reqs.set(uuid, d);
    this._sendMessage(init, pId);
    olmData.pendingSessionUuid = uuid;
    return d;
  }
  _sendSasMac(participant) {
    const pId = participant.getId();
    const olmData = this._getParticipantOlmData(participant);
    const { sas, transactionId } = olmData.sasVerification;
    const mac = {};
    const keyList = [];
    const baseInfo = `${OLM_KEY_VERIFICATION_MAC_INFO}${this.myId}${pId}${transactionId}`;
    const deviceKeyId = `ed25519:${pId}`;
    mac[deviceKeyId] = sas.calculate_mac(this._idKeys.ed25519, baseInfo + deviceKeyId);
    keyList.push(deviceKeyId);
    const keys = sas.calculate_mac(keyList.sort().join(","), baseInfo + OLM_KEY_VERIFICATION_MAC_KEY_IDS);
    const macMessage = {
      [_xmpp_xmpp__WEBPACK_IMPORTED_MODULE_6__.JITSI_MEET_MUC_TYPE]: OLM_MESSAGE_TYPE,
      olm: {
        type: OLM_MESSAGE_TYPES.SAS_MAC,
        data: {
          keys,
          mac,
          transactionId
        }
      }
    };
    this._sendMessage(macMessage, pId);
  }
  _computeCommitment(pubKey, data) {
    const olmUtil = new Olm.Utility();
    const commitment = olmUtil.sha256(pubKey + JSON.stringify(data));
    olmUtil.free();
    return commitment;
  }
}
function safeJsonParse(data) {
  try {
    return JSON.parse(data);
  } catch (e) {
    return {};
  }
}
OlmAdapter.events = OlmAdapterEvents;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/e2ee/SAS.js":
/*!*********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/e2ee/SAS.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateSas: () => (/* binding */ generateSas)
/* harmony export */ });

function generateDecimalSas(sasBytes) {
  return [
    (sasBytes[0] << 5 | sasBytes[1] >> 3) + 1e3,
    ((sasBytes[1] & 7) << 10 | sasBytes[2] << 2 | sasBytes[3] >> 6) + 1e3,
    ((sasBytes[3] & 63) << 7 | sasBytes[4] >> 1) + 1e3
  ];
}
const emojiMapping = [
  ["\u{1F436}", "dog"],
  ["\u{1F431}", "cat"],
  ["\u{1F981}", "lion"],
  ["\u{1F40E}", "horse"],
  ["\u{1F984}", "unicorn"],
  ["\u{1F437}", "pig"],
  ["\u{1F418}", "elephant"],
  ["\u{1F430}", "rabbit"],
  ["\u{1F43C}", "panda"],
  ["\u{1F413}", "rooster"],
  ["\u{1F427}", "penguin"],
  ["\u{1F422}", "turtle"],
  ["\u{1F41F}", "fish"],
  ["\u{1F419}", "octopus"],
  ["\u{1F98B}", "butterfly"],
  ["\u{1F337}", "flower"],
  ["\u{1F333}", "tree"],
  ["\u{1F335}", "cactus"],
  ["\u{1F344}", "mushroom"],
  ["\u{1F30F}", "globe"],
  ["\u{1F319}", "moon"],
  ["\u2601\uFE0F", "cloud"],
  ["\u{1F525}", "fire"],
  ["\u{1F34C}", "banana"],
  ["\u{1F34E}", "apple"],
  ["\u{1F353}", "strawberry"],
  ["\u{1F33D}", "corn"],
  ["\u{1F355}", "pizza"],
  ["\u{1F382}", "cake"],
  ["\u2764\uFE0F", "heart"],
  ["\u{1F642}", "smiley"],
  ["\u{1F916}", "robot"],
  ["\u{1F3A9}", "hat"],
  ["\u{1F453}", "glasses"],
  ["\u{1F527}", "spanner"],
  ["\u{1F385}", "santa"],
  ["\u{1F44D}", "thumbs up"],
  ["\u2602\uFE0F", "umbrella"],
  ["\u231B", "hourglass"],
  ["\u23F0", "clock"],
  ["\u{1F381}", "gift"],
  ["\u{1F4A1}", "light bulb"],
  ["\u{1F4D5}", "book"],
  ["\u270F\uFE0F", "pencil"],
  ["\u{1F4CE}", "paperclip"],
  ["\u2702\uFE0F", "scissors"],
  ["\u{1F512}", "lock"],
  ["\u{1F511}", "key"],
  ["\u{1F528}", "hammer"],
  ["\u260E\uFE0F", "telephone"],
  ["\u{1F3C1}", "flag"],
  ["\u{1F682}", "train"],
  ["\u{1F6B2}", "bicycle"],
  ["\u2708\uFE0F", "aeroplane"],
  ["\u{1F680}", "rocket"],
  ["\u{1F3C6}", "trophy"],
  ["\u26BD", "ball"],
  ["\u{1F3B8}", "guitar"],
  ["\u{1F3BA}", "trumpet"],
  ["\u{1F514}", "bell"],
  ["\u2693\uFE0F", "anchor"],
  ["\u{1F3A7}", "headphones"],
  ["\u{1F4C1}", "folder"],
  ["\u{1F4CC}", "pin"]
];
function generateEmojiSas(sasBytes) {
  const emojis = [
    sasBytes[0] >> 2,
    (sasBytes[0] & 3) << 4 | sasBytes[1] >> 4,
    (sasBytes[1] & 15) << 2 | sasBytes[2] >> 6,
    sasBytes[2] & 63,
    sasBytes[3] >> 2,
    (sasBytes[3] & 3) << 4 | sasBytes[4] >> 4,
    (sasBytes[4] & 15) << 2 | sasBytes[5] >> 6
  ];
  return emojis.map((num) => emojiMapping[num]);
}
const sasGenerators = {
  decimal: generateDecimalSas,
  emoji: generateEmojiSas
};
function generateSas(sasBytes) {
  const sas = {};
  for (const method in sasGenerators) {
    if (sasGenerators.hasOwnProperty(method)) {
      sas[method] = sasGenerators[method](sasBytes);
    }
  }
  return sas;
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/e2ee/crypto-utils.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/e2ee/crypto-utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),
/* harmony export */   importKey: () => (/* binding */ importKey),
/* harmony export */   ratchet: () => (/* binding */ ratchet)
/* harmony export */ });

var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function deriveKeys(material) {
  return __awaiter(this, void 0, void 0, function* () {
    const info = new ArrayBuffer();
    const textEncoder = new TextEncoder();
    const encryptionKey = yield crypto.subtle.deriveKey({
      name: "HKDF",
      salt: textEncoder.encode("JFrameEncryptionKey"),
      hash: "SHA-256",
      info
    }, material, {
      name: "AES-GCM",
      length: 128
    }, false, ["encrypt", "decrypt"]);
    return {
      material,
      encryptionKey
    };
  });
}
function ratchet(material) {
  return __awaiter(this, void 0, void 0, function* () {
    const textEncoder = new TextEncoder();
    return crypto.subtle.deriveBits({
      name: "HKDF",
      salt: textEncoder.encode("JFrameRatchetKey"),
      hash: "SHA-256",
      info: new ArrayBuffer()
    }, material, 256);
  });
}
function importKey(keyBytes) {
  return __awaiter(this, void 0, void 0, function* () {
    return crypto.subtle.importKey("raw", keyBytes, "HKDF", false, ["deriveBits", "deriveKey"]);
  });
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/e2eping/e2eping.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/e2eping/e2eping.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ E2ePing)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_e2eping_E2ePingEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/e2eping/E2ePingEvents */ "../../lib-jitsi-meet/dist/esm/service/e2eping/E2ePingEvents.js");




const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const E2E_PING_REQUEST = "e2e-ping-request";
const E2E_PING_RESPONSE = "e2e-ping-response";
const DEFAULT_NUM_REQUESTS = 5;
const DEFAULT_MAX_MESSAGES_PER_SECOND = 250;
const DEFAULT_MAX_CONFERENCE_SIZE = 200;
class ParticipantWrapper {
  constructor(participant, e2eping) {
    this.participant = participant;
    this.e2eping = e2eping;
    this.id = participant.getId();
    this.requests = {};
    this.lastRequestId = 1;
    this.sendRequest = this.sendRequest.bind(this);
    this.handleResponse = this.handleResponse.bind(this);
    this.maybeLogRttAndStop = this.maybeLogRttAndStop.bind(this);
    this.scheduleNext = this.scheduleNext.bind(this);
    this.stop = this.stop.bind(this);
    this.getDelay = this.getDelay.bind(this);
    this.timeout = this.scheduleNext();
  }
  scheduleNext() {
    return window.setTimeout(this.sendRequest, this.getDelay());
  }
  stop() {
    if (this.timeout) {
      window.clearTimeout(this.timeout);
    }
    this.e2eping.removeParticipant(this.id);
  }
  getDelay() {
    const conferenceSize = this.e2eping.conference.getParticipants().length;
    const endpointPairs = conferenceSize * (conferenceSize - 1) / 2;
    const totalMessages = endpointPairs * this.e2eping.numRequests;
    const totalSeconds = totalMessages / this.e2eping.maxMessagesPerSecond;
    const r = 1.5 - Math.random();
    const delayBetweenMessages = r * Math.max(1e3 * (totalSeconds / this.e2eping.numRequests), 1e3);
    return delayBetweenMessages;
  }
  sendRequest() {
    const requestId = this.lastRequestId++;
    const requestMessage = {
      type: E2E_PING_REQUEST,
      id: requestId
    };
    this.e2eping.sendMessage(requestMessage, this.id);
    this.requests[requestId] = {
      id: requestId,
      timeSent: window.performance.now()
    };
  }
  handleResponse(response) {
    const request = this.requests[response.id];
    if (request) {
      request.rtt = window.performance.now() - request.timeSent;
    }
    this.maybeLogRttAndStop();
  }
  maybeLogRttAndStop() {
    let rtt = Infinity;
    let request, requestId;
    let numRequestsWithResponses = 0;
    let totalNumRequests = 0;
    for (requestId in this.requests) {
      if (this.requests.hasOwnProperty(requestId)) {
        request = this.requests[requestId];
        totalNumRequests++;
        if (request.rtt) {
          numRequestsWithResponses++;
          rtt = Math.min(rtt, request.rtt);
        }
      }
    }
    if (numRequestsWithResponses >= this.e2eping.numRequests) {
      logger.info(`Measured RTT=${rtt} ms to ${this.id} (in ${this.participant.getProperty("region")})`);
      this.stop();
      this.e2eping.conference.eventEmitter.emit(_service_e2eping_E2ePingEvents__WEBPACK_IMPORTED_MODULE_2__.E2E_RTT_CHANGED, this.participant, rtt);
      return;
    } else if (totalNumRequests > 2 * this.e2eping.numRequests) {
      logger.info(`Stopping e2eping for ${this.id} because we sent ${totalNumRequests} with only ${numRequestsWithResponses} responses.`);
      this.stop();
      return;
    }
    this.timeout = this.scheduleNext();
  }
}
class E2ePing {
  constructor(conference, options, sendMessage) {
    this.conference = conference;
    this.eventEmitter = conference.eventEmitter;
    this.sendMessage = sendMessage;
    this.participants = {};
    this.numRequests = DEFAULT_NUM_REQUESTS;
    this.maxConferenceSize = DEFAULT_MAX_CONFERENCE_SIZE;
    this.maxMessagesPerSecond = DEFAULT_MAX_MESSAGES_PER_SECOND;
    if (options && options.e2eping) {
      if (typeof options.e2eping.numRequests === "number") {
        this.numRequests = options.e2eping.numRequests;
      }
      if (typeof options.e2eping.maxConferenceSize === "number") {
        this.maxConferenceSize = options.e2eping.maxConferenceSize;
      }
      if (typeof options.e2eping.maxMessagesPerSecond === "number") {
        this.maxMessagesPerSecond = options.e2eping.maxMessagesPerSecond;
      }
    }
    logger.info(`Initializing e2e ping with numRequests=${this.numRequests}, maxConferenceSize=${this.maxConferenceSize}, maxMessagesPerSecond=${this.maxMessagesPerSecond}.`);
    this.participantJoined = this.participantJoined.bind(this);
    this.participantLeft = this.participantLeft.bind(this);
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.USER_LEFT, this.participantLeft);
    this.messageReceived = this.messageReceived.bind(this);
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.ENDPOINT_MESSAGE_RECEIVED, this.messageReceived);
    this.conferenceJoined = this.conferenceJoined.bind(this);
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.CONFERENCE_JOINED, this.conferenceJoined);
  }
  conferenceJoined() {
    this.conference.getParticipants().forEach((p) => this.participantJoined(p.getId(), p));
    this.conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.USER_JOINED, this.participantJoined);
  }
  messageReceived(participant, payload) {
    if (payload.type === E2E_PING_REQUEST) {
      this.handleRequest(participant.getId(), payload);
    } else if (payload.type === E2E_PING_RESPONSE) {
      this.handleResponse(participant.getId(), payload);
    }
  }
  participantJoined(id, participant) {
    if (this.participants[id]) {
      logger.info(`Participant wrapper already exists for ${id}. Clearing.`);
      this.participants[id].stop();
    }
    if (this.conference.getParticipants().length > this.maxConferenceSize) {
      return;
    }
    if (this.conference.myUserId() > id) {
      logger.info(`Starting e2eping for participant ${id}`);
      this.participants[id] = new ParticipantWrapper(participant, this);
    }
  }
  removeParticipant(id) {
    if (this.participants[id]) {
      delete this.participants[id];
    }
  }
  participantLeft(id) {
    if (this.participants[id]) {
      this.participants[id].stop();
      delete this.participants[id];
    }
  }
  handleRequest(participantId, request) {
    if (request && request.id) {
      const response = {
        type: E2E_PING_RESPONSE,
        id: request.id
      };
      this.sendMessage(response, participantId);
    } else {
      logger.info(`Received an invalid e2e ping request from ${participantId}.`);
    }
  }
  handleResponse(participantId, response) {
    const participantWrapper = this.participants[participantId];
    if (participantWrapper) {
      participantWrapper.handleResponse(response);
    }
  }
  stop() {
    logger.info("Stopping e2eping");
    this.conference.off(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.USER_JOINED, this.participantJoined);
    this.conference.off(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.USER_LEFT, this.participantLeft);
    this.conference.off(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.ENDPOINT_MESSAGE_RECEIVED, this.messageReceived);
    for (const id in this.participants) {
      if (this.participants.hasOwnProperty(id)) {
        this.participants[id].stop();
      }
    }
    this.participants = {};
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/event/Jvb121EventGenerator.js":
/*!***************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/event/Jvb121EventGenerator.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Jvb121EventGenerator)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");



const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class Jvb121EventGenerator {
  constructor(conference) {
    this._conference = conference;
    this._jvb121 = true;
    this._conference.addEventListener(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.USER_JOINED, () => this.evaluateStatus());
    this._conference.addEventListener(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.USER_LEFT, () => this.evaluateStatus());
    this._conference.addEventListener(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.P2P_STATUS, () => this.evaluateStatus());
  }
  evaluateStatus() {
    const oldStatus = this._jvb121;
    const newStatus = !this._conference.isP2PActive() && this._conference.getParticipantCount() <= 2;
    if (oldStatus !== newStatus) {
      this._jvb121 = newStatus;
      logger.debug(`JVB121 status ${oldStatus} => ${newStatus}`);
      this._conference.eventEmitter.emit(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.JVB121_STATUS, oldStatus, newStatus);
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");


class FeatureFlags {
  init(flags) {
    var _a;
    this._runInLiteMode = Boolean(flags.runInLiteMode);
    this._ssrcRewriting = Boolean(flags.ssrcRewritingEnabled);
    this._joinAsVisitor = Boolean((_a = flags.enableJoinAsVisitor) !== null && _a !== void 0 ? _a : true);
  }
  isMultiStreamSendSupportEnabled() {
    return _browser__WEBPACK_IMPORTED_MODULE_0__["default"].supportsUnifiedPlan();
  }
  isRunInLiteModeEnabled() {
    return this._runInLiteMode && _browser__WEBPACK_IMPORTED_MODULE_0__["default"].supportsInsertableStreams();
  }
  isSsrcRewritingSupported() {
    return this._ssrcRewriting;
  }
  isJoinAsVisitorSupported() {
    return this._joinAsVisitor;
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new FeatureFlags());


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/litemode/LiteModeContext.js":
/*!*************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/litemode/LiteModeContext.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LiteModeContext: () => (/* binding */ LiteModeContext)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");




const kJitsiLiteMode = Symbol("kJitsiLiteMode");
const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class LiteModeContext {
  constructor(conference) {
    this.enabled = _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_2__["default"].isRunInLiteModeEnabled();
    if (!this.enabled) {
      return;
    }
    conference.rtc.on(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].REMOTE_TRACK_ADDED, (track, tpc) => this._setupLiteModeForTrack(tpc, track));
  }
  _setupLiteModeForTrack(tpc, track) {
    if (!this.enabled) {
      return;
    }
    const receiver = tpc.findReceiverForTrack(track.track);
    if (!receiver) {
      logger.warn(`Could not set up lite mode for ${track}: receiver not found in: ${tpc}`);
      return;
    }
    if (receiver[kJitsiLiteMode]) {
      return;
    }
    receiver[kJitsiLiteMode] = true;
    const receiverStreams = receiver.createEncodedStreams();
    const transformStream = new TransformStream({
      transform: () => {
      }
    });
    receiverStreams.readable.pipeThrough(transformStream).pipeTo(receiverStreams.writable);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/proxyconnection/CustomSignalingLayer.js":
/*!*************************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/proxyconnection/CustomSignalingLayer.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CustomSignalingLayer)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/SignalingLayer */ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingLayer.js");



const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class CustomSignalingLayer extends _service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();
    this.ssrcOwners = /* @__PURE__ */ new Map();
    this.chatRoom = null;
  }
  getPeerMediaInfo(owner, mediaType, sourceName) {
    return {};
  }
  getPeerSourceInfo(owner, sourceName) {
    return void 0;
  }
  getSSRCOwner(ssrc) {
    return this.ssrcOwners.get(ssrc);
  }
  getTrackSourceName(ssrc) {
    return void 0;
  }
  removeSSRCOwners(ssrcList) {
    if (!(ssrcList === null || ssrcList === void 0 ? void 0 : ssrcList.length)) {
      return;
    }
    for (const ssrc of ssrcList) {
      this.ssrcOwners.delete(ssrc);
    }
  }
  setChatRoom(room) {
    this.chatRoom = room;
  }
  setSSRCOwner(ssrc, endpointId) {
    if (typeof ssrc !== "number") {
      throw new TypeError(`SSRC(${ssrc}) must be a number`);
    }
    const existingOwner = this.ssrcOwners.get(ssrc);
    if (existingOwner && existingOwner !== endpointId) {
      logger.error(`SSRC owner re-assigned from ${existingOwner} to ${endpointId}`);
    }
    this.ssrcOwners.set(ssrc, endpointId);
  }
  setTrackMuteStatus(sourceName, muted) {
    return false;
  }
  setTrackVideoType(sourceName, videoType) {
    return false;
  }
  setTrackSourceName(ssrc, sourceName) {
  }
  updateSsrcOwnersOnLeave(id) {
    const ssrcs = Array.from(this.ssrcOwners).filter((entry) => entry[1] === id).map((entry) => entry[0]);
    if (!(ssrcs === null || ssrcs === void 0 ? void 0 : ssrcs.length)) {
      return;
    }
    this.removeSSRCOwners(ssrcs);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/proxyconnection/ProxyConnectionPC.js":
/*!**********************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/proxyconnection/ProxyConnectionPC.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProxyConnectionPC)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _RTC_RTC__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../RTC/RTC */ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTC.js");
/* harmony import */ var _xmpp_JingleSessionPC__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../xmpp/JingleSessionPC */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleSessionPC.js");
/* harmony import */ var _xmpp_xmpp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../xmpp/xmpp */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/xmpp.js");
/* harmony import */ var _CustomSignalingLayer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CustomSignalingLayer */ "../../lib-jitsi-meet/dist/esm/modules/proxyconnection/CustomSignalingLayer.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants */ "../../lib-jitsi-meet/dist/esm/modules/proxyconnection/constants.js");









const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class ProxyConnectionPC {
  constructor(options = {}) {
    this._options = Object.assign({ pcConfig: {}, isInitiator: false, receiveAudio: false, receiveVideo: false }, options);
    this._tracks = [];
    this._peerConnection = null;
    this._onError = this._onError.bind(this);
    this._onRemoteStream = this._onRemoteStream.bind(this);
    this._onSendMessage = this._onSendMessage.bind(this);
  }
  getPeerJid() {
    return this._options.peerJid;
  }
  processMessage($jingle) {
    switch ($jingle.attr("action")) {
      case _constants__WEBPACK_IMPORTED_MODULE_7__.ACTIONS.ACCEPT:
        this._onSessionAccept($jingle);
        break;
      case _constants__WEBPACK_IMPORTED_MODULE_7__.ACTIONS.INITIATE:
        this._onSessionInitiate($jingle);
        break;
      case _constants__WEBPACK_IMPORTED_MODULE_7__.ACTIONS.TERMINATE:
        this._onSessionTerminate($jingle);
        break;
      case _constants__WEBPACK_IMPORTED_MODULE_7__.ACTIONS.TRANSPORT_INFO:
        this._onTransportInfo($jingle);
        break;
    }
  }
  start(localTracks = []) {
    if (this._peerConnection) {
      return;
    }
    this._tracks = this._tracks.concat(localTracks);
    this._peerConnection = this._createPeerConnection();
    this._peerConnection.invite(localTracks);
  }
  stop() {
    if (this._peerConnection) {
      this._peerConnection.terminate();
    }
    this._onSessionTerminate();
  }
  _createPeerConnection() {
    const configStub = {};
    const connectionStub = {
      connected: true,
      jingle: {
        terminate: () => {
        }
      },
      sendIQ: this._onSendMessage,
      addEventListener: () => () => {
      }
    };
    const pcConfigStub = Object.assign({ iceServers: _xmpp_xmpp__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_STUN_SERVERS }, this._options.pcConfig);
    const emitter = (event) => {
      switch (event) {
        case _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.CONNECTION_ICE_FAILED:
        case _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.CONNECTION_FAILED:
          this._onError(_constants__WEBPACK_IMPORTED_MODULE_7__.ACTIONS.CONNECTION_ERROR, event);
          break;
      }
    };
    const roomStub = {
      addEventListener: () => {
      },
      addPresenceListener: () => {
      },
      connectionTimes: [],
      eventEmitter: { emit: emitter },
      removeEventListener: () => {
      },
      removePresenceListener: () => {
      },
      supportsRestartByTerminate: () => false
    };
    const conferenceStub = {
      myUserId: () => ""
    };
    this._rtc = new _RTC_RTC__WEBPACK_IMPORTED_MODULE_3__["default"](conferenceStub, {});
    this._rtc.addListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].REMOTE_TRACK_ADDED, this._onRemoteStream);
    const peerConnection = new _xmpp_JingleSessionPC__WEBPACK_IMPORTED_MODULE_4__["default"](
      void 0,
      void 0,
      this._options.peerJid,
      connectionStub,
      {
        offerToReceiveAudio: this._options.receiveAudio,
        offerToReceiveVideo: this._options.receiveVideo
      },
      pcConfigStub,
      true,
      this._options.isInitiator
    );
    const signalingLayer = new _CustomSignalingLayer__WEBPACK_IMPORTED_MODULE_6__["default"]();
    signalingLayer.setChatRoom(roomStub);
    peerConnection.initialize(roomStub, this._rtc, signalingLayer, configStub);
    return peerConnection;
  }
  _onError(errorType, details = "") {
    this._options.onError(this._options.peerJid, errorType, details);
  }
  _onRemoteStream(jitsiRemoteTrack) {
    this._tracks.push(jitsiRemoteTrack);
    this._options.onRemoteStream(jitsiRemoteTrack);
  }
  _onSendMessage(iq) {
    this._options.onSendMessage(this._options.peerJid, iq);
  }
  _onSessionAccept($jingle) {
    if (!this._peerConnection) {
      logger.error("Received an answer when no peer connection exists.");
      return;
    }
    this._peerConnection.setAnswer($jingle);
  }
  _onSessionInitiate($jingle) {
    if (this._peerConnection) {
      logger.error("Received an offer when an offer was already sent.");
      return;
    }
    this._peerConnection = this._createPeerConnection();
    this._peerConnection.acceptOffer($jingle, () => {
    }, () => this._onError(this._options.peerJid, _constants__WEBPACK_IMPORTED_MODULE_7__.ACTIONS.CONNECTION_ERROR, "session initiate error"));
  }
  _onSessionTerminate() {
    this._tracks.forEach((track) => track.dispose());
    this._tracks = [];
    if (this._peerConnection) {
      this._peerConnection.onTerminated();
    }
    if (this._rtc) {
      this._rtc.removeListener(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_1__["default"].REMOTE_TRACK_ADDED, this._onRemoteStream);
      this._rtc.destroy();
    }
  }
  _onTransportInfo($jingle) {
    this._peerConnection.addIceCandidates($jingle);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/proxyconnection/ProxyConnectionService.js":
/*!***************************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/proxyconnection/ProxyConnectionService.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProxyConnectionService)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/RTC/SignalingLayer */ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingLayer.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _RTC_RTC__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../RTC/RTC */ "../../lib-jitsi-meet/dist/esm/modules/RTC/RTC.js");
/* harmony import */ var _ProxyConnectionPC__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ProxyConnectionPC */ "../../lib-jitsi-meet/dist/esm/modules/proxyconnection/ProxyConnectionPC.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./constants */ "../../lib-jitsi-meet/dist/esm/modules/proxyconnection/constants.js");

var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};









const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class ProxyConnectionService {
  constructor(options = {}) {
    const { jitsiConnection } = options, otherOptions = __rest(options, ["jitsiConnection"]);
    this._options = Object.assign({ pcConfig: jitsiConnection && jitsiConnection.xmpp.connection.jingle.p2pIceConfig }, otherOptions);
    this._peerConnection = null;
    this._onFatalError = this._onFatalError.bind(this);
    this._onSendMessage = this._onSendMessage.bind(this);
    this._onRemoteStream = this._onRemoteStream.bind(this);
  }
  processMessage(message) {
    const peerJid = message.from;
    if (!peerJid) {
      return;
    }
    if (this._peerConnection && this._peerConnection.getPeerJid() !== peerJid) {
      this._onFatalError(peerJid, _constants__WEBPACK_IMPORTED_MODULE_8__.ACTIONS.CONNECTION_ERROR, "rejected");
      return;
    }
    const iq = this._convertStringToXML(message.data.iq);
    const $jingle = iq && iq.find("jingle");
    const action = $jingle && $jingle.attr("action");
    if (action === _constants__WEBPACK_IMPORTED_MODULE_8__.ACTIONS.INITIATE) {
      this._peerConnection = this._createPeerConnection(peerJid, {
        isInitiator: false,
        receiveVideo: true
      });
    }
    if (this._peerConnection) {
      this._peerConnection.processMessage($jingle);
    }
    if (action === _constants__WEBPACK_IMPORTED_MODULE_8__.ACTIONS.CONNECTION_ERROR || action === _constants__WEBPACK_IMPORTED_MODULE_8__.ACTIONS.UNAVAILABLE || action === _constants__WEBPACK_IMPORTED_MODULE_8__.ACTIONS.TERMINATE) {
      this._selfCloseConnection();
    }
    return;
  }
  start(peerJid, localTracks = []) {
    this._peerConnection = this._createPeerConnection(peerJid, {
      isInitiator: true,
      receiveVideo: false
    });
    localTracks.forEach((localTrack, localTrackIndex) => {
      const localSourceNameTrack = (0,_service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_4__.getSourceNameForJitsiTrack)("peer", localTrack.getType(), localTrackIndex);
      localTrack.setSourceName(localSourceNameTrack);
    });
    this._peerConnection.start(localTracks);
  }
  stop() {
    if (this._peerConnection) {
      this._peerConnection.stop();
    }
    this._peerConnection = null;
  }
  _convertStringToXML(xml) {
    try {
      const xmlDom = new DOMParser().parseFromString(xml, "text/xml");
      return jquery__WEBPACK_IMPORTED_MODULE_1___default()(xmlDom);
    } catch (e) {
      logger.error("Attempted to convert incorrectly formatted xml");
      return null;
    }
  }
  _createPeerConnection(peerJid, options = {}) {
    if (!peerJid) {
      throw new Error("Cannot create ProxyConnectionPC without a peer.");
    }
    const pcOptions = Object.assign({ pcConfig: this._options.pcConfig, onError: this._onFatalError, onRemoteStream: this._onRemoteStream, onSendMessage: this._onSendMessage, peerJid }, options);
    return new _ProxyConnectionPC__WEBPACK_IMPORTED_MODULE_7__["default"](pcOptions);
  }
  _onFatalError(peerJid, errorType, details = "") {
    logger.error("Received a proxy connection error", peerJid, errorType, details);
    const iq = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      to: peerJid,
      type: "set"
    }).c("jingle", {
      xmlns: "urn:xmpp:jingle:1",
      action: errorType
    }).c("details").t(details).up();
    this._onSendMessage(peerJid, iq);
    if (this._peerConnection && this._peerConnection.getPeerJid() === peerJid) {
      this._selfCloseConnection();
    }
  }
  _onRemoteStream(jitsiRemoteTrack) {
    if (!this._options.onRemoteStream) {
      logger.error("Remote track received without callback.");
      jitsiRemoteTrack.dispose();
      return;
    }
    const isVideo = jitsiRemoteTrack.isVideoTrack();
    let videoType;
    if (isVideo) {
      videoType = this._options.convertVideoToDesktop ? _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__.VideoType.DESKTOP : _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__.VideoType.CAMERA;
    }
    const mediaStream = jitsiRemoteTrack.getOriginalStream();
    const jitsiLocalTracks = _RTC_RTC__WEBPACK_IMPORTED_MODULE_6__["default"].createLocalTracks([
      {
        deviceId: `proxy:${this._peerConnection.getPeerJid()}`,
        mediaType: isVideo ? _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO : _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.AUDIO,
        sourceType: "proxy",
        stream: mediaStream,
        track: mediaStream.getVideoTracks()[0],
        videoType
      }
    ]);
    this._options.onRemoteStream(jitsiLocalTracks[0]);
  }
  _onSendMessage(peerJid, iq) {
    if (!this._options.onSendMessage) {
      return;
    }
    try {
      const stringifiedIq = new XMLSerializer().serializeToString(iq.nodeTree || iq);
      this._options.onSendMessage(peerJid, { iq: stringifiedIq });
    } catch (e) {
      logger.error("Attempted to send an incorrectly formatted iq.");
    }
  }
  _selfCloseConnection() {
    this.stop();
    this._options.onConnectionClosed && this._options.onConnectionClosed();
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/proxyconnection/constants.js":
/*!**************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/proxyconnection/constants.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ACTIONS: () => (/* binding */ ACTIONS)
/* harmony export */ });

var ACTIONS;
(function(ACTIONS2) {
  ACTIONS2["ACCEPT"] = "session-accept";
  ACTIONS2["CONNECTION_ERROR"] = "connection-error-encountered";
  ACTIONS2["INITIATE"] = "session-initiate";
  ACTIONS2["TERMINATE"] = "session-terminate";
  ACTIONS2["TRANSPORT_INFO"] = "transport-info";
  ACTIONS2["UNAVAILABLE"] = "unavailable";
})(ACTIONS || (ACTIONS = {}));
;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/qualitycontrol/ReceiveVideoController.js":
/*!**************************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/qualitycontrol/ReceiveVideoController.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReceiveVideoController)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.isequal */ "../../lib-jitsi-meet/node_modules/lodash.isequal/index.js");
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");





const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const MAX_HEIGHT = 2160;
const LASTN_UNLIMITED = -1;
const ASSUMED_BANDWIDTH_BPS = -1;
class ReceiverVideoConstraints {
  constructor(options) {
    const { lastN, assumedBandwidthBps } = options;
    this._lastN = lastN !== null && lastN !== void 0 ? lastN : LASTN_UNLIMITED;
    this._maxFrameHeight = MAX_HEIGHT;
    this._assumedBandwidthBps = assumedBandwidthBps !== null && assumedBandwidthBps !== void 0 ? assumedBandwidthBps : ASSUMED_BANDWIDTH_BPS;
    this._receiverVideoConstraints = {
      assumedBandwidthBps: this._assumedBandwidthBps,
      constraints: {},
      defaultConstraints: { "maxHeight": this._maxFrameHeight },
      lastN: this._lastN
    };
  }
  get constraints() {
    this._receiverVideoConstraints.assumedBandwidthBps = this._assumedBandwidthBps;
    this._receiverVideoConstraints.lastN = this._lastN;
    const individualConstraints = this._receiverVideoConstraints.constraints;
    if (individualConstraints && Object.keys(individualConstraints).length) {
      for (const [key, value] of Object.entries(individualConstraints)) {
        value.maxHeight = this._maxFrameHeight;
      }
    } else {
      this._receiverVideoConstraints.defaultConstraints = { "maxHeight": this._maxFrameHeight };
    }
    return this._receiverVideoConstraints;
  }
  updateAssumedBandwidthBps(assumedBandwidthBps) {
    const changed = this._assumedBandwidthBps !== assumedBandwidthBps;
    if (changed) {
      this._assumedBandwidthBps = assumedBandwidthBps;
      logger.debug(`Updating receive assumedBandwidthBps: ${assumedBandwidthBps}`);
    }
    return changed;
  }
  updateLastN(value) {
    const changed = this._lastN !== value;
    if (changed) {
      this._lastN = value;
      logger.debug(`Updating ReceiverVideoConstraints lastN(${value})`);
    }
    return changed;
  }
  updateReceiveResolution(maxFrameHeight) {
    const changed = this._maxFrameHeight !== maxFrameHeight;
    if (changed) {
      this._maxFrameHeight = maxFrameHeight;
      logger.debug(`Updating receive maxFrameHeight: ${maxFrameHeight}`);
    }
    return changed;
  }
  updateReceiverVideoConstraints(videoConstraints) {
    var _a;
    const changed = !lodash_isequal__WEBPACK_IMPORTED_MODULE_1___default()(this._receiverVideoConstraints, videoConstraints);
    if (changed) {
      this._receiverVideoConstraints = videoConstraints;
      if ((_a = videoConstraints.defaultConstraints) === null || _a === void 0 ? void 0 : _a.maxHeight) {
        this.updateReceiveResolution(videoConstraints.defaultConstraints.maxHeight);
      }
      logger.debug(`Updating ReceiverVideoConstraints ${JSON.stringify(videoConstraints)}`);
    }
    return changed;
  }
}
class ReceiveVideoController {
  constructor(conference, rtc) {
    var _a;
    this._conference = conference;
    this._rtc = rtc;
    const { config } = conference.options;
    this._lastN = (_a = config === null || config === void 0 ? void 0 : config.startLastN) !== null && _a !== void 0 ? _a : (config === null || config === void 0 ? void 0 : config.channelLastN) || LASTN_UNLIMITED;
    this._maxFrameHeight = MAX_HEIGHT;
    this._sourceReceiverConstraints = /* @__PURE__ */ new Map();
    this._assumedBandwidthBps = ASSUMED_BANDWIDTH_BPS;
    this._receiverVideoConstraints = new ReceiverVideoConstraints({
      lastN: this._lastN,
      assumedBandwidthBps: this._assumedBandwidthBps
    });
    this._conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__._MEDIA_SESSION_STARTED, (session) => this._onMediaSessionStarted(session));
  }
  _getDefaultSourceReceiverConstraints(mediaSession, maxFrameHeight) {
    var _a;
    const height = maxFrameHeight !== null && maxFrameHeight !== void 0 ? maxFrameHeight : MAX_HEIGHT;
    const remoteVideoTracks = ((_a = mediaSession.peerconnection) === null || _a === void 0 ? void 0 : _a.getRemoteTracks(null, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO)) || [];
    const receiverConstraints = /* @__PURE__ */ new Map();
    for (const track of remoteVideoTracks) {
      receiverConstraints.set(track.getSourceName(), height);
    }
    return receiverConstraints;
  }
  _onMediaSessionStarted(mediaSession) {
    if (mediaSession.isP2P) {
      mediaSession.setReceiverVideoConstraint(this._getDefaultSourceReceiverConstraints(mediaSession));
    } else {
      this._rtc.setReceiverVideoConstraints(this._receiverVideoConstraints.constraints);
    }
  }
  getLastN() {
    return this._lastN;
  }
  setAssumedBandwidthBps(assumedBandwidthBps) {
    if (this._receiverVideoConstraints.updateAssumedBandwidthBps(assumedBandwidthBps)) {
      this._rtc.setReceiverVideoConstraints(this._receiverVideoConstraints.constraints);
    }
  }
  setLastN(value) {
    if (this._lastN !== value) {
      this._lastN = value;
      if (this._receiverVideoConstraints.updateLastN(value)) {
        this._rtc.setReceiverVideoConstraints(this._receiverVideoConstraints.constraints);
      }
    }
  }
  setPreferredReceiveMaxFrameHeight(maxFrameHeight) {
    this._maxFrameHeight = maxFrameHeight;
    for (const session of this._conference.getMediaSessions()) {
      if (session.isP2P) {
        session.setReceiverVideoConstraint(this._getDefaultSourceReceiverConstraints(session, maxFrameHeight));
      } else if (this._receiverVideoConstraints.updateReceiveResolution(maxFrameHeight)) {
        this._rtc.setReceiverVideoConstraints(this._receiverVideoConstraints.constraints);
      }
    }
  }
  setReceiverConstraints(constraints) {
    var _a, _b;
    if (!constraints) {
      return;
    }
    const isEndpointsFormat = Object.keys(constraints).includes("onStageEndpoints", "selectedEndpoints");
    if (isEndpointsFormat) {
      throw new Error('"onStageEndpoints" and "selectedEndpoints" are not supported when sourceNameSignaling is enabled.');
    }
    const constraintsChanged = this._receiverVideoConstraints.updateReceiverVideoConstraints(constraints);
    if (constraintsChanged) {
      this._assumedBandwidthBps = (_a = constraints.assumedBandwidthBps) !== null && _a !== void 0 ? _a : this._assumedBandwidthBps;
      this._lastN = (_b = constraints.lastN) !== null && _b !== void 0 ? _b : this._lastN;
      this._rtc.setReceiverVideoConstraints(constraints);
      const p2pSession = this._conference.getMediaSessions().find((session) => session.isP2P);
      if (!p2pSession || !constraints.constraints) {
        return;
      }
      const mappedConstraints = Array.from(Object.entries(constraints.constraints)).map((constraint) => {
        constraint[1] = constraint[1].maxHeight;
        return constraint;
      });
      this._sourceReceiverConstraints = new Map(mappedConstraints);
      p2pSession.setReceiverVideoConstraint(this._sourceReceiverConstraints);
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/qualitycontrol/SendVideoController.js":
/*!***********************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/qualitycontrol/SendVideoController.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SendVideoController)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/RTCEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js");
/* harmony import */ var _xmpp_MediaSessionEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../xmpp/MediaSessionEvents */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/MediaSessionEvents.js");





const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const MAX_LOCAL_RESOLUTION = 2160;
class SendVideoController {
  constructor(conference, rtc) {
    this._conference = conference;
    this._preferredSendMaxFrameHeight = MAX_LOCAL_RESOLUTION;
    this._rtc = rtc;
    this._sourceSenderConstraints = /* @__PURE__ */ new Map();
    this._conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__._MEDIA_SESSION_STARTED, (session) => this._onMediaSessionStarted(session));
    this._conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__._MEDIA_SESSION_ACTIVE_CHANGED, () => this._configureConstraintsForLocalSources());
    this._rtc.on(_service_RTC_RTCEvents__WEBPACK_IMPORTED_MODULE_2__["default"].SENDER_VIDEO_CONSTRAINTS_CHANGED, (videoConstraints) => this._onSenderConstraintsReceived(videoConstraints));
  }
  _configureConstraintsForLocalSources() {
    for (const track of this._rtc.getLocalVideoTracks()) {
      const sourceName = track.getSourceName();
      sourceName && this._propagateSendMaxFrameHeight(sourceName);
    }
  }
  _onMediaSessionStarted(mediaSession) {
    mediaSession.addListener(_xmpp_MediaSessionEvents__WEBPACK_IMPORTED_MODULE_3__["default"].REMOTE_SOURCE_CONSTRAINTS_CHANGED, (session, sourceConstraints) => {
      session === this._conference.getActiveMediaSession() && sourceConstraints.forEach((constraint) => this._onSenderConstraintsReceived(constraint));
    });
  }
  _onSenderConstraintsReceived(videoConstraints) {
    var _a;
    const { maxHeight, sourceName } = videoConstraints;
    const localVideoTracks = (_a = this._conference.getLocalVideoTracks()) !== null && _a !== void 0 ? _a : [];
    for (const track of localVideoTracks) {
      if (track.getSourceName() === sourceName && this._sourceSenderConstraints.get(sourceName) !== maxHeight) {
        this._sourceSenderConstraints.set(sourceName, maxHeight === -1 ? Math.min(MAX_LOCAL_RESOLUTION, this._preferredSendMaxFrameHeight) : maxHeight);
        logger.debug(`Sender constraints for source:${sourceName} changed to maxHeight:${maxHeight}`);
        this._propagateSendMaxFrameHeight(sourceName);
      }
    }
  }
  _propagateSendMaxFrameHeight(sourceName) {
    if (!sourceName) {
      throw new Error("sourceName missing for calculating the sendMaxHeight for video tracks");
    }
    const sendMaxFrameHeight = this._selectSendMaxFrameHeight(sourceName);
    const promises = [];
    if (sendMaxFrameHeight >= 0) {
      for (const session of this._conference.getMediaSessions()) {
        promises.push(session.setSenderVideoConstraint(sendMaxFrameHeight, sourceName));
      }
    }
    return Promise.all(promises);
  }
  _selectSendMaxFrameHeight(sourceName) {
    if (!sourceName) {
      throw new Error("sourceName missing for calculating the sendMaxHeight for video tracks");
    }
    const activeMediaSession = this._conference.getActiveMediaSession();
    const remoteRecvMaxFrameHeight = activeMediaSession ? this._sourceSenderConstraints.get(sourceName) : void 0;
    if (this._preferredSendMaxFrameHeight >= 0 && remoteRecvMaxFrameHeight >= 0) {
      return Math.min(this._preferredSendMaxFrameHeight, remoteRecvMaxFrameHeight);
    } else if (remoteRecvMaxFrameHeight >= 0) {
      return remoteRecvMaxFrameHeight;
    }
    return this._preferredSendMaxFrameHeight;
  }
  setPreferredSendMaxFrameHeight(maxFrameHeight) {
    this._preferredSendMaxFrameHeight = maxFrameHeight;
    const promises = [];
    for (const sourceName of this._sourceSenderConstraints.keys()) {
      promises.push(this._propagateSendMaxFrameHeight(sourceName));
    }
    return Promise.allSettled(promises);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/recording/JibriSession.js":
/*!***********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/recording/JibriSession.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JibriSession)
/* harmony export */ });
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _recordingXMLUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./recordingXMLUtils */ "../../lib-jitsi-meet/dist/esm/modules/recording/recordingXMLUtils.js");



class JibriSession {
  constructor(options = {}) {
    this._connection = options.connection;
    this._mode = options.mode;
    this._jibriJid = null;
    this._statusFromJicofo = "";
    this._setSessionID(options.sessionID);
    this.setStatus(options.status);
  }
  getError() {
    return this._error;
  }
  getID() {
    return this._sessionID;
  }
  getInitiator() {
    return this._initiator;
  }
  getLiveStreamViewURL() {
    return this._liveStreamViewURL;
  }
  getStatus() {
    if (this._status) {
      return this._status;
    }
    return this._statusFromJicofo;
  }
  getJibriJid() {
    return this._jibriJid;
  }
  getTerminator() {
    return this._terminator;
  }
  getMode() {
    return this._mode;
  }
  setError(error) {
    this._error = error;
  }
  setLiveStreamViewURL(url) {
    this._liveStreamViewURL = url;
  }
  setStatus(status) {
    this._status = status;
  }
  setStatusFromJicofo(status) {
    this._statusFromJicofo = status;
  }
  setJibriJid(jibriJid) {
    this._jibriJid = jibriJid;
  }
  setInitiator(participant) {
    this._initiator = participant;
  }
  setTerminator(participant) {
    this._terminator = participant;
  }
  start({ appData, broadcastId, focusMucJid, streamId }) {
    return new Promise((resolve, reject) => {
      this._connection.sendIQ(this._createIQ({
        action: "start",
        appData,
        focusMucJid,
        broadcastId,
        streamId
      }), (result) => {
        this.setStatus("pending");
        this._setSessionID(_recordingXMLUtils__WEBPACK_IMPORTED_MODULE_1__["default"].getSessionIdFromIq(result));
        resolve();
      }, (error) => {
        this._setErrorFromIq(error);
        reject(error);
      });
    });
  }
  stop({ focusMucJid }) {
    return new Promise((resolve, reject) => {
      this._connection.sendIQ(this._createIQ({
        action: "stop",
        focusMucJid
      }), resolve, reject);
    });
  }
  _createIQ({ action, appData, broadcastId, focusMucJid, streamId }) {
    return (0,strophe_js__WEBPACK_IMPORTED_MODULE_0__.$iq)({
      to: focusMucJid,
      type: "set"
    }).c("jibri", {
      "xmlns": "http://jitsi.org/protocol/jibri",
      "action": action,
      "app_data": appData,
      "recording_mode": this._mode,
      "streamid": streamId,
      "you_tube_broadcast_id": broadcastId
    }).up();
  }
  _setErrorFromIq(errorIq) {
    const error = errorIq.getElementsByTagName("error")[0];
    this.setError(error.children[0].tagName);
  }
  _setSessionID(sessionID) {
    this._sessionID = sessionID;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/recording/RecordingManager.js":
/*!***************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/recording/RecordingManager.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _JibriSession__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JibriSession */ "../../lib-jitsi-meet/dist/esm/modules/recording/JibriSession.js");
/* harmony import */ var _recordingXMLUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./recordingXMLUtils */ "../../lib-jitsi-meet/dist/esm/modules/recording/recordingXMLUtils.js");





const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class RecordingManager {
  constructor(chatRoom) {
    this._sessions = {};
    this._chatRoom = chatRoom;
    this.onPresence = this.onPresence.bind(this);
    this.onMemberLeft = this.onMemberLeft.bind(this);
    this._chatRoom.eventEmitter.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_1__.XMPPEvents.PRESENCE_RECEIVED, this.onPresence);
    this._chatRoom.eventEmitter.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_1__.XMPPEvents.MUC_MEMBER_LEFT, this.onMemberLeft);
  }
  getSession(sessionID) {
    return this._sessions[sessionID];
  }
  getSessionByJibriJid(jibriJid) {
    let s;
    Object.values(this._sessions).forEach((session) => {
      if (session.getJibriJid() === jibriJid) {
        s = session;
      }
    });
    return s;
  }
  onPresence({ fromHiddenDomain, presence }) {
    if (_recordingXMLUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isFromFocus(presence)) {
      this._handleFocusPresence(presence);
    } else if (fromHiddenDomain) {
      this._handleJibriPresence(presence);
    }
  }
  onMemberLeft(jid) {
    const session = this.getSessionByJibriJid(jid);
    if (session) {
      const prevStatus = session.getStatus();
      session.setStatus("");
      session.setJibriJid(null);
      if (session.getStatus() !== prevStatus) {
        this._emitSessionUpdate(session);
      }
    }
  }
  startRecording(options) {
    const session = new _JibriSession__WEBPACK_IMPORTED_MODULE_2__["default"](Object.assign(Object.assign({}, options), { connection: this._chatRoom.connection }));
    return session.start({
      appData: options.appData,
      broadcastId: options.broadcastId,
      focusMucJid: this._chatRoom.focusMucJid,
      streamId: options.streamId
    }).then(() => {
      if (!this.getSession(session.getID())) {
        this._addSession(session);
        this._emitSessionUpdate(session);
      }
      return session;
    }).catch((error) => {
      this._emitSessionUpdate(session);
      return Promise.reject(error);
    });
  }
  stopRecording(sessionID) {
    const session = this.getSession(sessionID);
    if (session) {
      return session.stop({ focusMucJid: this._chatRoom.focusMucJid });
    }
    return Promise.reject(new Error("Could not find session"));
  }
  _addSession(session) {
    this._sessions[session.getID()] = session;
  }
  _createSession(sessionID, status, mode) {
    const session = new _JibriSession__WEBPACK_IMPORTED_MODULE_2__["default"]({
      connection: this._chatRoom.connection,
      focusMucJid: this._chatRoom.focusMucJid,
      mode,
      sessionID,
      status
    });
    this._addSession(session);
    return session;
  }
  _emitSessionUpdate(session, initiator) {
    this._chatRoom.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_1__.XMPPEvents.RECORDER_STATE_CHANGED, session, initiator);
  }
  _handleFocusPresence(presence) {
    const jibriStatus = _recordingXMLUtils__WEBPACK_IMPORTED_MODULE_3__["default"].getFocusRecordingUpdate(presence);
    if (!jibriStatus) {
      return;
    }
    const { error, initiator, recordingMode, sessionID, status } = jibriStatus;
    let session = this.getSession(sessionID);
    if (!session && status === "off") {
      logger.warn("Ignoring recording presence update", "Received a new session with status off.");
      return;
    }
    if (session && session.getStatus() === status && session.getError() === error) {
      logger.warn("Ignoring duplicate presence update: ", JSON.stringify(jibriStatus));
      return;
    }
    if (!session) {
      session = this._createSession(sessionID, status, recordingMode);
    }
    session.setStatusFromJicofo(status);
    if (error) {
      session.setError(error);
    }
    this._emitSessionUpdate(session, initiator);
  }
  _handleJibriPresence(presence) {
    const { liveStreamViewURL, mode, sessionID } = _recordingXMLUtils__WEBPACK_IMPORTED_MODULE_3__["default"].getHiddenDomainUpdate(presence);
    if (!sessionID) {
      logger.warn("Ignoring potential jibri presence due to no session id.");
      return;
    }
    let session = this.getSession(sessionID);
    if (!session) {
      session = this._createSession(sessionID, "on", mode);
    }
    session.setStatus("on");
    session.setJibriJid(presence.getAttribute("from"));
    session.setLiveStreamViewURL(liveStreamViewURL);
    this._emitSessionUpdate(session);
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RecordingManager);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/recording/recordingConstants.js":
/*!*****************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/recording/recordingConstants.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  error: {
    BUSY: "busy",
    ERROR: "error",
    RESOURCE_CONSTRAINT: "resource-constraint",
    UNEXPECTED_REQUEST: "unexpected-request",
    SERVICE_UNAVAILABLE: "service-unavailable"
  },
  mode: {
    FILE: "file",
    STREAM: "stream"
  },
  status: {
    OFF: "off",
    ON: "on",
    PENDING: "pending"
  }
});


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/recording/recordingXMLUtils.js":
/*!****************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/recording/recordingXMLUtils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  getFocusRecordingUpdate(presence) {
    const jibriStatus = presence && presence.getElementsByTagName("jibri-recording-status")[0];
    if (!jibriStatus) {
      return;
    }
    return {
      error: jibriStatus.getAttribute("failure_reason"),
      initiator: jibriStatus.getAttribute("initiator"),
      recordingMode: jibriStatus.getAttribute("recording_mode"),
      sessionID: jibriStatus.getAttribute("session_id"),
      status: jibriStatus.getAttribute("status")
    };
  },
  getHiddenDomainUpdate(presence) {
    const liveStreamViewURLContainer = presence.getElementsByTagName("live-stream-view-url")[0];
    const liveStreamViewURL = liveStreamViewURLContainer && liveStreamViewURLContainer.textContent;
    const modeContainer = presence.getElementsByTagName("mode")[0];
    const mode = modeContainer && modeContainer.textContent && modeContainer.textContent.toLowerCase();
    const sessionIDContainer = presence.getElementsByTagName("session_id")[0];
    const sessionID = sessionIDContainer && sessionIDContainer.textContent;
    return {
      liveStreamViewURL,
      mode,
      sessionID
    };
  },
  getSessionIdFromIq(response) {
    const jibri = response && response.getElementsByTagName("jibri")[0];
    return jibri && jibri.getAttribute("session_id");
  },
  getSessionId(presence) {
    const sessionIdContainer = presence.getElementsByTagName("session_id")[0];
    const sessionId = sessionIdContainer && sessionIdContainer.textContent;
    return sessionId;
  },
  isFromFocus(presence) {
    return presence.getAttribute("from").includes("focus");
  }
});


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/sdp/LocalSdpMunger.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/sdp/LocalSdpMunger.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LocalSdpMunger)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/MediaDirection */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaDirection.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/SignalingLayer */ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingLayer.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");
/* harmony import */ var _SdpTransformUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SdpTransformUtil */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SdpTransformUtil.js");









const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class LocalSdpMunger {
  constructor(tpc, localEndpointId) {
    this.tpc = tpc;
    this.localEndpointId = localEndpointId;
    this.audioSourcesToMsidMap = /* @__PURE__ */ new Map();
    this.videoSourcesToMsidMap = /* @__PURE__ */ new Map();
  }
  _addMutedLocalVideoTracksToSDP(transformer) {
    var _a;
    const localVideos = this.tpc.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO);
    if (!localVideos.length) {
      return false;
    } else if (localVideos.length !== 1) {
      logger.error(`${this.tpc} there is more than 1 video track ! Strange things may happen !`, localVideos);
    }
    const videoMLine = (_a = transformer.selectMedia(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO)) === null || _a === void 0 ? void 0 : _a[0];
    if (!videoMLine) {
      logger.debug(`${this.tpc} unable to hack local video track SDP- no "video" media`);
      return false;
    }
    let modified = false;
    for (const videoTrack of localVideos) {
      const muted = videoTrack.isMuted();
      const mediaStream = videoTrack.getOriginalStream();
      const isCamera = videoTrack.videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_4__.VideoType.CAMERA;
      const isInPeerConnection = mediaStream && this.tpc.isMediaStreamInPc(mediaStream);
      const shouldFakeSdp = isCamera && (muted || !isInPeerConnection);
      if (!shouldFakeSdp) {
        continue;
      }
      const requiredSSRCs = this.tpc.isSimulcastOn() ? this.tpc.simulcast.ssrcCache : [this.tpc.sdpConsistency.cachedPrimarySsrc];
      if (!requiredSSRCs.length) {
        logger.error(`No SSRCs stored for: ${videoTrack} in ${this.tpc}`);
        continue;
      }
      modified = true;
      videoMLine.direction = _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_1__.MediaDirection.SENDRECV;
      const primarySSRC = requiredSSRCs[0];
      const primaryCname = `injected-${primarySSRC}`;
      for (const ssrcNum of requiredSSRCs) {
        videoMLine.removeSSRC(ssrcNum);
        videoMLine.addSSRCAttribute({
          id: ssrcNum,
          attribute: "cname",
          value: primaryCname
        });
        videoMLine.addSSRCAttribute({
          id: ssrcNum,
          attribute: "msid",
          value: videoTrack.storedMSID
        });
      }
      if (requiredSSRCs.length > 1) {
        const group = {
          ssrcs: requiredSSRCs.join(" "),
          semantics: "SIM"
        };
        if (!videoMLine.findGroup(group.semantics, group.ssrcs)) {
          videoMLine.addSSRCGroup(group);
        }
      }
      if (!this.tpc.options.disableRtx) {
        this.tpc.rtxModifier.modifyRtxSsrcs2(videoMLine);
      }
    }
    return modified;
  }
  _generateMsidAttribute(mediaType, trackId, streamId) {
    if (!(mediaType && trackId)) {
      logger.error(`Unable to munge local MSID - track id=${trackId} or media type=${mediaType} is missing`);
      return null;
    }
    const pcId = this.tpc.id;
    return `${streamId}-${pcId} ${trackId}-${pcId}`;
  }
  _transformMediaIdentifiers(mediaSection) {
    var _a, _b, _c, _d, _e;
    const mediaType = (_a = mediaSection.mLine) === null || _a === void 0 ? void 0 : _a.type;
    const mediaDirection = (_b = mediaSection.mLine) === null || _b === void 0 ? void 0 : _b.direction;
    const msidLine = (_c = mediaSection.mLine) === null || _c === void 0 ? void 0 : _c.msid;
    const sources = [...new Set((_e = (_d = mediaSection.mLine) === null || _d === void 0 ? void 0 : _d.ssrcs) === null || _e === void 0 ? void 0 : _e.map((s) => s.id))];
    const streamId = `${this.localEndpointId}-${mediaType}`;
    const trackId = msidLine && msidLine.split(" ")[1];
    for (const source of sources) {
      const msid = mediaSection.ssrcs.find((ssrc) => ssrc.id === source && ssrc.attribute === "msid");
      if (msid) {
        const streamAndTrackIDs = msid.value.split(" ");
        const trackID = streamAndTrackIDs[1];
        this._updateSourcesToMsidMap(mediaType, streamId, trackID);
        const storedStreamId = mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO ? this.videoSourcesToMsidMap.get(trackID) : this.audioSourcesToMsidMap.get(trackID);
        msid.value = this._generateMsidAttribute(mediaType, trackID, storedStreamId);
      } else if (trackId) {
        this._updateSourcesToMsidMap(mediaType, streamId, trackId);
        const storedStreamId = mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO ? this.videoSourcesToMsidMap.get(trackId) : this.audioSourcesToMsidMap.get(trackId);
        const generatedMsid = this._generateMsidAttribute(mediaType, trackId, storedStreamId);
        mediaSection.ssrcs.push({
          id: source,
          attribute: "msid",
          value: generatedMsid
        });
      }
    }
    mediaSection.ssrcs = mediaSection.ssrcs.filter((ssrc) => ssrc.attribute === "msid");
    if (_browser__WEBPACK_IMPORTED_MODULE_5__["default"].isFirefox() && (mediaDirection === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_1__.MediaDirection.RECVONLY || mediaDirection === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_1__.MediaDirection.INACTIVE) && (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO && !this.tpc._hasHadVideoTrack || mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.AUDIO && !this.tpc._hasHadAudioTrack)) {
      mediaSection.ssrcs = void 0;
      mediaSection.ssrcGroups = void 0;
    }
  }
  _updateSourcesToMsidMap(mediaType, streamId, trackId) {
    if (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO) {
      if (!this.videoSourcesToMsidMap.has(trackId)) {
        const generatedStreamId = `${streamId}-${this.videoSourcesToMsidMap.size}`;
        this.videoSourcesToMsidMap.set(trackId, generatedStreamId);
      }
    } else if (!this.audioSourcesToMsidMap.has(trackId)) {
      const generatedStreamId = `${streamId}-${this.audioSourcesToMsidMap.size}`;
      this.audioSourcesToMsidMap.set(trackId, generatedStreamId);
    }
  }
  maybeAddMutedLocalVideoTracksToSDP(desc) {
    if (!desc) {
      throw new Error("No local description passed in.");
    }
    const transformer = new _SdpTransformUtil__WEBPACK_IMPORTED_MODULE_7__.SdpTransformWrap(desc.sdp);
    if (this._addMutedLocalVideoTracksToSDP(transformer)) {
      return new RTCSessionDescription({
        type: desc.type,
        sdp: transformer.toRawSDP()
      });
    }
    return desc;
  }
  transformStreamIdentifiers(sessionDesc) {
    var _a;
    if (!sessionDesc || !sessionDesc.sdp || !sessionDesc.type) {
      return sessionDesc;
    }
    const transformer = new _SdpTransformUtil__WEBPACK_IMPORTED_MODULE_7__.SdpTransformWrap(sessionDesc.sdp);
    const audioMLine = (_a = transformer.selectMedia(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.AUDIO)) === null || _a === void 0 ? void 0 : _a[0];
    if (audioMLine) {
      this._transformMediaIdentifiers(audioMLine);
      this._injectSourceNames(audioMLine);
    }
    const videoMlines = transformer.selectMedia(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO);
    if (!_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_6__["default"].isMultiStreamSendSupportEnabled()) {
      videoMlines.splice(1);
    }
    for (const videoMLine of videoMlines) {
      this._transformMediaIdentifiers(videoMLine);
      this._injectSourceNames(videoMLine);
    }
    if (!this.tpc._usesUnifiedPlan) {
      this.audioSourcesToMsidMap.clear();
      this.videoSourcesToMsidMap.clear();
    }
    return new RTCSessionDescription({
      type: sessionDesc.type,
      sdp: transformer.toRawSDP()
    });
  }
  _injectSourceNames(mediaSection) {
    var _a, _b, _c, _d;
    const sources = [...new Set((_b = (_a = mediaSection.mLine) === null || _a === void 0 ? void 0 : _a.ssrcs) === null || _b === void 0 ? void 0 : _b.map((s) => s.id))];
    const mediaType = (_c = mediaSection.mLine) === null || _c === void 0 ? void 0 : _c.type;
    if (!mediaType) {
      throw new Error("_transformMediaIdentifiers - no media type in mediaSection");
    }
    for (const source of sources) {
      const nameExists = mediaSection.ssrcs.find((ssrc) => ssrc.id === source && ssrc.attribute === "name");
      const msid = mediaSection.ssrcs.find((ssrc) => ssrc.id === source && ssrc.attribute === "msid").value;
      const streamId = msid.split(" ")[0];
      const trackIndexParts = streamId.split("-");
      const trackIndex = trackIndexParts[trackIndexParts.length - 2];
      const sourceName = (0,_service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_3__.getSourceNameForJitsiTrack)(this.localEndpointId, mediaType, trackIndex);
      if (!nameExists) {
        mediaSection.ssrcs.push({
          id: source,
          attribute: "name",
          value: sourceName
        });
      }
      if (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO) {
        const videoType = (_d = this.tpc.getLocalVideoTracks().find((track) => track.getSourceName() === sourceName)) === null || _d === void 0 ? void 0 : _d.getVideoType();
        if (videoType) {
          mediaSection.ssrcs.push({
            id: source,
            attribute: "videoType",
            value: videoType
          });
        }
      }
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/sdp/RtxModifier.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/sdp/RtxModifier.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RtxModifier)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/MediaDirection */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaDirection.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _SDPUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SDPUtil */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SDPUtil.js");
/* harmony import */ var _SdpTransformUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SdpTransformUtil */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SdpTransformUtil.js");






const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
function updateAssociatedRtxStream(mLine, primarySsrcInfo, rtxSsrc) {
  const primarySsrc = primarySsrcInfo.id;
  const primarySsrcMsid = primarySsrcInfo.msid;
  const primarySsrcCname = primarySsrcInfo.cname;
  const previousRtxSSRC = mLine.getRtxSSRC(primarySsrc);
  if (previousRtxSSRC === rtxSsrc) {
    return;
  }
  if (previousRtxSSRC) {
    mLine.removeSSRC(previousRtxSSRC);
    mLine.removeGroupsWithSSRC(previousRtxSSRC);
  }
  mLine.addSSRCAttribute({
    id: rtxSsrc,
    attribute: "cname",
    value: primarySsrcCname
  });
  mLine.addSSRCAttribute({
    id: rtxSsrc,
    attribute: "msid",
    value: primarySsrcMsid
  });
  mLine.addSSRCGroup({
    semantics: "FID",
    ssrcs: `${primarySsrc} ${rtxSsrc}`
  });
}
class RtxModifier {
  constructor() {
    this.correspondingRtxSsrcs = /* @__PURE__ */ new Map();
  }
  clearSsrcCache() {
    this.correspondingRtxSsrcs.clear();
  }
  setSsrcCache(ssrcMapping) {
    logger.debug("Setting ssrc cache to ", ssrcMapping);
    this.correspondingRtxSsrcs = ssrcMapping;
  }
  modifyRtxSsrcs(sdpStr) {
    let modified = false;
    const sdpTransformer = new _SdpTransformUtil__WEBPACK_IMPORTED_MODULE_4__.SdpTransformWrap(sdpStr);
    const videoMLines = sdpTransformer.selectMedia(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO);
    if (!(videoMLines === null || videoMLines === void 0 ? void 0 : videoMLines.length)) {
      logger.debug(`No 'video' media found in the sdp: ${sdpStr}`);
      return sdpStr;
    }
    for (const videoMLine of videoMLines) {
      if (this.modifyRtxSsrcs2(videoMLine)) {
        modified = true;
      }
    }
    return modified ? sdpTransformer.toRawSDP() : sdpStr;
  }
  modifyRtxSsrcs2(videoMLine) {
    if (videoMLine.direction === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_1__.MediaDirection.RECVONLY) {
      return false;
    }
    if (videoMLine.getSSRCCount() < 1) {
      return false;
    }
    const primaryVideoSsrcs = videoMLine.getPrimaryVideoSSRCs();
    for (const ssrc of primaryVideoSsrcs) {
      const msid = videoMLine.getSSRCAttrValue(ssrc, "msid");
      const cname = videoMLine.getSSRCAttrValue(ssrc, "cname");
      let correspondingRtxSsrc = this.correspondingRtxSsrcs.get(ssrc);
      if (!correspondingRtxSsrc) {
        const previousAssociatedRtxStream = videoMLine.getRtxSSRC(ssrc);
        if (previousAssociatedRtxStream) {
          correspondingRtxSsrc = previousAssociatedRtxStream;
        } else {
          correspondingRtxSsrc = _SDPUtil__WEBPACK_IMPORTED_MODULE_3__["default"].generateSsrc();
        }
        this.correspondingRtxSsrcs.set(ssrc, correspondingRtxSsrc);
      }
      updateAssociatedRtxStream(videoMLine, {
        id: ssrc,
        cname,
        msid
      }, correspondingRtxSsrc);
    }
    return true;
  }
  stripRtx(sdpStr) {
    const sdpTransformer = new _SdpTransformUtil__WEBPACK_IMPORTED_MODULE_4__.SdpTransformWrap(sdpStr);
    const videoMLines = sdpTransformer.selectMedia(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO);
    if (!(videoMLines === null || videoMLines === void 0 ? void 0 : videoMLines.length)) {
      logger.debug(`No 'video' media found in the sdp: ${sdpStr}`);
      return sdpStr;
    }
    for (const videoMLine of videoMLines) {
      if (videoMLine.direction !== _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_1__.MediaDirection.RECVONLY && videoMLine.getSSRCCount() && videoMLine.containsAnySSRCGroups()) {
        const fidGroups = videoMLine.findGroups("FID");
        videoMLine.removeGroupsBySemantics("FID");
        for (const fidGroup of fidGroups) {
          const rtxSsrc = (0,_SdpTransformUtil__WEBPACK_IMPORTED_MODULE_4__.parseSecondarySSRC)(fidGroup);
          videoMLine.removeSSRC(rtxSsrc);
        }
      }
    }
    return sdpTransformer.toRawSDP();
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/sdp/SDP.js":
/*!********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/sdp/SDP.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SDP)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.clonedeep */ "../../lib-jitsi-meet/node_modules/lodash.clonedeep/index.js");
/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var sdp_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sdp-transform */ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/index.js");
/* harmony import */ var _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/MediaDirection */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaDirection.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _SDPUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SDPUtil */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SDPUtil.js");







function SDP(sdp) {
  const media = sdp.split("\r\nm=");
  for (let i = 1, length = media.length; i < length; i++) {
    let mediaI = `m=${media[i]}`;
    if (i !== length - 1) {
      mediaI += "\r\n";
    }
    media[i] = mediaI;
  }
  const session = `${media.shift()}\r
`;
  this.media = media;
  this.raw = session + media.join("");
  this.session = session;
}
SDP.prototype.failICE = false;
SDP.prototype.removeTcpCandidates = false;
SDP.prototype.removeUdpCandidates = false;
SDP.prototype.addMlineForNewLocalSource = function(mediaType) {
  const mid = this.media.length;
  const sdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(this.raw);
  const mline = lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1___default()(sdp.media.find((m) => m.type === mediaType));
  mline.mid = mid;
  mline.direction = _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.RECVONLY;
  mline.msid = void 0;
  mline.ssrcs = void 0;
  mline.ssrcGroups = void 0;
  sdp.media = sdp.media.concat(mline);
  sdp.groups.forEach((group) => {
    if (group.type === "BUNDLE") {
      const mids = group.mids.split(" ");
      mids.push(mid);
      group.mids = mids.join(" ");
    }
  });
  this.raw = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.write(sdp);
};
SDP.prototype.getMediaSsrcMap = function() {
  const mediaSSRCs = {};
  for (let mediaindex = 0; mediaindex < this.media.length; mediaindex++) {
    const mid = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseMID(_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(this.media[mediaindex], "a=mid:"));
    const media = {
      mediaindex,
      mid,
      ssrcs: {},
      ssrcGroups: []
    };
    mediaSSRCs[mediaindex] = media;
    _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLines(this.media[mediaindex], "a=ssrc:").forEach((line) => {
      const linessrc = line.substring(7).split(" ")[0];
      if (!media.ssrcs[linessrc]) {
        media.ssrcs[linessrc] = {
          ssrc: linessrc,
          lines: []
        };
      }
      media.ssrcs[linessrc].lines.push(line);
    });
    _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLines(this.media[mediaindex], "a=ssrc-group:").forEach((line) => {
      const idx = line.indexOf(" ");
      const semantics = line.substr(0, idx).substr(13);
      const ssrcs = line.substr(14 + semantics.length).split(" ");
      if (ssrcs.length) {
        media.ssrcGroups.push({
          semantics,
          ssrcs
        });
      }
    });
  }
  return mediaSSRCs;
};
SDP.prototype.containsSSRC = function(ssrc) {
  const medias = this.getMediaSsrcMap();
  let result = false;
  Object.keys(medias).forEach((mediaindex) => {
    if (result) {
      return;
    }
    if (medias[mediaindex].ssrcs[ssrc]) {
      result = true;
    }
  });
  return result;
};
SDP.prototype.toJingle = function(elem, thecreator) {
  _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLines(this.session, "a=group:").forEach((line) => {
    const parts = line.split(" ");
    const semantics = parts.shift().substr(8);
    elem.c("group", {
      xmlns: "urn:xmpp:jingle:apps:grouping:0",
      semantics
    });
    for (let j = 0; j < parts.length; j++) {
      elem.c("content", { name: parts[j] }).up();
    }
    elem.up();
  });
  for (let i = 0; i < this.media.length; i++) {
    const mline = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseMLine(this.media[i].split("\r\n")[0]);
    if (!(mline.media === "audio" || mline.media === "video" || mline.media === "application")) {
      continue;
    }
    let ssrc;
    const assrcline = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(this.media[i], "a=ssrc:");
    if (assrcline) {
      ssrc = assrcline.substring(7).split(" ")[0];
    } else {
      ssrc = false;
    }
    elem.c("content", {
      creator: thecreator,
      name: mline.media
    });
    const amidline = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(this.media[i], "a=mid:");
    if (amidline) {
      const mid = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseMID(amidline);
      elem.attrs({ name: mid });
    }
    if (mline.media === "video" && typeof this.initialLastN === "number") {
      elem.c("initial-last-n", {
        xmlns: "jitsi:colibri2",
        value: this.initialLastN
      }).up();
    }
    if (mline.media === "audio" || mline.media === "video") {
      elem.c("description", {
        xmlns: "urn:xmpp:jingle:apps:rtp:1",
        media: mline.media
      });
      if (ssrc) {
        elem.attrs({ ssrc });
      }
      for (let j = 0; j < mline.fmt.length; j++) {
        const rtpmap = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(this.media[i], `a=rtpmap:${mline.fmt[j]}`);
        elem.c("payload-type", _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseRTPMap(rtpmap));
        const afmtpline = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(this.media[i], `a=fmtp:${mline.fmt[j]}`);
        if (afmtpline) {
          const fmtpParameters = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseFmtp(afmtpline);
          for (let k = 0; k < fmtpParameters.length; k++) {
            elem.c("parameter", fmtpParameters[k]).up();
          }
        }
        this.rtcpFbToJingle(i, elem, mline.fmt[j]);
        elem.up();
      }
      if (ssrc) {
        const ssrcMap = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseSSRC(this.media[i]);
        for (const [availableSsrc, ssrcParameters] of ssrcMap) {
          const sourceName = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseSourceNameLine(ssrcParameters);
          const videoType = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseVideoTypeLine(ssrcParameters);
          elem.c("source", {
            ssrc: availableSsrc,
            name: sourceName,
            videoType,
            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
          });
          const msid = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseMSIDAttribute(ssrcParameters);
          if (msid) {
            elem.c("parameter");
            elem.attrs({ name: "msid" });
            elem.attrs({ value: msid });
            elem.up();
          }
          elem.up();
        }
        const ssrcGroupLines = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLines(this.media[i], "a=ssrc-group:");
        ssrcGroupLines.forEach((line) => {
          const idx = line.indexOf(" ");
          const semantics = line.substr(0, idx).substr(13);
          const ssrcs = line.substr(14 + semantics.length).split(" ");
          if (ssrcs.length) {
            elem.c("ssrc-group", {
              semantics,
              xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
            });
            ssrcs.forEach((s) => elem.c("source", { ssrc: s }).up());
            elem.up();
          }
        });
      }
      const ridLines = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLines(this.media[i], "a=rid:");
      if (ridLines.length && _browser__WEBPACK_IMPORTED_MODULE_4__["default"].usesRidsForSimulcast()) {
        const rids = ridLines.map((ridLine) => ridLine.split(":")[1]).map((ridInfo) => ridInfo.split(" ")[0]);
        rids.forEach((rid) => {
          elem.c("source", {
            rid,
            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
          });
          elem.up();
        });
        const unifiedSimulcast = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(this.media[i], "a=simulcast:");
        if (unifiedSimulcast) {
          elem.c("rid-group", {
            semantics: "SIM",
            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
          });
          rids.forEach((rid) => {
            elem.c("source", { rid }).up();
          });
          elem.up();
        }
      }
      if (_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(this.media[i], "a=rtcp-mux")) {
        elem.c("rtcp-mux").up();
      }
      this.rtcpFbToJingle(i, elem, "*");
      const extmapLines = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLines(this.media[i], "a=extmap:", this.session);
      for (let j = 0; j < extmapLines.length; j++) {
        const extmap = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseExtmap(extmapLines[j]);
        elem.c("rtp-hdrext", {
          xmlns: "urn:xmpp:jingle:apps:rtp:rtp-hdrext:0",
          uri: extmap.uri,
          id: extmap.value
        });
        if (extmap.hasOwnProperty("direction")) {
          switch (extmap.direction) {
            case _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.SENDONLY:
              elem.attrs({ senders: "responder" });
              break;
            case _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.RECVONLY:
              elem.attrs({ senders: "initiator" });
              break;
            case _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.SENDRECV:
              elem.attrs({ senders: "both" });
              break;
            case _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.INACTIVE:
              elem.attrs({ senders: "none" });
              break;
          }
        }
        elem.up();
      }
      if (_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(this.media[i], "a=extmap-allow-mixed", this.session)) {
        elem.c("extmap-allow-mixed", {
          xmlns: "urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"
        });
        elem.up();
      }
      elem.up();
    }
    this.transportToJingle(i, elem);
    const m = this.media[i];
    if (_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(m, `a=${_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.SENDRECV}`)) {
      elem.attrs({ senders: "both" });
    } else if (_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(m, `a=${_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.SENDONLY}`)) {
      elem.attrs({ senders: "initiator" });
    } else if (_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(m, `a=${_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.RECVONLY}`)) {
      elem.attrs({ senders: "responder" });
    } else if (_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(m, `a=${_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.INACTIVE}`)) {
      elem.attrs({ senders: "none" });
    }
    if (mline.port === "0" && !_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(m, "a=bundle-only", this.session)) {
      elem.attrs({ senders: "rejected" });
    }
    elem.up();
  }
  elem.up();
  return elem;
};
SDP.prototype.transportToJingle = function(mediaindex, elem) {
  elem.c("transport");
  const sctpport = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(this.media[mediaindex], "a=sctp-port:", this.session);
  const sctpmap = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(this.media[mediaindex], "a=sctpmap:", this.session);
  if (sctpport) {
    const sctpAttrs = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseSCTPPort(sctpport);
    elem.c("sctpmap", {
      xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
      number: sctpAttrs,
      protocol: "webrtc-datachannel"
    });
    elem.attrs({ streams: 0 });
    elem.up();
  } else if (sctpmap) {
    const sctpAttrs = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseSCTPMap(sctpmap);
    elem.c("sctpmap", {
      xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
      number: sctpAttrs[0],
      protocol: sctpAttrs[1]
    });
    if (sctpAttrs.length > 2) {
      elem.attrs({ streams: sctpAttrs[2] });
    } else {
      elem.attrs({ streams: 0 });
    }
    elem.up();
  }
  const fingerprints = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLines(this.media[mediaindex], "a=fingerprint:", this.session);
  fingerprints.forEach((line) => {
    const fingerprint = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseFingerprint(line);
    fingerprint.xmlns = "urn:xmpp:jingle:apps:dtls:0";
    elem.c("fingerprint").t(fingerprint.fingerprint);
    delete fingerprint.fingerprint;
    const setupLine = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLine(this.media[mediaindex], "a=setup:", this.session);
    if (setupLine) {
      fingerprint.setup = setupLine.substr(8);
    }
    elem.attrs(fingerprint);
    elem.up();
  });
  const iceParameters = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].iceparams(this.media[mediaindex], this.session);
  if (iceParameters) {
    iceParameters.xmlns = "urn:xmpp:jingle:transports:ice-udp:1";
    elem.attrs(iceParameters);
    const candidateLines = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLines(this.media[mediaindex], "a=candidate:", this.session);
    candidateLines.forEach((line) => {
      const candidate = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].candidateToJingle(line);
      if (this.failICE) {
        candidate.ip = "1.1.1.1";
      }
      const protocol = candidate && typeof candidate.protocol === "string" ? candidate.protocol.toLowerCase() : "";
      if (this.removeTcpCandidates && (protocol === "tcp" || protocol === "ssltcp") || this.removeUdpCandidates && protocol === "udp") {
        return;
      }
      elem.c("candidate", candidate).up();
    });
  }
  elem.up();
};
SDP.prototype.rtcpFbToJingle = function(mediaindex, elem, payloadtype) {
  const lines = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].findLines(this.media[mediaindex], `a=rtcp-fb:${payloadtype}`);
  lines.forEach((line) => {
    const feedback = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].parseRTCPFB(line);
    if (feedback.type === "trr-int") {
      elem.c("rtcp-fb-trr-int", {
        xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
        value: feedback.params[0]
      });
      elem.up();
    } else {
      elem.c("rtcp-fb", {
        xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
        type: feedback.type
      });
      if (feedback.params.length > 0) {
        elem.attrs({ "subtype": feedback.params[0] });
      }
      elem.up();
    }
  });
};
SDP.prototype.rtcpFbFromJingle = function(elem, payloadtype) {
  let sdp = "";
  const feedbackElementTrrInt = elem.find('>rtcp-fb-trr-int[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
  if (feedbackElementTrrInt.length) {
    sdp += "a=rtcp-fb:* trr-int ";
    if (feedbackElementTrrInt.attr("value")) {
      sdp += feedbackElementTrrInt.attr("value");
    } else {
      sdp += "0";
    }
    sdp += "\r\n";
  }
  const feedbackElements = elem.find('>rtcp-fb[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
  feedbackElements.each((_, fb) => {
    sdp += `a=rtcp-fb:${payloadtype} ${fb.getAttribute("type")}`;
    if (fb.hasAttribute("subtype")) {
      sdp += ` ${fb.getAttribute("subtype")}`;
    }
    sdp += "\r\n";
  });
  return sdp;
};
SDP.prototype.fromJingle = function(jingle) {
  const sessionId = Date.now();
  this.raw = `v=0\r
o=- ${sessionId} 2 IN IP4 0.0.0.0\r
s=-\r
t=0 0\r
`;
  const groups = jquery__WEBPACK_IMPORTED_MODULE_0___default()(jingle).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]');
  if (groups.length) {
    groups.each((idx, group) => {
      const contents = jquery__WEBPACK_IMPORTED_MODULE_0___default()(group).find(">content").map((_, content) => content.getAttribute("name")).get();
      if (contents.length > 0) {
        this.raw += `a=group:${group.getAttribute("semantics") || group.getAttribute("type")} ${contents.join(" ")}\r
`;
      }
    });
  }
  this.session = this.raw;
  jingle.find(">content").each((_, content) => {
    const m = this.jingle2media(jquery__WEBPACK_IMPORTED_MODULE_0___default()(content));
    this.media.push(m);
  });
  this.raw = this.session + this.media.join("");
};
SDP.prototype.jingle2media = function(content) {
  const desc = content.find(">description");
  const transport = content.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]');
  let sdp = "";
  const sctp = transport.find('>sctpmap[xmlns="urn:xmpp:jingle:transports:dtls-sctp:1"]');
  const media = { media: desc.attr("media") };
  media.port = "9";
  if (content.attr("senders") === "rejected") {
    media.port = "0";
  }
  if (transport.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').length) {
    media.proto = sctp.length ? "UDP/DTLS/SCTP" : "UDP/TLS/RTP/SAVPF";
  } else {
    media.proto = "UDP/TLS/RTP/SAVPF";
  }
  if (sctp.length) {
    sdp += `m=application ${media.port} UDP/DTLS/SCTP webrtc-datachannel\r
`;
    sdp += `a=sctp-port:${sctp.attr("number")}\r
`;
    sdp += "a=max-message-size:262144\r\n";
  } else {
    media.fmt = desc.find(">payload-type").map((_, payloadType) => payloadType.getAttribute("id")).get();
    sdp += `${_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].buildMLine(media)}\r
`;
  }
  sdp += "c=IN IP4 0.0.0.0\r\n";
  if (!sctp.length) {
    sdp += "a=rtcp:1 IN IP4 0.0.0.0\r\n";
  }
  if (transport.length) {
    if (transport.attr("ufrag")) {
      sdp += `${_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].buildICEUfrag(transport.attr("ufrag"))}\r
`;
    }
    if (transport.attr("pwd")) {
      sdp += `${_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].buildICEPwd(transport.attr("pwd"))}\r
`;
    }
    transport.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').each((_, fingerprint) => {
      sdp += `a=fingerprint:${fingerprint.getAttribute("hash")}`;
      sdp += ` ${jquery__WEBPACK_IMPORTED_MODULE_0___default()(fingerprint).text()}`;
      sdp += "\r\n";
      if (fingerprint.hasAttribute("setup")) {
        sdp += `a=setup:${fingerprint.getAttribute("setup")}\r
`;
      }
    });
  }
  transport.find(">candidate").each((_, candidate) => {
    let protocol = candidate.getAttribute("protocol");
    protocol = typeof protocol === "string" ? protocol.toLowerCase() : "";
    if (this.removeTcpCandidates && (protocol === "tcp" || protocol === "ssltcp") || this.removeUdpCandidates && protocol === "udp") {
      return;
    } else if (this.failICE) {
      candidate.setAttribute("ip", "1.1.1.1");
    }
    sdp += _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].candidateFromJingle(candidate);
  });
  switch (content.attr("senders")) {
    case "initiator":
      sdp += `a=${_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.SENDONLY}\r
`;
      break;
    case "responder":
      sdp += `a=${_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.RECVONLY}\r
`;
      break;
    case "none":
      sdp += `a=${_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.INACTIVE}\r
`;
      break;
    case "both":
      sdp += `a=${_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_3__.MediaDirection.SENDRECV}\r
`;
      break;
  }
  sdp += `a=mid:${content.attr("name")}\r
`;
  if (desc.find(">rtcp-mux").length) {
    sdp += "a=rtcp-mux\r\n";
  }
  desc.find(">payload-type").each((_, payloadType) => {
    sdp += `${_SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].buildRTPMap(payloadType)}\r
`;
    if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(payloadType).find(">parameter").length) {
      sdp += `a=fmtp:${payloadType.getAttribute("id")} `;
      sdp += jquery__WEBPACK_IMPORTED_MODULE_0___default()(payloadType).find(">parameter").map((__, parameter) => {
        const name = parameter.getAttribute("name");
        return (name ? `${name}=` : "") + parameter.getAttribute("value");
      }).get().join(";");
      sdp += "\r\n";
    }
    sdp += this.rtcpFbFromJingle(jquery__WEBPACK_IMPORTED_MODULE_0___default()(payloadType), payloadType.getAttribute("id"));
  });
  sdp += this.rtcpFbFromJingle(desc, "*");
  desc.find('>rtp-hdrext[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]').each((_, hdrExt) => {
    sdp += `a=extmap:${hdrExt.getAttribute("id")} ${hdrExt.getAttribute("uri")}\r
`;
  });
  if (desc.find('>extmap-allow-mixed[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]').length > 0) {
    sdp += "a=extmap-allow-mixed\r\n";
  }
  desc.find('>ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((_, ssrcGroup) => {
    const semantics = ssrcGroup.getAttribute("semantics");
    const ssrcs = jquery__WEBPACK_IMPORTED_MODULE_0___default()(ssrcGroup).find(">source").map((__, source) => source.getAttribute("ssrc")).get();
    if (ssrcs.length) {
      sdp += `a=ssrc-group:${semantics} ${ssrcs.join(" ")}\r
`;
    }
  });
  let userSources = "";
  let nonUserSources = "";
  desc.find('>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((_, source) => {
    const ssrc = source.getAttribute("ssrc");
    let isUserSource = true;
    let sourceStr = "";
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(source).find(">parameter").each((__, parameter) => {
      const name = parameter.getAttribute("name");
      let value = parameter.getAttribute("value");
      value = _SDPUtil__WEBPACK_IMPORTED_MODULE_5__["default"].filterSpecialChars(value);
      sourceStr += `a=ssrc:${ssrc} ${name}`;
      if (value && value.length) {
        sourceStr += `:${value}`;
      }
      sourceStr += "\r\n";
      if (value === null || value === void 0 ? void 0 : value.includes("mixedmslabel")) {
        isUserSource = false;
      }
    });
    if (isUserSource) {
      userSources += sourceStr;
    } else {
      nonUserSources += sourceStr;
    }
  });
  sdp += nonUserSources + userSources;
  return sdp;
};


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/sdp/SDPDiffer.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/sdp/SDPDiffer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SDPDiffer)
/* harmony export */ });
/* harmony import */ var _SDPUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SDPUtil */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SDPUtil.js");


function arrayEquals(array1, array2) {
  if (!array2) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i = 0, l = array1.length; i < l; i++) {
    if (array1[i] instanceof Array && array2[i] instanceof Array) {
      if (!array1[i].equals(array2[i])) {
        return false;
      }
    } else if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function SDPDiffer(mySDP, otherSDP) {
  this.mySDP = mySDP;
  this.otherSDP = otherSDP;
  if (!mySDP) {
    throw new Error('"mySDP" is undefined!');
  } else if (!otherSDP) {
    throw new Error('"otherSDP" is undefined!');
  }
}
SDPDiffer.prototype.getNewMedia = function() {
  const myMedias = this.mySDP.getMediaSsrcMap();
  const othersMedias = this.otherSDP.getMediaSsrcMap();
  const newMedia = {};
  Object.keys(othersMedias).forEach((othersMediaIdx) => {
    const myMedia = myMedias[othersMediaIdx];
    const othersMedia = othersMedias[othersMediaIdx];
    if (!myMedia && othersMedia) {
      newMedia[othersMediaIdx] = othersMedia;
      return;
    }
    Object.keys(othersMedia.ssrcs).forEach((ssrc) => {
      if (Object.keys(myMedia.ssrcs).indexOf(ssrc) === -1) {
        if (!newMedia[othersMediaIdx]) {
          newMedia[othersMediaIdx] = {
            mediaindex: othersMedia.mediaindex,
            mid: othersMedia.mid,
            ssrcs: {},
            ssrcGroups: []
          };
        }
        newMedia[othersMediaIdx].ssrcs[ssrc] = othersMedia.ssrcs[ssrc];
      } else if (othersMedia.ssrcs[ssrc].lines && myMedia.ssrcs[ssrc].lines) {
        const myContainMsid = myMedia.ssrcs[ssrc].lines.find((line) => line.indexOf("msid") !== -1) !== void 0;
        const newContainMsid = othersMedia.ssrcs[ssrc].lines.find((line) => line.indexOf("msid") !== -1) !== void 0;
        if (myContainMsid !== newContainMsid) {
          if (!newMedia[othersMediaIdx]) {
            newMedia[othersMediaIdx] = {
              mediaindex: othersMedia.mediaindex,
              mid: othersMedia.mid,
              ssrcs: {},
              ssrcGroups: []
            };
          }
          newMedia[othersMediaIdx].ssrcs[ssrc] = othersMedia.ssrcs[ssrc];
        }
      }
    });
    othersMedia.ssrcGroups.forEach((otherSsrcGroup) => {
      let matched = false;
      for (let i = 0; i < myMedia.ssrcGroups.length; i++) {
        const mySsrcGroup = myMedia.ssrcGroups[i];
        if (otherSsrcGroup.semantics === mySsrcGroup.semantics && arrayEquals(otherSsrcGroup.ssrcs, mySsrcGroup.ssrcs)) {
          matched = true;
          break;
        }
      }
      if (!matched) {
        if (!newMedia[othersMediaIdx]) {
          newMedia[othersMediaIdx] = {
            mediaindex: othersMedia.mediaindex,
            mid: othersMedia.mid,
            ssrcs: {},
            ssrcGroups: []
          };
        }
        newMedia[othersMediaIdx].ssrcGroups.push(otherSsrcGroup);
      }
    });
  });
  return newMedia;
};
SDPDiffer.prototype.toJingle = function(modify) {
  const sdpMediaSsrcs = this.getNewMedia();
  let modified = false;
  Object.keys(sdpMediaSsrcs).forEach((mediaindex) => {
    modified = true;
    const media = sdpMediaSsrcs[mediaindex];
    modify.c("content", { name: media.mid });
    modify.c("description", {
      xmlns: "urn:xmpp:jingle:apps:rtp:1",
      media: media.mid
    });
    Object.keys(media.ssrcs).forEach((ssrcNum) => {
      const mediaSsrc = media.ssrcs[ssrcNum];
      const ssrcLines = mediaSsrc.lines;
      const sourceName = _SDPUtil__WEBPACK_IMPORTED_MODULE_0__["default"].parseSourceNameLine(ssrcLines);
      const videoType = _SDPUtil__WEBPACK_IMPORTED_MODULE_0__["default"].parseVideoTypeLine(ssrcLines);
      modify.c("source", { xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0" });
      modify.attrs({
        name: sourceName,
        videoType,
        ssrc: mediaSsrc.ssrc
      });
      const msid = _SDPUtil__WEBPACK_IMPORTED_MODULE_0__["default"].parseMSIDAttribute(ssrcLines);
      if (msid) {
        modify.c("parameter");
        modify.attrs({ name: "msid" });
        modify.attrs({ value: msid });
        modify.up();
      }
      modify.up();
    });
    media.ssrcGroups.forEach((ssrcGroup) => {
      if (ssrcGroup.ssrcs.length) {
        modify.c("ssrc-group", {
          semantics: ssrcGroup.semantics,
          xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
        });
        ssrcGroup.ssrcs.forEach((ssrc) => {
          modify.c("source", { ssrc }).up();
        });
        modify.up();
      }
    });
    modify.up();
    modify.up();
  });
  return modified;
};


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/sdp/SDPUtil.js":
/*!************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/sdp/SDPUtil.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/CodecMimeType */ "../../lib-jitsi-meet/dist/esm/service/RTC/CodecMimeType.js");
/* harmony import */ var _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/MediaDirection */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaDirection.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _util_RandomUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/RandomUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/RandomUtil.js");
/* harmony import */ var _util_RandomUtil__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_util_RandomUtil__WEBPACK_IMPORTED_MODULE_4__);


const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);




const SDPUtil = {
  filterSpecialChars(text) {
    return text ? text.replace(/[\\\/\{,\}\+]/g, "") : text;
  },
  iceparams(mediadesc, sessiondesc) {
    let data = null;
    let pwd, ufrag;
    if ((ufrag = SDPUtil.findLine(mediadesc, "a=ice-ufrag:", sessiondesc)) && (pwd = SDPUtil.findLine(mediadesc, "a=ice-pwd:", sessiondesc))) {
      data = {
        ufrag: SDPUtil.parseICEUfrag(ufrag),
        pwd: SDPUtil.parseICEPwd(pwd)
      };
    }
    return data;
  },
  parseICEUfrag(line) {
    return line.substring(12);
  },
  buildICEUfrag(frag) {
    return `a=ice-ufrag:${frag}`;
  },
  parseICEPwd(line) {
    return line.substring(10);
  },
  buildICEPwd(pwd) {
    return `a=ice-pwd:${pwd}`;
  },
  parseMID(line) {
    return line.substring(6);
  },
  parseMSIDAttribute(ssrcLines) {
    const msidLine = ssrcLines.find((line) => line.indexOf(" msid:") > 0);
    if (!msidLine) {
      return void 0;
    }
    const v = msidLine.substring(msidLine.indexOf(" msid:") + 6);
    return SDPUtil.filterSpecialChars(v);
  },
  parseMLine(line) {
    const data = {};
    const parts = line.substring(2).split(" ");
    data.media = parts.shift();
    data.port = parts.shift();
    data.proto = parts.shift();
    if (parts[parts.length - 1] === "") {
      parts.pop();
    }
    data.fmt = parts;
    return data;
  },
  buildMLine(mline) {
    return `m=${mline.media} ${mline.port} ${mline.proto} ${mline.fmt.join(" ")}`;
  },
  parseRTPMap(line) {
    const data = {};
    let parts = line.substring(9).split(" ");
    data.id = parts.shift();
    parts = parts[0].split("/");
    data.name = parts.shift();
    data.clockrate = parts.shift();
    data.channels = parts.length ? parts.shift() : "1";
    return data;
  },
  parseSCTPMap(line) {
    const parts = line.substring(10).split(" ");
    const sctpPort = parts[0];
    const protocol = parts[1];
    const streamCount = parts.length > 2 ? parts[2] : null;
    return [sctpPort, protocol, streamCount];
  },
  parseSCTPPort(line) {
    return line.substring(12);
  },
  buildRTPMap(el) {
    let line = `a=rtpmap:${el.getAttribute("id")} ${el.getAttribute("name")}/${el.getAttribute("clockrate")}`;
    if (el.getAttribute("channels") && el.getAttribute("channels") !== "1") {
      line += `/${el.getAttribute("channels")}`;
    }
    return line;
  },
  parseCrypto(line) {
    const data = {};
    const parts = line.substring(9).split(" ");
    data.tag = parts.shift();
    data["crypto-suite"] = parts.shift();
    data["key-params"] = parts.shift();
    if (parts.length) {
      data["session-params"] = parts.join(" ");
    }
    return data;
  },
  parseFingerprint(line) {
    const data = {};
    const parts = line.substring(14).split(" ");
    data.hash = parts.shift();
    data.fingerprint = parts.shift();
    return data;
  },
  parseFmtp(line) {
    const data = [];
    let parts = line.split(" ");
    parts.shift();
    parts = parts.join(" ").split(";");
    for (let i = 0; i < parts.length; i++) {
      let key = parts[i].split("=")[0];
      while (key.length && key[0] === " ") {
        key = key.substring(1);
      }
      const value = parts[i].split("=")[1];
      if (key && value) {
        data.push({
          name: key,
          value
        });
      } else if (key) {
        data.push({
          name: "",
          value: key
        });
      }
    }
    return data;
  },
  parseICECandidate(line) {
    const candidate = {};
    const elems = line.split(" ");
    candidate.foundation = elems[0].substring(12);
    candidate.component = elems[1];
    candidate.protocol = elems[2].toLowerCase();
    candidate.priority = elems[3];
    candidate.ip = elems[4];
    candidate.port = elems[5];
    candidate.type = elems[7];
    candidate.generation = 0;
    for (let i = 8; i < elems.length; i += 2) {
      switch (elems[i]) {
        case "raddr":
          candidate["rel-addr"] = elems[i + 1];
          break;
        case "rport":
          candidate["rel-port"] = elems[i + 1];
          break;
        case "generation":
          candidate.generation = elems[i + 1];
          break;
        case "tcptype":
          candidate.tcptype = elems[i + 1];
          break;
        default:
          logger.debug(`parseICECandidate not translating "${elems[i]}" = "${elems[i + 1]}"`);
      }
    }
    candidate.network = "1";
    candidate.id = Math.random().toString(36).substr(2, 10);
    return candidate;
  },
  buildICECandidate(cand) {
    let line = [
      `a=candidate:${cand.foundation}`,
      cand.component,
      cand.protocol,
      cand.priority,
      cand.ip,
      cand.port,
      "typ",
      cand.type
    ].join(" ");
    line += " ";
    switch (cand.type) {
      case "srflx":
      case "prflx":
      case "relay":
        if (cand.hasOwnAttribute("rel-addr") && cand.hasOwnAttribute("rel-port")) {
          line += "raddr";
          line += " ";
          line += cand["rel-addr"];
          line += " ";
          line += "rport";
          line += " ";
          line += cand["rel-port"];
          line += " ";
        }
        break;
    }
    if (cand.hasOwnAttribute("tcptype")) {
      line += "tcptype";
      line += " ";
      line += cand.tcptype;
      line += " ";
    }
    line += "generation";
    line += " ";
    line += cand.hasOwnAttribute("generation") ? cand.generation : "0";
    return line;
  },
  parseSSRC(desc) {
    const data = /* @__PURE__ */ new Map();
    const lines = desc.split("\r\n");
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].substring(0, 7) === "a=ssrc:") {
        const ssrc = lines[i].split("a=ssrc:")[1].split(" ")[0];
        if (!data.get(ssrc)) {
          data.set(ssrc, []);
        }
        data.get(ssrc).push(lines[i]);
      }
    }
    return data;
  },
  parseSourceNameLine(ssrcLines) {
    const sourceNameLine = ssrcLines.find((ssrcSdpLine) => ssrcSdpLine.indexOf(" name:") > 0);
    return sourceNameLine === null || sourceNameLine === void 0 ? void 0 : sourceNameLine.substring(sourceNameLine.indexOf(" name:") + 6);
  },
  parseVideoTypeLine(ssrcLines) {
    const s = " videoType:";
    const videoTypeLine = ssrcLines.find((ssrcSdpLine) => ssrcSdpLine.indexOf(s) > 0);
    return videoTypeLine === null || videoTypeLine === void 0 ? void 0 : videoTypeLine.substring(videoTypeLine.indexOf(s) + s.length);
  },
  parseRTCPFB(line) {
    const parts = line.substr(10).split(" ");
    const data = {};
    data.pt = parts.shift();
    data.type = parts.shift();
    data.params = parts;
    return data;
  },
  parseExtmap(line) {
    const parts = line.substr(9).split(" ");
    const data = {};
    data.value = parts.shift();
    if (data.value.indexOf("/") === -1) {
      data.direction = "both";
    } else {
      data.direction = data.value.substr(data.value.indexOf("/") + 1);
      data.value = data.value.substr(0, data.value.indexOf("/"));
    }
    data.uri = parts.shift();
    data.params = parts;
    return data;
  },
  findLine(haystack, needle, sessionpart) {
    let lines = haystack.split("\r\n");
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].substring(0, needle.length) === needle) {
        return lines[i];
      }
    }
    if (!sessionpart) {
      return false;
    }
    lines = sessionpart.split("\r\n");
    for (let j = 0; j < lines.length; j++) {
      if (lines[j].substring(0, needle.length) === needle) {
        return lines[j];
      }
    }
    return false;
  },
  findLines(haystack, needle, sessionpart) {
    let lines = haystack.split("\r\n");
    const needles = [];
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].substring(0, needle.length) === needle) {
        needles.push(lines[i]);
      }
    }
    if (needles.length || !sessionpart) {
      return needles;
    }
    lines = sessionpart.split("\r\n");
    for (let j = 0; j < lines.length; j++) {
      if (lines[j].substring(0, needle.length) === needle) {
        needles.push(lines[j]);
      }
    }
    return needles;
  },
  candidateToJingle(line) {
    if (line.indexOf("candidate:") === 0) {
      line = `a=${line}`;
    } else if (line.substring(0, 12) !== "a=candidate:") {
      logger.warn("parseCandidate called with a line that is not a candidate line");
      logger.warn(line);
      return null;
    }
    if (line.substring(line.length - 2) === "\r\n") {
      line = line.substring(0, line.length - 2);
    }
    const candidate = {};
    const elems = line.split(" ");
    if (elems[6] !== "typ") {
      logger.warn("did not find typ in the right place");
      logger.warn(line);
      return null;
    }
    candidate.foundation = elems[0].substring(12);
    candidate.component = elems[1];
    candidate.protocol = elems[2].toLowerCase();
    candidate.priority = elems[3];
    candidate.ip = elems[4];
    candidate.port = elems[5];
    candidate.type = elems[7];
    candidate.generation = "0";
    for (let i = 8; i < elems.length; i += 2) {
      switch (elems[i]) {
        case "raddr":
          candidate["rel-addr"] = elems[i + 1];
          break;
        case "rport":
          candidate["rel-port"] = elems[i + 1];
          break;
        case "generation":
          candidate.generation = elems[i + 1];
          break;
        case "tcptype":
          candidate.tcptype = elems[i + 1];
          break;
        default:
          logger.debug(`not translating "${elems[i]}" = "${elems[i + 1]}"`);
      }
    }
    candidate.network = "1";
    candidate.id = Math.random().toString(36).substr(2, 10);
    return candidate;
  },
  candidateFromJingle(cand) {
    let line = "a=candidate:";
    line += cand.getAttribute("foundation");
    line += " ";
    line += cand.getAttribute("component");
    line += " ";
    let protocol = cand.getAttribute("protocol");
    if (_browser__WEBPACK_IMPORTED_MODULE_3__["default"].isFirefox() && protocol.toLowerCase() === "ssltcp") {
      protocol = "tcp";
    }
    line += protocol;
    line += " ";
    line += cand.getAttribute("priority");
    line += " ";
    line += cand.getAttribute("ip");
    line += " ";
    line += cand.getAttribute("port");
    line += " ";
    line += "typ";
    line += ` ${cand.getAttribute("type")}`;
    line += " ";
    switch (cand.getAttribute("type")) {
      case "srflx":
      case "prflx":
      case "relay":
        if (cand.getAttribute("rel-addr") && cand.getAttribute("rel-port")) {
          line += "raddr";
          line += " ";
          line += cand.getAttribute("rel-addr");
          line += " ";
          line += "rport";
          line += " ";
          line += cand.getAttribute("rel-port");
          line += " ";
        }
        break;
    }
    if (protocol.toLowerCase() === "tcp") {
      line += "tcptype";
      line += " ";
      line += cand.getAttribute("tcptype");
      line += " ";
    }
    line += "generation";
    line += " ";
    line += cand.getAttribute("generation") || "0";
    return `${line}\r
`;
  },
  parsePrimaryVideoSsrc(videoMLine) {
    const numSsrcs = videoMLine.ssrcs.map((ssrcInfo) => ssrcInfo.id).filter((ssrc, index, array) => array.indexOf(ssrc) === index).length;
    const numGroups = videoMLine.ssrcGroups && videoMLine.ssrcGroups.length || 0;
    if (numSsrcs > 1 && numGroups === 0) {
      return;
    }
    let primarySsrc = null;
    if (numSsrcs === 1) {
      primarySsrc = videoMLine.ssrcs[0].id;
    } else if (numSsrcs === 2) {
      const fidGroup = videoMLine.ssrcGroups.find((group) => group.semantics === "FID");
      if (fidGroup) {
        primarySsrc = fidGroup.ssrcs.split(" ")[0];
      }
    } else if (numSsrcs >= 3) {
      const simGroup = videoMLine.ssrcGroups.find((group) => group.semantics === "SIM");
      if (simGroup) {
        primarySsrc = simGroup.ssrcs.split(" ")[0];
      }
    }
    return primarySsrc;
  },
  generateSsrc() {
    return _util_RandomUtil__WEBPACK_IMPORTED_MODULE_4___default().randomInt(1, 4294967295);
  },
  getSsrcAttribute(mLine, ssrc, attributeName) {
    for (let i = 0; i < mLine.ssrcs.length; ++i) {
      const ssrcLine = mLine.ssrcs[i];
      if (ssrcLine.id === ssrc && ssrcLine.attribute === attributeName) {
        return ssrcLine.value;
      }
    }
  },
  parseGroupSsrcs(ssrcGroup) {
    return ssrcGroup.ssrcs.split(" ").map((ssrcStr) => parseInt(ssrcStr, 10));
  },
  getMedia(sdp, type) {
    return sdp.media.find((m) => m.type === type);
  },
  getUfrag(sdp) {
    const ufragLines = sdp.split("\n").filter((line) => line.startsWith("a=ice-ufrag:"));
    if (ufragLines.length > 0) {
      return ufragLines[0].substr("a=ice-ufrag:".length);
    }
  },
  preferCodec(mline, codecName) {
    if (!mline || !codecName) {
      return;
    }
    const matchingPayloadTypes = mline.rtp.filter((rtp) => rtp.codec && rtp.codec.toLowerCase() === codecName.toLowerCase()).map((rtp) => rtp.payload);
    if (matchingPayloadTypes) {
      const payloadTypes = mline.payloads.toString().split(" ").map((p) => parseInt(p, 10));
      for (const pt of matchingPayloadTypes.reverse()) {
        const payloadIndex = payloadTypes.indexOf(pt);
        payloadTypes.splice(payloadIndex, 1);
        payloadTypes.unshift(pt);
      }
      mline.payloads = payloadTypes.join(" ");
    } else {
      logger.error(`No matching RTP payload type found for ${codecName}, failed to set preferred codecs`);
    }
  },
  stripCodec(mLine, codecName, highProfile = false) {
    if (!mLine || !codecName) {
      return;
    }
    const h264Pts = [];
    let removePts = [];
    const stripH264HighCodec = codecName.toLowerCase() === _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_1__["default"].H264 && highProfile;
    for (const rtp of mLine.rtp) {
      if (rtp.codec && rtp.codec.toLowerCase() === codecName.toLowerCase()) {
        if (stripH264HighCodec) {
          h264Pts.push(rtp.payload);
        } else {
          removePts.push(rtp.payload);
        }
      }
    }
    if (stripH264HighCodec) {
      removePts = mLine.fmtp.filter((item) => h264Pts.indexOf(item.payload) > -1 && item.config.includes("profile-level-id=64")).map((item) => item.payload);
    }
    if (removePts.length > 0) {
      const rtxApts = removePts.map((item) => `apt=${item}`);
      const rtxPts = mLine.fmtp.filter((item) => rtxApts.indexOf(item.config) !== -1);
      removePts.push(...rtxPts.map((item) => item.payload));
      const allPts = mLine.payloads.toString().split(" ").map(Number);
      const keepPts = allPts.filter((pt) => removePts.indexOf(pt) === -1);
      if (keepPts.length === 0) {
        mLine.port = 0;
        mLine.direction = _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_2__.MediaDirection.INACTIVE;
        mLine.payloads = "*";
      } else {
        mLine.payloads = keepPts.join(" ");
      }
      mLine.rtp = mLine.rtp.filter((item) => keepPts.indexOf(item.payload) !== -1);
      mLine.fmtp = mLine.fmtp.filter((item) => keepPts.indexOf(item.payload) !== -1);
      if (mLine.rtcpFb) {
        mLine.rtcpFb = mLine.rtcpFb.filter((item) => keepPts.indexOf(item.payload) !== -1);
      }
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SDPUtil);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/sdp/SdpConsistency.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/sdp/SdpConsistency.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SdpConsistency)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _SdpTransformUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SdpTransformUtil */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SdpTransformUtil.js");




const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class SdpConsistency {
  constructor(logPrefix) {
    this.clearVideoSsrcCache();
    this.logPrefix = logPrefix;
  }
  clearVideoSsrcCache() {
    this.cachedPrimarySsrc = null;
    this.injectRecvOnly = false;
  }
  setPrimarySsrc(primarySsrc) {
    if (typeof primarySsrc !== "number") {
      throw new Error("Primary SSRC must be a number!");
    }
    this.cachedPrimarySsrc = primarySsrc;
  }
  hasPrimarySsrcCached() {
    return Boolean(this.cachedPrimarySsrc);
  }
  makeVideoPrimarySsrcsConsistent(sdpStr) {
    var _a;
    const sdpTransformer = new _SdpTransformUtil__WEBPACK_IMPORTED_MODULE_2__.SdpTransformWrap(sdpStr);
    const videoMLine = (_a = sdpTransformer.selectMedia(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_1__.MediaType.VIDEO)) === null || _a === void 0 ? void 0 : _a[0];
    if (!videoMLine) {
      logger.debug(`${this.logPrefix} no 'video' media found in the sdp: ${sdpStr}`);
      return sdpStr;
    }
    if (videoMLine.direction === "recvonly") {
      if (this.cachedPrimarySsrc && this.injectRecvOnly) {
        videoMLine.addSSRCAttribute({
          id: this.cachedPrimarySsrc,
          attribute: "cname",
          value: `recvonly-${this.cachedPrimarySsrc}`
        });
      } else {
        logger.info(`${this.logPrefix} no SSRC found for the recvonly video stream!`);
      }
    } else {
      const newPrimarySsrc = videoMLine.getPrimaryVideoSsrc();
      if (!newPrimarySsrc) {
        logger.info(`${this.logPrefix} sdp-consistency couldn't parse new primary ssrc`);
        return sdpStr;
      }
      if (this.cachedPrimarySsrc) {
        videoMLine.replaceSSRC(newPrimarySsrc, this.cachedPrimarySsrc);
        for (const group of videoMLine.ssrcGroups) {
          if (group.semantics === "FID") {
            const primarySsrc = (0,_SdpTransformUtil__WEBPACK_IMPORTED_MODULE_2__.parsePrimarySSRC)(group);
            const rtxSsrc = (0,_SdpTransformUtil__WEBPACK_IMPORTED_MODULE_2__.parseSecondarySSRC)(group);
            if (primarySsrc === newPrimarySsrc) {
              group.ssrcs = `${this.cachedPrimarySsrc} ${rtxSsrc}`;
            }
          }
        }
      } else {
        this.cachedPrimarySsrc = newPrimarySsrc;
      }
      this.injectRecvOnly = true;
    }
    return sdpTransformer.toRawSDP();
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/sdp/SdpSimulcast.js":
/*!*****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/sdp/SdpSimulcast.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SdpSimulcast)
/* harmony export */ });
/* harmony import */ var _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../service/RTC/MediaDirection */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaDirection.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var sdp_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sdp-transform */ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/index.js");




const DEFAULT_NUM_OF_LAYERS = 3;
class SdpSimulcast {
  constructor(options) {
    this._options = options;
    this._ssrcCache = /* @__PURE__ */ new Map();
    if (!this._options.numOfLayers) {
      this._options.numOfLayers = DEFAULT_NUM_OF_LAYERS;
    }
  }
  _fillSsrcsFromCache(mLine) {
    const mid = mLine.mid;
    const cachedSsrcs = this._ssrcCache.get(mid);
    const newSsrcs = this._parseSimLayers(mLine);
    const newMsid = this._getSsrcAttribute(mLine, newSsrcs[0], "msid");
    const newCname = this._getSsrcAttribute(mLine, newSsrcs[0], "cname");
    mLine.ssrcs = [];
    mLine.ssrcGroups = [];
    for (const ssrc of cachedSsrcs) {
      mLine.ssrcs.push({
        id: ssrc,
        attribute: "msid",
        value: newMsid
      });
      mLine.ssrcs.push({
        id: ssrc,
        attribute: "cname",
        value: newCname
      });
    }
    mLine.ssrcGroups.push({
      semantics: "SIM",
      ssrcs: cachedSsrcs.join(" ")
    });
    return mLine;
  }
  _generateNewSsrcsForSimulcast(mLine, primarySsrc) {
    const cname = this._getSsrcAttribute(mLine, primarySsrc, "cname");
    let msid = this._getSsrcAttribute(mLine, primarySsrc, "msid");
    const addAssociatedAttributes = (mLine2, ssrc) => {
      mLine2.ssrcs.push({
        id: ssrc,
        attribute: "cname",
        value: cname
      });
      mLine2.ssrcs.push({
        id: ssrc,
        attribute: "msid",
        value: msid
      });
    };
    if (!msid) {
      msid = mLine.msid;
      const primarySsrcs = mLine.ssrcs;
      primarySsrcs.forEach((ssrc) => {
        mLine.ssrcs.push({
          id: ssrc.id,
          attribute: "msid",
          value: msid
        });
      });
    }
    const simSsrcs = [];
    for (let i = 0; i < this._options.numOfLayers - 1; ++i) {
      const simSsrc = this._generateSsrc();
      addAssociatedAttributes(mLine, simSsrc);
      simSsrcs.push(simSsrc);
    }
    mLine.ssrcGroups = mLine.ssrcGroups || [];
    mLine.ssrcGroups.push({
      semantics: "SIM",
      ssrcs: primarySsrc + " " + simSsrcs.join(" ")
    });
    return mLine;
  }
  _generateSsrc() {
    const max = 4294967295;
    return Math.floor(Math.random() * max);
  }
  _getSsrcAttribute(mLine, ssrc, attributeName) {
    var _a, _b;
    return (_b = (_a = mLine.ssrcs) === null || _a === void 0 ? void 0 : _a.find((ssrcInfo) => Number(ssrcInfo.id) === ssrc && ssrcInfo.attribute === attributeName)) === null || _b === void 0 ? void 0 : _b.value;
  }
  _parseSimLayers(mLine) {
    var _a, _b;
    const simGroup = (_a = mLine.ssrcGroups) === null || _a === void 0 ? void 0 : _a.find((group) => group.semantics === "SIM");
    if (simGroup) {
      return simGroup.ssrcs.split(" ").map((ssrc) => Number(ssrc));
    }
    if ((_b = mLine.ssrcs) === null || _b === void 0 ? void 0 : _b.length) {
      return [Number(mLine.ssrcs[0].id)];
    }
    return null;
  }
  mungeLocalDescription(description) {
    var _a, _b, _c, _d;
    if (!description || !description.sdp) {
      return description;
    }
    const session = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(description.sdp);
    for (let media of session.media) {
      if (media.direction === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_0__.MediaDirection.RECVONLY || media.direction === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_0__.MediaDirection.INACTIVE) {
        continue;
      }
      if (media.type !== _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_1__.MediaType.VIDEO) {
        continue;
      }
      const mid = media.mid;
      const numSsrcs = new Set((_a = media.ssrcs) === null || _a === void 0 ? void 0 : _a.map((ssrcInfo) => ssrcInfo.id));
      const numGroups = (_c = (_b = media.ssrcGroups) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
      let primarySsrc;
      if (numSsrcs.size === 0 || numSsrcs.size > 2 || numSsrcs.size === 2 && numGroups === 0) {
        continue;
      }
      if (numSsrcs.size === 1) {
        primarySsrc = Number((_d = media.ssrcs[0]) === null || _d === void 0 ? void 0 : _d.id);
      } else {
        const fidGroup = media.ssrcGroups.find((group) => group.semantics === "FID");
        if (fidGroup) {
          primarySsrc = Number(fidGroup.ssrcs.split(" ")[0]);
        }
      }
      if (this._ssrcCache.has(mid)) {
        media = this._fillSsrcsFromCache(media);
      } else {
        media = this._generateNewSsrcsForSimulcast(media, primarySsrc);
        const simulcastSsrcs = this._parseSimLayers(media);
        this._ssrcCache.set(mid, simulcastSsrcs);
      }
    }
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp_transform__WEBPACK_IMPORTED_MODULE_2__.write(session)
    });
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/sdp/SdpTransformUtil.js":
/*!*********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/sdp/SdpTransformUtil.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SdpTransformWrap: () => (/* binding */ SdpTransformWrap),
/* harmony export */   parsePrimarySSRC: () => (/* binding */ parsePrimarySSRC),
/* harmony export */   parseSecondarySSRC: () => (/* binding */ parseSecondarySSRC)
/* harmony export */ });
/* harmony import */ var sdp_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdp-transform */ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/index.js");


function parsePrimarySSRC(group) {
  return parseInt(group.ssrcs.split(" ")[0], 10);
}
function parseSecondarySSRC(group) {
  return parseInt(group.ssrcs.split(" ")[1], 10);
}
function _getSSRCCount(mLine) {
  if (!mLine.ssrcs) {
    return 0;
  }
  return mLine.ssrcs.map((ssrcInfo) => ssrcInfo.id).filter((ssrc, index, array) => array.indexOf(ssrc) === index).length;
}
class MLineWrap {
  constructor(mLine) {
    if (!mLine) {
      throw new Error("mLine is undefined");
    }
    this.mLine = mLine;
  }
  get ssrcs() {
    if (!this.mLine.ssrcs) {
      this.mLine.ssrcs = [];
    }
    return this.mLine.ssrcs;
  }
  set ssrcs(ssrcs) {
    this.mLine.ssrcs = ssrcs;
  }
  get direction() {
    return this.mLine.direction;
  }
  set direction(direction) {
    this.mLine.direction = direction;
  }
  get ssrcGroups() {
    if (!this.mLine.ssrcGroups) {
      this.mLine.ssrcGroups = [];
    }
    return this.mLine.ssrcGroups;
  }
  set ssrcGroups(ssrcGroups) {
    this.mLine.ssrcGroups = ssrcGroups;
  }
  getSSRCAttrValue(ssrcNumber, attrName) {
    const attribute = this.ssrcs.find((ssrcObj) => ssrcObj.id === ssrcNumber && ssrcObj.attribute === attrName);
    return attribute && attribute.value;
  }
  removeSSRC(ssrcNum) {
    if (!this.mLine.ssrcs || !this.mLine.ssrcs.length) {
      return;
    }
    this.mLine.ssrcs = this.mLine.ssrcs.filter((ssrcObj) => ssrcObj.id !== ssrcNum);
  }
  addSSRCAttribute(ssrcObj) {
    this.ssrcs.push(ssrcObj);
  }
  findGroup(semantics, ssrcs) {
    return this.ssrcGroups.find((group) => group.semantics === semantics && (!ssrcs || ssrcs === group.ssrcs));
  }
  findGroups(semantics) {
    return this.ssrcGroups.filter((group) => group.semantics === semantics);
  }
  findGroupByPrimarySSRC(semantics, primarySSRC) {
    return this.ssrcGroups.find((group) => group.semantics === semantics && parsePrimarySSRC(group) === primarySSRC);
  }
  findSSRCByMSID(msid) {
    return this.ssrcs.find((ssrcObj) => ssrcObj.attribute === "msid" && (msid === null || ssrcObj.value === msid));
  }
  getSSRCCount() {
    return _getSSRCCount(this.mLine);
  }
  containsAnySSRCGroups() {
    return this.mLine.ssrcGroups !== void 0;
  }
  getPrimaryVideoSsrc() {
    const mediaType = this.mLine.type;
    if (mediaType !== "video") {
      throw new Error(`getPrimarySsrc doesn't work with '${mediaType}'`);
    }
    const numSsrcs = _getSSRCCount(this.mLine);
    if (numSsrcs === 1) {
      return this.mLine.ssrcs[0].id;
    }
    if (this.mLine.ssrcGroups) {
      const simGroup = this.findGroup("SIM");
      if (simGroup) {
        return parsePrimarySSRC(simGroup);
      }
      const fidGroup = this.findGroup("FID");
      if (fidGroup) {
        return parsePrimarySSRC(fidGroup);
      }
      const fecGroup = this.findGroup("FEC-FR");
      if (fecGroup) {
        return parsePrimarySSRC(fecGroup);
      }
    }
  }
  getRtxSSRC(primarySsrc) {
    const fidGroup = this.findGroupByPrimarySSRC("FID", primarySsrc);
    return fidGroup && parseSecondarySSRC(fidGroup);
  }
  getSSRCs() {
    return this.ssrcs.map((ssrcInfo) => ssrcInfo.id).filter((ssrc, index, array) => array.indexOf(ssrc) === index);
  }
  getPrimaryVideoSSRCs() {
    const mediaType = this.mLine.type;
    if (mediaType !== "video") {
      throw new Error(`getPrimaryVideoSSRCs doesn't work with ${mediaType}`);
    }
    const videoSSRCs = this.getSSRCs();
    for (const ssrcGroupInfo of this.ssrcGroups) {
      if (ssrcGroupInfo.semantics === "FID" || ssrcGroupInfo.semantics === "FEC-FR") {
        const secondarySsrc = parseSecondarySSRC(ssrcGroupInfo);
        videoSSRCs.splice(videoSSRCs.indexOf(secondarySsrc), 1);
      }
    }
    return videoSSRCs;
  }
  dumpSSRCGroups() {
    return JSON.stringify(this.mLine.ssrcGroups);
  }
  removeGroupsWithSSRC(ssrc) {
    if (!this.mLine.ssrcGroups) {
      return;
    }
    this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((groupInfo) => groupInfo.ssrcs.indexOf(`${ssrc}`) === -1);
  }
  removeGroupsBySemantics(semantics) {
    if (!this.mLine.ssrcGroups) {
      return;
    }
    this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((groupInfo) => groupInfo.semantics !== semantics);
  }
  replaceSSRC(oldSSRC, newSSRC) {
    if (this.mLine.ssrcs) {
      this.mLine.ssrcs.forEach((ssrcInfo) => {
        if (ssrcInfo.id === oldSSRC) {
          ssrcInfo.id = newSSRC;
        }
      });
    }
  }
  addSSRCGroup(group) {
    this.ssrcGroups.push(group);
  }
}
class SdpTransformWrap {
  constructor(rawSDP) {
    this.parsedSDP = sdp_transform__WEBPACK_IMPORTED_MODULE_0__.parse(rawSDP);
  }
  selectMedia(mediaType) {
    const selectedMLines = this.parsedSDP.media.filter((mLine) => mLine.type === mediaType).map((mLine) => new MLineWrap(mLine));
    return selectedMLines !== null && selectedMLines !== void 0 ? selectedMLines : null;
  }
  toRawSDP() {
    return sdp_transform__WEBPACK_IMPORTED_MODULE_0__.write(this.parsedSDP);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/settings/Settings.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/settings/Settings.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jitsi_js_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/js-utils */ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _util_UsernameGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/UsernameGenerator */ "../../lib-jitsi-meet/dist/esm/modules/util/UsernameGenerator.js");
/* harmony import */ var _util_UsernameGenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_util_UsernameGenerator__WEBPACK_IMPORTED_MODULE_2__);



const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_1__.getLogger)(__filename);

let _callStatsUserName;
let _machineId;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  _storage: _jitsi_js_utils__WEBPACK_IMPORTED_MODULE_0__.jitsiLocalStorage,
  init(externalStorage) {
    this._storage = externalStorage || _jitsi_js_utils__WEBPACK_IMPORTED_MODULE_0__.jitsiLocalStorage;
  },
  get callStatsUserName() {
    if (!_callStatsUserName) {
      _callStatsUserName = this._storage.getItem("callStatsUserName");
      if (!_callStatsUserName) {
        _callStatsUserName = generateCallStatsUserName();
        this._storage.setItem("callStatsUserName", _callStatsUserName);
      }
    }
    return _callStatsUserName;
  },
  get machineId() {
    if (!_machineId) {
      const amDid = this._storage.getItem("billingId");
      _machineId = amDid || this._storage.getItem("jitsiMeetId");
      if (amDid) {
        this._storage.setItem("jitsiMeetId", amDid);
      } else if (!_machineId) {
        _machineId = generateJitsiMeetId();
        this._storage.setItem("jitsiMeetId", _machineId);
      }
    }
    return _machineId;
  },
  get sessionId() {
    return this._storage.getItem("sessionId");
  },
  set sessionId(sessionId) {
    if (sessionId) {
      this._storage.setItem("sessionId", sessionId);
    } else {
      this._storage.removeItem("sessionId");
    }
  }
});
function generateCallStatsUserName() {
  const username = _util_UsernameGenerator__WEBPACK_IMPORTED_MODULE_2___default().generateUsername();
  logger.log("generated callstats uid", username);
  return username;
}
function generateJitsiMeetId() {
  const jitsiMeetId = generateUniqueId();
  logger.log("generated id", jitsiMeetId);
  return jitsiMeetId;
}
function generateUniqueId() {
  return _p8() + _p8() + _p8() + _p8();
}
function _p8() {
  return `${Math.random().toString(16)}000000000`.substr(2, 8);
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/AnalyticsAdapter.js":
/*!****************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/AnalyticsAdapter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");




const MAX_CACHE_SIZE = 100;
const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class AnalyticsAdapter {
  constructor() {
    this.reset();
  }
  reset() {
    this.disposed = false;
    this.analyticsHandlers = /* @__PURE__ */ new Set();
    this.cache = [];
    this.permanentProperties = {};
    this.conferenceName = "";
    this.addPermanentProperties({
      "user_agent": navigator.userAgent,
      "browser_name": _browser__WEBPACK_IMPORTED_MODULE_2__["default"].getName()
    });
  }
  dispose() {
    logger.warn("Disposing of analytics adapter.");
    if (this.analyticsHandlers && this.analyticsHandlers.size > 0) {
      this.analyticsHandlers.forEach((handler) => {
        if (typeof handler.dispose === "function") {
          handler.dispose();
        }
      });
    }
    this.setAnalyticsHandlers([]);
    this.disposed = true;
  }
  setAnalyticsHandlers(handlers) {
    if (this.disposed) {
      return;
    }
    this.analyticsHandlers = new Set(handlers);
    this._setUserProperties();
    const cache = this.cache;
    this.cache = null;
    if (cache) {
      cache.forEach((event) => this._sendEvent(event));
    }
  }
  _setUserProperties() {
    this.analyticsHandlers.forEach((handler) => {
      try {
        handler.setUserProperties(this.permanentProperties);
      } catch (error) {
        logger.warn(`Error in setUserProperties method of one of the analytics handlers: ${error}`);
      }
    });
  }
  addPermanentProperties(properties) {
    this.permanentProperties = Object.assign(Object.assign({}, this.permanentProperties), properties);
    this._setUserProperties();
  }
  setConferenceName(name) {
    this.conferenceName = name;
    this.addPermanentProperties({ "conference_name": name });
  }
  sendEvent(eventName, properties = {}) {
    if (this.disposed) {
      return;
    }
    let event = null;
    if (typeof eventName === "string") {
      event = {
        type: _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_1__.TYPE_OPERATIONAL,
        action: eventName,
        actionSubject: eventName,
        source: eventName,
        attributes: properties
      };
    } else if (typeof eventName === "object") {
      event = eventName;
    }
    if (!this._verifyRequiredFields(event)) {
      logger.error(`Dropping a mis-formatted event: ${JSON.stringify(event)}`);
      return;
    }
    this._sendEvent(event);
  }
  _verifyRequiredFields(event) {
    if (!event) {
      return false;
    }
    if (!event.type) {
      event.type = _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_1__.TYPE_OPERATIONAL;
    }
    const type = event.type;
    if (type !== _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_1__.TYPE_OPERATIONAL && type !== _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_1__.TYPE_PAGE && type !== _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_1__.TYPE_UI && type !== _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_1__.TYPE_TRACK) {
      logger.error(`Unknown event type: ${type}`);
      return false;
    }
    if (type === _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_1__.TYPE_PAGE) {
      return Boolean(event.name);
    }
    event.action = event.action || event.name || event.actionSubject;
    event.actionSubject = event.actionSubject || event.name || event.action;
    event.source = event.source || event.name || event.action || event.actionSubject;
    if (!event.action || !event.actionSubject || !event.source) {
      logger.error("Required field missing (action, actionSubject or source)");
      return false;
    }
    if (type === _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_1__.TYPE_TRACK) {
      event.objectType = event.objectType || "generic-object-type";
      event.containerType = event.containerType || "conference";
      if (event.containerType === "conference" && !event.containerId) {
        event.containerId = this.conferenceName;
      }
      if (!event.objectType || !event.objectId || !event.containerType || !event.containerId) {
        logger.error("Required field missing (containerId, containerType, objectId or objectType)");
        return false;
      }
    }
    return true;
  }
  _maybeCacheEvent(event) {
    if (this.cache) {
      this.cache.push(event);
      if (this.cache.length > MAX_CACHE_SIZE) {
        this.cache.splice(0, 1);
      }
      return true;
    }
    return false;
  }
  _sendEvent(event) {
    if (this._maybeCacheEvent(event)) {
    } else {
      this.analyticsHandlers.forEach((handler) => {
        try {
          handler.sendEvent(event);
        } catch (e) {
          logger.warn(`Error sending analytics event: ${e}`);
        }
      });
    }
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new AnalyticsAdapter());


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/AudioOutputProblemDetector.js":
/*!**************************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/AudioOutputProblemDetector.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioOutputProblemDetector)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/connectivity/ConnectionQualityEvents */ "../../lib-jitsi-meet/dist/esm/service/connectivity/ConnectionQualityEvents.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _statistics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");







const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const NUMBER_OF_LOCAL_SAMPLES = 2;
class AudioOutputProblemDetector {
  constructor(conference) {
    this._conference = conference;
    this._localAudioLevelCache = {};
    this._reportedParticipants = [];
    this._audioProblemCandidates = {};
    this._numberOfRemoteAudioLevelsReceived = {};
    this._onLocalAudioLevelsReport = this._onLocalAudioLevelsReport.bind(this);
    this._onRemoteAudioLevelReceived = this._onRemoteAudioLevelReceived.bind(this);
    this._clearUserData = this._clearUserData.bind(this);
    this._conference.on(_service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_3__.REMOTE_STATS_UPDATED, this._onRemoteAudioLevelReceived);
    this._conference.statistics.addConnectionStatsListener(this._onLocalAudioLevelsReport);
    this._conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.USER_LEFT, this._clearUserData);
  }
  _onRemoteAudioLevelReceived(userID, { avgAudioLevels }) {
    const numberOfReports = this._numberOfRemoteAudioLevelsReceived[userID] + 1 || 0;
    this._numberOfRemoteAudioLevelsReceived[userID] = numberOfReports;
    if (this._reportedParticipants.indexOf(userID) !== -1 || userID in this._audioProblemCandidates || avgAudioLevels <= 0 || numberOfReports < 3) {
      return;
    }
    const participant = this._conference.getParticipantById(userID);
    if (participant) {
      const tracks = participant.getTracksByMediaType(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.AUDIO);
      if (tracks.length > 0 && participant.isAudioMuted()) {
        return;
      }
    }
    const localAudioLevels = this._localAudioLevelCache[userID];
    if (!Array.isArray(localAudioLevels) || localAudioLevels.every((audioLevel) => audioLevel === 0)) {
      this._audioProblemCandidates[userID] = {
        remoteAudioLevels: avgAudioLevels,
        localAudioLevels: []
      };
    }
  }
  _onLocalAudioLevelsReport(tpc, { avgAudioLevels }) {
    if (tpc !== this._conference.getActivePeerConnection()) {
      return;
    }
    Object.keys(avgAudioLevels).forEach((userID) => {
      if (this._reportedParticipants.indexOf(userID) !== -1) {
        return;
      }
      const localAudioLevels = this._localAudioLevelCache[userID];
      if (!Array.isArray(localAudioLevels)) {
        this._localAudioLevelCache[userID] = [];
      } else if (localAudioLevels.length >= NUMBER_OF_LOCAL_SAMPLES) {
        localAudioLevels.shift();
      }
      this._localAudioLevelCache[userID].push(avgAudioLevels[userID]);
    });
    Object.keys(this._audioProblemCandidates).forEach((userID) => {
      const { localAudioLevels, remoteAudioLevels } = this._audioProblemCandidates[userID];
      localAudioLevels.push(avgAudioLevels[userID]);
      if (localAudioLevels.length === NUMBER_OF_LOCAL_SAMPLES) {
        if (localAudioLevels.every((audioLevel) => typeof audioLevel === "undefined" || audioLevel === 0)) {
          const localAudioLevelsString = JSON.stringify(localAudioLevels);
          _statistics__WEBPACK_IMPORTED_MODULE_5__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__.createAudioOutputProblemEvent)(userID, localAudioLevelsString, remoteAudioLevels));
          logger.warn(`A potential problem is detected with the audio output for participant ${userID}, local audio levels: ${localAudioLevelsString}, remote audio levels: ${remoteAudioLevels}`);
          this._reportedParticipants.push(userID);
          this._clearUserData(userID);
        }
        delete this._audioProblemCandidates[userID];
      }
    });
  }
  _clearUserData(userID) {
    delete this._localAudioLevelCache[userID];
  }
  dispose() {
    this._conference.off(_service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_3__.REMOTE_STATS_UPDATED, this._onRemoteAudioLevelReceived);
    this._conference.off(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.USER_LEFT, this._clearUserData);
    this._conference.statistics.removeConnectionStatsListener(this._onLocalAudioLevelsReport);
    this._localAudioLevelCache = void 0;
    this._audioProblemCandidates = void 0;
    this._reportedParticipants = void 0;
    this._numberOfRemoteAudioLevelsReceived = void 0;
    this._conference = void 0;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/AvgRTPStatsReporter.js":
/*!*******************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/AvgRTPStatsReporter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AvgRTPStatsReporter)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.isequal */ "../../lib-jitsi-meet/node_modules/lodash.isequal/index.js");
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../service/connectivity/ConnectionQualityEvents */ "../../lib-jitsi-meet/dist/esm/service/connectivity/ConnectionQualityEvents.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _statistics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");










const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class AverageStatReport {
  constructor(name) {
    this.name = name;
    this.count = 0;
    this.sum = 0;
    this.samples = [];
  }
  addNext(nextValue) {
    if (typeof nextValue === "undefined") {
      return;
    }
    if (typeof nextValue !== "number") {
      logger.error(`${this.name} - invalid value for idx: ${this.count}`, nextValue);
    } else if (!isNaN(nextValue)) {
      this.sum += nextValue;
      this.samples.push(nextValue);
      this.count += 1;
    }
  }
  calculate() {
    return this.sum / this.count;
  }
  appendReport(report) {
    report[`${this.name}_avg`] = this.calculate();
    report[`${this.name}_samples`] = JSON.stringify(this.samples);
  }
  reset() {
    this.samples = [];
    this.sum = 0;
    this.count = 0;
  }
}
class ConnectionAvgStats {
  constructor(avgRtpStatsReporter, isP2P, n) {
    this.isP2P = isP2P;
    this._n = n;
    this._sampleIdx = 0;
    this._avgRTT = new AverageStatReport("rtt");
    this._avgRemoteRTTMap = /* @__PURE__ */ new Map();
    this._avgRtpStatsReporter = avgRtpStatsReporter;
    this._avgEnd2EndRTT = void 0;
    this._onConnectionStats = (tpc, stats) => {
      if (this.isP2P === tpc.isP2P) {
        this._calculateAvgStats(stats);
      }
    };
    const conference = avgRtpStatsReporter._conference;
    conference.statistics.addConnectionStatsListener(this._onConnectionStats);
    if (!this.isP2P) {
      this._onUserLeft = (id) => this._avgRemoteRTTMap.delete(id);
      conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.USER_LEFT, this._onUserLeft);
      this._onRemoteStatsUpdated = (id, data) => this._processRemoteStats(id, data);
      conference.on(_service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_5__.REMOTE_STATS_UPDATED, this._onRemoteStatsUpdated);
    }
  }
  _calculateAvgStats(data) {
    if (!data) {
      logger.error("No stats");
      return;
    }
    if (_browser__WEBPACK_IMPORTED_MODULE_7__["default"].supportsRTTStatistics()) {
      if (data.transport && data.transport.length) {
        this._avgRTT.addNext(data.transport[0].rtt);
      }
    }
    this._sampleIdx += 1;
    if (this._sampleIdx >= this._n) {
      if (_browser__WEBPACK_IMPORTED_MODULE_7__["default"].supportsRTTStatistics()) {
        const conference = this._avgRtpStatsReporter._conference;
        const batchReport = {
          p2p: this.isP2P,
          "conference_size": conference.getParticipantCount()
        };
        if (data.transport && data.transport.length) {
          Object.assign(batchReport, {
            "local_candidate_type": data.transport[0].localCandidateType,
            "remote_candidate_type": data.transport[0].remoteCandidateType,
            "transport_type": data.transport[0].type
          });
        }
        this._avgRTT.appendReport(batchReport);
        if (this.isP2P) {
          const jvbEnd2EndRTT = this._avgRtpStatsReporter.jvbStatsMonitor._avgEnd2EndRTT;
          if (!isNaN(jvbEnd2EndRTT)) {
            batchReport["rtt_diff"] = this._avgRTT.calculate() - jvbEnd2EndRTT;
          }
        } else {
          const avgRemoteRTT = this._calculateAvgRemoteRTT();
          const avgLocalRTT = this._avgRTT.calculate();
          this._avgEnd2EndRTT = avgLocalRTT + avgRemoteRTT;
          if (!isNaN(avgLocalRTT) && !isNaN(avgRemoteRTT)) {
            batchReport["end2end_rtt_avg"] = this._avgEnd2EndRTT;
          }
        }
        _statistics__WEBPACK_IMPORTED_MODULE_8__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_6__.createRtpStatsEvent)(batchReport));
      }
      this._resetAvgStats();
    }
  }
  _calculateAvgRemoteRTT() {
    let count = 0, sum = 0;
    for (const remoteAvg of this._avgRemoteRTTMap.values()) {
      const avg = remoteAvg.calculate();
      if (!isNaN(avg)) {
        sum += avg;
        count += 1;
        remoteAvg.reset();
      }
    }
    return sum / count;
  }
  _processRemoteStats(id, data) {
    const validData = typeof data.jvbRTT === "number";
    let rttAvg = this._avgRemoteRTTMap.get(id);
    if (!rttAvg && validData) {
      rttAvg = new AverageStatReport(`${id}_stat_rtt`);
      this._avgRemoteRTTMap.set(id, rttAvg);
    }
    if (validData) {
      rttAvg.addNext(data.jvbRTT);
    } else if (rttAvg) {
      this._avgRemoteRTTMap.delete(id);
    }
  }
  _resetAvgStats() {
    this._avgRTT.reset();
    if (this._avgRemoteRTTMap) {
      this._avgRemoteRTTMap.clear();
    }
    this._sampleIdx = 0;
  }
  dispose() {
    const conference = this._avgRtpStatsReporter._conference;
    conference.statistics.removeConnectionStatsListener(this._onConnectionStats);
    if (!this.isP2P) {
      conference.off(_service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_5__.REMOTE_STATS_UPDATED, this._onRemoteStatsUpdated);
      conference.off(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.USER_LEFT, this._onUserLeft);
    }
  }
}
class AvgRTPStatsReporter {
  constructor(conference, n) {
    this._n = n;
    if (n > 0) {
      logger.info(`Avg RTP stats will be calculated every ${n} samples`);
    } else {
      logger.info("Avg RTP stats reports are disabled.");
      return;
    }
    this._sampleIdx = 0;
    this._conference = conference;
    this._avgAudioBitrateUp = new AverageStatReport("bitrate_audio_upload");
    this._avgAudioBitrateDown = new AverageStatReport("bitrate_audio_download");
    this._avgVideoBitrateUp = new AverageStatReport("bitrate_video_upload");
    this._avgVideoBitrateDown = new AverageStatReport("bitrate_video_download");
    this._avgBandwidthUp = new AverageStatReport("bandwidth_upload");
    this._avgBandwidthDown = new AverageStatReport("bandwidth_download");
    this._avgPacketLossTotal = new AverageStatReport("packet_loss_total");
    this._avgPacketLossUp = new AverageStatReport("packet_loss_upload");
    this._avgPacketLossDown = new AverageStatReport("packet_loss_download");
    this._avgRemoteFPS = new AverageStatReport("framerate_remote");
    this._avgRemoteScreenFPS = new AverageStatReport("framerate_screen_remote");
    this._avgLocalFPS = new AverageStatReport("framerate_local");
    this._avgLocalScreenFPS = new AverageStatReport("framerate_screen_local");
    this._avgRemoteCameraPixels = new AverageStatReport("pixels_remote");
    this._avgRemoteScreenPixels = new AverageStatReport("pixels_screen_remote");
    this._avgLocalCameraPixels = new AverageStatReport("pixels_local");
    this._avgLocalScreenPixels = new AverageStatReport("pixels_screen_local");
    this._avgCQ = new AverageStatReport("connection_quality");
    this._cachedTransportStats = void 0;
    this._onLocalStatsUpdated = (data) => {
      this._calculateAvgStats(data);
      this._maybeSendTransportAnalyticsEvent(data);
    };
    conference.on(_service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_5__.LOCAL_STATS_UPDATED, this._onLocalStatsUpdated);
    this._onP2PStatusChanged = () => {
      logger.debug("Resetting average stats calculation");
      this._resetAvgStats();
      this.jvbStatsMonitor._resetAvgStats();
      this.p2pStatsMonitor._resetAvgStats();
    };
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.P2P_STATUS, this._onP2PStatusChanged);
    this._onJvb121StatusChanged = (oldStatus, newStatus) => {
      if (newStatus === true) {
        logger.info("Resetting JVB avg RTP stats");
        this._resetAvgJvbStats();
      }
    };
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.JVB121_STATUS, this._onJvb121StatusChanged);
    this.jvbStatsMonitor = new ConnectionAvgStats(this, false, n);
    this.p2pStatsMonitor = new ConnectionAvgStats(this, true, n);
  }
  _calculateAvgStats(data) {
    if (!data) {
      logger.error("No stats");
      return;
    }
    const isP2P = this._conference.isP2PActive();
    const confSize = this._conference.getParticipantCount();
    if (!isP2P && confSize < 2) {
      return;
    }
    const bitrate = data.bitrate;
    const bandwidth = data.bandwidth;
    const packetLoss = data.packetLoss;
    const frameRate = data.framerate;
    const resolution = data.resolution;
    if (!bitrate) {
      logger.error('No "bitrate"');
      return;
    } else if (!bandwidth) {
      logger.error('No "bandwidth"');
      return;
    } else if (!packetLoss) {
      logger.error('No "packetloss"');
      return;
    } else if (!frameRate) {
      logger.error('No "framerate"');
      return;
    } else if (!resolution) {
      logger.error("No resolution");
      return;
    }
    this._avgAudioBitrateUp.addNext(bitrate.audio.upload);
    this._avgAudioBitrateDown.addNext(bitrate.audio.download);
    this._avgVideoBitrateUp.addNext(bitrate.video.upload);
    this._avgVideoBitrateDown.addNext(bitrate.video.download);
    if (_browser__WEBPACK_IMPORTED_MODULE_7__["default"].supportsBandwidthStatistics()) {
      this._avgBandwidthUp.addNext(bandwidth.upload);
      this._avgBandwidthDown.addNext(bandwidth.download);
    }
    this._avgPacketLossUp.addNext(packetLoss.upload);
    this._avgPacketLossDown.addNext(packetLoss.download);
    this._avgPacketLossTotal.addNext(packetLoss.total);
    this._avgCQ.addNext(data.connectionQuality);
    if (frameRate) {
      this._avgRemoteFPS.addNext(this._calculateAvgVideoFps(frameRate, false, _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_4__.VideoType.CAMERA));
      this._avgRemoteScreenFPS.addNext(this._calculateAvgVideoFps(frameRate, false, _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_4__.VideoType.DESKTOP));
      this._avgLocalFPS.addNext(this._calculateAvgVideoFps(frameRate, true, _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_4__.VideoType.CAMERA));
      this._avgLocalScreenFPS.addNext(this._calculateAvgVideoFps(frameRate, true, _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_4__.VideoType.DESKTOP));
    }
    if (resolution) {
      this._avgRemoteCameraPixels.addNext(this._calculateAvgVideoPixels(resolution, false, _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_4__.VideoType.CAMERA));
      this._avgRemoteScreenPixels.addNext(this._calculateAvgVideoPixels(resolution, false, _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_4__.VideoType.DESKTOP));
      this._avgLocalCameraPixels.addNext(this._calculateAvgVideoPixels(resolution, true, _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_4__.VideoType.CAMERA));
      this._avgLocalScreenPixels.addNext(this._calculateAvgVideoPixels(resolution, true, _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_4__.VideoType.DESKTOP));
    }
    this._sampleIdx += 1;
    if (this._sampleIdx >= this._n) {
      const batchReport = {
        p2p: isP2P,
        "conference_size": confSize
      };
      if (data.transport && data.transport.length) {
        Object.assign(batchReport, {
          "local_candidate_type": data.transport[0].localCandidateType,
          "remote_candidate_type": data.transport[0].remoteCandidateType,
          "transport_type": data.transport[0].type
        });
      }
      this._avgAudioBitrateUp.appendReport(batchReport);
      this._avgAudioBitrateDown.appendReport(batchReport);
      this._avgVideoBitrateUp.appendReport(batchReport);
      this._avgVideoBitrateDown.appendReport(batchReport);
      if (_browser__WEBPACK_IMPORTED_MODULE_7__["default"].supportsBandwidthStatistics()) {
        this._avgBandwidthUp.appendReport(batchReport);
        this._avgBandwidthDown.appendReport(batchReport);
      }
      this._avgPacketLossUp.appendReport(batchReport);
      this._avgPacketLossDown.appendReport(batchReport);
      this._avgPacketLossTotal.appendReport(batchReport);
      this._avgRemoteFPS.appendReport(batchReport);
      if (!isNaN(this._avgRemoteScreenFPS.calculate())) {
        this._avgRemoteScreenFPS.appendReport(batchReport);
      }
      this._avgLocalFPS.appendReport(batchReport);
      if (!isNaN(this._avgLocalScreenFPS.calculate())) {
        this._avgLocalScreenFPS.appendReport(batchReport);
      }
      this._avgRemoteCameraPixels.appendReport(batchReport);
      if (!isNaN(this._avgRemoteScreenPixels.calculate())) {
        this._avgRemoteScreenPixels.appendReport(batchReport);
      }
      this._avgLocalCameraPixels.appendReport(batchReport);
      if (!isNaN(this._avgLocalScreenPixels.calculate())) {
        this._avgLocalScreenPixels.appendReport(batchReport);
      }
      this._avgCQ.appendReport(batchReport);
      _statistics__WEBPACK_IMPORTED_MODULE_8__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_6__.createRtpStatsEvent)(batchReport));
      this._resetAvgStats();
    }
  }
  _calculateAvgVideoPixels(peerResolutions, isLocal, videoType) {
    let peerPixelsSum = 0;
    let peerCount = 0;
    const myID = this._conference.myUserId();
    for (const peerID of Object.keys(peerResolutions)) {
      if (isLocal ? peerID === myID : peerID !== myID) {
        const participant = isLocal ? null : this._conference.getParticipantById(peerID);
        const videosResolution = peerResolutions[peerID];
        if ((isLocal || participant) && videosResolution) {
          const peerAvgPixels = this._calculatePeerAvgVideoPixels(videosResolution, participant, videoType);
          if (!isNaN(peerAvgPixels)) {
            peerPixelsSum += peerAvgPixels;
            peerCount += 1;
          }
        }
      }
    }
    return peerPixelsSum / peerCount;
  }
  _calculatePeerAvgVideoPixels(videos, participant, videoType) {
    let ssrcs = Object.keys(videos).map((ssrc) => Number(ssrc));
    let videoTracks = null;
    const tpc = this._conference.getActivePeerConnection();
    if (participant) {
      videoTracks = participant.getTracksByMediaType(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO);
      if (videoTracks) {
        ssrcs = ssrcs.filter((ssrc) => videoTracks.find((track) => !track.isMuted() && track.getSSRC() === ssrc && track.videoType === videoType));
      }
    } else {
      videoTracks = this._conference.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO);
      ssrcs = ssrcs.filter((ssrc) => videoTracks.find((track) => !track.isMuted() && tpc.getLocalSSRC(track) === ssrc && track.videoType === videoType));
    }
    let peerPixelsSum = 0;
    let peerSsrcCount = 0;
    for (const ssrc of ssrcs) {
      const peerSsrcPixels = Number(videos[ssrc].height) * Number(videos[ssrc].width);
      if (!isNaN(peerSsrcPixels) && peerSsrcPixels > 0) {
        peerPixelsSum += peerSsrcPixels;
        peerSsrcCount += 1;
      }
    }
    return peerPixelsSum / peerSsrcCount;
  }
  _calculateAvgVideoFps(frameRate, isLocal, videoType) {
    let peerFpsSum = 0;
    let peerCount = 0;
    const myID = this._conference.myUserId();
    for (const peerID of Object.keys(frameRate)) {
      if (isLocal ? peerID === myID : peerID !== myID) {
        const participant = isLocal ? null : this._conference.getParticipantById(peerID);
        const videosFps = frameRate[peerID];
        if ((isLocal || participant) && videosFps) {
          const peerAvgFPS = this._calculatePeerAvgVideoFps(videosFps, participant, videoType);
          if (!isNaN(peerAvgFPS)) {
            peerFpsSum += peerAvgFPS;
            peerCount += 1;
          }
        }
      }
    }
    return peerFpsSum / peerCount;
  }
  _calculatePeerAvgVideoFps(videos, participant, videoType) {
    let ssrcs = Object.keys(videos).map((ssrc) => Number(ssrc));
    let videoTracks = null;
    const tpc = this._conference.getActivePeerConnection();
    if (participant) {
      videoTracks = participant.getTracksByMediaType(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO);
      if (videoTracks) {
        ssrcs = ssrcs.filter((ssrc) => videoTracks.find((track) => !track.isMuted() && track.getSSRC() === ssrc && track.videoType === videoType));
      }
    } else {
      videoTracks = this._conference.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO);
      ssrcs = ssrcs.filter((ssrc) => videoTracks.find((track) => !track.isMuted() && tpc.getLocalSSRC(track) === ssrc && track.videoType === videoType));
    }
    let peerFpsSum = 0;
    let peerSsrcCount = 0;
    for (const ssrc of ssrcs) {
      const peerSsrcFps = Number(videos[ssrc]);
      if (!isNaN(peerSsrcFps) && peerSsrcFps > 0) {
        peerFpsSum += peerSsrcFps;
        peerSsrcCount += 1;
      }
    }
    return peerFpsSum / peerSsrcCount;
  }
  _maybeSendTransportAnalyticsEvent(data) {
    if (!data || !data.transport || !data.transport.length) {
      return;
    }
    const transportStats = {
      p2p: data.transport[0].p2p,
      "local_candidate_type": data.transport[0].localCandidateType,
      "remote_candidate_type": data.transport[0].remoteCandidateType,
      "transport_type": data.transport[0].type
    };
    if (!this._cachedTransportStats || !lodash_isequal__WEBPACK_IMPORTED_MODULE_1___default()(transportStats, this._cachedTransportStats)) {
      this._cachedTransportStats = transportStats;
      _statistics__WEBPACK_IMPORTED_MODULE_8__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_6__.createTransportStatsEvent)(transportStats));
    }
  }
  _resetAvgJvbStats() {
    this._resetAvgStats();
    this.jvbStatsMonitor._resetAvgStats();
  }
  _resetAvgStats() {
    this._avgAudioBitrateUp.reset();
    this._avgAudioBitrateDown.reset();
    this._avgVideoBitrateUp.reset();
    this._avgVideoBitrateDown.reset();
    this._avgBandwidthUp.reset();
    this._avgBandwidthDown.reset();
    this._avgPacketLossUp.reset();
    this._avgPacketLossDown.reset();
    this._avgPacketLossTotal.reset();
    this._avgRemoteFPS.reset();
    this._avgRemoteScreenFPS.reset();
    this._avgLocalFPS.reset();
    this._avgLocalScreenFPS.reset();
    this._avgRemoteCameraPixels.reset();
    this._avgRemoteScreenPixels.reset();
    this._avgLocalCameraPixels.reset();
    this._avgLocalScreenPixels.reset();
    this._avgCQ.reset();
    this._sampleIdx = 0;
  }
  dispose() {
    this._conference.off(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.P2P_STATUS, this._onP2PStatusChanged);
    this._conference.off(_service_connectivity_ConnectionQualityEvents__WEBPACK_IMPORTED_MODULE_5__.LOCAL_STATS_UPDATED, this._onLocalStatsUpdated);
    this._conference.off(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_2__.JVB121_STATUS, this._onJvb121StatusChanged);
    this.jvbStatsMonitor.dispose();
    this.p2pStatsMonitor.dispose();
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/CallStats.js":
/*!*********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/CallStats.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CallStats)
/* harmony export */ });
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_1__);



const logger = (__webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js").getLogger)(__filename);
const wrtcFuncNames = {
  createOffer: "createOffer",
  createAnswer: "createAnswer",
  setLocalDescription: "setLocalDescription",
  setRemoteDescription: "setRemoteDescription",
  addIceCandidate: "addIceCandidate",
  getUserMedia: "getUserMedia",
  iceConnectionFailure: "iceConnectionFailure",
  signalingError: "signalingError",
  applicationLog: "applicationLog"
};
const fabricEvent = {
  fabricHold: "fabricHold",
  fabricResume: "fabricResume",
  audioMute: "audioMute",
  audioUnmute: "audioUnmute",
  videoPause: "videoPause",
  videoResume: "videoResume",
  fabricUsageEvent: "fabricUsageEvent",
  fabricStats: "fabricStats",
  fabricTerminated: "fabricTerminated",
  screenShareStart: "screenShareStart",
  screenShareStop: "screenShareStop",
  dominantSpeaker: "dominantSpeaker",
  activeDeviceList: "activeDeviceList"
};
const DEFAULT_REMOTE_USER = "jitsi";
const reportType = {
  ERROR: "error",
  EVENT: "event",
  MST_WITH_USERID: "mstWithUserID"
};
let _fabrics;
class CallStats {
  static _addNewFabricCallback(error, msg) {
    if (CallStats.backend && error !== "success") {
      logger.error(`Monitoring status: ${error} msg: ${msg}`);
    }
  }
  static _initCallback(error, msg) {
    logger.log(`CallStats Status: err=${error} msg=${msg}`);
    if (error !== "success") {
      return;
    }
    CallStats.backendInitialized = true;
    let atLeastOneFabric = false;
    let defaultInstance = null;
    for (const callStatsInstance of CallStats.fabrics.values()) {
      if (!callStatsInstance.hasFabric) {
        logger.debug("addNewFabric - initCallback");
        if (callStatsInstance._addNewFabric()) {
          atLeastOneFabric = true;
          if (!defaultInstance) {
            defaultInstance = callStatsInstance;
          }
        }
      }
    }
    if (!atLeastOneFabric) {
      return;
    }
    CallStats._emptyReportQueue(defaultInstance);
  }
  static _emptyReportQueue(csInstance) {
    const defaultConfID = csInstance.confID;
    const defaultPC = csInstance.peerconnection;
    for (const report of CallStats.reportsQueue) {
      if (report.type === reportType.ERROR) {
        const errorData = report.data;
        CallStats._reportError(csInstance, errorData.type, errorData.error, errorData.pc || defaultPC);
      } else if (report.type === reportType.EVENT) {
        const eventData = report.data;
        CallStats.backend.sendFabricEvent(report.pc || defaultPC, eventData.event, defaultConfID, eventData.eventData);
      } else if (report.type === reportType.MST_WITH_USERID) {
        const data = report.data;
        CallStats.backend.associateMstWithUserID(report.pc || defaultPC, data.callStatsId, defaultConfID, data.ssrc, data.usageLabel, data.containerId);
      }
    }
    CallStats.reportsQueue.length = 0;
  }
  static _reportError(cs, type, error, pc) {
    let _error = error;
    if (!_error) {
      logger.warn("No error is passed!");
      _error = new Error("Unknown error");
    }
    if (CallStats.backendInitialized && cs) {
      CallStats.backend.reportError(pc, cs.confID, type, _error);
    } else {
      CallStats.reportsQueue.push({
        type: reportType.ERROR,
        data: {
          error: _error,
          pc,
          type
        }
      });
    }
  }
  static _reportEvent(cs, event, eventData) {
    const pc = cs && cs.peerconnection;
    const confID = cs && cs.confID;
    if (CallStats.backendInitialized && cs) {
      CallStats.backend.sendFabricEvent(pc, event, confID, eventData);
    } else {
      CallStats.reportsQueue.push({
        confID,
        pc,
        type: reportType.EVENT,
        data: {
          event,
          eventData
        }
      });
    }
  }
  static _traceAndCatchBackendCalls(theBackend) {
    const tryCatchMethods = [
      "associateMstWithUserID",
      "sendFabricEvent",
      "sendUserFeedback"
    ];
    for (const methodName of tryCatchMethods) {
      const originalMethod = theBackend[methodName];
      theBackend[methodName] = function(...theArguments) {
        try {
          return originalMethod.apply(theBackend, theArguments);
        } catch (e) {
          _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_1___default().callErrorHandler(e);
        }
      };
    }
    const debugMethods = [
      "associateMstWithUserID",
      "sendFabricEvent",
      "sendUserFeedback"
    ];
    for (const methodName of debugMethods) {
      const originalMethod = theBackend[methodName];
      theBackend[methodName] = function(...theArguments) {
        logger.debug(methodName, theArguments);
        originalMethod.apply(theBackend, theArguments);
      };
    }
    const originalReportError = theBackend.reportError;
    theBackend.reportError = function(pc, cs, type, ...args) {
      if (type === wrtcFuncNames.applicationLog) {
        if (!_browser__WEBPACK_IMPORTED_MODULE_0__["default"].isReactNative()) {
          console && console.debug("reportError", pc, cs, type);
        }
      } else {
        logger.debug("reportError", pc, cs, type, ...args);
      }
      try {
        originalReportError.call(theBackend, pc, cs, type, ...args);
      } catch (exception) {
        if (type === wrtcFuncNames.applicationLog) {
          console && console.error("reportError", exception);
        } else {
          _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_1___default().callErrorHandler(exception);
        }
      }
    };
  }
  static get fabrics() {
    if (!_fabrics) {
      _fabrics = /* @__PURE__ */ new Set();
    }
    return _fabrics;
  }
  static initBackend(options) {
    if (CallStats.backend) {
      throw new Error("CallStats backend has been initialized already!");
    }
    try {
      const CallStatsBackend = callstats;
      CallStats.backend = new CallStatsBackend();
      CallStats._traceAndCatchBackendCalls(CallStats.backend);
      CallStats.userID = {
        aliasName: options.aliasName,
        userName: options.userName
      };
      CallStats.callStatsID = options.callStatsID;
      CallStats.callStatsSecret = options.callStatsSecret;
      const configParams = Object.assign({}, options.configParams);
      if (options.applicationName) {
        configParams.applicationVersion = `${options.applicationName} (${_browser__WEBPACK_IMPORTED_MODULE_0__["default"].getName()})`;
      }
      if (options.confID) {
        const match = options.confID.match(/.*\/(.*)\/.*/);
        configParams.siteID = options.siteID || match && match[1] || "/";
      }
      CallStats.backend.initialize(CallStats.callStatsID, CallStats.callStatsSecret, CallStats.userID, CallStats._initCallback, void 0, configParams);
      return true;
    } catch (e) {
      _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_1___default().callErrorHandler(e);
      CallStats.backend = null;
      logger.error(e);
      return false;
    }
  }
  static isBackendInitialized() {
    return Boolean(CallStats.backend);
  }
  static sendActiveDeviceListEvent(devicesData, cs) {
    CallStats._reportEvent(cs, fabricEvent.activeDeviceList, devicesData);
  }
  static sendApplicationLog(e, cs) {
    try {
      CallStats._reportError(cs, wrtcFuncNames.applicationLog, e, cs && cs.peerconnection);
    } catch (error) {
      if (console && typeof console.error === "function") {
        console.error("sendApplicationLog failed", error);
      }
    }
  }
  static sendFeedback(conferenceID, overall, comment) {
    return new Promise((resolve, reject) => {
      if (CallStats.backend) {
        CallStats.backend.sendUserFeedback(conferenceID, {
          userID: CallStats.userID,
          overall,
          comment
        }, (status, message) => {
          if (status === "success") {
            resolve(message);
          } else {
            reject(message);
          }
        });
      } else {
        const reason = "Failed to submit feedback to CallStats - no backend";
        logger.error(reason);
        reject(reason);
      }
    });
  }
  static sendGetUserMediaFailed(e, cs) {
    CallStats._reportError(cs, wrtcFuncNames.getUserMedia, e, null);
  }
  static sendMuteEvent(mute, type, cs) {
    let event;
    if (type === "video") {
      event = mute ? fabricEvent.videoPause : fabricEvent.videoResume;
    } else {
      event = mute ? fabricEvent.audioMute : fabricEvent.audioUnmute;
    }
    CallStats._reportEvent(cs, event);
  }
  constructor(tpc, options) {
    this.confID = options.confID;
    this.tpc = tpc;
    this.peerconnection = tpc.peerconnection;
    this.remoteUserID = options.remoteUserID || DEFAULT_REMOTE_USER;
    this.hasFabric = false;
    CallStats.fabrics.add(this);
    if (CallStats.backendInitialized) {
      this._addNewFabric();
      if (CallStats.fabrics.size === 1) {
        CallStats._emptyReportQueue(this);
      }
    }
  }
  _addNewFabric() {
    logger.info("addNewFabric", this.remoteUserID);
    try {
      const fabricAttributes = {
        remoteEndpointType: this.tpc.isP2P ? CallStats.backend.endpointType.peer : CallStats.backend.endpointType.server
      };
      const ret = CallStats.backend.addNewFabric(this.peerconnection, this.remoteUserID, CallStats.backend.fabricUsage.multiplex, this.confID, fabricAttributes, CallStats._addNewFabricCallback);
      this.hasFabric = true;
      const success = ret.status === "success";
      if (!success) {
        logger.error("callstats fabric not initilized", ret.message);
      }
      return success;
    } catch (error) {
      _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_1___default().callErrorHandler(error);
      return false;
    }
  }
  associateStreamWithVideoTag(ssrc, isLocal, streamEndpointId, usageLabel, containerId) {
    if (!CallStats.backend) {
      return;
    }
    const callStatsId = isLocal ? CallStats.userID : streamEndpointId;
    if (CallStats.backendInitialized) {
      CallStats.backend.associateMstWithUserID(this.peerconnection, callStatsId, this.confID, ssrc, usageLabel, containerId);
    } else {
      CallStats.reportsQueue.push({
        type: reportType.MST_WITH_USERID,
        pc: this.peerconnection,
        data: {
          callStatsId,
          containerId,
          ssrc,
          usageLabel
        }
      });
    }
  }
  sendDominantSpeakerEvent() {
    CallStats._reportEvent(this, fabricEvent.dominantSpeaker);
  }
  sendTerminateEvent() {
    if (CallStats.backendInitialized) {
      CallStats.backend.sendFabricEvent(this.peerconnection, CallStats.backend.fabricEvent.fabricTerminated, this.confID);
    }
    CallStats.fabrics.delete(this);
  }
  sendIceConnectionFailedEvent() {
    CallStats._reportError(this, wrtcFuncNames.iceConnectionFailure, null, this.peerconnection);
  }
  sendCreateOfferFailed(e) {
    CallStats._reportError(this, wrtcFuncNames.createOffer, e, this.peerconnection);
  }
  sendCreateAnswerFailed(e) {
    CallStats._reportError(this, wrtcFuncNames.createAnswer, e, this.peerconnection);
  }
  sendResumeOrHoldEvent(isResume) {
    CallStats._reportEvent(this, isResume ? fabricEvent.fabricResume : fabricEvent.fabricHold);
  }
  sendScreenSharingEvent(start, ssrc) {
    let eventData;
    if (ssrc) {
      eventData = { ssrc };
    }
    CallStats._reportEvent(this, start ? fabricEvent.screenShareStart : fabricEvent.screenShareStop, eventData);
  }
  sendSetLocalDescFailed(e) {
    CallStats._reportError(this, wrtcFuncNames.setLocalDescription, e, this.peerconnection);
  }
  sendSetRemoteDescFailed(e) {
    CallStats._reportError(this, wrtcFuncNames.setRemoteDescription, e, this.peerconnection);
  }
  sendAddIceCandidateFailed(e) {
    CallStats._reportError(this, wrtcFuncNames.addIceCandidate, e, this.peerconnection);
  }
}
CallStats.backend = null;
CallStats.reportsQueue = [];
CallStats.backendInitialized = false;
CallStats.callStatsID = null;
CallStats.callStatsSecret = null;
CallStats.userID = null;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/LocalStatsCollector.js":
/*!*******************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/LocalStatsCollector.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LocalStatsCollector)
/* harmony export */ });

var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger = (__webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js").getLogger)(__filename);
const WEBAUDIO_ANALYZER_FFT_SIZE = 2048;
const WEBAUDIO_ANALYZER_SMOOTING_TIME = 0.8;
window.AudioContext = window.AudioContext || window.webkitAudioContext;
let context = null;
function timeDomainDataToAudioLevel(samples) {
  let maxVolume = 0;
  const length = samples.length;
  for (let i = 0; i < length; i++) {
    if (maxVolume < samples[i]) {
      maxVolume = samples[i];
    }
  }
  return parseFloat(((maxVolume - 127) / 128).toFixed(3));
}
function animateLevel(newLevel, lastLevel) {
  let value = 0;
  const diff = lastLevel - newLevel;
  if (diff > 0.2) {
    value = lastLevel - 0.2;
  } else if (diff < -0.4) {
    value = lastLevel + 0.4;
  } else {
    value = newLevel;
  }
  return parseFloat(value.toFixed(3));
}
function LocalStatsCollector(stream, interval, callback) {
  this.stream = stream;
  this.intervalId = null;
  this.intervalMilis = interval;
  this.audioLevel = 0;
  this.callback = callback;
  this.source = null;
  this.analyser = null;
}
LocalStatsCollector.prototype.start = function() {
  if (!LocalStatsCollector.isLocalStatsSupported()) {
    return;
  }
  context.resume();
  this.analyser = context.createAnalyser();
  this.analyser.smoothingTimeConstant = WEBAUDIO_ANALYZER_SMOOTING_TIME;
  this.analyser.fftSize = WEBAUDIO_ANALYZER_FFT_SIZE;
  this.source = context.createMediaStreamSource(this.stream);
  this.source.connect(this.analyser);
  this.intervalId = setInterval(() => {
    const array = new Uint8Array(this.analyser.frequencyBinCount);
    this.analyser.getByteTimeDomainData(array);
    const audioLevel = timeDomainDataToAudioLevel(array);
    this.audioLevel = animateLevel(audioLevel, this.audioLevel);
    this.callback(this.audioLevel);
  }, this.intervalMilis);
};
LocalStatsCollector.prototype.stop = function() {
  var _a, _b;
  if (this.intervalId) {
    clearInterval(this.intervalId);
    this.intervalId = null;
  }
  (_a = this.analyser) === null || _a === void 0 ? void 0 : _a.disconnect();
  this.analyser = null;
  (_b = this.source) === null || _b === void 0 ? void 0 : _b.disconnect();
  this.source = null;
};
LocalStatsCollector.isLocalStatsSupported = function() {
  return Boolean(window === null || window === void 0 ? void 0 : window.AudioContext);
};
LocalStatsCollector.disconnectAudioContext = function() {
  return __awaiter(this, void 0, void 0, function* () {
    if (context) {
      logger.info("Disconnecting audio context");
      yield context.close();
      context = null;
    }
  });
};
LocalStatsCollector.connectAudioContext = function() {
  if (!LocalStatsCollector.isLocalStatsSupported()) {
    return;
  }
  logger.info("Connecting audio context");
  context = new AudioContext();
  context.suspend();
};
LocalStatsCollector.connectAudioContext();


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/PerformanceObserverStats.js":
/*!************************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/PerformanceObserverStats.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerformanceObserverStats: () => (/* binding */ PerformanceObserverStats)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_statistics_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/statistics/Events */ "../../lib-jitsi-meet/dist/esm/service/statistics/Events.js");
/* harmony import */ var _util_MathUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/MathUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/MathUtil.js");




const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const MILLI_SECONDS = 1e3;
const SECONDS = 60;
class PerformanceObserverStats {
  constructor(emitter, statsInterval) {
    this.eventEmitter = emitter;
    this.longTasks = 0;
    this.maxDuration = 0;
    this.performanceStatsInterval = statsInterval;
    this.stats = new _util_MathUtil__WEBPACK_IMPORTED_MODULE_2__.RunningAverage();
  }
  getLongTasksStats() {
    return {
      avgRatePerMinute: (this.stats.getAverage() * SECONDS).toFixed(2),
      maxDurationMs: this.maxDuration
    };
  }
  startObserver() {
    this.longTaskEventHandler = (list) => {
      const entries = list.getEntries();
      for (const task of entries) {
        this.longTasks++;
        this.maxDuration = Math.max(this.maxDuration, task.duration).toFixed(3);
      }
    };
    logger.info("Creating a Performance Observer for monitoring Long Tasks");
    this.observer = new PerformanceObserver(this.longTaskEventHandler);
    this.observer.observe({
      type: "longtask",
      buffered: true
    });
    const startTime = Date.now();
    this.longTasksIntervalId = setInterval(() => {
      const now = Date.now();
      const interval = this._lastTimeStamp ? (now - this._lastTimeStamp) / MILLI_SECONDS : (now - startTime) / MILLI_SECONDS;
      const rate = this.longTasks / interval;
      this.stats.addNext(rate);
      this.eventEmitter.emit(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_1__.LONG_TASKS_STATS, this.getLongTasksStats());
      this.longTasks = 0;
      this._lastTimeStamp = Date.now();
    }, this.performanceStatsInterval);
  }
  stopObserver() {
    this.observer && this.observer.disconnect();
    this.longTaskEventHandler = null;
    if (this.longTasksIntervalId) {
      clearInterval(this.longTasksIntervalId);
      this.longTasksIntervalId = null;
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/PrecallTest.js":
/*!***********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/PrecallTest.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   execute: () => (/* binding */ execute),
/* harmony export */   init: () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _settings_Settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../settings/Settings */ "../../lib-jitsi-meet/dist/esm/modules/settings/Settings.js");
/* harmony import */ var _util_ScriptUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/ScriptUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/ScriptUtil.js");
/* harmony import */ var _util_ScriptUtil__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_util_ScriptUtil__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "../../lib-jitsi-meet/dist/esm/modules/statistics/constants.js");

var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};





const PRECALL_TEST_RESULTS = "preCallTestResults";
const emitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())();
let _initialized = false;
let api = null;
function _loadScript(options) {
  if (_browser__WEBPACK_IMPORTED_MODULE_1__["default"].isReactNative()) {
    return;
  }
  return new Promise((resolve) => {
    _util_ScriptUtil__WEBPACK_IMPORTED_MODULE_3___default().loadScript(
      options.callStatsCustomScriptUrl || _constants__WEBPACK_IMPORTED_MODULE_4__.CALLSTATS_SCRIPT_URL,
      true,
      true,
      void 0,
      resolve
    );
  });
}
function _initialize(options) {
  return new Promise((resolve, reject) => {
    const appId = options.callStatsID;
    const appSecret = options.callStatsSecret;
    const userId = options.statisticsId || options.statisticsDisplayName || _settings_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].callStatsUserName;
    api.initialize(appId, appSecret, userId, (status, message) => {
      if (status === "success") {
        api.on(PRECALL_TEST_RESULTS, (...args) => {
          emitter.emit(PRECALL_TEST_RESULTS, ...args);
        });
        _initialized = true;
        resolve();
      } else {
        reject({
          status,
          message
        });
      }
    }, null, { disablePrecalltest: true });
  });
}
function init(options) {
  return __awaiter(this, void 0, void 0, function* () {
    if (_initialized) {
      throw new Error("Precall Test already initialized");
    }
    const { callStatsID, callStatsSecret, disableThirdPartyRequests } = options;
    if (!callStatsID || !callStatsSecret || disableThirdPartyRequests) {
      throw new Error("Callstats is disabled");
    }
    yield _loadScript(options);
    api = new window.callstats();
    return _initialize(options);
  });
}
function execute() {
  if (!_initialized) {
    return Promise.reject("uninitialized");
  }
  return new Promise((resolve, reject) => {
    emitter.on(PRECALL_TEST_RESULTS, (status, payload) => {
      if (status === "success") {
        resolve(payload);
      } else {
        reject({
          status,
          payload
        });
      }
    });
    api.makePrecallTest();
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  init,
  execute
});


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/RTPStatsCollector.js":
/*!*****************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/RTPStatsCollector.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StatsCollector)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_statistics_Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/statistics/Events */ "../../lib-jitsi-meet/dist/esm/service/statistics/Events.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");






const GlobalOnErrorHandler = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
function calculatePacketLoss(lostPackets, totalPackets) {
  if (!totalPackets || totalPackets <= 0 || !lostPackets || lostPackets <= 0) {
    return 0;
  }
  return Math.round(lostPackets / totalPackets * 100);
}
function SsrcStats() {
  this.loss = {};
  this.bitrate = {
    download: 0,
    upload: 0
  };
  this.resolution = {};
  this.framerate = 0;
  this.codec = "";
}
SsrcStats.prototype.setLoss = function(loss) {
  this.loss = loss || {};
};
SsrcStats.prototype.setResolution = function(resolution) {
  this.resolution = resolution || {};
};
SsrcStats.prototype.addBitrate = function(bitrate) {
  this.bitrate.download += bitrate.download;
  this.bitrate.upload += bitrate.upload;
};
SsrcStats.prototype.resetBitrate = function() {
  this.bitrate.download = 0;
  this.bitrate.upload = 0;
};
SsrcStats.prototype.setFramerate = function(framerate) {
  this.framerate = framerate || 0;
};
SsrcStats.prototype.setCodec = function(codec) {
  this.codec = codec || "";
};
function ConferenceStats() {
  this.bandwidth = {};
  this.bitrate = {};
  this.packetLoss = null;
  this.transport = [];
}
function StatsCollector(peerconnection, audioLevelsInterval, statsInterval, eventEmitter) {
  this.peerconnection = peerconnection;
  this.currentStatsReport = null;
  this.previousStatsReport = null;
  this.audioLevelReportHistory = {};
  this.audioLevelsIntervalId = null;
  this.eventEmitter = eventEmitter;
  this.conferenceStats = new ConferenceStats();
  this.audioLevelsIntervalMilis = audioLevelsInterval;
  this.speakerList = [];
  this.statsIntervalId = null;
  this.statsIntervalMilis = statsInterval;
  this.ssrc2stats = /* @__PURE__ */ new Map();
}
StatsCollector.prototype.setSpeakerList = function(speakerList) {
  this.speakerList = speakerList;
};
StatsCollector.prototype.stop = function() {
  if (this.audioLevelsIntervalId) {
    clearInterval(this.audioLevelsIntervalId);
    this.audioLevelsIntervalId = null;
  }
  if (this.statsIntervalId) {
    clearInterval(this.statsIntervalId);
    this.statsIntervalId = null;
  }
};
StatsCollector.prototype.errorCallback = function(error) {
  GlobalOnErrorHandler.callErrorHandler(error);
  logger.error("Get stats error", error);
  this.stop();
};
StatsCollector.prototype.start = function(startAudioLevelStats) {
  if (startAudioLevelStats && _browser__WEBPACK_IMPORTED_MODULE_3__["default"].supportsReceiverStats()) {
    this.audioLevelsIntervalId = setInterval(() => {
      const audioLevels = this.peerconnection.getAudioLevels(this.speakerList);
      for (const ssrc in audioLevels) {
        if (audioLevels.hasOwnProperty(ssrc)) {
          const audioLevel = audioLevels[ssrc] * 2.5;
          this.eventEmitter.emit(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_2__.AUDIO_LEVEL, this.peerconnection, Number.parseInt(ssrc, 10), audioLevel, false);
        }
      }
    }, this.audioLevelsIntervalMilis);
  }
  const processStats = () => {
    this.peerconnection.getStats().then((report) => {
      this.currentStatsReport = typeof (report === null || report === void 0 ? void 0 : report.result) === "function" ? report.result() : report;
      try {
        this.processStatsReport();
      } catch (error) {
        GlobalOnErrorHandler.callErrorHandler(error);
        logger.error("Processing of RTP stats failed:", error);
      }
      this.previousStatsReport = this.currentStatsReport;
    }).catch((error) => this.errorCallback(error));
  };
  processStats();
  this.statsIntervalId = setInterval(processStats, this.statsIntervalMilis);
};
StatsCollector.prototype._processAndEmitReport = function() {
  var _a, _b;
  const totalPackets = {
    download: 0,
    upload: 0
  };
  const lostPackets = {
    download: 0,
    upload: 0
  };
  let bitrateDownload = 0;
  let bitrateUpload = 0;
  const resolutions = {};
  const framerates = {};
  const codecs = {};
  let audioBitrateDownload = 0;
  let audioBitrateUpload = 0;
  let videoBitrateDownload = 0;
  let videoBitrateUpload = 0;
  for (const [ssrc, ssrcStats] of this.ssrc2stats) {
    const loss = ssrcStats.loss;
    const type = loss.isDownloadStream ? "download" : "upload";
    totalPackets[type] += loss.packetsTotal;
    lostPackets[type] += loss.packetsLost;
    bitrateDownload += ssrcStats.bitrate.download;
    bitrateUpload += ssrcStats.bitrate.upload;
    ssrcStats.resetBitrate();
    const track = this.peerconnection.getTrackBySSRC(ssrc);
    if (!track) {
      continue;
    }
    let audioCodec;
    let videoCodec;
    if (track.isAudioTrack()) {
      audioBitrateDownload += ssrcStats.bitrate.download;
      audioBitrateUpload += ssrcStats.bitrate.upload;
      audioCodec = ssrcStats.codec;
    } else {
      videoBitrateDownload += ssrcStats.bitrate.download;
      videoBitrateUpload += ssrcStats.bitrate.upload;
      videoCodec = ssrcStats.codec;
    }
    const participantId = track.getParticipantId();
    if (!participantId) {
      if (!_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_4__["default"].isSsrcRewritingSupported()) {
        logger.error(`No participant ID returned by ${track}`);
      }
      continue;
    }
    const userCodecs = (_a = codecs[participantId]) !== null && _a !== void 0 ? _a : {};
    userCodecs[ssrc] = {
      audio: audioCodec,
      video: videoCodec
    };
    codecs[participantId] = userCodecs;
    const { resolution } = ssrcStats;
    if (!track.isVideoTrack() || isNaN(resolution === null || resolution === void 0 ? void 0 : resolution.height) || isNaN(resolution === null || resolution === void 0 ? void 0 : resolution.width) || resolution.height === -1 || resolution.width === -1) {
      continue;
    }
    const userResolutions = resolutions[participantId] || {};
    if (track.isLocal() && !_browser__WEBPACK_IMPORTED_MODULE_3__["default"].supportsTrackBasedStats() && this.peerconnection.doesTrueSimulcast()) {
      const localSsrcs = this.peerconnection.getLocalVideoSSRCs(track);
      for (const localSsrc of localSsrcs) {
        const ssrcResolution = (_b = this.ssrc2stats.get(localSsrc)) === null || _b === void 0 ? void 0 : _b.resolution;
        if ((ssrcResolution === null || ssrcResolution === void 0 ? void 0 : ssrcResolution.height) && (ssrcResolution === null || ssrcResolution === void 0 ? void 0 : ssrcResolution.width)) {
          resolution.height = Math.max(resolution.height, ssrcResolution.height);
          resolution.width = Math.max(resolution.width, ssrcResolution.width);
        }
      }
    }
    userResolutions[ssrc] = resolution;
    resolutions[participantId] = userResolutions;
    if (ssrcStats.framerate > 0) {
      const userFramerates = framerates[participantId] || {};
      userFramerates[ssrc] = ssrcStats.framerate;
      framerates[participantId] = userFramerates;
    }
  }
  this.conferenceStats.bitrate = {
    "upload": bitrateUpload,
    "download": bitrateDownload
  };
  this.conferenceStats.bitrate.audio = {
    "upload": audioBitrateUpload,
    "download": audioBitrateDownload
  };
  this.conferenceStats.bitrate.video = {
    "upload": videoBitrateUpload,
    "download": videoBitrateDownload
  };
  this.conferenceStats.packetLoss = {
    total: calculatePacketLoss(lostPackets.download + lostPackets.upload, totalPackets.download + totalPackets.upload),
    download: calculatePacketLoss(lostPackets.download, totalPackets.download),
    upload: calculatePacketLoss(lostPackets.upload, totalPackets.upload)
  };
  const avgAudioLevels = {};
  let localAvgAudioLevels;
  Object.keys(this.audioLevelReportHistory).forEach((ssrc) => {
    const { data, isLocal } = this.audioLevelReportHistory[ssrc];
    const avgAudioLevel = data.reduce((sum, currentValue) => sum + currentValue) / data.length;
    if (isLocal) {
      localAvgAudioLevels = avgAudioLevel;
    } else {
      const track = this.peerconnection.getTrackBySSRC(Number(ssrc));
      if (track) {
        const participantId = track.getParticipantId();
        if (participantId) {
          avgAudioLevels[participantId] = avgAudioLevel;
        }
      }
    }
  });
  this.audioLevelReportHistory = {};
  this.eventEmitter.emit(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_2__.CONNECTION_STATS, this.peerconnection, {
    "bandwidth": this.conferenceStats.bandwidth,
    "bitrate": this.conferenceStats.bitrate,
    "packetLoss": this.conferenceStats.packetLoss,
    "resolution": resolutions,
    "framerate": framerates,
    "codec": codecs,
    "transport": this.conferenceStats.transport,
    localAvgAudioLevels,
    avgAudioLevels
  });
  this.conferenceStats.transport = [];
};
StatsCollector.prototype.getNonNegativeValue = function(v) {
  let value = v;
  if (typeof value !== "number") {
    value = Number(value);
  }
  if (isNaN(value)) {
    return 0;
  }
  return Math.max(0, value);
};
StatsCollector.prototype._calculateBitrate = function(now, before, fieldName) {
  const bytesNow = this.getNonNegativeValue(now[fieldName]);
  const bytesBefore = this.getNonNegativeValue(before[fieldName]);
  const bytesProcessed = Math.max(0, bytesNow - bytesBefore);
  const timeMs = now.timestamp - before.timestamp;
  let bitrateKbps = 0;
  if (timeMs > 0) {
    bitrateKbps = Math.round(bytesProcessed * 8 / timeMs);
  }
  return bitrateKbps;
};
StatsCollector.prototype._calculateFps = function(now, before, fieldName) {
  const timeMs = now.timestamp - before.timestamp;
  let frameRate = 0;
  if (timeMs > 0 && now[fieldName]) {
    const numberOfFramesSinceBefore = now[fieldName] - before[fieldName];
    frameRate = numberOfFramesSinceBefore / timeMs * 1e3;
  }
  return frameRate;
};
StatsCollector.prototype.processStatsReport = function() {
  const byteSentStats = {};
  this.currentStatsReport.forEach((now) => {
    var _a;
    const before = this.previousStatsReport ? this.previousStatsReport.get(now.id) : null;
    if (now.type === "candidate-pair" && now.nominated && now.state === "succeeded") {
      const availableIncomingBitrate = now.availableIncomingBitrate;
      const availableOutgoingBitrate = now.availableOutgoingBitrate;
      if (availableIncomingBitrate || availableOutgoingBitrate) {
        this.conferenceStats.bandwidth = {
          "download": Math.round(availableIncomingBitrate / 1e3),
          "upload": Math.round(availableOutgoingBitrate / 1e3)
        };
      }
      const remoteUsedCandidate = this.currentStatsReport.get(now.remoteCandidateId);
      const localUsedCandidate = this.currentStatsReport.get(now.localCandidateId);
      if (remoteUsedCandidate && localUsedCandidate) {
        const remoteIpAddress = _browser__WEBPACK_IMPORTED_MODULE_3__["default"].isChromiumBased() ? remoteUsedCandidate.ip : remoteUsedCandidate.address;
        const remotePort = remoteUsedCandidate.port;
        const ip = `${remoteIpAddress}:${remotePort}`;
        const localIpAddress = _browser__WEBPACK_IMPORTED_MODULE_3__["default"].isChromiumBased() ? localUsedCandidate.ip : localUsedCandidate.address;
        const localPort = localUsedCandidate.port;
        const localip = `${localIpAddress}:${localPort}`;
        const type = remoteUsedCandidate.protocol;
        const conferenceStatsTransport = this.conferenceStats.transport;
        if (!conferenceStatsTransport.some((t) => t.ip === ip && t.type === type && t.localip === localip)) {
          conferenceStatsTransport.push({
            ip,
            type,
            localip,
            p2p: this.peerconnection.isP2P,
            localCandidateType: localUsedCandidate.candidateType,
            remoteCandidateType: remoteUsedCandidate.candidateType,
            networkType: localUsedCandidate.networkType,
            rtt: now.currentRoundTripTime * 1e3
          });
        }
      }
    } else if (now.type === "inbound-rtp" || now.type === "outbound-rtp") {
      const ssrc = this.getNonNegativeValue(now.ssrc);
      if (!ssrc) {
        return;
      }
      let ssrcStats = this.ssrc2stats.get(ssrc);
      if (!ssrcStats) {
        ssrcStats = new SsrcStats();
        this.ssrc2stats.set(ssrc, ssrcStats);
      }
      let isDownloadStream = true;
      let key = "packetsReceived";
      if (now.type === "outbound-rtp") {
        isDownloadStream = false;
        key = "packetsSent";
      }
      let packetsNow = now[key];
      if (!packetsNow || packetsNow < 0) {
        packetsNow = 0;
      }
      if (before) {
        const packetsBefore = this.getNonNegativeValue(before[key]);
        const packetsDiff = Math.max(0, packetsNow - packetsBefore);
        const packetsLostNow = this.getNonNegativeValue(now.packetsLost);
        const packetsLostBefore = this.getNonNegativeValue(before.packetsLost);
        const packetsLostDiff = Math.max(0, packetsLostNow - packetsLostBefore);
        ssrcStats.setLoss({
          packetsTotal: packetsDiff + packetsLostDiff,
          packetsLost: packetsLostDiff,
          isDownloadStream
        });
      }
      let resolution;
      if (typeof now.frameHeight !== "undefined" && typeof now.frameWidth !== "undefined") {
        const isStreamActive = (_a = now.active) !== null && _a !== void 0 ? _a : true;
        if (now.type === "inbound-rtp" || !_browser__WEBPACK_IMPORTED_MODULE_3__["default"].supportsTrackBasedStats() && isStreamActive) {
          resolution = {
            height: now.frameHeight,
            width: now.frameWidth
          };
        }
      }
      ssrcStats.setResolution(resolution);
      let frameRate = now.framesPerSecond;
      if (!frameRate && before) {
        frameRate = this._calculateFps(now, before, "framesSent");
      }
      ssrcStats.setFramerate(Math.round(frameRate || 0));
      if (now.type === "inbound-rtp" && before) {
        ssrcStats.addBitrate({
          "download": this._calculateBitrate(now, before, "bytesReceived"),
          "upload": 0
        });
      } else if (before) {
        byteSentStats[ssrc] = this.getNonNegativeValue(now.bytesSent);
        ssrcStats.addBitrate({
          "download": 0,
          "upload": this._calculateBitrate(now, before, "bytesSent")
        });
      }
      const codec = this.currentStatsReport.get(now.codecId);
      if (codec) {
        const codecShortType = codec.mimeType.split("/")[1];
        codecShortType && ssrcStats.setCodec(codecShortType);
      }
    } else if (_browser__WEBPACK_IMPORTED_MODULE_3__["default"].supportsTrackBasedStats() && now.type === "track" && now.kind === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_1__.MediaType.VIDEO && !now.remoteSource) {
      const resolution = {
        height: now.frameHeight,
        width: now.frameWidth
      };
      const localVideoTracks = this.peerconnection.getLocalTracks(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_1__.MediaType.VIDEO);
      if (!(localVideoTracks === null || localVideoTracks === void 0 ? void 0 : localVideoTracks.length)) {
        return;
      }
      const ssrc = this.peerconnection.getSsrcByTrackId(now.trackIdentifier);
      if (!ssrc) {
        return;
      }
      let ssrcStats = this.ssrc2stats.get(ssrc);
      if (!ssrcStats) {
        ssrcStats = new SsrcStats();
        this.ssrc2stats.set(ssrc, ssrcStats);
      }
      if (resolution.height && resolution.width) {
        ssrcStats.setResolution(resolution);
      }
      let frameRate = now.framesPerSecond;
      if (!frameRate && before) {
        frameRate = this._calculateFps(now, before, "framesSent");
      }
      ssrcStats.setFramerate(frameRate);
    }
  });
  if (Object.keys(byteSentStats).length) {
    this.eventEmitter.emit(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_2__.BYTE_SENT_STATS, this.peerconnection, byteSentStats);
  }
  this._processAndEmitReport();
};


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/SpeakerStats.js":
/*!************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/SpeakerStats.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";

class SpeakerStats {
  constructor(userId, displayName, isLocalStats) {
    this._userId = userId;
    this.setDisplayName(displayName);
    this._isLocalStats = isLocalStats || false;
    this.setDominantSpeaker(false);
    this.totalDominantSpeakerTime = 0;
    this._dominantSpeakerStart = 0;
    this._isDominantSpeaker = false;
    this._isSilent = false;
    this._hasLeft = false;
    this._faceLandmarks = [];
  }
  getUserId() {
    return this._userId;
  }
  getDisplayName() {
    return this.displayName;
  }
  setDisplayName(newName) {
    this.displayName = newName;
  }
  isLocalStats() {
    return this._isLocalStats;
  }
  isDominantSpeaker() {
    return this._isDominantSpeaker;
  }
  setDominantSpeaker(isNowDominantSpeaker, silence) {
    if (!this.isDominantSpeaker() && isNowDominantSpeaker && !silence) {
      this._dominantSpeakerStart = Date.now();
    } else if (this.isDominantSpeaker()) {
      if (!isNowDominantSpeaker) {
        if (!this._isSilent) {
          const now = Date.now();
          const timeElapsed = now - this._dominantSpeakerStart;
          this.totalDominantSpeakerTime += timeElapsed;
          this._dominantSpeakerStart = 0;
        }
      } else if (this._isSilent && !silence) {
        this._dominantSpeakerStart = Date.now();
      } else if (!this._isSilent && silence) {
        const now = Date.now();
        const timeElapsed = now - this._dominantSpeakerStart;
        this.totalDominantSpeakerTime += timeElapsed;
        this._dominantSpeakerStart = 0;
      }
    }
    this._isDominantSpeaker = isNowDominantSpeaker;
    this._isSilent = silence;
  }
  getTotalDominantSpeakerTime() {
    let total = this.totalDominantSpeakerTime;
    if (this.isDominantSpeaker() && !this._isSilent) {
      total += Date.now() - this._dominantSpeakerStart;
    }
    return total;
  }
  hasLeft() {
    return this._hasLeft;
  }
  markAsHasLeft() {
    this._hasLeft = true;
    this.setDominantSpeaker(false);
  }
  getFaceLandmarks() {
    return this._faceLandmarks;
  }
  setFaceLandmarks(faceLandmarks) {
    this._faceLandmarks = faceLandmarks;
  }
  addFaceLandmarks(faceLandmarks) {
    this._faceLandmarks.push(faceLandmarks);
  }
}
module.exports = SpeakerStats;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/SpeakerStatsCollector.js":
/*!*********************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/SpeakerStatsCollector.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpeakerStatsCollector)
/* harmony export */ });
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _SpeakerStats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SpeakerStats */ "../../lib-jitsi-meet/dist/esm/modules/statistics/SpeakerStats.js");
/* harmony import */ var _SpeakerStats__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_SpeakerStats__WEBPACK_IMPORTED_MODULE_2__);




const FACE_LANDMARK_MESSAGE_TYPE = "face-landmarks";
class SpeakerStatsCollector {
  constructor(conference) {
    this.stats = {
      users: {},
      dominantSpeakerId: null
    };
    const userId = conference.myUserId();
    this.stats.users[userId] = new (_SpeakerStats__WEBPACK_IMPORTED_MODULE_2___default())(userId, null, true);
    this.conference = conference;
    conference.addEventListener(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_0__.DOMINANT_SPEAKER_CHANGED, this._onDominantSpeaker.bind(this));
    conference.addEventListener(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_0__.USER_JOINED, this._onUserJoin.bind(this));
    conference.addEventListener(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_0__.USER_LEFT, this._onUserLeave.bind(this));
    conference.addEventListener(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_0__.DISPLAY_NAME_CHANGED, this._onDisplayNameChange.bind(this));
    conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_0__.ENDPOINT_MESSAGE_RECEIVED, (participant, { type, faceLandmarks }) => {
      if (type === FACE_LANDMARK_MESSAGE_TYPE) {
        this._onFaceLandmarkAdd(participant.getId(), faceLandmarks);
      }
    });
    if (conference.xmpp) {
      conference.xmpp.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_1__.XMPPEvents.SPEAKER_STATS_RECEIVED, this._updateStats.bind(this));
    }
  }
  _onDominantSpeaker(dominantSpeakerId, previous, silence) {
    const oldDominantSpeaker = this.stats.users[this.stats.dominantSpeakerId];
    const newDominantSpeaker = this.stats.users[dominantSpeakerId];
    oldDominantSpeaker && oldDominantSpeaker.setDominantSpeaker(false);
    newDominantSpeaker && newDominantSpeaker.setDominantSpeaker(true, silence);
    this.stats.dominantSpeakerId = dominantSpeakerId;
  }
  _onUserJoin(userId, participant) {
    if (participant.isHidden()) {
      return;
    }
    if (!this.stats.users[userId]) {
      this.stats.users[userId] = new (_SpeakerStats__WEBPACK_IMPORTED_MODULE_2___default())(userId, participant.getDisplayName());
    }
  }
  _onUserLeave(userId) {
    const savedUser = this.stats.users[userId];
    if (savedUser) {
      savedUser.markAsHasLeft();
    }
  }
  _onDisplayNameChange(userId, newName) {
    const savedUser = this.stats.users[userId];
    if (savedUser) {
      savedUser.setDisplayName(newName);
    }
  }
  _onFaceLandmarkAdd(userId, data) {
    const savedUser = this.stats.users[userId];
    if (savedUser && data) {
      savedUser.addFaceLandmarks(data);
    }
  }
  getStats() {
    return this.stats.users;
  }
  _updateStats(newStats) {
    for (const userId in newStats) {
      let speakerStatsToUpdate;
      const newParticipant = this.conference.getParticipantById(userId);
      if (!newParticipant || !newParticipant.isHidden()) {
        if (this.stats.users[userId]) {
          speakerStatsToUpdate = this.stats.users[userId];
          if (!speakerStatsToUpdate.getDisplayName()) {
            speakerStatsToUpdate.setDisplayName(newStats[userId].displayName);
          }
        } else {
          speakerStatsToUpdate = new (_SpeakerStats__WEBPACK_IMPORTED_MODULE_2___default())(userId, newStats[userId].displayName);
          this.stats.users[userId] = speakerStatsToUpdate;
          speakerStatsToUpdate.markAsHasLeft();
        }
        speakerStatsToUpdate.totalDominantSpeakerTime = newStats[userId].totalDominantSpeakerTime;
        if (Array.isArray(newStats[userId].faceLandmarks)) {
          speakerStatsToUpdate.setFaceLandmarks(newStats[userId].faceLandmarks);
        }
      }
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/constants.js":
/*!*********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/constants.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CALLSTATS_SCRIPT_URL: () => (/* binding */ CALLSTATS_SCRIPT_URL),
/* harmony export */   SPEAKERS_AUDIO_LEVELS: () => (/* binding */ SPEAKERS_AUDIO_LEVELS)
/* harmony export */ });

const CALLSTATS_SCRIPT_URL = "https://api.callstats.io/static/callstats-ws.min.js";
const SPEAKERS_AUDIO_LEVELS = 5;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js":
/*!**********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Statistics)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../JitsiConferenceEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConferenceEvents.js");
/* harmony import */ var _JitsiTrackError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../JitsiTrackError */ "../../lib-jitsi-meet/dist/esm/JitsiTrackError.js");
/* harmony import */ var _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../JitsiTrackEvents */ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../service/statistics/Events */ "../../lib-jitsi-meet/dist/esm/service/statistics/Events.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _util_ScriptUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/ScriptUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/ScriptUtil.js");
/* harmony import */ var _util_ScriptUtil__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_util_ScriptUtil__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _watchRTC_WatchRTC__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../watchRTC/WatchRTC */ "../../lib-jitsi-meet/dist/esm/modules/watchRTC/WatchRTC.js");
/* harmony import */ var _AnalyticsAdapter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AnalyticsAdapter */ "../../lib-jitsi-meet/dist/esm/modules/statistics/AnalyticsAdapter.js");
/* harmony import */ var _CallStats__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./CallStats */ "../../lib-jitsi-meet/dist/esm/modules/statistics/CallStats.js");
/* harmony import */ var _LocalStatsCollector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./LocalStatsCollector */ "../../lib-jitsi-meet/dist/esm/modules/statistics/LocalStatsCollector.js");
/* harmony import */ var _PerformanceObserverStats__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./PerformanceObserverStats */ "../../lib-jitsi-meet/dist/esm/modules/statistics/PerformanceObserverStats.js");
/* harmony import */ var _RTPStatsCollector__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./RTPStatsCollector */ "../../lib-jitsi-meet/dist/esm/modules/statistics/RTPStatsCollector.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./constants */ "../../lib-jitsi-meet/dist/esm/modules/statistics/constants.js");

var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};















const logger = (__webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js").getLogger)(__filename);
let _instances;
let isCallstatsLoaded = false;
function loadCallStatsAPI(options) {
  if (!isCallstatsLoaded) {
    _util_ScriptUtil__WEBPACK_IMPORTED_MODULE_7___default().loadScript(
      options.customScriptUrl || _constants__WEBPACK_IMPORTED_MODULE_14__.CALLSTATS_SCRIPT_URL,
      true,
      true,
      void 0,
      () => _initCallStatsBackend(options)
    );
    isCallstatsLoaded = true;
  }
}
function _initCallStatsBackend(options) {
  if (_CallStats__WEBPACK_IMPORTED_MODULE_10__["default"].isBackendInitialized()) {
    return;
  }
  if (!_CallStats__WEBPACK_IMPORTED_MODULE_10__["default"].initBackend({
    callStatsID: options.callStatsID,
    callStatsSecret: options.callStatsSecret,
    userName: options.userName,
    aliasName: options.aliasName,
    applicationName: options.applicationName,
    confID: options.confID,
    siteID: options.siteID,
    configParams: options.configParams
  })) {
    logger.error("CallStats Backend initialization failed bad");
  }
}
function formatJitsiTrackErrorForCallStats(error) {
  const err = new Error();
  err.stack = error.stack;
  err.name = (error.name || "Unknown error") + (error.gum && error.gum.error && error.gum.error.name ? ` - ${error.gum.error.name}` : "");
  err.constraintName = error.gum && error.gum.constraints ? JSON.stringify(error.gum.constraints) : "";
  err.message = error.message;
  return err;
}
Statistics.init = function(options) {
  Statistics.audioLevelsEnabled = !options.disableAudioLevels;
  if (typeof options.pcStatsInterval === "number") {
    Statistics.pcStatsInterval = options.pcStatsInterval;
  }
  if (typeof options.audioLevelsInterval === "number") {
    Statistics.audioLevelsInterval = options.audioLevelsInterval;
  }
  if (typeof options.longTasksStatsInterval === "number") {
    Statistics.longTasksStatsInterval = options.longTasksStatsInterval;
  }
  Statistics.disableThirdPartyRequests = options.disableThirdPartyRequests;
  if (!_browser__WEBPACK_IMPORTED_MODULE_6__["default"].isReactNative()) {
    _watchRTC_WatchRTC__WEBPACK_IMPORTED_MODULE_8__["default"].init(options);
  }
};
function Statistics(xmpp, options) {
  this.rtpStatsMap = /* @__PURE__ */ new Map();
  this.eventEmitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())();
  this.xmpp = xmpp;
  this.options = options || {};
  this.callStatsIntegrationEnabled = this.options.callStatsID && this.options.callStatsSecret && Statistics.disableThirdPartyRequests !== true;
  if (this.callStatsIntegrationEnabled) {
    this.callStatsApplicationLogsDisabled = this.options.callStatsApplicationLogsDisabled;
    if (_browser__WEBPACK_IMPORTED_MODULE_6__["default"].isReactNative()) {
      _initCallStatsBackend(this.options);
    } else {
      loadCallStatsAPI(this.options);
    }
    if (!this.options.confID) {
      logger.warn('"confID" is not defined');
    }
  }
  this.callsStatsInstances = /* @__PURE__ */ new Map();
  Statistics.instances.add(this);
  if (!_browser__WEBPACK_IMPORTED_MODULE_6__["default"].isReactNative()) {
    _watchRTC_WatchRTC__WEBPACK_IMPORTED_MODULE_8__["default"].start(this.options.roomName, this.options.userName);
  }
}
Statistics.audioLevelsEnabled = false;
Statistics.audioLevelsInterval = 200;
Statistics.pcStatsInterval = 1e4;
Statistics.disableThirdPartyRequests = false;
Statistics.analytics = _AnalyticsAdapter__WEBPACK_IMPORTED_MODULE_9__["default"];
Object.defineProperty(Statistics, "instances", {
  get() {
    if (!_instances) {
      _instances = /* @__PURE__ */ new Set();
    }
    return _instances;
  }
});
Statistics.prototype.startRemoteStats = function(peerconnection) {
  this.stopRemoteStats(peerconnection);
  try {
    const rtpStats = new _RTPStatsCollector__WEBPACK_IMPORTED_MODULE_13__["default"](peerconnection, Statistics.audioLevelsInterval, Statistics.pcStatsInterval, this.eventEmitter);
    rtpStats.start(Statistics.audioLevelsEnabled);
    this.rtpStatsMap.set(peerconnection.id, rtpStats);
  } catch (e) {
    logger.error(`Failed to start collecting remote statistics: ${e}`);
  }
};
Statistics.localStats = [];
Statistics.startLocalStats = function(track, callback) {
  if (_browser__WEBPACK_IMPORTED_MODULE_6__["default"].isIosBrowser()) {
    track.addEventListener(
      _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_3__.JitsiTrackEvents.NO_DATA_FROM_SOURCE,
      (value) => __awaiter(this, void 0, void 0, function* () {
        if (value) {
          for (const localStat of Statistics.localStats) {
            localStat.stop();
          }
          yield _LocalStatsCollector__WEBPACK_IMPORTED_MODULE_11__["default"].disconnectAudioContext();
        } else {
          _LocalStatsCollector__WEBPACK_IMPORTED_MODULE_11__["default"].connectAudioContext();
          for (const localStat of Statistics.localStats) {
            localStat.start();
          }
        }
      })
    );
  }
  if (!Statistics.audioLevelsEnabled) {
    return;
  }
  track.addEventListener(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_3__.JitsiTrackEvents.LOCAL_TRACK_STOPPED, () => {
    Statistics.stopLocalStats(track);
  });
  const stream = track.getOriginalStream();
  const localStats = new _LocalStatsCollector__WEBPACK_IMPORTED_MODULE_11__["default"](stream, Statistics.audioLevelsInterval, callback);
  this.localStats.push(localStats);
  localStats.start();
};
Statistics.prototype.addAudioLevelListener = function(listener) {
  if (!Statistics.audioLevelsEnabled) {
    return;
  }
  this.eventEmitter.on(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.AUDIO_LEVEL, listener);
};
Statistics.prototype.removeAudioLevelListener = function(listener) {
  if (!Statistics.audioLevelsEnabled) {
    return;
  }
  this.eventEmitter.removeListener(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.AUDIO_LEVEL, listener);
};
Statistics.prototype.addBeforeDisposedListener = function(listener) {
  this.eventEmitter.on(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.BEFORE_DISPOSED, listener);
};
Statistics.prototype.removeBeforeDisposedListener = function(listener) {
  this.eventEmitter.removeListener(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.BEFORE_DISPOSED, listener);
};
Statistics.prototype.addConnectionStatsListener = function(listener) {
  this.eventEmitter.on(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.CONNECTION_STATS, listener);
};
Statistics.prototype.removeConnectionStatsListener = function(listener) {
  this.eventEmitter.removeListener(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.CONNECTION_STATS, listener);
};
Statistics.prototype.addByteSentStatsListener = function(listener) {
  this.eventEmitter.on(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.BYTE_SENT_STATS, listener);
};
Statistics.prototype.removeByteSentStatsListener = function(listener) {
  this.eventEmitter.removeListener(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.BYTE_SENT_STATS, listener);
};
Statistics.prototype.addLongTasksStatsListener = function(listener) {
  this.eventEmitter.on(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.LONG_TASKS_STATS, listener);
};
Statistics.prototype.attachLongTasksStats = function(conference) {
  if (!_browser__WEBPACK_IMPORTED_MODULE_6__["default"].supportsPerformanceObserver()) {
    logger.warn("Performance observer for long tasks not supported by browser!");
    return;
  }
  this.performanceObserverStats = new _PerformanceObserverStats__WEBPACK_IMPORTED_MODULE_12__.PerformanceObserverStats(this.eventEmitter, Statistics.longTasksStatsInterval);
  conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.CONFERENCE_JOINED, () => this.performanceObserverStats.startObserver());
  conference.on(_JitsiConferenceEvents__WEBPACK_IMPORTED_MODULE_1__.CONFERENCE_LEFT, () => this.performanceObserverStats.stopObserver());
};
Statistics.prototype.getLongTasksStats = function() {
  return this.performanceObserverStats ? this.performanceObserverStats.getLongTasksStats() : null;
};
Statistics.prototype.removeLongTasksStatsListener = function(listener) {
  this.eventEmitter.removeListener(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.LONG_TASKS_STATS, listener);
};
Statistics.prototype.setSpeakerList = function(speakerList) {
  for (const rtpStats of Array.from(this.rtpStatsMap.values())) {
    if (!rtpStats.peerconnection.isP2P) {
      rtpStats.setSpeakerList(speakerList);
    }
  }
};
Statistics.prototype.dispose = function() {
  try {
    if (!this.callsStatsInstances.size) {
      this.eventEmitter.emit(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.BEFORE_DISPOSED);
    }
    for (const callStats of this.callsStatsInstances.values()) {
      this.stopCallStats(callStats.tpc);
    }
    for (const tpcId of this.rtpStatsMap.keys()) {
      this._stopRemoteStats(tpcId);
    }
    if (this.eventEmitter) {
      this.eventEmitter.removeAllListeners();
    }
  } finally {
    Statistics.instances.delete(this);
  }
};
Statistics.stopLocalStats = function(track) {
  if (!Statistics.audioLevelsEnabled) {
    return;
  }
  const stream = track.getOriginalStream();
  for (let i = 0; i < Statistics.localStats.length; i++) {
    if (Statistics.localStats[i].stream === stream) {
      const localStats = Statistics.localStats.splice(i, 1);
      localStats[0].stop();
      break;
    }
  }
};
Statistics.prototype._stopRemoteStats = function(tpcId) {
  const rtpStats = this.rtpStatsMap.get(tpcId);
  if (rtpStats) {
    rtpStats.stop();
    this.rtpStatsMap.delete(tpcId);
  }
};
Statistics.prototype.stopRemoteStats = function(tpc) {
  this._stopRemoteStats(tpc.id);
};
Statistics.prototype.startCallStats = function(tpc, remoteUserID) {
  if (!this.callStatsIntegrationEnabled) {
    return;
  } else if (this.callsStatsInstances.has(tpc.id)) {
    logger.error("CallStats instance for ${tpc} exists already");
    return;
  }
  let confID = this.options.confID;
  if (!confID.endsWith(this.options.roomName)) {
    confID = `${this.options.confID.slice(0, this.options.confID.lastIndexOf("/"))}/${this.options.roomName}`;
  }
  logger.info(`Starting CallStats for ${tpc}...`);
  const newInstance = new _CallStats__WEBPACK_IMPORTED_MODULE_10__["default"](tpc, {
    confID,
    remoteUserID
  });
  this.callsStatsInstances.set(tpc.id, newInstance);
};
Statistics._getAllCallStatsInstances = function() {
  const csInstances = /* @__PURE__ */ new Set();
  for (const statistics of Statistics.instances) {
    for (const cs of statistics.callsStatsInstances.values()) {
      csInstances.add(cs);
    }
  }
  return csInstances;
};
Statistics.prototype.stopCallStats = function(tpc) {
  const callStatsInstance = this.callsStatsInstances.get(tpc.id);
  if (callStatsInstance) {
    if (this.callsStatsInstances.size === 1) {
      this.eventEmitter.emit(_service_statistics_Events__WEBPACK_IMPORTED_MODULE_5__.BEFORE_DISPOSED);
    }
    this.callsStatsInstances.delete(tpc.id);
    callStatsInstance.sendTerminateEvent();
  }
};
Statistics.prototype.isCallstatsEnabled = function() {
  return this.callStatsIntegrationEnabled;
};
Statistics.prototype.sendConnectionResumeOrHoldEvent = function(tpc, isResume) {
  const instance = this.callsStatsInstances.get(tpc.id);
  if (instance) {
    instance.sendResumeOrHoldEvent(isResume);
  }
};
Statistics.prototype.sendIceConnectionFailedEvent = function(tpc) {
  const instance = this.callsStatsInstances.get(tpc.id);
  if (instance) {
    instance.sendIceConnectionFailedEvent();
  }
};
Statistics.prototype.sendMuteEvent = function(tpc, muted, type) {
  const instance = tpc && this.callsStatsInstances.get(tpc.id);
  _CallStats__WEBPACK_IMPORTED_MODULE_10__["default"].sendMuteEvent(muted, type, instance);
};
Statistics.prototype.sendScreenSharingEvent = function(start, ssrc) {
  for (const cs of this.callsStatsInstances.values()) {
    cs.sendScreenSharingEvent(start, ssrc);
  }
};
Statistics.prototype.sendDominantSpeakerEvent = function(roomJid, silence) {
  for (const cs of this.callsStatsInstances.values()) {
    cs.sendDominantSpeakerEvent();
  }
  this.xmpp.sendDominantSpeakerEvent(roomJid, silence);
};
Statistics.sendActiveDeviceListEvent = function(devicesData) {
  const globalSet = Statistics._getAllCallStatsInstances();
  if (globalSet.size) {
    for (const cs of globalSet) {
      _CallStats__WEBPACK_IMPORTED_MODULE_10__["default"].sendActiveDeviceListEvent(devicesData, cs);
    }
  } else {
    _CallStats__WEBPACK_IMPORTED_MODULE_10__["default"].sendActiveDeviceListEvent(devicesData, null);
  }
};
Statistics.prototype.associateStreamWithVideoTag = function(tpc, ssrc, isLocal, userId, usageLabel, containerId) {
  const instance = this.callsStatsInstances.get(tpc.id);
  if (instance) {
    instance.associateStreamWithVideoTag(ssrc, isLocal, userId, usageLabel, containerId);
  }
};
Statistics.sendGetUserMediaFailed = function(e) {
  const error = e instanceof _JitsiTrackError__WEBPACK_IMPORTED_MODULE_2__["default"] ? formatJitsiTrackErrorForCallStats(e) : e;
  const globalSet = Statistics._getAllCallStatsInstances();
  if (globalSet.size) {
    for (const cs of globalSet) {
      _CallStats__WEBPACK_IMPORTED_MODULE_10__["default"].sendGetUserMediaFailed(error, cs);
    }
  } else {
    _CallStats__WEBPACK_IMPORTED_MODULE_10__["default"].sendGetUserMediaFailed(error, null);
  }
};
Statistics.prototype.sendCreateOfferFailed = function(e, tpc) {
  const instance = this.callsStatsInstances.get(tpc.id);
  if (instance) {
    instance.sendCreateOfferFailed(e);
  }
};
Statistics.prototype.sendCreateAnswerFailed = function(e, tpc) {
  const instance = this.callsStatsInstances.get(tpc.id);
  if (instance) {
    instance.sendCreateAnswerFailed(e);
  }
};
Statistics.prototype.sendSetLocalDescFailed = function(e, tpc) {
  const instance = this.callsStatsInstances.get(tpc.id);
  if (instance) {
    instance.sendSetLocalDescFailed(e);
  }
};
Statistics.prototype.sendSetRemoteDescFailed = function(e, tpc) {
  const instance = this.callsStatsInstances.get(tpc.id);
  if (instance) {
    instance.sendSetRemoteDescFailed(e);
  }
};
Statistics.prototype.sendAddIceCandidateFailed = function(e, tpc) {
  const instance = this.callsStatsInstances.get(tpc.id);
  if (instance) {
    instance.sendAddIceCandidateFailed(e);
  }
};
Statistics.sendLog = function(m) {
  const globalSubSet = /* @__PURE__ */ new Set();
  for (const stats of Statistics.instances) {
    if (stats.callStatsApplicationLogsDisabled) {
      return;
    }
    if (stats.callsStatsInstances.size) {
      globalSubSet.add(stats.callsStatsInstances.values().next().value);
    }
  }
  if (globalSubSet.size) {
    for (const csPerStats of globalSubSet) {
      _CallStats__WEBPACK_IMPORTED_MODULE_10__["default"].sendApplicationLog(m, csPerStats);
    }
  } else {
    _CallStats__WEBPACK_IMPORTED_MODULE_10__["default"].sendApplicationLog(m, null);
  }
};
Statistics.prototype.sendFeedback = function(overall, comment) {
  Statistics.analytics.sendEvent(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__.FEEDBACK, {
    rating: overall,
    comment
  });
  return _CallStats__WEBPACK_IMPORTED_MODULE_10__["default"].sendFeedback(this.options.confID, overall, comment);
};
Statistics.LOCAL_JID = (__webpack_require__(/*! ../../service/statistics/constants */ "../../lib-jitsi-meet/dist/esm/service/statistics/constants.js").LOCAL_JID);
Statistics.reportGlobalError = function(error) {
  if (error instanceof _JitsiTrackError__WEBPACK_IMPORTED_MODULE_2__["default"] && error.gum) {
    Statistics.sendGetUserMediaFailed(error);
  } else {
    Statistics.sendLog(error);
  }
};
Statistics.sendAnalyticsAndLog = function(event, properties = {}) {
  if (!event) {
    logger.warn("No event or event name given.");
    return;
  }
  let eventToLog;
  if (typeof event === "object") {
    eventToLog = event;
  } else {
    eventToLog = {
      name: event,
      properties
    };
  }
  logger.log(JSON.stringify(eventToLog));
  this.analytics.sendEvent(event, properties);
};
Statistics.sendAnalytics = function(eventName, properties = {}) {
  this.analytics.sendEvent(eventName, properties);
};


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/transcription/audioRecorder.js":
/*!****************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/transcription/audioRecorder.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _recordingResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./recordingResult */ "../../lib-jitsi-meet/dist/esm/modules/transcription/recordingResult.js");
/* harmony import */ var _trackRecorder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trackRecorder */ "../../lib-jitsi-meet/dist/esm/modules/transcription/trackRecorder.js");



const AUDIO_WEBM = "audio/webm";
const AUDIO_OGG = "audio/ogg";
function startRecorder(trackRecorder) {
  if (trackRecorder.recorder === void 0) {
    throw new Error("Passed an object to startRecorder which is not a TrackRecorder object");
  }
  trackRecorder.recorder.start();
  trackRecorder.startTime = new Date();
}
function stopRecorder(trackRecorder) {
  if (trackRecorder.recorder === void 0) {
    throw new Error("Passed an object to stopRecorder which is not a TrackRecorder object");
  }
  trackRecorder.recorder.stop();
}
function determineCorrectFileType() {
  if (MediaRecorder.isTypeSupported(AUDIO_WEBM)) {
    return AUDIO_WEBM;
  } else if (MediaRecorder.isTypeSupported(AUDIO_OGG)) {
    return AUDIO_OGG;
  }
  throw new Error("unable to create a MediaRecorder with the right mimetype!");
}
function AudioRecorder(jitsiConference) {
  this.recorders = [];
  this.fileType = determineCorrectFileType();
  this.isRecording = false;
  this.jitsiConference = jitsiConference;
}
AudioRecorder.determineCorrectFileType = determineCorrectFileType;
AudioRecorder.prototype.addTrack = function(track) {
  if (track.isAudioTrack()) {
    const trackRecorder = this.instantiateTrackRecorder(track);
    this.recorders.push(trackRecorder);
    this.updateNames();
    if (this.isRecording) {
      startRecorder(trackRecorder);
    }
  }
};
AudioRecorder.prototype.instantiateTrackRecorder = function(track) {
  const trackRecorder = new _trackRecorder__WEBPACK_IMPORTED_MODULE_1__["default"](track);
  const originalStream = trackRecorder.track.getOriginalStream();
  const stream = new MediaStream();
  originalStream.getAudioTracks().forEach((t) => stream.addTrack(t));
  trackRecorder.recorder = new MediaRecorder(stream, { mimeType: this.fileType });
  trackRecorder.data = [];
  trackRecorder.recorder.ondataavailable = function(dataEvent) {
    if (dataEvent.data.size > 0) {
      trackRecorder.data.push(dataEvent.data);
    }
  };
  return trackRecorder;
};
AudioRecorder.prototype.removeTrack = function(track) {
  if (track.isVideoTrack()) {
    return;
  }
  const array = this.recorders;
  let i;
  for (i = 0; i < array.length; i++) {
    if (array[i].track.getParticipantId() === track.getParticipantId()) {
      const recorderToRemove = array[i];
      if (this.isRecording) {
        stopRecorder(recorderToRemove);
      } else {
        array.splice(i, 1);
      }
    }
  }
  this.updateNames();
};
AudioRecorder.prototype.updateNames = function() {
  const conference = this.jitsiConference;
  this.recorders.forEach((trackRecorder) => {
    if (trackRecorder.track.isLocal()) {
      trackRecorder.name = "the transcriber";
    } else {
      const id = trackRecorder.track.getParticipantId();
      const participant = conference.getParticipantById(id);
      const newName = participant.getDisplayName();
      if (newName !== "undefined") {
        trackRecorder.name = newName;
      }
    }
  });
};
AudioRecorder.prototype.start = function() {
  if (this.isRecording) {
    throw new Error("audiorecorder is already recording");
  }
  this.isRecording = true;
  this.recorders.forEach((trackRecorder) => startRecorder(trackRecorder));
  console.log(`Started the recording of the audio. There are currently ${this.recorders.length} recorders active.`);
};
AudioRecorder.prototype.stop = function() {
  this.isRecording = false;
  this.recorders.forEach((trackRecorder) => stopRecorder(trackRecorder));
  console.log("stopped recording");
};
AudioRecorder.prototype.download = function() {
  this.recorders.forEach((trackRecorder) => {
    const blob = new Blob(trackRecorder.data, { type: this.fileType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    document.body.appendChild(a);
    a.style = "display: none";
    a.href = url;
    a.download = `test.${this.fileType.split("/")[1]}`;
    a.click();
    window.URL.revokeObjectURL(url);
  });
};
AudioRecorder.prototype.getRecordingResults = function() {
  if (this.isRecording) {
    throw new Error("cannot get blobs because the AudioRecorder is still recording!");
  }
  this.updateNames();
  const array = [];
  this.recorders.forEach((recorder) => array.push(new _recordingResult__WEBPACK_IMPORTED_MODULE_0__["default"](new Blob(recorder.data, { type: this.fileType }), recorder.name, recorder.startTime)));
  return array;
};
AudioRecorder.prototype.getFileType = function() {
  return this.fileType;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AudioRecorder);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/transcription/recordingResult.js":
/*!******************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/transcription/recordingResult.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RecordingResult)
/* harmony export */ });

class RecordingResult {
  constructor(blob, name, startTime, wordArray) {
    this.blob = blob;
    this.name = name;
    this.startTime = startTime;
    this.wordArray = wordArray;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/transcription/trackRecorder.js":
/*!****************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/transcription/trackRecorder.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TrackRecorder)
/* harmony export */ });

class TrackRecorder {
  constructor(track) {
    this.track = track;
    this.recorder = null;
    this.data = null;
    this.name = null;
    this.startTime = null;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/transcription/transcriber.js":
/*!**************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/transcription/transcriber.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _audioRecorder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audioRecorder */ "../../lib-jitsi-meet/dist/esm/modules/transcription/audioRecorder.js");
/* harmony import */ var _transcriptionServices_SphinxTranscriptionService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transcriptionServices/SphinxTranscriptionService */ "../../lib-jitsi-meet/dist/esm/modules/transcription/transcriptionServices/SphinxTranscriptionService.js");



const BEFORE_STATE = "before";
const RECORDING_STATE = "recording";
const TRANSCRIBING_STATE = "transcribing";
const FINISHED_STATE = "finished";
const MAXIMUM_SENTENCE_LENGTH = 80;
function Transcriber() {
  this.audioRecorder = new _audioRecorder__WEBPACK_IMPORTED_MODULE_0__["default"]();
  this.transcriptionService = new _transcriptionServices_SphinxTranscriptionService__WEBPACK_IMPORTED_MODULE_1__["default"]();
  this.counter = null;
  this.startTime = null;
  this.transcription = null;
  this.callback = null;
  this.results = [];
  this.state = BEFORE_STATE;
  this.lineLength = 0;
}
Transcriber.prototype.start = function start() {
  if (this.state !== BEFORE_STATE) {
    throw new Error(`The transcription can only start when it's in the "${BEFORE_STATE}" state. It's currently in the "${this.state}" state`);
  }
  this.state = RECORDING_STATE;
  this.audioRecorder.start();
  this.startTime = new Date();
};
Transcriber.prototype.stop = function stop(callback) {
  if (this.state !== RECORDING_STATE) {
    throw new Error(`The transcription can only stop when it's in the "${RECORDING_STATE}" state. It's currently in the "${this.state}" state`);
  }
  console.log("stopping recording and sending audio files");
  this.audioRecorder.stop();
  const callBack = blobCallBack.bind(null, this);
  this.audioRecorder.getRecordingResults().forEach((recordingResult) => {
    this.transcriptionService.send(recordingResult, callBack);
    this.counter++;
  });
  this.state = TRANSCRIBING_STATE;
  this.callback = callback;
};
function blobCallBack(transcriber, answer) {
  console.log(`retrieved an answer from the transcription service. The answer has an array of length: ${answer.wordArray.length}`);
  if (answer.wordArray.length > 0) {
    let offset = answer.startTime.getUTCMilliseconds() - transcriber.startTime.getUTCMilliseconds();
    if (offset < 0) {
      offset = 0;
    }
    let array = "[";
    answer.wordArray.forEach((wordObject) => {
      wordObject.begin += offset;
      wordObject.end += offset;
      array += `${wordObject.word},`;
    });
    array += "]";
    console.log(array);
    answer.wordArray.name = answer.name;
  }
  transcriber.results.push(answer.wordArray);
  transcriber.counter--;
  console.log(`current counter: ${transcriber.counter}`);
  transcriber.maybeMerge();
}
Transcriber.prototype.maybeMerge = function() {
  if (this.state === TRANSCRIBING_STATE && this.counter === 0) {
    this.merge();
  }
};
Transcriber.prototype.merge = function() {
  console.log(`starting merge process!
 The length of the array: ${this.results.length}`);
  this.transcription = "";
  const arrays = this.results;
  const potentialWords = [];
  hasPopulatedArrays(arrays);
  arrays.forEach((array) => pushWordToSortedArray(potentialWords, array));
  while (hasPopulatedArrays(arrays)) {
    let lowestWordArray = arrays[0];
    arrays.forEach((wordArray) => {
      if (wordArray[0].begin < lowestWordArray[0].begin) {
        lowestWordArray = wordArray;
      }
    });
    let wordToAdd = lowestWordArray.shift();
    this.updateTranscription(wordToAdd, lowestWordArray.name);
    while (lowestWordArray.length > 0) {
      let foundSmaller = false;
      const wordToCompare = lowestWordArray[0].begin;
      arrays.forEach((wordArray) => {
        if (wordArray[0].begin < wordToCompare) {
          foundSmaller = true;
        }
      });
      if (foundSmaller) {
        break;
      }
      wordToAdd = lowestWordArray.shift();
      this.updateTranscription(wordToAdd, null);
    }
  }
  this.state = FINISHED_STATE;
  if (this.callback) {
    this.callback(this.transcription);
  }
};
Transcriber.prototype.updateTranscription = function(word, name) {
  if (name !== void 0 && name !== null) {
    this.transcription += `
${name}:`;
    this.lineLength = name.length + 1;
  }
  if (this.lineLength + word.word.length > MAXIMUM_SENTENCE_LENGTH) {
    this.transcription += "\n    ";
    this.lineLength = 4;
  }
  this.transcription += ` ${word.word}`;
  this.lineLength += word.word.length + 1;
};
function hasPopulatedArrays(twoDimensionalArray) {
  for (let i = 0; i < twoDimensionalArray.length; i++) {
    if (twoDimensionalArray[i].length === 0) {
      twoDimensionalArray.splice(i, 1);
    }
  }
  return twoDimensionalArray.length > 0;
}
function pushWordToSortedArray(array, word) {
  if (array.length === 0) {
    array.push(word);
  } else {
    if (array[array.length - 1].begin <= word.begin) {
      array.push(word);
      return;
    }
    for (let i = 0; i < array.length; i++) {
      if (word.begin < array[i].begin) {
        array.splice(i, 0, word);
        return;
      }
    }
    array.push(word);
  }
}
Transcriber.prototype.addTrack = function(track) {
  this.audioRecorder.addTrack(track);
};
Transcriber.prototype.removeTrack = function(track) {
  this.audioRecorder.removeTrack(track);
};
Transcriber.prototype.getTranscription = function() {
  if (this.state !== FINISHED_STATE) {
    throw new Error(`The transcription can only be retrieved when it's in the "${FINISHED_STATE}" state. It's currently in the "${this.state}" state`);
  }
  return this.transcription;
};
Transcriber.prototype.getState = function() {
  return this.state;
};
Transcriber.prototype.reset = function() {
  this.state = BEFORE_STATE;
  this.counter = null;
  this.transcription = null;
  this.startTime = null;
  this.callback = null;
  this.results = [];
  this.lineLength = 0;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Transcriber);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/transcription/transcriptionServices/AbstractTranscriptionService.js":
/*!*****************************************************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/transcription/transcriptionServices/AbstractTranscriptionService.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TranscriptionService)
/* harmony export */ });

class TranscriptionService {
  constructor() {
    throw new Error("TranscriptionService is abstract and cannot be created");
  }
  send(recordingResult, callback) {
    this.sendRequest(recordingResult.blob, (response) => {
      if (this.verify(response)) {
        recordingResult.wordArray = this.formatResponse(response);
      } else {
        console.log("the retrieved response from the server is not valid!");
        recordingResult.wordArray = [];
      }
      callback(recordingResult);
    });
  }
  sendRequest(audioBlob, callback) {
    throw new Error("TranscriptionService.sendRequest is abstract");
  }
  formatResponse(response) {
    throw new Error("TranscriptionService.format is abstract");
  }
  verify(response) {
    throw new Error("TranscriptionService.verify is abstract");
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/transcription/transcriptionServices/SphinxTranscriptionService.js":
/*!***************************************************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/transcription/transcriptionServices/SphinxTranscriptionService.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SphinxService)
/* harmony export */ });
/* harmony import */ var _word__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../word */ "../../lib-jitsi-meet/dist/esm/modules/transcription/word.js");
/* harmony import */ var _audioRecorder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../audioRecorder */ "../../lib-jitsi-meet/dist/esm/modules/transcription/audioRecorder.js");
/* harmony import */ var _AbstractTranscriptionService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractTranscriptionService */ "../../lib-jitsi-meet/dist/esm/modules/transcription/transcriptionServices/AbstractTranscriptionService.js");




class SphinxService extends _AbstractTranscriptionService__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();
    this.url = getURL();
  }
  sendRequest(audioFileBlob, callback) {
    console.log(`sending an audio file  to ${this.url}`);
    console.log(`the audio file being sent: ${audioFileBlob}`);
    const request = new XMLHttpRequest();
    request.onreadystatechange = function() {
      if (request.readyState === XMLHttpRequest.DONE && request.status === 200) {
        callback(request.responseText);
      } else if (request.readyState === XMLHttpRequest.DONE) {
        throw new Error(`unable to accept response from sphinx server. status: ${request.status}`);
      }
    };
    request.open("POST", this.url);
    request.setRequestHeader("Content-Type", _audioRecorder__WEBPACK_IMPORTED_MODULE_1__["default"].determineCorrectFileType());
    request.send(audioFileBlob);
    console.log(`send ${audioFileBlob}`);
  }
  formatResponse(response) {
    const result = JSON.parse(response).objects;
    result.shift();
    const array = [];
    result.forEach((word) => word.filler || array.push(new _word__WEBPACK_IMPORTED_MODULE_0__["default"](word.word, word.start, word.end)));
    return array;
  }
  verify(response) {
    console.log(`response from server:${response.toString()}`);
    if (typeof response !== "string") {
      return false;
    }
    let json;
    try {
      json = JSON.parse(response);
    } catch (error) {
      console.log(error);
      return false;
    }
    if (json.objects === void 0) {
      return false;
    }
    const array = json.objects;
    if (!(array[0] && array[0]["session-id"])) {
      return false;
    }
    return true;
  }
}
function getURL() {
  const message = "config does not contain an url to a Sphinx4 https server";
  if (config.sphinxURL === void 0) {
    console.log(message);
  } else {
    const toReturn = config.sphinxURL;
    if (toReturn.includes !== void 0 && toReturn.includes("https://")) {
      return toReturn;
    }
    console.log(message);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/transcription/word.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/transcription/word.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Word)
/* harmony export */ });

class Word {
  constructor(word, begin, end) {
    this.word = word;
    this.begin = begin;
    this.end = end;
  }
  getWord() {
    return this.word;
  }
  getBeginTime() {
    return this.begin;
  }
  getEndTime() {
    return this.end;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/util/AsyncQueue.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/util/AsyncQueue.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AsyncQueue)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var async_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! async-es */ "../../lib-jitsi-meet/node_modules/async-es/queue.js");



const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class AsyncQueue {
  constructor() {
    this._queue = (0,async_es__WEBPACK_IMPORTED_MODULE_1__["default"])(this._processQueueTasks.bind(this), 1);
    this._stopped = false;
  }
  clear() {
    this._queue.kill();
  }
  _processQueueTasks(task, finishedCallback) {
    try {
      task(finishedCallback);
    } catch (error) {
      logger.error(`Task failed: ${error === null || error === void 0 ? void 0 : error.stack}`);
      finishedCallback(error);
    }
  }
  pause() {
    this._queue.pause();
  }
  push(task, callback) {
    if (this._stopped) {
      callback && callback(new Error("The queue has been stopped"));
      return;
    }
    this._queue.push(task, callback);
  }
  resume() {
    this._queue.resume();
  }
  shutdown() {
    this._stopped = true;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/util/AuthUtil.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/util/AuthUtil.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";

const AuthUtil = {
  getTokenAuthUrl(urlPattern, roomName, roleUpgrade) {
    const url = urlPattern;
    if (typeof url !== "string") {
      return null;
    }
    return url.replace("{room}", roomName).replace("{roleUpgrade}", roleUpgrade === true);
  }
};
module.exports = AuthUtil;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/util/Deferred.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/util/Deferred.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Deferred)
/* harmony export */ });

class Deferred {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = (...args) => {
        this.clearRejectTimeout();
        resolve(...args);
      };
      this.reject = (...args) => {
        this.clearRejectTimeout();
        reject(...args);
      };
    });
    this.then = this.promise.then.bind(this.promise);
    this.catch = this.promise.catch.bind(this.promise);
  }
  clearRejectTimeout() {
    clearTimeout(this._timeout);
  }
  setRejectTimeout(ms) {
    this._timeout = setTimeout(() => {
      this.reject(new Error("timeout"));
    }, ms);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/util/EventEmitterForwarder.js":
/*!***************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/util/EventEmitterForwarder.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";

function EventEmitterForwarder(src, dest) {
  if (!src || !dest || typeof src.addListener !== "function" || typeof dest.emit !== "function") {
    throw new Error("Invalid arguments passed to EventEmitterForwarder");
  }
  this.src = src;
  this.dest = dest;
}
EventEmitterForwarder.prototype.forward = function(...args) {
  const srcEvent = args[0];
  args[0] = this.dest;
  this.src.addListener(srcEvent, Function.prototype.bind.apply(this.dest.emit, args));
};
module.exports = EventEmitterForwarder;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js":
/*!**************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";

const handlers = [];
const oldOnErrorHandler = window.onerror;
function JitsiGlobalErrorHandler(...args) {
  handlers.forEach((handler) => handler(...args));
  oldOnErrorHandler && oldOnErrorHandler(...args);
}
const oldOnUnhandledRejection = window.onunhandledrejection;
function JitsiGlobalUnhandledRejection(event) {
  handlers.forEach((handler) => handler(null, null, null, null, event.reason));
  oldOnUnhandledRejection && oldOnUnhandledRejection(event);
}
window.onerror = JitsiGlobalErrorHandler;
window.onunhandledrejection = JitsiGlobalUnhandledRejection;
const GlobalOnErrorHandler = {
  addHandler(handler) {
    handlers.push(handler);
  },
  callErrorHandler(error) {
    const errHandler = window.onerror;
    if (!errHandler) {
      return;
    }
    errHandler(null, null, null, null, error);
  },
  callUnhandledRejectionHandler(error) {
    const errHandler = window.onunhandledrejection;
    if (!errHandler) {
      return;
    }
    errHandler(error);
  }
};
module.exports = GlobalOnErrorHandler;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Listenable)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);


class Listenable {
  constructor(eventEmitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())()) {
    this.eventEmitter = eventEmitter;
    this.addEventListener = this.on = this.addListener;
    this.removeEventListener = this.off = this.removeListener;
  }
  addListener(eventName, listener) {
    this.eventEmitter.addListener(eventName, listener);
    return () => this.removeEventListener(eventName, listener);
  }
  removeListener(eventName, listener) {
    this.eventEmitter.removeListener(eventName, listener);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/util/MathUtil.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/util/MathUtil.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RunningAverage: () => (/* binding */ RunningAverage),
/* harmony export */   calculateAverage: () => (/* binding */ calculateAverage),
/* harmony export */   filterPositiveValues: () => (/* binding */ filterPositiveValues),
/* harmony export */   hashString: () => (/* binding */ hashString),
/* harmony export */   safeCounterIncrement: () => (/* binding */ safeCounterIncrement)
/* harmony export */ });

function safeCounterIncrement(number) {
  let nextValue = number;
  if (number >= Number.MAX_SAFE_INTEGER) {
    nextValue = 0;
  }
  return nextValue + 1;
}
function calculateAverage(valueArray) {
  return valueArray.length > 0 ? valueArray.reduce((a, b) => a + b) / valueArray.length : 0;
}
function hashString(string) {
  let hash = 0;
  for (let i = 0; i < string.length; i++) {
    hash += Math.pow(string.charCodeAt(i) * 31, string.length - i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}
function filterPositiveValues(valueArray) {
  return valueArray.filter((value) => value >= 0);
}
class RunningAverage {
  constructor() {
    this.average = 0;
    this.n = 0;
  }
  addNext(value) {
    if (typeof value !== "number") {
      return;
    }
    this.n += 1;
    this.average = this.average + (value - this.average) / this.n;
  }
  getAverage() {
    return this.average;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/util/RandomUtil.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/util/RandomUtil.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";

const ALPHANUM = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
const HEX_DIGITS = "0123456789abcdef";
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function randomElement(arr) {
  return arr[randomInt(0, arr.length - 1)];
}
function randomAlphanumStr(length) {
  let result = "";
  for (let i = 0; i < length; i += 1) {
    result += randomElement(ALPHANUM);
  }
  return result;
}
const RandomUtil = {
  randomHexDigit() {
    return randomElement(HEX_DIGITS);
  },
  randomHexString(len) {
    let ret = "";
    while (len--) {
      ret += this.randomHexDigit();
    }
    return ret;
  },
  randomElement,
  randomAlphanumStr,
  randomInt
};
module.exports = RandomUtil;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/util/Retry.js":
/*!***********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/util/Retry.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getJitterDelay: () => (/* binding */ getJitterDelay)
/* harmony export */ });

function getJitterDelay(retry, minDelay = 500, base = 2) {
  return Math.floor(Math.random() * (Math.pow(base, retry) * 1e3 - minDelay) + minDelay);
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/util/ScriptUtil.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/util/ScriptUtil.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const currentExecutingScript = __webpack_require__(/*! current-executing-script */ "../../lib-jitsi-meet/node_modules/current-executing-script/dist/currentExecutingScript.js");
const ScriptUtil = {
  loadScript(src, async, prepend, relativeURL, loadCallback, errorCallback) {
    const d = document;
    const tagName = "script";
    const script = d.createElement(tagName);
    const referenceNode = d.getElementsByTagName(tagName)[0];
    script.async = async;
    if (relativeURL) {
      const scriptEl = currentExecutingScript();
      if (scriptEl) {
        const scriptSrc = scriptEl.src;
        const baseScriptSrc = scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
        if (scriptSrc && baseScriptSrc) {
          src = baseScriptSrc + src;
        }
      }
    }
    if (loadCallback) {
      script.onload = loadCallback;
    }
    if (errorCallback) {
      script.onerror = errorCallback;
    }
    script.src = src;
    if (prepend) {
      referenceNode.parentNode.insertBefore(script, referenceNode);
    } else {
      referenceNode.parentNode.appendChild(script);
    }
  }
};
module.exports = ScriptUtil;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/util/UsernameGenerator.js":
/*!***********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/util/UsernameGenerator.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const RandomUtil = __webpack_require__(/*! ./RandomUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/RandomUtil.js");
const names = [
  "Aaliyah",
  "Aaron",
  "Abagail",
  "Abbey",
  "Abbie",
  "Abbigail",
  "Abby",
  "Abdiel",
  "Abdul",
  "Abdullah",
  "Abe",
  "Abel",
  "Abelardo",
  "Abigail",
  "Abigale",
  "Abigayle",
  "Abner",
  "Abraham",
  "Ada",
  "Adah",
  "Adalberto",
  "Adaline",
  "Adam",
  "Adan",
  "Addie",
  "Addison",
  "Adela",
  "Adelbert",
  "Adele",
  "Adelia",
  "Adeline",
  "Adell",
  "Adella",
  "Adelle",
  "Aditya",
  "Adolf",
  "Adolfo",
  "Adolph",
  "Adolphus",
  "Adonis",
  "Adrain",
  "Adrian",
  "Adriana",
  "Adrianna",
  "Adriel",
  "Adrien",
  "Adrienne",
  "Afton",
  "Aglae",
  "Agnes",
  "Agustin",
  "Agustina",
  "Ahmad",
  "Ahmed",
  "Aida",
  "Aidan",
  "Aiden",
  "Aileen",
  "Aisha",
  "Aiyana",
  "Akeem",
  "Al",
  "Alaina",
  "Alan",
  "Alana",
  "Alanis",
  "Alanna",
  "Alayna",
  "Alba",
  "Albert",
  "Alberta",
  "Albertha",
  "Alberto",
  "Albin",
  "Albina",
  "Alda",
  "Alden",
  "Alec",
  "Aleen",
  "Alejandra",
  "Alejandrin",
  "Alek",
  "Alena",
  "Alene",
  "Alessandra",
  "Alessandro",
  "Alessia",
  "Aletha",
  "Alex",
  "Alexa",
  "Alexander",
  "Alexandra",
  "Alexandre",
  "Alexandrea",
  "Alexandria",
  "Alexandrine",
  "Alexandro",
  "Alexane",
  "Alexanne",
  "Alexie",
  "Alexis",
  "Alexys",
  "Alexzander",
  "Alf",
  "Alfonso",
  "Alfonzo",
  "Alford",
  "Alfred",
  "Alfreda",
  "Alfredo",
  "Ali",
  "Alia",
  "Alice",
  "Alicia",
  "Alisa",
  "Alisha",
  "Alison",
  "Alivia",
  "Aliya",
  "Aliyah",
  "Aliza",
  "Alize",
  "Allan",
  "Allen",
  "Allene",
  "Allie",
  "Allison",
  "Ally",
  "Alphonso",
  "Alta",
  "Althea",
  "Alva",
  "Alvah",
  "Alvena",
  "Alvera",
  "Alverta",
  "Alvina",
  "Alvis",
  "Alyce",
  "Alycia",
  "Alysa",
  "Alysha",
  "Alyson",
  "Alysson",
  "Amalia",
  "Amanda",
  "Amani",
  "Amara",
  "Amari",
  "Amaya",
  "Amber",
  "Ambrose",
  "Amelia",
  "Amelie",
  "Amely",
  "America",
  "Americo",
  "Amie",
  "Amina",
  "Amir",
  "Amira",
  "Amiya",
  "Amos",
  "Amparo",
  "Amy",
  "Amya",
  "Ana",
  "Anabel",
  "Anabelle",
  "Anahi",
  "Anais",
  "Anastacio",
  "Anastasia",
  "Anderson",
  "Andre",
  "Andreane",
  "Andreanne",
  "Andres",
  "Andrew",
  "Andy",
  "Angel",
  "Angela",
  "Angelica",
  "Angelina",
  "Angeline",
  "Angelita",
  "Angelo",
  "Angie",
  "Angus",
  "Anibal",
  "Anika",
  "Anissa",
  "Anita",
  "Aniya",
  "Aniyah",
  "Anjali",
  "Anna",
  "Annabel",
  "Annabell",
  "Annabelle",
  "Annalise",
  "Annamae",
  "Annamarie",
  "Anne",
  "Annetta",
  "Annette",
  "Annie",
  "Ansel",
  "Ansley",
  "Anthony",
  "Antoinette",
  "Antone",
  "Antonetta",
  "Antonette",
  "Antonia",
  "Antonietta",
  "Antonina",
  "Antonio",
  "Antwan",
  "Antwon",
  "Anya",
  "April",
  "Ara",
  "Araceli",
  "Aracely",
  "Arch",
  "Archibald",
  "Ardella",
  "Arden",
  "Ardith",
  "Arely",
  "Ari",
  "Ariane",
  "Arianna",
  "Aric",
  "Ariel",
  "Arielle",
  "Arjun",
  "Arlene",
  "Arlie",
  "Arlo",
  "Armand",
  "Armando",
  "Armani",
  "Arnaldo",
  "Arne",
  "Arno",
  "Arnold",
  "Arnoldo",
  "Arnulfo",
  "Aron",
  "Art",
  "Arthur",
  "Arturo",
  "Arvel",
  "Arvid",
  "Arvilla",
  "Aryanna",
  "Asa",
  "Asha",
  "Ashlee",
  "Ashleigh",
  "Ashley",
  "Ashly",
  "Ashlynn",
  "Ashton",
  "Ashtyn",
  "Asia",
  "Assunta",
  "Astrid",
  "Athena",
  "Aubree",
  "Aubrey",
  "Audie",
  "Audra",
  "Audreanne",
  "Audrey",
  "August",
  "Augusta",
  "Augustine",
  "Augustus",
  "Aurelia",
  "Aurelie",
  "Aurelio",
  "Aurore",
  "Austen",
  "Austin",
  "Austyn",
  "Autumn",
  "Ava",
  "Avery",
  "Avis",
  "Axel",
  "Ayana",
  "Ayden",
  "Ayla",
  "Aylin",
  "Baby",
  "Bailee",
  "Bailey",
  "Barbara",
  "Barney",
  "Baron",
  "Barrett",
  "Barry",
  "Bart",
  "Bartholome",
  "Barton",
  "Baylee",
  "Beatrice",
  "Beau",
  "Beaulah",
  "Bell",
  "Bella",
  "Belle",
  "Ben",
  "Benedict",
  "Benjamin",
  "Bennett",
  "Bennie",
  "Benny",
  "Benton",
  "Berenice",
  "Bernadette",
  "Bernadine",
  "Bernard",
  "Bernardo",
  "Berneice",
  "Bernhard",
  "Bernice",
  "Bernie",
  "Berniece",
  "Bernita",
  "Berry",
  "Bert",
  "Berta",
  "Bertha",
  "Bertram",
  "Bertrand",
  "Beryl",
  "Bessie",
  "Beth",
  "Bethany",
  "Bethel",
  "Betsy",
  "Bette",
  "Bettie",
  "Betty",
  "Bettye",
  "Beulah",
  "Beverly",
  "Bianka",
  "Bill",
  "Billie",
  "Billy",
  "Birdie",
  "Blair",
  "Blaise",
  "Blake",
  "Blanca",
  "Blanche",
  "Blaze",
  "Bo",
  "Bobbie",
  "Bobby",
  "Bonita",
  "Bonnie",
  "Boris",
  "Boyd",
  "Brad",
  "Braden",
  "Bradford",
  "Bradley",
  "Bradly",
  "Brady",
  "Braeden",
  "Brain",
  "Brandi",
  "Brando",
  "Brandon",
  "Brandt",
  "Brandy",
  "Brandyn",
  "Brannon",
  "Branson",
  "Brant",
  "Braulio",
  "Braxton",
  "Brayan",
  "Breana",
  "Breanna",
  "Breanne",
  "Brenda",
  "Brendan",
  "Brenden",
  "Brendon",
  "Brenna",
  "Brennan",
  "Brennon",
  "Brent",
  "Bret",
  "Brett",
  "Bria",
  "Brian",
  "Briana",
  "Brianne",
  "Brice",
  "Bridget",
  "Bridgette",
  "Bridie",
  "Brielle",
  "Brigitte",
  "Brionna",
  "Brisa",
  "Britney",
  "Brittany",
  "Brock",
  "Broderick",
  "Brody",
  "Brook",
  "Brooke",
  "Brooklyn",
  "Brooks",
  "Brown",
  "Bruce",
  "Bryana",
  "Bryce",
  "Brycen",
  "Bryon",
  "Buck",
  "Bud",
  "Buddy",
  "Buford",
  "Bulah",
  "Burdette",
  "Burley",
  "Burnice",
  "Buster",
  "Cade",
  "Caden",
  "Caesar",
  "Caitlyn",
  "Cale",
  "Caleb",
  "Caleigh",
  "Cali",
  "Calista",
  "Callie",
  "Camden",
  "Cameron",
  "Camila",
  "Camilla",
  "Camille",
  "Camren",
  "Camron",
  "Camryn",
  "Camylle",
  "Candace",
  "Candelario",
  "Candice",
  "Candida",
  "Candido",
  "Cara",
  "Carey",
  "Carissa",
  "Carlee",
  "Carleton",
  "Carley",
  "Carli",
  "Carlie",
  "Carlo",
  "Carlos",
  "Carlotta",
  "Carmel",
  "Carmela",
  "Carmella",
  "Carmelo",
  "Carmen",
  "Carmine",
  "Carol",
  "Carolanne",
  "Carole",
  "Carolina",
  "Caroline",
  "Carolyn",
  "Carolyne",
  "Carrie",
  "Carroll",
  "Carson",
  "Carter",
  "Cary",
  "Casandra",
  "Casey",
  "Casimer",
  "Casimir",
  "Casper",
  "Cassandra",
  "Cassandre",
  "Cassidy",
  "Cassie",
  "Catalina",
  "Caterina",
  "Catharine",
  "Catherine",
  "Cathrine",
  "Cathryn",
  "Cathy",
  "Cayla",
  "Ceasar",
  "Cecelia",
  "Cecil",
  "Cecile",
  "Cecilia",
  "Cedrick",
  "Celestine",
  "Celestino",
  "Celia",
  "Celine",
  "Cesar",
  "Chad",
  "Chadd",
  "Chadrick",
  "Chaim",
  "Chance",
  "Chandler",
  "Chanel",
  "Chanelle",
  "Charity",
  "Charlene",
  "Charles",
  "Charley",
  "Charlie",
  "Charlotte",
  "Chase",
  "Chasity",
  "Chauncey",
  "Chaya",
  "Chaz",
  "Chelsea",
  "Chelsey",
  "Chelsie",
  "Chesley",
  "Chester",
  "Chet",
  "Cheyanne",
  "Cheyenne",
  "Chloe",
  "Chris",
  "Christ",
  "Christa",
  "Christelle",
  "Christian",
  "Christiana",
  "Christina",
  "Christine",
  "Christop",
  "Christophe",
  "Christopher",
  "Christy",
  "Chyna",
  "Ciara",
  "Cicero",
  "Cielo",
  "Cierra",
  "Cindy",
  "Citlalli",
  "Clair",
  "Claire",
  "Clara",
  "Clarabelle",
  "Clare",
  "Clarissa",
  "Clark",
  "Claud",
  "Claude",
  "Claudia",
  "Claudie",
  "Claudine",
  "Clay",
  "Clemens",
  "Clement",
  "Clementina",
  "Clementine",
  "Clemmie",
  "Cleo",
  "Cleora",
  "Cleta",
  "Cletus",
  "Cleve",
  "Cleveland",
  "Clifford",
  "Clifton",
  "Clint",
  "Clinton",
  "Clotilde",
  "Clovis",
  "Cloyd",
  "Clyde",
  "Coby",
  "Cody",
  "Colby",
  "Cole",
  "Coleman",
  "Colin",
  "Colleen",
  "Collin",
  "Colt",
  "Colten",
  "Colton",
  "Columbus",
  "Concepcion",
  "Conner",
  "Connie",
  "Connor",
  "Conor",
  "Conrad",
  "Constance",
  "Constantin",
  "Consuelo",
  "Cooper",
  "Cora",
  "Coralie",
  "Corbin",
  "Cordelia",
  "Cordell",
  "Cordia",
  "Cordie",
  "Corene",
  "Corine",
  "Cornelius",
  "Cornell",
  "Corrine",
  "Cortez",
  "Cortney",
  "Cory",
  "Coty",
  "Courtney",
  "Coy",
  "Craig",
  "Crawford",
  "Creola",
  "Cristal",
  "Cristian",
  "Cristina",
  "Cristobal",
  "Cristopher",
  "Cruz",
  "Crystal",
  "Crystel",
  "Cullen",
  "Curt",
  "Curtis",
  "Cydney",
  "Cynthia",
  "Cyril",
  "Cyrus",
  "Dagmar",
  "Dahlia",
  "Daija",
  "Daisha",
  "Daisy",
  "Dakota",
  "Dale",
  "Dallas",
  "Dallin",
  "Dalton",
  "Damaris",
  "Dameon",
  "Damian",
  "Damien",
  "Damion",
  "Damon",
  "Dan",
  "Dana",
  "Dandre",
  "Dane",
  "D'angelo",
  "Dangelo",
  "Danial",
  "Daniela",
  "Daniella",
  "Danielle",
  "Danika",
  "Dannie",
  "Danny",
  "Dante",
  "Danyka",
  "Daphne",
  "Daphnee",
  "Daphney",
  "Darby",
  "Daren",
  "Darian",
  "Dariana",
  "Darien",
  "Dario",
  "Darion",
  "Darius",
  "Darlene",
  "Daron",
  "Darrel",
  "Darrell",
  "Darren",
  "Darrick",
  "Darrin",
  "Darrion",
  "Darron",
  "Darryl",
  "Darwin",
  "Daryl",
  "Dashawn",
  "Dasia",
  "Dave",
  "David",
  "Davin",
  "Davion",
  "Davon",
  "Davonte",
  "Dawn",
  "Dawson",
  "Dax",
  "Dayana",
  "Dayna",
  "Dayne",
  "Dayton",
  "Dean",
  "Deangelo",
  "Deanna",
  "Deborah",
  "Declan",
  "Dedric",
  "Dedrick",
  "Dee",
  "Deion",
  "Deja",
  "Dejah",
  "Dejon",
  "Dejuan",
  "Delaney",
  "Delbert",
  "Delfina",
  "Delia",
  "Delilah",
  "Dell",
  "Della",
  "Delmer",
  "Delores",
  "Delpha",
  "Delphia",
  "Delphine",
  "Delta",
  "Demarco",
  "Demarcus",
  "Demario",
  "Demetris",
  "Demetrius",
  "Demond",
  "Dena",
  "Denis",
  "Dennis",
  "Deon",
  "Deondre",
  "Deontae",
  "Deonte",
  "Dereck",
  "Derek",
  "Derick",
  "Deron",
  "Derrick",
  "Deshaun",
  "Deshawn",
  "Desiree",
  "Desmond",
  "Dessie",
  "Destany",
  "Destin",
  "Destinee",
  "Destiney",
  "Destini",
  "Destiny",
  "Devan",
  "Devante",
  "Deven",
  "Devin",
  "Devon",
  "Devonte",
  "Devyn",
  "Dewayne",
  "Dewitt",
  "Dexter",
  "Diamond",
  "Diana",
  "Dianna",
  "Diego",
  "Dillan",
  "Dillon",
  "Dimitri",
  "Dina",
  "Dino",
  "Dion",
  "Dixie",
  "Dock",
  "Dolly",
  "Dolores",
  "Domenic",
  "Domenica",
  "Domenick",
  "Domenico",
  "Domingo",
  "Dominic",
  "Dominique",
  "Don",
  "Donald",
  "Donato",
  "Donavon",
  "Donna",
  "Donnell",
  "Donnie",
  "Donny",
  "Dora",
  "Dorcas",
  "Dorian",
  "Doris",
  "Dorothea",
  "Dorothy",
  "Dorris",
  "Dortha",
  "Dorthy",
  "Doug",
  "Douglas",
  "Dovie",
  "Doyle",
  "Drake",
  "Drew",
  "Duane",
  "Dudley",
  "Dulce",
  "Duncan",
  "Durward",
  "Dustin",
  "Dusty",
  "Dwight",
  "Dylan",
  "Earl",
  "Earlene",
  "Earline",
  "Earnest",
  "Earnestine",
  "Easter",
  "Easton",
  "Ebba",
  "Ebony",
  "Ed",
  "Eda",
  "Edd",
  "Eddie",
  "Eden",
  "Edgar",
  "Edgardo",
  "Edison",
  "Edmond",
  "Edmund",
  "Edna",
  "Eduardo",
  "Edward",
  "Edwardo",
  "Edwin",
  "Edwina",
  "Edyth",
  "Edythe",
  "Effie",
  "Efrain",
  "Efren",
  "Eileen",
  "Einar",
  "Eino",
  "Eladio",
  "Elaina",
  "Elbert",
  "Elda",
  "Eldon",
  "Eldora",
  "Eldred",
  "Eldridge",
  "Eleanora",
  "Eleanore",
  "Eleazar",
  "Electa",
  "Elena",
  "Elenor",
  "Elenora",
  "Eleonore",
  "Elfrieda",
  "Eli",
  "Elian",
  "Eliane",
  "Elias",
  "Eliezer",
  "Elijah",
  "Elinor",
  "Elinore",
  "Elisa",
  "Elisabeth",
  "Elise",
  "Eliseo",
  "Elisha",
  "Elissa",
  "Eliza",
  "Elizabeth",
  "Ella",
  "Ellen",
  "Ellie",
  "Elliot",
  "Elliott",
  "Ellis",
  "Ellsworth",
  "Elmer",
  "Elmira",
  "Elmo",
  "Elmore",
  "Elna",
  "Elnora",
  "Elody",
  "Eloisa",
  "Eloise",
  "Elouise",
  "Eloy",
  "Elroy",
  "Elsa",
  "Else",
  "Elsie",
  "Elta",
  "Elton",
  "Elva",
  "Elvera",
  "Elvie",
  "Elvis",
  "Elwin",
  "Elwyn",
  "Elyse",
  "Elyssa",
  "Elza",
  "Emanuel",
  "Emelia",
  "Emelie",
  "Emely",
  "Emerald",
  "Emerson",
  "Emery",
  "Emie",
  "Emil",
  "Emile",
  "Emilia",
  "Emiliano",
  "Emilie",
  "Emilio",
  "Emily",
  "Emma",
  "Emmalee",
  "Emmanuel",
  "Emmanuelle",
  "Emmet",
  "Emmett",
  "Emmie",
  "Emmitt",
  "Emmy",
  "Emory",
  "Ena",
  "Enid",
  "Enoch",
  "Enola",
  "Enos",
  "Enrico",
  "Enrique",
  "Ephraim",
  "Era",
  "Eriberto",
  "Eric",
  "Erica",
  "Erich",
  "Erick",
  "Ericka",
  "Erik",
  "Erika",
  "Erin",
  "Erling",
  "Erna",
  "Ernest",
  "Ernestina",
  "Ernestine",
  "Ernesto",
  "Ernie",
  "Ervin",
  "Erwin",
  "Eryn",
  "Esmeralda",
  "Esperanza",
  "Esta",
  "Esteban",
  "Estefania",
  "Estel",
  "Estell",
  "Estella",
  "Estelle",
  "Estevan",
  "Esther",
  "Estrella",
  "Etha",
  "Ethan",
  "Ethel",
  "Ethelyn",
  "Ethyl",
  "Ettie",
  "Eudora",
  "Eugene",
  "Eugenia",
  "Eula",
  "Eulah",
  "Eulalia",
  "Euna",
  "Eunice",
  "Eusebio",
  "Eva",
  "Evalyn",
  "Evan",
  "Evangeline",
  "Evans",
  "Eve",
  "Eveline",
  "Evelyn",
  "Everardo",
  "Everett",
  "Everette",
  "Evert",
  "Evie",
  "Ewald",
  "Ewell",
  "Ezekiel",
  "Ezequiel",
  "Ezra",
  "Fabian",
  "Fabiola",
  "Fae",
  "Fannie",
  "Fanny",
  "Fatima",
  "Faustino",
  "Fausto",
  "Favian",
  "Fay",
  "Faye",
  "Federico",
  "Felicia",
  "Felicita",
  "Felicity",
  "Felipa",
  "Felipe",
  "Felix",
  "Felton",
  "Fermin",
  "Fern",
  "Fernando",
  "Ferne",
  "Fidel",
  "Filiberto",
  "Filomena",
  "Finn",
  "Fiona",
  "Flavie",
  "Flavio",
  "Fleta",
  "Fletcher",
  "Flo",
  "Florence",
  "Florencio",
  "Florian",
  "Florida",
  "Florine",
  "Flossie",
  "Floy",
  "Floyd",
  "Ford",
  "Forest",
  "Forrest",
  "Foster",
  "Frances",
  "Francesca",
  "Francesco",
  "Francis",
  "Francisca",
  "Francisco",
  "Franco",
  "Frank",
  "Frankie",
  "Franz",
  "Fred",
  "Freda",
  "Freddie",
  "Freddy",
  "Frederic",
  "Frederick",
  "Frederik",
  "Frederique",
  "Fredrick",
  "Fredy",
  "Freeda",
  "Freeman",
  "Freida",
  "Frida",
  "Frieda",
  "Friedrich",
  "Fritz",
  "Furman",
  "Gabe",
  "Gabriel",
  "Gabriella",
  "Gabrielle",
  "Gaetano",
  "Gage",
  "Gail",
  "Gardner",
  "Garett",
  "Garfield",
  "Garland",
  "Garnet",
  "Garnett",
  "Garret",
  "Garrett",
  "Garrick",
  "Garrison",
  "Garry",
  "Garth",
  "Gaston",
  "Gavin",
  "Gay",
  "Gayle",
  "Gaylord",
  "Gene",
  "General",
  "Genesis",
  "Genevieve",
  "Gennaro",
  "Genoveva",
  "Geo",
  "Geoffrey",
  "George",
  "Georgette",
  "Georgiana",
  "Georgianna",
  "Geovanni",
  "Geovanny",
  "Geovany",
  "Gerald",
  "Geraldine",
  "Gerard",
  "Gerardo",
  "Gerda",
  "Gerhard",
  "Germaine",
  "German",
  "Gerry",
  "Gerson",
  "Gertrude",
  "Gia",
  "Gianni",
  "Gideon",
  "Gilbert",
  "Gilberto",
  "Gilda",
  "Giles",
  "Gillian",
  "Gina",
  "Gino",
  "Giovani",
  "Giovanna",
  "Giovanni",
  "Giovanny",
  "Gisselle",
  "Giuseppe",
  "Gladyce",
  "Gladys",
  "Glen",
  "Glenda",
  "Glenna",
  "Glennie",
  "Gloria",
  "Godfrey",
  "Golda",
  "Golden",
  "Gonzalo",
  "Gordon",
  "Grace",
  "Gracie",
  "Graciela",
  "Grady",
  "Graham",
  "Grant",
  "Granville",
  "Grayce",
  "Grayson",
  "Green",
  "Greg",
  "Gregg",
  "Gregoria",
  "Gregorio",
  "Gregory",
  "Greta",
  "Gretchen",
  "Greyson",
  "Griffin",
  "Grover",
  "Guadalupe",
  "Gudrun",
  "Guido",
  "Guillermo",
  "Guiseppe",
  "Gunnar",
  "Gunner",
  "Gus",
  "Gussie",
  "Gust",
  "Gustave",
  "Guy",
  "Gwen",
  "Gwendolyn",
  "Hadley",
  "Hailee",
  "Hailey",
  "Hailie",
  "Hal",
  "Haleigh",
  "Haley",
  "Halie",
  "Halle",
  "Hallie",
  "Hank",
  "Hanna",
  "Hannah",
  "Hans",
  "Hardy",
  "Harley",
  "Harmon",
  "Harmony",
  "Harold",
  "Harrison",
  "Harry",
  "Harvey",
  "Haskell",
  "Hassan",
  "Hassie",
  "Hattie",
  "Haven",
  "Hayden",
  "Haylee",
  "Hayley",
  "Haylie",
  "Hazel",
  "Hazle",
  "Heath",
  "Heather",
  "Heaven",
  "Heber",
  "Hector",
  "Heidi",
  "Helen",
  "Helena",
  "Helene",
  "Helga",
  "Hellen",
  "Helmer",
  "Heloise",
  "Henderson",
  "Henri",
  "Henriette",
  "Henry",
  "Herbert",
  "Herman",
  "Hermann",
  "Hermina",
  "Herminia",
  "Herminio",
  "Hershel",
  "Herta",
  "Hertha",
  "Hester",
  "Hettie",
  "Hilario",
  "Hilbert",
  "Hilda",
  "Hildegard",
  "Hillard",
  "Hillary",
  "Hilma",
  "Hilton",
  "Hipolito",
  "Hiram",
  "Hobart",
  "Holden",
  "Hollie",
  "Hollis",
  "Holly",
  "Hope",
  "Horace",
  "Horacio",
  "Hortense",
  "Hosea",
  "Houston",
  "Howard",
  "Howell",
  "Hoyt",
  "Hubert",
  "Hudson",
  "Hugh",
  "Hulda",
  "Humberto",
  "Hunter",
  "Hyman",
  "Ian",
  "Ibrahim",
  "Icie",
  "Ida",
  "Idell",
  "Idella",
  "Ignacio",
  "Ignatius",
  "Ike",
  "Ila",
  "Ilene",
  "Iliana",
  "Ima",
  "Imani",
  "Imelda",
  "Immanuel",
  "Imogene",
  "Ines",
  "Irma",
  "Irving",
  "Irwin",
  "Isaac",
  "Isabel",
  "Isabell",
  "Isabella",
  "Isabelle",
  "Isac",
  "Isadore",
  "Isai",
  "Isaiah",
  "Isaias",
  "Isidro",
  "Ismael",
  "Isobel",
  "Isom",
  "Israel",
  "Issac",
  "Itzel",
  "Iva",
  "Ivah",
  "Ivory",
  "Ivy",
  "Izabella",
  "Izaiah",
  "Jabari",
  "Jace",
  "Jacey",
  "Jacinthe",
  "Jacinto",
  "Jack",
  "Jackeline",
  "Jackie",
  "Jacklyn",
  "Jackson",
  "Jacky",
  "Jaclyn",
  "Jacquelyn",
  "Jacques",
  "Jacynthe",
  "Jada",
  "Jade",
  "Jaden",
  "Jadon",
  "Jadyn",
  "Jaeden",
  "Jaida",
  "Jaiden",
  "Jailyn",
  "Jaime",
  "Jairo",
  "Jakayla",
  "Jake",
  "Jakob",
  "Jaleel",
  "Jalen",
  "Jalon",
  "Jalyn",
  "Jamaal",
  "Jamal",
  "Jamar",
  "Jamarcus",
  "Jamel",
  "Jameson",
  "Jamey",
  "Jamie",
  "Jamil",
  "Jamir",
  "Jamison",
  "Jammie",
  "Jan",
  "Jana",
  "Janae",
  "Jane",
  "Janelle",
  "Janessa",
  "Janet",
  "Janice",
  "Janick",
  "Janie",
  "Janis",
  "Janiya",
  "Jannie",
  "Jany",
  "Jaquan",
  "Jaquelin",
  "Jaqueline",
  "Jared",
  "Jaren",
  "Jarod",
  "Jaron",
  "Jarred",
  "Jarrell",
  "Jarret",
  "Jarrett",
  "Jarrod",
  "Jarvis",
  "Jasen",
  "Jasmin",
  "Jason",
  "Jasper",
  "Jaunita",
  "Javier",
  "Javon",
  "Javonte",
  "Jay",
  "Jayce",
  "Jaycee",
  "Jayda",
  "Jayde",
  "Jayden",
  "Jaydon",
  "Jaylan",
  "Jaylen",
  "Jaylin",
  "Jaylon",
  "Jayme",
  "Jayne",
  "Jayson",
  "Jazlyn",
  "Jazmin",
  "Jazmyn",
  "Jazmyne",
  "Jean",
  "Jeanette",
  "Jeanie",
  "Jeanne",
  "Jed",
  "Jedediah",
  "Jedidiah",
  "Jeff",
  "Jefferey",
  "Jeffery",
  "Jeffrey",
  "Jeffry",
  "Jena",
  "Jenifer",
  "Jennie",
  "Jennifer",
  "Jennings",
  "Jennyfer",
  "Jensen",
  "Jerad",
  "Jerald",
  "Jeramie",
  "Jeramy",
  "Jerel",
  "Jeremie",
  "Jeremy",
  "Jermain",
  "Jermaine",
  "Jermey",
  "Jerod",
  "Jerome",
  "Jeromy",
  "Jerrell",
  "Jerrod",
  "Jerrold",
  "Jerry",
  "Jess",
  "Jesse",
  "Jessica",
  "Jessie",
  "Jessika",
  "Jessy",
  "Jessyca",
  "Jesus",
  "Jett",
  "Jettie",
  "Jevon",
  "Jewel",
  "Jewell",
  "Jillian",
  "Jimmie",
  "Jimmy",
  "Jo",
  "Joan",
  "Joana",
  "Joanie",
  "Joanne",
  "Joannie",
  "Joanny",
  "Joany",
  "Joaquin",
  "Jocelyn",
  "Jodie",
  "Jody",
  "Joe",
  "Joel",
  "Joelle",
  "Joesph",
  "Joey",
  "Johan",
  "Johann",
  "Johanna",
  "Johathan",
  "John",
  "Johnathan",
  "Johnathon",
  "Johnnie",
  "Johnny",
  "Johnpaul",
  "Johnson",
  "Jolie",
  "Jon",
  "Jonas",
  "Jonatan",
  "Jonathan",
  "Jonathon",
  "Jordan",
  "Jordane",
  "Jordi",
  "Jordon",
  "Jordy",
  "Jordyn",
  "Jorge",
  "Jose",
  "Josefa",
  "Josefina",
  "Joseph",
  "Josephine",
  "Josh",
  "Joshua",
  "Joshuah",
  "Josiah",
  "Josiane",
  "Josianne",
  "Josie",
  "Josue",
  "Jovan",
  "Jovani",
  "Jovanny",
  "Jovany",
  "Joy",
  "Joyce",
  "Juana",
  "Juanita",
  "Judah",
  "Judd",
  "Jude",
  "Judge",
  "Judson",
  "Judy",
  "Jules",
  "Julia",
  "Julian",
  "Juliana",
  "Julianne",
  "Julie",
  "Julien",
  "Juliet",
  "Julio",
  "Julius",
  "June",
  "Junior",
  "Junius",
  "Justen",
  "Justice",
  "Justina",
  "Justine",
  "Juston",
  "Justus",
  "Justyn",
  "Juvenal",
  "Juwan",
  "Kacey",
  "Kaci",
  "Kacie",
  "Kade",
  "Kaden",
  "Kadin",
  "Kaela",
  "Kaelyn",
  "Kaia",
  "Kailee",
  "Kailey",
  "Kailyn",
  "Kaitlin",
  "Kaitlyn",
  "Kale",
  "Kaleb",
  "Kaleigh",
  "Kaley",
  "Kali",
  "Kallie",
  "Kameron",
  "Kamille",
  "Kamren",
  "Kamron",
  "Kamryn",
  "Kane",
  "Kara",
  "Kareem",
  "Karelle",
  "Karen",
  "Kari",
  "Kariane",
  "Karianne",
  "Karina",
  "Karine",
  "Karl",
  "Karlee",
  "Karley",
  "Karli",
  "Karlie",
  "Karolann",
  "Karson",
  "Kasandra",
  "Kasey",
  "Kassandra",
  "Katarina",
  "Katelin",
  "Katelyn",
  "Katelynn",
  "Katharina",
  "Katherine",
  "Katheryn",
  "Kathleen",
  "Kathlyn",
  "Kathryn",
  "Kathryne",
  "Katlyn",
  "Katlynn",
  "Katrina",
  "Katrine",
  "Kattie",
  "Kavon",
  "Kay",
  "Kaya",
  "Kaycee",
  "Kayden",
  "Kayla",
  "Kaylah",
  "Kaylee",
  "Kayleigh",
  "Kayley",
  "Kayli",
  "Kaylie",
  "Kaylin",
  "Keagan",
  "Keanu",
  "Keara",
  "Keaton",
  "Keegan",
  "Keeley",
  "Keely",
  "Keenan",
  "Keira",
  "Keith",
  "Kellen",
  "Kelley",
  "Kelli",
  "Kellie",
  "Kelly",
  "Kelsi",
  "Kelsie",
  "Kelton",
  "Kelvin",
  "Ken",
  "Kendall",
  "Kendra",
  "Kendrick",
  "Kenna",
  "Kennedi",
  "Kennedy",
  "Kenneth",
  "Kennith",
  "Kenny",
  "Kenton",
  "Kenya",
  "Kenyatta",
  "Kenyon",
  "Keon",
  "Keshaun",
  "Keshawn",
  "Keven",
  "Kevin",
  "Kevon",
  "Keyon",
  "Keyshawn",
  "Khalid",
  "Khalil",
  "Kian",
  "Kiana",
  "Kianna",
  "Kiara",
  "Kiarra",
  "Kiel",
  "Kiera",
  "Kieran",
  "Kiley",
  "Kim",
  "Kimberly",
  "King",
  "Kip",
  "Kira",
  "Kirk",
  "Kirsten",
  "Kirstin",
  "Kitty",
  "Kobe",
  "Koby",
  "Kody",
  "Kolby",
  "Kole",
  "Korbin",
  "Korey",
  "Kory",
  "Kraig",
  "Kris",
  "Krista",
  "Kristian",
  "Kristin",
  "Kristina",
  "Kristofer",
  "Kristoffer",
  "Kristopher",
  "Kristy",
  "Krystal",
  "Krystel",
  "Krystina",
  "Kurt",
  "Kurtis",
  "Kyla",
  "Kyle",
  "Kylee",
  "Kyleigh",
  "Kyler",
  "Kylie",
  "Kyra",
  "Lacey",
  "Lacy",
  "Ladarius",
  "Lafayette",
  "Laila",
  "Laisha",
  "Lamar",
  "Lambert",
  "Lamont",
  "Lance",
  "Landen",
  "Lane",
  "Laney",
  "Larissa",
  "Laron",
  "Larry",
  "Larue",
  "Laura",
  "Laurel",
  "Lauren",
  "Laurence",
  "Lauretta",
  "Lauriane",
  "Laurianne",
  "Laurie",
  "Laurine",
  "Laury",
  "Lauryn",
  "Lavada",
  "Lavern",
  "Laverna",
  "Laverne",
  "Lavina",
  "Lavinia",
  "Lavon",
  "Lavonne",
  "Lawrence",
  "Lawson",
  "Layla",
  "Layne",
  "Lazaro",
  "Lea",
  "Leann",
  "Leanna",
  "Leanne",
  "Leatha",
  "Leda",
  "Lee",
  "Leif",
  "Leila",
  "Leilani",
  "Lela",
  "Lelah",
  "Leland",
  "Lelia",
  "Lempi",
  "Lemuel",
  "Lenna",
  "Lennie",
  "Lenny",
  "Lenora",
  "Lenore",
  "Leo",
  "Leola",
  "Leon",
  "Leonard",
  "Leonardo",
  "Leone",
  "Leonel",
  "Leonie",
  "Leonor",
  "Leonora",
  "Leopold",
  "Leopoldo",
  "Leora",
  "Lera",
  "Lesley",
  "Leslie",
  "Lesly",
  "Lessie",
  "Lester",
  "Leta",
  "Letha",
  "Letitia",
  "Levi",
  "Lew",
  "Lewis",
  "Lexi",
  "Lexie",
  "Lexus",
  "Lia",
  "Liam",
  "Liana",
  "Libbie",
  "Libby",
  "Lila",
  "Lilian",
  "Liliana",
  "Liliane",
  "Lilla",
  "Lillian",
  "Lilliana",
  "Lillie",
  "Lilly",
  "Lily",
  "Lilyan",
  "Lina",
  "Lincoln",
  "Linda",
  "Lindsay",
  "Lindsey",
  "Linnea",
  "Linnie",
  "Linwood",
  "Lionel",
  "Lisa",
  "Lisandro",
  "Lisette",
  "Litzy",
  "Liza",
  "Lizeth",
  "Lizzie",
  "Llewellyn",
  "Lloyd",
  "Logan",
  "Lois",
  "Lola",
  "Lolita",
  "Loma",
  "Lon",
  "London",
  "Lonie",
  "Lonnie",
  "Lonny",
  "Lonzo",
  "Lora",
  "Loraine",
  "Loren",
  "Lorena",
  "Lorenz",
  "Lorenza",
  "Lorenzo",
  "Lori",
  "Lorine",
  "Lorna",
  "Lottie",
  "Lou",
  "Louie",
  "Louisa",
  "Lourdes",
  "Louvenia",
  "Lowell",
  "Loy",
  "Loyal",
  "Loyce",
  "Lucas",
  "Luciano",
  "Lucie",
  "Lucienne",
  "Lucile",
  "Lucinda",
  "Lucio",
  "Lucious",
  "Lucius",
  "Lucy",
  "Ludie",
  "Ludwig",
  "Lue",
  "Luella",
  "Luigi",
  "Luis",
  "Luisa",
  "Lukas",
  "Lula",
  "Lulu",
  "Luna",
  "Lupe",
  "Lura",
  "Lurline",
  "Luther",
  "Luz",
  "Lyda",
  "Lydia",
  "Lyla",
  "Lynn",
  "Lyric",
  "Lysanne",
  "Mabel",
  "Mabelle",
  "Mable",
  "Mac",
  "Macey",
  "Maci",
  "Macie",
  "Mack",
  "Mackenzie",
  "Macy",
  "Madaline",
  "Madalyn",
  "Maddison",
  "Madeline",
  "Madelyn",
  "Madelynn",
  "Madge",
  "Madie",
  "Madilyn",
  "Madisen",
  "Madison",
  "Madisyn",
  "Madonna",
  "Madyson",
  "Mae",
  "Maegan",
  "Maeve",
  "Mafalda",
  "Magali",
  "Magdalen",
  "Magdalena",
  "Maggie",
  "Magnolia",
  "Magnus",
  "Maia",
  "Maida",
  "Maiya",
  "Major",
  "Makayla",
  "Makenna",
  "Makenzie",
  "Malachi",
  "Malcolm",
  "Malika",
  "Malinda",
  "Mallie",
  "Mallory",
  "Malvina",
  "Mandy",
  "Manley",
  "Manuel",
  "Manuela",
  "Mara",
  "Marc",
  "Marcel",
  "Marcelina",
  "Marcelino",
  "Marcella",
  "Marcelle",
  "Marcellus",
  "Marcelo",
  "Marcia",
  "Marco",
  "Marcos",
  "Marcus",
  "Margaret",
  "Margarete",
  "Margarett",
  "Margaretta",
  "Margarette",
  "Margarita",
  "Marge",
  "Margie",
  "Margot",
  "Margret",
  "Marguerite",
  "Maria",
  "Mariah",
  "Mariam",
  "Marian",
  "Mariana",
  "Mariane",
  "Marianna",
  "Marianne",
  "Mariano",
  "Maribel",
  "Marie",
  "Mariela",
  "Marielle",
  "Marietta",
  "Marilie",
  "Marilou",
  "Marilyne",
  "Marina",
  "Mario",
  "Marion",
  "Marisa",
  "Marisol",
  "Maritza",
  "Marjolaine",
  "Marjorie",
  "Marjory",
  "Mark",
  "Markus",
  "Marlee",
  "Marlen",
  "Marlene",
  "Marley",
  "Marlin",
  "Marlon",
  "Marques",
  "Marquis",
  "Marquise",
  "Marshall",
  "Marta",
  "Martin",
  "Martina",
  "Martine",
  "Marty",
  "Marvin",
  "Mary",
  "Maryam",
  "Maryjane",
  "Maryse",
  "Mason",
  "Mateo",
  "Mathew",
  "Mathias",
  "Mathilde",
  "Matilda",
  "Matilde",
  "Matt",
  "Matteo",
  "Mattie",
  "Maud",
  "Maude",
  "Maudie",
  "Maureen",
  "Maurice",
  "Mauricio",
  "Maurine",
  "Maverick",
  "Mavis",
  "Max",
  "Maxie",
  "Maxime",
  "Maximilian",
  "Maximillia",
  "Maximillian",
  "Maximo",
  "Maximus",
  "Maxine",
  "Maxwell",
  "May",
  "Maya",
  "Maybell",
  "Maybelle",
  "Maye",
  "Maymie",
  "Maynard",
  "Mayra",
  "Mazie",
  "Mckayla",
  "Mckenna",
  "Mckenzie",
  "Meagan",
  "Meaghan",
  "Meda",
  "Megane",
  "Meggie",
  "Meghan",
  "Mekhi",
  "Melany",
  "Melba",
  "Melisa",
  "Melissa",
  "Mellie",
  "Melody",
  "Melvin",
  "Melvina",
  "Melyna",
  "Melyssa",
  "Mercedes",
  "Meredith",
  "Merl",
  "Merle",
  "Merlin",
  "Merritt",
  "Mertie",
  "Mervin",
  "Meta",
  "Mia",
  "Micaela",
  "Micah",
  "Michael",
  "Michaela",
  "Michale",
  "Micheal",
  "Michel",
  "Michele",
  "Michelle",
  "Miguel",
  "Mikayla",
  "Mike",
  "Mikel",
  "Milan",
  "Miles",
  "Milford",
  "Miller",
  "Millie",
  "Milo",
  "Milton",
  "Mina",
  "Minerva",
  "Minnie",
  "Miracle",
  "Mireille",
  "Mireya",
  "Misael",
  "Missouri",
  "Misty",
  "Mitchel",
  "Mitchell",
  "Mittie",
  "Modesta",
  "Modesto",
  "Mohamed",
  "Mohammad",
  "Mohammed",
  "Moises",
  "Mollie",
  "Molly",
  "Mona",
  "Monica",
  "Monique",
  "Monroe",
  "Monserrat",
  "Monserrate",
  "Montana",
  "Monte",
  "Monty",
  "Morgan",
  "Moriah",
  "Morris",
  "Mortimer",
  "Morton",
  "Mose",
  "Moses",
  "Moshe",
  "Mossie",
  "Mozell",
  "Mozelle",
  "Muhammad",
  "Muriel",
  "Murl",
  "Murphy",
  "Murray",
  "Mustafa",
  "Mya",
  "Myah",
  "Mylene",
  "Myles",
  "Myra",
  "Myriam",
  "Myrl",
  "Myrna",
  "Myron",
  "Myrtice",
  "Myrtie",
  "Myrtis",
  "Myrtle",
  "Nadia",
  "Nakia",
  "Name",
  "Nannie",
  "Naomi",
  "Naomie",
  "Napoleon",
  "Narciso",
  "Nash",
  "Nasir",
  "Nat",
  "Natalia",
  "Natalie",
  "Natasha",
  "Nathan",
  "Nathanael",
  "Nathanial",
  "Nathaniel",
  "Nathen",
  "Nayeli",
  "Neal",
  "Ned",
  "Nedra",
  "Neha",
  "Neil",
  "Nelda",
  "Nella",
  "Nelle",
  "Nellie",
  "Nels",
  "Nelson",
  "Neoma",
  "Nestor",
  "Nettie",
  "Neva",
  "Newell",
  "Newton",
  "Nia",
  "Nicholas",
  "Nicholaus",
  "Nichole",
  "Nick",
  "Nicklaus",
  "Nickolas",
  "Nico",
  "Nicola",
  "Nicolas",
  "Nicole",
  "Nicolette",
  "Nigel",
  "Nikita",
  "Nikki",
  "Nikko",
  "Niko",
  "Nikolas",
  "Nils",
  "Nina",
  "Noah",
  "Noble",
  "Noe",
  "Noel",
  "Noelia",
  "Noemi",
  "Noemie",
  "Noemy",
  "Nola",
  "Nolan",
  "Nona",
  "Nora",
  "Norbert",
  "Norberto",
  "Norene",
  "Norma",
  "Norris",
  "Norval",
  "Norwood",
  "Nova",
  "Novella",
  "Nya",
  "Nyah",
  "Nyasia",
  "Obie",
  "Oceane",
  "Ocie",
  "Octavia",
  "Oda",
  "Odell",
  "Odessa",
  "Odie",
  "Ofelia",
  "Okey",
  "Ola",
  "Olaf",
  "Ole",
  "Olen",
  "Oleta",
  "Olga",
  "Olin",
  "Oliver",
  "Ollie",
  "Oma",
  "Omari",
  "Omer",
  "Ona",
  "Onie",
  "Opal",
  "Ophelia",
  "Ora",
  "Oral",
  "Oran",
  "Oren",
  "Orie",
  "Orin",
  "Orion",
  "Orland",
  "Orlando",
  "Orlo",
  "Orpha",
  "Orrin",
  "Orval",
  "Orville",
  "Osbaldo",
  "Osborne",
  "Oscar",
  "Osvaldo",
  "Oswald",
  "Oswaldo",
  "Otha",
  "Otho",
  "Otilia",
  "Otis",
  "Ottilie",
  "Ottis",
  "Otto",
  "Ova",
  "Owen",
  "Ozella",
  "Pablo",
  "Paige",
  "Palma",
  "Pamela",
  "Pansy",
  "Paolo",
  "Paris",
  "Parker",
  "Pascale",
  "Pasquale",
  "Pat",
  "Patience",
  "Patricia",
  "Patrick",
  "Patsy",
  "Pattie",
  "Paul",
  "Paula",
  "Pauline",
  "Paxton",
  "Payton",
  "Pearl",
  "Pearlie",
  "Pearline",
  "Pedro",
  "Peggie",
  "Penelope",
  "Percival",
  "Percy",
  "Perry",
  "Pete",
  "Peter",
  "Petra",
  "Peyton",
  "Philip",
  "Phoebe",
  "Phyllis",
  "Pierce",
  "Pierre",
  "Pietro",
  "Pink",
  "Pinkie",
  "Piper",
  "Polly",
  "Porter",
  "Precious",
  "Presley",
  "Preston",
  "Price",
  "Prince",
  "Princess",
  "Priscilla",
  "Providenci",
  "Prudence",
  "Queen",
  "Queenie",
  "Quentin",
  "Quincy",
  "Quinn",
  "Quinten",
  "Quinton",
  "Rachael",
  "Rachel",
  "Rachelle",
  "Rae",
  "Raegan",
  "Rafael",
  "Rafaela",
  "Raheem",
  "Rahsaan",
  "Rahul",
  "Raina",
  "Raleigh",
  "Ralph",
  "Ramiro",
  "Ramon",
  "Ramona",
  "Randal",
  "Randall",
  "Randi",
  "Randy",
  "Ransom",
  "Raoul",
  "Raphael",
  "Raphaelle",
  "Raquel",
  "Rashad",
  "Rashawn",
  "Rasheed",
  "Raul",
  "Raven",
  "Ray",
  "Raymond",
  "Raymundo",
  "Reagan",
  "Reanna",
  "Reba",
  "Rebeca",
  "Rebecca",
  "Rebeka",
  "Rebekah",
  "Reece",
  "Reed",
  "Reese",
  "Regan",
  "Reggie",
  "Reginald",
  "Reid",
  "Reilly",
  "Reina",
  "Reinhold",
  "Remington",
  "Rene",
  "Renee",
  "Ressie",
  "Reta",
  "Retha",
  "Retta",
  "Reuben",
  "Reva",
  "Rex",
  "Rey",
  "Reyes",
  "Reymundo",
  "Reyna",
  "Reynold",
  "Rhea",
  "Rhett",
  "Rhianna",
  "Rhiannon",
  "Rhoda",
  "Ricardo",
  "Richard",
  "Richie",
  "Richmond",
  "Rick",
  "Rickey",
  "Rickie",
  "Ricky",
  "Rico",
  "Rigoberto",
  "Riley",
  "Rita",
  "River",
  "Robb",
  "Robbie",
  "Robert",
  "Roberta",
  "Roberto",
  "Robin",
  "Robyn",
  "Rocio",
  "Rocky",
  "Rod",
  "Roderick",
  "Rodger",
  "Rodolfo",
  "Rodrick",
  "Rodrigo",
  "Roel",
  "Rogelio",
  "Roger",
  "Rogers",
  "Rolando",
  "Rollin",
  "Roma",
  "Romaine",
  "Roman",
  "Ron",
  "Ronaldo",
  "Ronny",
  "Roosevelt",
  "Rory",
  "Rosa",
  "Rosalee",
  "Rosalia",
  "Rosalind",
  "Rosalinda",
  "Rosalyn",
  "Rosamond",
  "Rosanna",
  "Rosario",
  "Roscoe",
  "Rose",
  "Rosella",
  "Roselyn",
  "Rosemarie",
  "Rosemary",
  "Rosendo",
  "Rosetta",
  "Rosie",
  "Rosina",
  "Roslyn",
  "Ross",
  "Rossie",
  "Rowan",
  "Rowena",
  "Rowland",
  "Roxane",
  "Roxanne",
  "Roy",
  "Royal",
  "Royce",
  "Rozella",
  "Ruben",
  "Rubie",
  "Ruby",
  "Rubye",
  "Rudolph",
  "Rudy",
  "Rupert",
  "Russ",
  "Russel",
  "Russell",
  "Rusty",
  "Ruth",
  "Ruthe",
  "Ruthie",
  "Ryan",
  "Ryann",
  "Ryder",
  "Rylan",
  "Rylee",
  "Ryleigh",
  "Ryley",
  "Sabina",
  "Sabrina",
  "Sabryna",
  "Sadie",
  "Sadye",
  "Sage",
  "Saige",
  "Sallie",
  "Sally",
  "Salma",
  "Salvador",
  "Salvatore",
  "Sam",
  "Samanta",
  "Samantha",
  "Samara",
  "Samir",
  "Sammie",
  "Sammy",
  "Samson",
  "Sandra",
  "Sandrine",
  "Sandy",
  "Sanford",
  "Santa",
  "Santiago",
  "Santina",
  "Santino",
  "Santos",
  "Sarah",
  "Sarai",
  "Sarina",
  "Sasha",
  "Saul",
  "Savanah",
  "Savanna",
  "Savannah",
  "Savion",
  "Scarlett",
  "Schuyler",
  "Scot",
  "Scottie",
  "Scotty",
  "Seamus",
  "Sean",
  "Sebastian",
  "Sedrick",
  "Selena",
  "Selina",
  "Selmer",
  "Serena",
  "Serenity",
  "Seth",
  "Shad",
  "Shaina",
  "Shakira",
  "Shana",
  "Shane",
  "Shanel",
  "Shanelle",
  "Shania",
  "Shanie",
  "Shaniya",
  "Shanna",
  "Shannon",
  "Shanny",
  "Shanon",
  "Shany",
  "Sharon",
  "Shaun",
  "Shawn",
  "Shawna",
  "Shaylee",
  "Shayna",
  "Shayne",
  "Shea",
  "Sheila",
  "Sheldon",
  "Shemar",
  "Sheridan",
  "Sherman",
  "Sherwood",
  "Shirley",
  "Shyann",
  "Shyanne",
  "Sibyl",
  "Sid",
  "Sidney",
  "Sienna",
  "Sierra",
  "Sigmund",
  "Sigrid",
  "Sigurd",
  "Silas",
  "Sim",
  "Simeon",
  "Simone",
  "Sincere",
  "Sister",
  "Skye",
  "Skyla",
  "Skylar",
  "Sofia",
  "Soledad",
  "Solon",
  "Sonia",
  "Sonny",
  "Sonya",
  "Sophia",
  "Sophie",
  "Spencer",
  "Stacey",
  "Stacy",
  "Stan",
  "Stanford",
  "Stanley",
  "Stanton",
  "Stefan",
  "Stefanie",
  "Stella",
  "Stephan",
  "Stephania",
  "Stephanie",
  "Stephany",
  "Stephen",
  "Stephon",
  "Sterling",
  "Steve",
  "Stevie",
  "Stewart",
  "Stone",
  "Stuart",
  "Summer",
  "Sunny",
  "Susan",
  "Susana",
  "Susanna",
  "Susie",
  "Suzanne",
  "Sven",
  "Syble",
  "Sydnee",
  "Sydney",
  "Sydni",
  "Sydnie",
  "Sylvan",
  "Sylvester",
  "Sylvia",
  "Tabitha",
  "Tad",
  "Talia",
  "Talon",
  "Tamara",
  "Tamia",
  "Tania",
  "Tanner",
  "Tanya",
  "Tara",
  "Taryn",
  "Tate",
  "Tatum",
  "Tatyana",
  "Taurean",
  "Tavares",
  "Taya",
  "Taylor",
  "Teagan",
  "Ted",
  "Telly",
  "Terence",
  "Teresa",
  "Terrance",
  "Terrell",
  "Terrence",
  "Terrill",
  "Terry",
  "Tess",
  "Tessie",
  "Tevin",
  "Thad",
  "Thaddeus",
  "Thalia",
  "Thea",
  "Thelma",
  "Theo",
  "Theodora",
  "Theodore",
  "Theresa",
  "Therese",
  "Theresia",
  "Theron",
  "Thomas",
  "Thora",
  "Thurman",
  "Tia",
  "Tiana",
  "Tianna",
  "Tiara",
  "Tierra",
  "Tiffany",
  "Tillman",
  "Timmothy",
  "Timmy",
  "Timothy",
  "Tina",
  "Tito",
  "Titus",
  "Tobin",
  "Toby",
  "Tod",
  "Tom",
  "Tomas",
  "Tomasa",
  "Tommie",
  "Toney",
  "Toni",
  "Tony",
  "Torey",
  "Torrance",
  "Torrey",
  "Toy",
  "Trace",
  "Tracey",
  "Tracy",
  "Travis",
  "Travon",
  "Tre",
  "Tremaine",
  "Tremayne",
  "Trent",
  "Trenton",
  "Tressa",
  "Tressie",
  "Treva",
  "Trever",
  "Trevion",
  "Trevor",
  "Trey",
  "Trinity",
  "Trisha",
  "Tristian",
  "Tristin",
  "Triston",
  "Troy",
  "Trudie",
  "Trycia",
  "Trystan",
  "Turner",
  "Twila",
  "Tyler",
  "Tyra",
  "Tyree",
  "Tyreek",
  "Tyrel",
  "Tyrell",
  "Tyrese",
  "Tyrique",
  "Tyshawn",
  "Tyson",
  "Ubaldo",
  "Ulices",
  "Ulises",
  "Una",
  "Unique",
  "Urban",
  "Uriah",
  "Uriel",
  "Ursula",
  "Vada",
  "Valentin",
  "Valentina",
  "Valentine",
  "Valerie",
  "Vallie",
  "Van",
  "Vance",
  "Vanessa",
  "Vaughn",
  "Veda",
  "Velda",
  "Vella",
  "Velma",
  "Velva",
  "Vena",
  "Verda",
  "Verdie",
  "Vergie",
  "Verla",
  "Verlie",
  "Vern",
  "Verna",
  "Verner",
  "Vernice",
  "Vernie",
  "Vernon",
  "Verona",
  "Veronica",
  "Vesta",
  "Vicenta",
  "Vicente",
  "Vickie",
  "Vicky",
  "Victor",
  "Victoria",
  "Vida",
  "Vidal",
  "Vilma",
  "Vince",
  "Vincent",
  "Vincenza",
  "Vincenzo",
  "Vinnie",
  "Viola",
  "Violet",
  "Violette",
  "Virgie",
  "Virgil",
  "Virginia",
  "Virginie",
  "Vita",
  "Vito",
  "Viva",
  "Vivian",
  "Viviane",
  "Vivianne",
  "Vivien",
  "Vivienne",
  "Vladimir",
  "Wade",
  "Waino",
  "Waldo",
  "Walker",
  "Wallace",
  "Walter",
  "Walton",
  "Wanda",
  "Ward",
  "Warren",
  "Watson",
  "Wava",
  "Waylon",
  "Wayne",
  "Webster",
  "Weldon",
  "Wellington",
  "Wendell",
  "Wendy",
  "Werner",
  "Westley",
  "Weston",
  "Whitney",
  "Wilber",
  "Wilbert",
  "Wilburn",
  "Wiley",
  "Wilford",
  "Wilfred",
  "Wilfredo",
  "Wilfrid",
  "Wilhelm",
  "Wilhelmine",
  "Will",
  "Willa",
  "Willard",
  "William",
  "Willie",
  "Willis",
  "Willow",
  "Willy",
  "Wilma",
  "Wilmer",
  "Wilson",
  "Wilton",
  "Winfield",
  "Winifred",
  "Winnifred",
  "Winona",
  "Winston",
  "Woodrow",
  "Wyatt",
  "Wyman",
  "Xander",
  "Xavier",
  "Xzavier",
  "Yadira",
  "Yasmeen",
  "Yasmin",
  "Yasmine",
  "Yazmin",
  "Yesenia",
  "Yessenia",
  "Yolanda",
  "Yoshiko",
  "Yvette",
  "Yvonne",
  "Zachariah",
  "Zachary",
  "Zachery",
  "Zack",
  "Zackary",
  "Zackery",
  "Zakary",
  "Zander",
  "Zane",
  "Zaria",
  "Zechariah",
  "Zelda",
  "Zella",
  "Zelma",
  "Zena",
  "Zetta",
  "Zion",
  "Zita",
  "Zoe",
  "Zoey",
  "Zoie",
  "Zoila",
  "Zola",
  "Zora",
  "Zula"
];
function generateUsername() {
  const name = RandomUtil.randomElement(names);
  const suffix = RandomUtil.randomAlphanumStr(3);
  return `${name}-${suffix}`;
}
module.exports = {
  generateUsername
};


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/version/ComponentsVersions.js":
/*!***************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/version/ComponentsVersions.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ComponentsVersions)
/* harmony export */ });
/* harmony import */ var _statistics_statistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");


const logger = (__webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js").getLogger)(__filename);
function ComponentsVersions(conference) {
  this.versions = {};
  this.conference = conference;
  this.conference.addCommandListener("versions", this.processVersions.bind(this));
}
ComponentsVersions.prototype.processVersions = function(versions, mucResource, mucJid) {
  if (!this.conference.isFocus(mucJid)) {
    logger.warn(`Received versions not from the focus user: ${versions}`, mucJid);
    return;
  }
  const log = [];
  versions.children.forEach((component) => {
    const name = component.attributes.name;
    const version = component.value;
    if (this.versions[name] !== version) {
      this.versions[name] = version;
      logger.info(`Got ${name} version: ${version}`);
      log.push({
        id: "component_version",
        component: name,
        version
      });
    }
  });
  if (log.length > 0) {
    _statistics_statistics__WEBPACK_IMPORTED_MODULE_0__["default"].sendLog(JSON.stringify(log));
  }
};
ComponentsVersions.prototype.getComponentVersion = function(componentName) {
  return this.versions[componentName];
};


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/videosipgw/JitsiVideoSIPGWSession.js":
/*!**********************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/videosipgw/JitsiVideoSIPGWSession.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JitsiVideoSIPGWSession)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");
/* harmony import */ var _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VideoSIPGWConstants */ "../../lib-jitsi-meet/dist/esm/modules/videosipgw/VideoSIPGWConstants.js");





const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const STATE_CHANGED = "STATE_CHANGED";
class JitsiVideoSIPGWSession extends _util_Listenable__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(sipAddress, displayName, chatRoom) {
    super();
    this.sipAddress = sipAddress;
    this.displayName = displayName;
    this.chatRoom = chatRoom;
    this.state = void 0;
  }
  stop() {
    if (this.state === _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_OFF || this.state === _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_FAILED) {
      logger.warn("Video SIP GW session already stopped or failed!");
      return;
    }
    this._sendJibriIQ("stop");
  }
  start() {
    if (this.state === _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_ON || this.state === _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_OFF || this.state === _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_PENDING || this.state === _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_RETRYING) {
      logger.warn("Video SIP GW session already started!");
      return;
    }
    this._sendJibriIQ("start");
  }
  setState(newState, failureReason) {
    if (newState === this.state) {
      return;
    }
    const oldState = this.state;
    this.state = newState;
    this.eventEmitter.emit(STATE_CHANGED, {
      address: this.sipAddress,
      failureReason,
      oldState,
      newState: this.state,
      displayName: this.displayName
    });
  }
  addStateListener(listener) {
    this.addListener(STATE_CHANGED, listener);
  }
  removeStateListener(listener) {
    this.removeListener(STATE_CHANGED, listener);
  }
  _sendJibriIQ(action) {
    const attributes = {
      "xmlns": "http://jitsi.org/protocol/jibri",
      "action": action,
      sipaddress: this.sipAddress
    };
    attributes.displayname = this.displayName;
    const iq = (0,strophe_js__WEBPACK_IMPORTED_MODULE_1__.$iq)({
      to: this.chatRoom.focusMucJid,
      type: "set"
    }).c("jibri", attributes).up();
    logger.debug(`${action} video SIP GW session`, iq.nodeTree);
    this.chatRoom.connection.sendIQ(
      iq,
      () => {
      },
      (error) => {
        logger.error(`Failed to ${action} video SIP GW session, error: `, error);
        this.setState(_VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_FAILED);
      }
    );
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/videosipgw/VideoSIPGW.js":
/*!**********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/videosipgw/VideoSIPGW.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoSIPGW)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _JitsiVideoSIPGWSession__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JitsiVideoSIPGWSession */ "../../lib-jitsi-meet/dist/esm/modules/videosipgw/JitsiVideoSIPGWSession.js");
/* harmony import */ var _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VideoSIPGWConstants */ "../../lib-jitsi-meet/dist/esm/modules/videosipgw/VideoSIPGWConstants.js");


const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);



class VideoSIPGW {
  constructor(chatRoom) {
    this.chatRoom = chatRoom;
    this.eventEmitter = chatRoom.eventEmitter;
    logger.debug("creating VideoSIPGW");
    this.sessions = {};
    this.sessionStateChangeListener = this.sessionStateChanged.bind(this);
    chatRoom.addPresenceListener("jibri-sip-call-state", this.handleJibriSIPState.bind(this));
  }
  handleJibriSIPState(node) {
    const attributes = node.attributes;
    if (!attributes) {
      return;
    }
    logger.debug("Handle video sip gw state : ", attributes);
    const newState = attributes.state;
    if (newState === this.state) {
      return;
    }
    switch (newState) {
      case _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_ON:
      case _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_OFF:
      case _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_PENDING:
      case _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_RETRYING:
      case _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_FAILED: {
        const address = attributes.sipaddress;
        if (!address) {
          return;
        }
        const session = this.sessions[address];
        if (session) {
          session.setState(newState, attributes.failure_reason);
        } else {
          logger.warn("Video SIP GW session not found:", address);
        }
      }
    }
  }
  createVideoSIPGWSession(sipAddress, displayName) {
    if (this.sessions[sipAddress]) {
      logger.warn("There was already a Video SIP GW session for address", sipAddress);
      return new Error(_VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.ERROR_SESSION_EXISTS);
    }
    const session = new _JitsiVideoSIPGWSession__WEBPACK_IMPORTED_MODULE_2__["default"](sipAddress, displayName, this.chatRoom);
    session.addStateListener(this.sessionStateChangeListener);
    this.sessions[sipAddress] = session;
    return session;
  }
  sessionStateChanged(event) {
    const address = event.address;
    if (event.newState === _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_OFF || event.newState === _VideoSIPGWConstants__WEBPACK_IMPORTED_MODULE_3__.STATE_FAILED) {
      const session = this.sessions[address];
      if (!session) {
        logger.error("Missing Video SIP GW session with address:", address);
        return;
      }
      session.removeStateListener(this.sessionStateChangeListener);
      delete this.sessions[address];
    }
    this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_1__.XMPPEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED, event);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/videosipgw/VideoSIPGWConstants.js":
/*!*******************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/videosipgw/VideoSIPGWConstants.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ERROR_NO_CONNECTION: () => (/* binding */ ERROR_NO_CONNECTION),
/* harmony export */   ERROR_SESSION_EXISTS: () => (/* binding */ ERROR_SESSION_EXISTS),
/* harmony export */   STATE_FAILED: () => (/* binding */ STATE_FAILED),
/* harmony export */   STATE_OFF: () => (/* binding */ STATE_OFF),
/* harmony export */   STATE_ON: () => (/* binding */ STATE_ON),
/* harmony export */   STATE_PENDING: () => (/* binding */ STATE_PENDING),
/* harmony export */   STATE_RETRYING: () => (/* binding */ STATE_RETRYING),
/* harmony export */   STATUS_AVAILABLE: () => (/* binding */ STATUS_AVAILABLE),
/* harmony export */   STATUS_BUSY: () => (/* binding */ STATUS_BUSY),
/* harmony export */   STATUS_UNDEFINED: () => (/* binding */ STATUS_UNDEFINED),
/* harmony export */   VideoSIPGWErrorConstants: () => (/* binding */ VideoSIPGWErrorConstants),
/* harmony export */   VideoSIPGWStateConstants: () => (/* binding */ VideoSIPGWStateConstants),
/* harmony export */   VideoSIPGWStatusConstants: () => (/* binding */ VideoSIPGWStatusConstants)
/* harmony export */ });

var VideoSIPGWStatusConstants;
(function(VideoSIPGWStatusConstants2) {
  VideoSIPGWStatusConstants2["STATUS_AVAILABLE"] = "available";
  VideoSIPGWStatusConstants2["STATUS_UNDEFINED"] = "undefined";
  VideoSIPGWStatusConstants2["STATUS_BUSY"] = "busy";
})(VideoSIPGWStatusConstants || (VideoSIPGWStatusConstants = {}));
;
var VideoSIPGWStateConstants;
(function(VideoSIPGWStateConstants2) {
  VideoSIPGWStateConstants2["STATE_ON"] = "on";
  VideoSIPGWStateConstants2["STATE_OFF"] = "off";
  VideoSIPGWStateConstants2["STATE_PENDING"] = "pending";
  VideoSIPGWStateConstants2["STATE_RETRYING"] = "retrying";
  VideoSIPGWStateConstants2["STATE_FAILED"] = "failed";
})(VideoSIPGWStateConstants || (VideoSIPGWStateConstants = {}));
;
var VideoSIPGWErrorConstants;
(function(VideoSIPGWErrorConstants2) {
  VideoSIPGWErrorConstants2["ERROR_NO_CONNECTION"] = "error_no_connection";
  VideoSIPGWErrorConstants2["ERROR_SESSION_EXISTS"] = "error_session_already_exists";
})(VideoSIPGWErrorConstants || (VideoSIPGWErrorConstants = {}));
;
const STATUS_AVAILABLE = VideoSIPGWStatusConstants.STATUS_AVAILABLE;
const STATUS_UNDEFINED = VideoSIPGWStatusConstants.STATUS_UNDEFINED;
const STATUS_BUSY = VideoSIPGWStatusConstants.STATUS_BUSY;
const STATE_ON = VideoSIPGWStateConstants.STATE_ON;
const STATE_OFF = VideoSIPGWStateConstants.STATE_OFF;
const STATE_PENDING = VideoSIPGWStateConstants.STATE_PENDING;
const STATE_RETRYING = VideoSIPGWStateConstants.STATE_RETRYING;
const STATE_FAILED = VideoSIPGWStateConstants.STATE_FAILED;
const ERROR_NO_CONNECTION = VideoSIPGWErrorConstants.ERROR_NO_CONNECTION;
const ERROR_SESSION_EXISTS = VideoSIPGWErrorConstants.ERROR_SESSION_EXISTS;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/watchRTC/WatchRTC.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/watchRTC/WatchRTC.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _testrtc_watchrtc_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @testrtc/watchrtc-sdk */ "../../lib-jitsi-meet/node_modules/@testrtc/watchrtc-sdk/lib/index.js");
/* harmony import */ var _testrtc_watchrtc_sdk__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_testrtc_watchrtc_sdk__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions */ "../../lib-jitsi-meet/dist/esm/modules/watchRTC/functions.js");




const logger = _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default().getLogger(__filename);
class WatchRTCHandler {
  init(options) {
    var _a;
    if ((0,_functions__WEBPACK_IMPORTED_MODULE_2__.isWatchRTCEnabled)(options)) {
      if (!(0,_functions__WEBPACK_IMPORTED_MODULE_2__.isAnalyticsEnabled)(options)) {
        logger.error("Cannot initialize WatchRTC when analytics or third party requests are disabled.");
        return;
      }
      if ((0,_functions__WEBPACK_IMPORTED_MODULE_2__.isRtcstatsEnabled)(options)) {
        logger.error("Cannot initialize WatchRTC when RTCStats is enabled.");
        return;
      }
      try {
        if ((_a = options === null || options === void 0 ? void 0 : options.watchRTCConfigParams) === null || _a === void 0 ? void 0 : _a.rtcApiKey) {
          _testrtc_watchrtc_sdk__WEBPACK_IMPORTED_MODULE_1___default().init({
            rtcApiKey: options.watchRTCConfigParams.rtcApiKey
          });
          this.options = options.watchRTCConfigParams;
          logger.info("WatchRTC initialized.");
        } else {
          logger.error("WatchRTC is enabled but missing API key.");
        }
      } catch (error) {
        logger.error("Failed to initialize WatchRTC: ", error);
      }
    }
  }
  start(roomName, userName) {
    try {
      if (this.options) {
        this.options.rtcRoomId = this.options.rtcRoomId ? this.options.rtcRoomId : roomName;
        this.options.rtcPeerId = this.options.rtcPeerId ? this.options.rtcPeerId : userName;
        _testrtc_watchrtc_sdk__WEBPACK_IMPORTED_MODULE_1___default().persistentEnd();
        _testrtc_watchrtc_sdk__WEBPACK_IMPORTED_MODULE_1___default().setConfig(this.options);
        logger.info("WatchRTC setConfig.");
      }
    } catch (error) {
      logger.error("Failed to start WatchRTC session: ", error);
    }
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new WatchRTCHandler());


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/watchRTC/functions.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/watchRTC/functions.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAnalyticsEnabled: () => (/* binding */ isAnalyticsEnabled),
/* harmony export */   isRtcstatsEnabled: () => (/* binding */ isRtcstatsEnabled),
/* harmony export */   isWatchRTCEnabled: () => (/* binding */ isWatchRTCEnabled)
/* harmony export */ });

function isAnalyticsEnabled(options) {
  const { analytics, disableThirdPartyRequests } = options;
  return !((analytics === null || analytics === void 0 ? void 0 : analytics.disabled) || disableThirdPartyRequests);
}
function isRtcstatsEnabled(options) {
  var _a;
  const { analytics } = options;
  return (_a = analytics === null || analytics === void 0 ? void 0 : analytics.rtcstatsEnabled) !== null && _a !== void 0 ? _a : false;
}
function isWatchRTCEnabled(options) {
  var _a;
  const { analytics } = options;
  return (_a = analytics === null || analytics === void 0 ? void 0 : analytics.watchRTCEnabled) !== null && _a !== void 0 ? _a : false;
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/webaudio/AudioMixer.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/webaudio/AudioMixer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioMixer)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _WebAudioUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebAudioUtils */ "../../lib-jitsi-meet/dist/esm/modules/webaudio/WebAudioUtils.js");



const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class AudioMixer {
  constructor() {
    this._started = false;
    this._streamsToMix = [];
    this._streamMSSArray = [];
  }
  addMediaStream(stream) {
    if (!stream.getAudioTracks()) {
      logger.warn("Added MediaStream doesn't contain audio tracks.");
    }
    this._streamsToMix.push(stream);
  }
  start() {
    if (this._started) {
      return this._mixedMSD.stream;
    }
    this._audioContext = (0,_WebAudioUtils__WEBPACK_IMPORTED_MODULE_1__.createAudioContext)();
    if (!this._streamsToMix.length) {
      logger.warn("No MediaStream's added to AudioMixer, nothing will happen.");
      return null;
    }
    this._started = true;
    this._mixedMSD = this._audioContext.createMediaStreamDestination();
    for (const stream of this._streamsToMix) {
      const streamMSS = this._audioContext.createMediaStreamSource(stream);
      streamMSS.connect(this._mixedMSD);
      this._streamMSSArray.push(streamMSS);
    }
    return this._mixedMSD.stream;
  }
  reset() {
    this._started = false;
    this._streamsToMix = [];
    for (const streamMSS of this._streamMSSArray) {
      streamMSS.disconnect();
    }
    this._streamMSSArray = [];
    if (this._audioContext) {
      this._audioContext = void 0;
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/webaudio/WebAudioUtils.js":
/*!***********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/webaudio/WebAudioUtils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createAudioContext: () => (/* binding */ createAudioContext)
/* harmony export */ });

function createAudioContext(options) {
  const AudioContextImpl = window.AudioContext || window.webkitAudioContext;
  if (!AudioContextImpl) {
    return void 0;
  }
  return new AudioContextImpl(options);
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/AVModeration.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/AVModeration.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVModeration)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");





const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class AVModeration {
  constructor(room) {
    this._xmpp = room.xmpp;
    this._mainRoom = room;
    this._moderationEnabledByType = {
      [_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.AUDIO]: false,
      [_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO]: false
    };
    this._whitelistAudio = [];
    this._whitelistVideo = [];
    this._onMessage = this._onMessage.bind(this);
    this._xmpp.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.AV_MODERATION_RECEIVED, this._onMessage);
  }
  dispose() {
    this._xmpp.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.AV_MODERATION_RECEIVED, this._onMessage);
  }
  isSupported() {
    return Boolean(this._xmpp.avModerationComponentAddress);
  }
  enable(state, mediaType) {
    if (!this.isSupported() || !this._mainRoom.isModerator()) {
      logger.error(`Cannot enable:${state} AV moderation supported:${this.isSupported()},
                moderator:${this._mainRoom.isModerator()}`);
      return;
    }
    if (state === this._moderationEnabledByType[mediaType]) {
      logger.warn(`Moderation already in state:${state} for mediaType:${mediaType}`);
      return;
    }
    const msg = (0,strophe_js__WEBPACK_IMPORTED_MODULE_1__.$msg)({ to: this._xmpp.avModerationComponentAddress });
    msg.c("av_moderation", {
      enable: state,
      mediaType
    }).up();
    this._xmpp.connection.send(msg);
  }
  approve(mediaType, jid) {
    if (!this.isSupported() || !this._mainRoom.isModerator()) {
      logger.error(`Cannot approve in AV moderation supported:${this.isSupported()},
                moderator:${this._mainRoom.isModerator()}`);
      return;
    }
    const msg = (0,strophe_js__WEBPACK_IMPORTED_MODULE_1__.$msg)({ to: this._xmpp.avModerationComponentAddress });
    msg.c("av_moderation", {
      mediaType,
      jidToWhitelist: jid
    }).up();
    this._xmpp.connection.send(msg);
  }
  reject(mediaType, jid) {
    if (!this.isSupported() || !this._mainRoom.isModerator()) {
      logger.error(`Cannot reject in AV moderation supported:${this.isSupported()},
                moderator:${this._mainRoom.isModerator()}`);
      return;
    }
    const msg = (0,strophe_js__WEBPACK_IMPORTED_MODULE_1__.$msg)({ to: this._xmpp.avModerationComponentAddress });
    msg.c("av_moderation", {
      mediaType,
      jidToBlacklist: jid
    }).up();
    this._xmpp.connection.send(msg);
  }
  _onMessage(obj) {
    const { removed, mediaType: media, enabled, approved, actor, whitelists: newWhitelists } = obj;
    if (newWhitelists) {
      const oldList = media === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.AUDIO ? this._whitelistAudio : this._whitelistVideo;
      const newList = Array.isArray(newWhitelists[media]) ? newWhitelists[media] : [];
      if (removed) {
        oldList.filter((x) => !newList.includes(x)).forEach((jid) => this._xmpp.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.AV_MODERATION_PARTICIPANT_REJECTED, media, jid));
      } else {
        newList.filter((x) => !oldList.includes(x)).forEach((jid) => this._xmpp.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.AV_MODERATION_PARTICIPANT_APPROVED, media, jid));
      }
      if (media === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.AUDIO) {
        this._whitelistAudio = newList;
      } else {
        this._whitelistVideo = newList;
      }
    } else if (enabled !== void 0 && this._moderationEnabledByType[media] !== enabled) {
      this._moderationEnabledByType[media] = enabled;
      this._xmpp.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.AV_MODERATION_CHANGED, enabled, media, actor);
    } else if (removed) {
      this._xmpp.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.AV_MODERATION_REJECTED, media);
    } else if (approved) {
      this._xmpp.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.AV_MODERATION_APPROVED, media);
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/BreakoutRooms.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/BreakoutRooms.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BreakoutRooms)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");




const FEATURE_KEY = "features/breakout-rooms";
const BREAKOUT_ROOM_ACTIONS = {
  ADD: `${FEATURE_KEY}/add`,
  REMOVE: `${FEATURE_KEY}/remove`,
  MOVE_TO_ROOM: `${FEATURE_KEY}/move-to-room`
};
const BREAKOUT_ROOM_EVENTS = {
  MOVE_TO_ROOM: `${FEATURE_KEY}/move-to-room`,
  UPDATE: `${FEATURE_KEY}/update`
};
const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class BreakoutRooms {
  constructor(room) {
    this.room = room;
    this._handleMessages = this._handleMessages.bind(this);
    this.room.xmpp.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.BREAKOUT_ROOMS_EVENT, this._handleMessages);
    this._rooms = {};
  }
  dispose() {
    this.room.xmpp.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.BREAKOUT_ROOMS_EVENT, this._handleMessages);
  }
  createBreakoutRoom(subject) {
    if (!this.isSupported() || !this.room.isModerator()) {
      logger.error(`Cannot create breakout room - supported:${this.isSupported()},
                moderator:${this.room.isModerator()}`);
      return;
    }
    const message = {
      type: BREAKOUT_ROOM_ACTIONS.ADD,
      subject
    };
    this._sendMessage(message);
  }
  removeBreakoutRoom(breakoutRoomJid) {
    if (!this.isSupported() || !this.room.isModerator()) {
      logger.error(`Cannot remove breakout room - supported:${this.isSupported()},
                moderator:${this.room.isModerator()}`);
      return;
    }
    const message = {
      type: BREAKOUT_ROOM_ACTIONS.REMOVE,
      breakoutRoomJid
    };
    this._sendMessage(message);
  }
  sendParticipantToRoom(participantJid, roomJid) {
    if (!this.isSupported() || !this.room.isModerator()) {
      logger.error(`Cannot send participant to room - supported:${this.isSupported()},
                moderator:${this.room.isModerator()}`);
      return;
    }
    const message = {
      type: BREAKOUT_ROOM_ACTIONS.MOVE_TO_ROOM,
      participantJid,
      roomJid
    };
    this._sendMessage(message);
  }
  isSupported() {
    return Boolean(this.getComponentAddress());
  }
  getComponentAddress() {
    return this.room.xmpp.breakoutRoomsComponentAddress;
  }
  _setIsBreakoutRoom(isBreakoutRoom) {
    this._isBreakoutRoom = isBreakoutRoom;
  }
  isBreakoutRoom() {
    if (typeof this._isBreakoutRoom !== "undefined") {
      return this._isBreakoutRoom;
    }
    return strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getDomainFromJid(this.room.myroomjid) === this.getComponentAddress();
  }
  _setMainRoomJid(jid) {
    this._mainRoomJid = jid;
  }
  getMainRoomJid() {
    return this._mainRoomJid;
  }
  _handleMessages(payload) {
    switch (payload.event) {
      case BREAKOUT_ROOM_EVENTS.MOVE_TO_ROOM:
        this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.BREAKOUT_ROOMS_MOVE_TO_ROOM, payload.roomJid);
        break;
      case BREAKOUT_ROOM_EVENTS.UPDATE: {
        const filteredPayload = this._filterUpdatePayload(payload);
        this._rooms = filteredPayload.rooms;
        this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.BREAKOUT_ROOMS_UPDATED, filteredPayload);
        break;
      }
    }
  }
  _filterUpdatePayload(payload) {
    const hiddenDomain = this.room.options.hiddenDomain;
    const { rooms } = payload;
    const filteredRooms = {};
    Object.entries(rooms).forEach(([key, room]) => {
      const { participants = {} } = room;
      const filteredParticipants = {};
      Object.entries(participants).forEach(([k, participant]) => {
        if (strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getDomainFromJid(participant.jid) !== hiddenDomain) {
          filteredParticipants[k] = participant;
        }
      });
      filteredRooms[key] = Object.assign(Object.assign({}, room), { participants: filteredParticipants });
    });
    return Object.assign(Object.assign({}, payload), { rooms: filteredRooms });
  }
  _sendMessage(message) {
    const msg = (0,strophe_js__WEBPACK_IMPORTED_MODULE_1__.$msg)({ to: this.getComponentAddress() });
    msg.c("breakout_rooms", message).up();
    this.room.xmpp.connection.send(msg);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/Caps.js":
/*!**********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/Caps.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Caps),
/* harmony export */   parseDiscoInfo: () => (/* binding */ parseDiscoInfo)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");
/* harmony import */ var _sha1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sha1 */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/sha1.js");






const IDENTITY_PROPERTIES = ["category", "type", "lang", "name"];
const IDENTITY_PROPERTIES_FOR_COMPARE = ["category", "type", "lang"];
const HASH = "sha-1";
function compareIdentities(a, b) {
  let res = 0;
  IDENTITY_PROPERTIES_FOR_COMPARE.some((key) => (res = a[key] > b[key] && 1 || a[key] < b[key] && -1) !== 0);
  return res;
}
function generateSha(identities, features) {
  const sortedIdentities = identities.sort(compareIdentities).reduce((accumulatedValue, identity) => `${IDENTITY_PROPERTIES.reduce((tmp, key, idx) => tmp + (idx === 0 ? "" : "/") + (identity[key] ? identity[key] : ""), "")}<`, "");
  const sortedFeatures = features.sort().reduce((tmp, feature) => `${tmp + feature}<`, "");
  return _sha1__WEBPACK_IMPORTED_MODULE_4__["default"].b64_sha1(sortedIdentities + sortedFeatures);
}
function parseDiscoInfo(node) {
  const features = /* @__PURE__ */ new Set();
  const identities = /* @__PURE__ */ new Set();
  jquery__WEBPACK_IMPORTED_MODULE_0___default()(node).find(">query>feature").each((_, el) => features.add(el.getAttribute("var")));
  jquery__WEBPACK_IMPORTED_MODULE_0___default()(node).find(">query>identity").each((_, el) => identities.add({
    type: el.getAttribute("type"),
    name: el.getAttribute("name"),
    category: el.getAttribute("category")
  }));
  return {
    features,
    identities
  };
}
class Caps extends _util_Listenable__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor(connection = {}, node = "http://jitsi.org/jitsimeet") {
    super();
    this.node = node;
    this.disco = connection.disco;
    if (!this.disco) {
      throw new Error("Missing strophe-plugins (disco plugin is required)!");
    }
    this.version = "";
    this.rooms = /* @__PURE__ */ new Set();
    this.externalFeatures = /* @__PURE__ */ new Set();
    const emuc = connection.emuc;
    emuc.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.EMUC_ROOM_ADDED, (room) => this._addChatRoom(room));
    emuc.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.EMUC_ROOM_REMOVED, (room) => this._removeChatRoom(room));
    Object.keys(emuc.rooms).forEach((jid) => {
      this._addChatRoom(emuc.rooms[jid]);
    });
    strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.addNamespace("CAPS", "http://jabber.org/protocol/caps");
    this.disco.addFeature(strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.NS.CAPS);
  }
  addFeature(feature, submit = false, external = false) {
    this.disco.addFeature(feature);
    this._generateVersion();
    if (external && !this.externalFeatures.has(feature)) {
      this.externalFeatures.add(feature);
      this.rooms.forEach((room) => this._updateRoomWithExternalFeatures(room));
    }
    if (submit) {
      this.submit();
    }
  }
  removeFeature(feature, submit = false, external = false) {
    this.disco.removeFeature(feature);
    this._generateVersion();
    if (external && this.externalFeatures.has(feature)) {
      this.externalFeatures.delete(feature);
      this.rooms.forEach((room) => this._updateRoomWithExternalFeatures(room));
    }
    if (submit) {
      this.submit();
    }
  }
  submit() {
    this.rooms.forEach((room) => room.sendPresence());
  }
  _updateRoomWithExternalFeatures(room) {
    if (this.externalFeatures.size === 0) {
      room.removeFromPresence("features");
    } else {
      const children = [];
      this.externalFeatures.forEach((f) => {
        children.push({
          "tagName": "feature",
          attributes: { "var": f }
        });
      });
      room.addOrReplaceInPresence("features", { children });
    }
  }
  getFeaturesAndIdentities(jid, node, timeout = 5e3) {
    return this._getDiscoInfo(jid, node, timeout);
  }
  _getDiscoInfo(jid, node, timeout) {
    return new Promise((resolve, reject) => this.disco.info(jid, node, (response) => {
      resolve(parseDiscoInfo(response));
    }, reject, timeout));
  }
  _addChatRoom(room) {
    this.rooms.add(room);
    this._fixChatRoomPresenceMap(room);
    this._updateRoomWithExternalFeatures(room);
  }
  _removeChatRoom(room) {
    this.rooms.delete(room);
  }
  _fixChatRoomPresenceMap(room) {
    room.addOrReplaceInPresence("c", {
      attributes: {
        xmlns: strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.NS.CAPS,
        hash: HASH,
        node: this.node,
        ver: this.version
      }
    });
  }
  _notifyVersionChanged() {
    this.rooms.forEach((room) => this._fixChatRoomPresenceMap(room));
  }
  _generateVersion() {
    this.version = generateSha(this.disco._identities, this.disco._features);
    this._notifyVersionChanged();
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/ChatRoom.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/ChatRoom.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ChatRoom),
/* harmony export */   filterNodeFromPresenceJSON: () => (/* binding */ filterNodeFromPresenceJSON),
/* harmony export */   parser: () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash.isequal */ "../../lib-jitsi-meet/node_modules/lodash.isequal/index.js");
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _JitsiTranscriptionStatus__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../JitsiTranscriptionStatus */ "../../lib-jitsi-meet/dist/esm/JitsiTranscriptionStatus.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");
/* harmony import */ var _AVModeration__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./AVModeration */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/AVModeration.js");
/* harmony import */ var _BreakoutRooms__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./BreakoutRooms */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/BreakoutRooms.js");
/* harmony import */ var _Lobby__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Lobby */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/Lobby.js");
/* harmony import */ var _RoomMetadata__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./RoomMetadata */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/RoomMetadata.js");
/* harmony import */ var _XmppConnection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./XmppConnection */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/XmppConnection.js");
/* harmony import */ var _moderator__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./moderator */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/moderator.js");

















const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const parser = {
  packet2JSON(xmlElement, nodes) {
    for (const child of Array.from(xmlElement.children)) {
      const node = {
        attributes: {},
        children: [],
        tagName: child.tagName
      };
      for (const attr of Array.from(child.attributes)) {
        node.attributes[attr.name] = attr.value;
      }
      const text = strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.getText(child);
      if (text) {
        node.value = strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.xmlunescape(text);
      }
      nodes.push(node);
      this.packet2JSON(child, node.children);
    }
  },
  json2packet(nodes, packet) {
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node) {
        packet.c(node.tagName, node.attributes);
        if (node.value) {
          packet.t(node.value);
        }
        if (node.children) {
          this.json2packet(node.children, packet);
        }
        packet.up();
      }
    }
  }
};
function filterNodeFromPresenceJSON(pres, nodeName) {
  const res = [];
  for (let i = 0; i < pres.length; i++) {
    if (pres[i].tagName === nodeName) {
      res.push(pres[i]);
    }
  }
  return res;
}
const MEMBERS_AFFILIATIONS = ["owner", "admin", "member"];
function extractIdentityInformation(node, hiddenFromRecorderFeatureEnabled) {
  const identity = {};
  const userInfo = node.children.find((c) => c.tagName === "user");
  if (userInfo) {
    identity.user = {};
    const tags = ["id", "name", "avatar"];
    if (hiddenFromRecorderFeatureEnabled) {
      tags.push("hidden-from-recorder");
    }
    for (const tag of tags) {
      const child = userInfo.children.find((c) => c.tagName === tag);
      if (child) {
        identity.user[tag] = child.value;
      }
    }
  }
  const groupInfo = node.children.find((c) => c.tagName === "group");
  if (groupInfo) {
    identity.group = groupInfo.value;
  }
  return identity;
}
class ChatRoom extends _util_Listenable__WEBPACK_IMPORTED_MODULE_9__["default"] {
  constructor(connection, jid, password, xmpp, options) {
    super();
    this.xmpp = xmpp;
    this.connection = connection;
    this.roomjid = strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.getBareJidFromJid(jid);
    this.myroomjid = jid;
    this.password = password;
    this.replaceParticipant = false;
    logger.info(`Joining MUC as ${this.myroomjid}`);
    this.members = {};
    this.presMap = {};
    this.presHandlers = {};
    this._removeConnListeners = [];
    this.joined = false;
    this.inProgressEmitted = false;
    this.role = null;
    this.focusMucJid = null;
    this.noBridgeAvailable = false;
    this.options = options || {};
    this.moderator = new _moderator__WEBPACK_IMPORTED_MODULE_15__["default"](this.roomjid, this.xmpp, this.eventEmitter, xmpp.options);
    if (typeof this.options.enableLobby === "undefined" || this.options.enableLobby) {
      this.lobby = new _Lobby__WEBPACK_IMPORTED_MODULE_12__["default"](this);
    }
    this.avModeration = new _AVModeration__WEBPACK_IMPORTED_MODULE_10__["default"](this);
    this.breakoutRooms = new _BreakoutRooms__WEBPACK_IMPORTED_MODULE_11__["default"](this);
    this.roomMetadata = new _RoomMetadata__WEBPACK_IMPORTED_MODULE_13__["default"](this);
    this.initPresenceMap(options);
    this.lastPresences = {};
    this.phoneNumber = null;
    this.phonePin = null;
    this.connectionTimes = {};
    this.participantPropertyListener = null;
    this.locked = false;
    this.transcriptionStatus = _JitsiTranscriptionStatus__WEBPACK_IMPORTED_MODULE_4__.OFF;
  }
  initPresenceMap(options = {}) {
    this.presMap.to = this.myroomjid;
    this.presMap.xns = "http://jabber.org/protocol/muc";
    this.presMap.nodes = [];
    if (options.statsId) {
      this.presMap.nodes.push({
        "tagName": "stats-id",
        "value": options.statsId
      });
    }
    this.presenceUpdateTime = Date.now();
  }
  join(password, replaceParticipant) {
    this.password = password;
    this.replaceParticipant = replaceParticipant;
    return new Promise((resolve) => {
      this.options.disableFocus && logger.info(`Conference focus disabled for ${this.roomjid}`);
      const preJoin = this.options.disableFocus ? Promise.resolve() : this.moderator.sendConferenceRequest();
      preJoin.then(() => {
        this.sendPresence(true);
        this._removeConnListeners.push(this.connection.addEventListener(_XmppConnection__WEBPACK_IMPORTED_MODULE_14__["default"].Events.CONN_STATUS_CHANGED, this.onConnStatusChanged.bind(this)));
        resolve();
      });
    });
  }
  sendPresence(fromJoin) {
    const to = this.presMap.to;
    if (!this.connection || !this.connection.connected || !to || !this.joined && !fromJoin) {
      return;
    }
    const pres = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$pres)({ to });
    if (fromJoin) {
      if (this.replaceParticipant) {
        pres.c("flip_device").up();
      }
      pres.c("x", { xmlns: this.presMap.xns });
      if (this.password) {
        pres.c("password").t(this.password).up();
      }
      if (this.options.billingId) {
        pres.c("billingid").t(this.options.billingId).up();
      }
      pres.up();
    }
    parser.json2packet(this.presMap.nodes, pres);
    this.presenceSyncTime = Date.now();
    this.connection.send(pres);
    if (fromJoin) {
      this.connection.flush();
    }
  }
  doLeave(reason) {
    logger.log("do leave", this.myroomjid);
    const pres = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$pres)({
      to: this.myroomjid,
      type: "unavailable"
    });
    if (reason) {
      pres.c("status").t(reason).up();
    }
    this.presMap.length = 0;
    !this.connection.isUsingWebSocket && this.connection.flush();
    this.connection.send(pres);
    this.connection.flush();
  }
  discoRoomInfo() {
    const getInfo = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$iq)({
      type: "get",
      to: this.roomjid
    }).c("query", { xmlns: strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.NS.DISCO_INFO });
    this.connection.sendIQ(getInfo, (result) => {
      const locked = jquery__WEBPACK_IMPORTED_MODULE_1___default()(result).find('>query>feature[var="muc_passwordprotected"]').length === 1;
      if (locked !== this.locked) {
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_LOCK_CHANGED, locked);
        this.locked = locked;
      }
      const meetingIdValEl = jquery__WEBPACK_IMPORTED_MODULE_1___default()(result).find('>query>x[type="result"]>field[var="muc#roominfo_meetingId"]>value');
      if (meetingIdValEl.length) {
        this.setMeetingId(meetingIdValEl.text());
      } else {
        logger.warn("No meeting ID from backend");
      }
      const membersOnly = jquery__WEBPACK_IMPORTED_MODULE_1___default()(result).find('>query>feature[var="muc_membersonly"]').length === 1;
      const lobbyRoomField = jquery__WEBPACK_IMPORTED_MODULE_1___default()(result).find('>query>x[type="result"]>field[var="muc#roominfo_lobbyroom"]>value');
      if (this.lobby) {
        this.lobby.setLobbyRoomJid(lobbyRoomField && lobbyRoomField.length ? lobbyRoomField.text() : void 0);
      }
      const isBreakoutField = jquery__WEBPACK_IMPORTED_MODULE_1___default()(result).find('>query>x[type="result"]>field[var="muc#roominfo_isbreakout"]>value');
      const isBreakoutRoom = Boolean(isBreakoutField === null || isBreakoutField === void 0 ? void 0 : isBreakoutField.text());
      this.breakoutRooms._setIsBreakoutRoom(isBreakoutRoom);
      const breakoutMainRoomField = jquery__WEBPACK_IMPORTED_MODULE_1___default()(result).find('>query>x[type="result"]>field[var="muc#roominfo_breakout_main_room"]>value');
      if (breakoutMainRoomField === null || breakoutMainRoomField === void 0 ? void 0 : breakoutMainRoomField.length) {
        this.breakoutRooms._setMainRoomJid(breakoutMainRoomField.text());
      }
      if (membersOnly !== this.membersOnlyEnabled) {
        this.membersOnlyEnabled = membersOnly;
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, membersOnly);
      }
      const roomMetadataEl = jquery__WEBPACK_IMPORTED_MODULE_1___default()(result).find('>query>x[type="result"]>field[var="muc#roominfo_jitsimetadata"]>value');
      const roomMetadataText = roomMetadataEl === null || roomMetadataEl === void 0 ? void 0 : roomMetadataEl.text();
      if (roomMetadataText) {
        try {
          this.roomMetadata._handleMessages(JSON.parse(roomMetadataText));
        } catch (e) {
          logger.warn("Failed to set room metadata", e);
        }
      }
    }, (error) => {
      _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_8___default().callErrorHandler(error);
      logger.error("Error getting room info: ", error);
    });
  }
  setMeetingId(meetingId) {
    if (this.meetingId !== meetingId) {
      if (this.meetingId) {
        logger.warn(`Meeting Id changed from:${this.meetingId} to:${meetingId}`);
      }
      this.meetingId = meetingId;
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MEETING_ID_SET, meetingId);
    }
  }
  createNonAnonymousRoom() {
    if (this.options.disableDiscoInfo) {
      return;
    }
    const getForm = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$iq)({
      type: "get",
      to: this.roomjid
    }).c("query", { xmlns: "http://jabber.org/protocol/muc#owner" }).c("x", {
      xmlns: "jabber:x:data",
      type: "submit"
    });
    this.connection.sendIQ(getForm, (form) => {
      if (!jquery__WEBPACK_IMPORTED_MODULE_1___default()(form).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_whois"]').length) {
        const errmsg = "non-anonymous rooms not supported";
        _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_8___default().callErrorHandler(new Error(errmsg));
        logger.error(errmsg);
        return;
      }
      const formSubmit = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$iq)({
        to: this.roomjid,
        type: "set"
      }).c("query", { xmlns: "http://jabber.org/protocol/muc#owner" });
      formSubmit.c("x", {
        xmlns: "jabber:x:data",
        type: "submit"
      });
      formSubmit.c("field", { "var": "FORM_TYPE" }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up();
      formSubmit.c("field", { "var": "muc#roomconfig_whois" }).c("value").t("anyone").up().up();
      this.connection.sendIQ(formSubmit);
    }, (error) => {
      _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_8___default().callErrorHandler(error);
      logger.error("Error getting room configuration form: ", error);
    });
  }
  onConnStatusChanged(status) {
    if (status === _XmppConnection__WEBPACK_IMPORTED_MODULE_14__["default"].Status.CONNECTED && this.presenceUpdateTime > this.presenceSyncTime) {
      this.sendPresence();
    }
  }
  onPresence(pres) {
    const from = pres.getAttribute("from");
    const member = {};
    const statusEl = pres.getElementsByTagName("status")[0];
    if (statusEl) {
      member.status = statusEl.textContent || "";
    }
    let hasStatusUpdate = false;
    let hasVersionUpdate = false;
    const xElement = pres.getElementsByTagNameNS("http://jabber.org/protocol/muc#user", "x")[0];
    const mucUserItem = xElement && xElement.getElementsByTagName("item")[0];
    member.isReplaceParticipant = pres.getElementsByTagName("flip_device").length;
    member.affiliation = mucUserItem && mucUserItem.getAttribute("affiliation");
    member.role = mucUserItem && mucUserItem.getAttribute("role");
    const jid = mucUserItem && mucUserItem.getAttribute("jid");
    member.jid = jid;
    member.isFocus = this.moderator.isFocusJid(jid);
    member.isHiddenDomain = jid && jid.indexOf("@") > 0 && this.options.hiddenDomain === jid.substring(jid.indexOf("@") + 1, jid.indexOf("/"));
    this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.PRESENCE_RECEIVED, {
      fromHiddenDomain: member.isHiddenDomain,
      presence: pres
    });
    const xEl = pres.querySelector("x");
    if (xEl) {
      xEl.remove();
    }
    const nodes = [];
    parser.packet2JSON(pres, nodes);
    this.lastPresences[from] = nodes;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      switch (node.tagName) {
        case "bot": {
          const { attributes } = node;
          if (!attributes) {
            break;
          }
          const { type } = attributes;
          member.botType = type;
          break;
        }
        case "nick":
          member.nick = node.value;
          break;
        case "userId":
          member.id = node.value;
          break;
        case "stats-id":
          member.statsID = node.value;
          break;
        case "identity":
          member.identity = extractIdentityInformation(node, this.options.hiddenFromRecorderFeatureEnabled);
          break;
        case "features": {
          member.features = this._extractFeatures(node);
          break;
        }
        case "stat": {
          const { attributes } = node;
          if (!attributes) {
            break;
          }
          const { name } = attributes;
          if (name === "version") {
            member.version = attributes.value;
          }
          break;
        }
      }
    }
    if (!this.joined && !this.inProgressEmitted) {
      const now = this.connectionTimes["muc.join.started"] = window.performance.now();
      logger.log("(TIME) MUC join started:	", now);
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_JOIN_IN_PROGRESS);
      this.inProgressEmitted = true;
    }
    if (from === this.myroomjid) {
      const newRole = member.affiliation === "owner" ? member.role : "none";
      if (this.role !== newRole) {
        this.role = newRole;
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.LOCAL_ROLE_CHANGED, this.role);
      }
      if (!this.joined) {
        this.joined = true;
        const now = this.connectionTimes["muc.joined"] = window.performance.now();
        logger.log("(TIME) MUC joined:	", now);
        if (this.password) {
          this.locked = true;
        }
        if (this.presenceUpdateTime >= this.presenceSyncTime) {
          this.sendPresence();
        }
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_JOINED);
        !this.options.disableDiscoInfo && this.discoRoomInfo();
      }
    } else if (jid === void 0) {
      logger.info("Ignoring member with undefined JID");
    } else if (this.members[from] === void 0) {
      this.members[from] = member;
      logger.log("entered", from, member);
      hasStatusUpdate = member.status !== void 0;
      hasVersionUpdate = member.version !== void 0;
      if (member.isFocus) {
        this._initFocus(from, member.features);
      } else {
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_MEMBER_JOINED, from, member.nick, member.role, member.isHiddenDomain, member.statsID, member.status, member.identity, member.botType, member.jid, member.features, member.isReplaceParticipant);
        hasStatusUpdate = false;
      }
    } else {
      const memberOfThis = this.members[from];
      if (memberOfThis.role !== member.role) {
        memberOfThis.role = member.role;
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_ROLE_CHANGED, from, member.role);
      }
      if (memberOfThis.affiliation !== member.affiliation) {
        memberOfThis.affiliation = member.affiliation;
      }
      if (memberOfThis.botType !== member.botType) {
        memberOfThis.botType = member.botType;
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_MEMBER_BOT_TYPE_CHANGED, from, member.botType);
      }
      if (member.isFocus) {
        memberOfThis.isFocus = true;
        this._initFocus(from, member.features);
      }
      if (member.displayName) {
        memberOfThis.displayName = member.displayName;
      }
      if (memberOfThis.status !== member.status) {
        hasStatusUpdate = true;
        memberOfThis.status = member.status;
      }
      if (memberOfThis.version !== member.version) {
        hasVersionUpdate = true;
        memberOfThis.version = member.version;
      }
      if (!lodash_isequal__WEBPACK_IMPORTED_MODULE_2___default()(memberOfThis.features, member.features)) {
        memberOfThis.features = member.features;
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.PARTICIPANT_FEATURES_CHANGED, from, member.features);
      }
    }
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      switch (node.tagName) {
        case "nick":
          if (!member.isFocus) {
            const displayName = this.xmpp.options.displayJids ? strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.getResourceFromJid(from) : member.nick;
            this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.DISPLAY_NAME_CHANGED, from, displayName);
          }
          break;
        case "bridgeNotAvailable":
          if (member.isFocus && !this.noBridgeAvailable) {
            this.noBridgeAvailable = true;
            this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.BRIDGE_DOWN);
          }
          break;
        case "conference-properties":
          if (member.isFocus) {
            const properties = {};
            for (let j = 0; j < node.children.length; j++) {
              const { attributes } = node.children[j];
              if (attributes && attributes.key) {
                properties[attributes.key] = attributes.value;
              }
            }
            this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, properties);
            if (typeof this.restartByTerminateSupported === "undefined") {
              this.restartByTerminateSupported = properties["support-terminate-restart"] === "true";
              logger.info(`Jicofo supports restart by terminate: ${this.supportsRestartByTerminate()}`);
            }
          }
          break;
        case "transcription-status": {
          const { attributes } = node;
          if (!attributes) {
            break;
          }
          const { status } = attributes;
          if (status && status !== this.transcriptionStatus) {
            this.transcriptionStatus = status;
            this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.TRANSCRIPTION_STATUS_CHANGED, status);
          }
          break;
        }
        case "call-control": {
          const att = node.attributes;
          if (!att) {
            break;
          }
          this.phoneNumber = att.phone || null;
          this.phonePin = att.pin || null;
          this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.PHONE_NUMBER_CHANGED);
          break;
        }
        default:
          this.processNode(node, from);
      }
    }
    if (hasStatusUpdate) {
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.PRESENCE_STATUS, from, member.status);
    }
    if (hasVersionUpdate) {
      logger.info(`Received version for ${jid}: ${member.version}`);
    }
  }
  _extractFeatures(node) {
    const features = /* @__PURE__ */ new Set();
    for (let j = 0; j < node.children.length; j++) {
      const { attributes } = node.children[j];
      if (attributes && attributes.var) {
        features.add(attributes.var);
      }
    }
    return features;
  }
  _initFocus(from, features) {
    this.focusMucJid = from;
    this.focusFeatures = features;
  }
  setParticipantPropertyListener(listener) {
    this.participantPropertyListener = listener;
  }
  supportsRestartByTerminate() {
    return this.restartByTerminateSupported;
  }
  processNode(node, from) {
    try {
      let tagHandlers = this.presHandlers[node.tagName];
      if (node.tagName.startsWith("jitsi_participant_")) {
        tagHandlers = [this.participantPropertyListener];
      }
      if (tagHandlers) {
        tagHandlers.forEach((handler) => {
          handler(node, strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.getResourceFromJid(from), from);
        });
      }
    } catch (e) {
      _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_8___default().callErrorHandler(e);
      logger.error(`Error processing:${node.tagName} node.`, e);
    }
  }
  sendMessage(message, elementName) {
    const msg = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$msg)({
      to: this.roomjid,
      type: "groupchat"
    });
    if (elementName === "body") {
      msg.c(elementName, {}, message);
    } else {
      msg.c(elementName, { xmlns: "http://jitsi.org/jitmeet" }, message);
    }
    this.connection.send(msg);
    this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.SENDING_CHAT_MESSAGE, message);
  }
  sendPrivateMessage(id, message, elementName) {
    const msg = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$msg)({
      to: `${this.roomjid}/${id}`,
      type: "chat"
    });
    if (elementName === "body") {
      msg.c(elementName, message).up();
    } else {
      msg.c(elementName, { xmlns: "http://jitsi.org/jitmeet" }, message).up();
    }
    this.connection.send(msg);
    this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.SENDING_PRIVATE_CHAT_MESSAGE, message);
  }
  setSubject(subject) {
    const msg = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$msg)({
      to: this.roomjid,
      type: "groupchat"
    });
    msg.c("subject", subject);
    this.connection.send(msg);
  }
  onPresenceUnavailable(pres, from) {
    if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>ignore[xmlns="http://jitsi.org/jitmeet/"]').length) {
      return true;
    }
    const destroySelect = jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy');
    if (destroySelect.length) {
      let reason;
      const reasonSelect = jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy>reason');
      if (reasonSelect.length) {
        reason = reasonSelect.text();
      }
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_DESTROYED, reason, destroySelect.attr("jid"));
      this.connection.emuc.doLeave(this.roomjid);
      return true;
    }
    const isSelfPresence = jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="110"]').length;
    const isKick = jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="307"]').length;
    const membersKeys = Object.keys(this.members);
    const isReplaceParticipant = jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find("flip_device").length;
    if (isKick) {
      const actorSelect = jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>actor');
      let actorNick;
      if (actorSelect.length) {
        actorNick = actorSelect.attr("nick");
      }
      let reason;
      const reasonSelect = jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>reason');
      if (reasonSelect.length) {
        reason = reasonSelect.text();
      }
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.KICKED, isSelfPresence, actorNick, strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.getResourceFromJid(from), reason, isReplaceParticipant);
    }
    if (isSelfPresence) {
      membersKeys.forEach((jid) => {
        const member = this.members[jid];
        delete this.members[jid];
        delete this.lastPresences[jid];
        if (!member.isFocus) {
          this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_MEMBER_LEFT, jid);
        }
      });
      this.connection.emuc.doLeave(this.roomjid);
      if (!isKick) {
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_LEFT);
      }
    } else {
      const reasonSelect = jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find(">status");
      const member = this.members[from];
      let reason;
      if (reasonSelect.length) {
        reason = reasonSelect.text();
      }
      delete this.members[from];
      delete this.lastPresences[from];
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_MEMBER_LEFT, from, reason);
      if (member === null || member === void 0 ? void 0 : member.isFocus) {
        logger.info("Focus has left the room - leaving conference");
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.FOCUS_LEFT);
      }
    }
  }
  onMessage(msg, from) {
    const type = msg.getAttribute("type");
    if (type === "error") {
      const settingsErrorMsg = jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find(">settings-error>text").text();
      if (settingsErrorMsg.length) {
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.SETTINGS_ERROR_RECEIVED, settingsErrorMsg);
        return true;
      }
      const errorMsg = jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find(">error>text").text();
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.CHAT_ERROR_RECEIVED, errorMsg);
      return true;
    }
    const txt = jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find(">body").text();
    const subject = jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find(">subject");
    if (subject.length) {
      const subjectText = subject.text();
      if (subjectText || subjectText === "") {
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.SUBJECT_CHANGED, subjectText);
        logger.log(`Subject is changed to ${subjectText}`);
      }
    }
    let stamp = jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find(">delay").attr("stamp");
    if (!stamp) {
      stamp = jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find('>[xmlns="jabber:x:delay"]').attr("stamp");
      if (stamp) {
        const dateParts = stamp.match(/(\d{4})(\d{2})(\d{2}T\d{2}:\d{2}:\d{2})/);
        stamp = `${dateParts[1]}-${dateParts[2]}-${dateParts[3]}Z`;
      }
    }
    if (from === this.roomjid) {
      let invite;
      if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="104"]').length) {
        this.discoRoomInfo();
      } else if ((invite = jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>invite')) && invite.length) {
        const passwordSelect = jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>password');
        let password;
        if (passwordSelect && passwordSelect.length) {
          password = passwordSelect.text();
        }
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.INVITE_MESSAGE_RECEIVED, from, invite.attr("from"), txt, password);
      }
    }
    const jsonMessage = jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find(">json-message").text();
    if (jsonMessage) {
      const parsedJson = this.xmpp.tryParseJSONAndVerify(jsonMessage);
      if (parsedJson && stamp === void 0) {
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.JSON_MESSAGE_RECEIVED, from, parsedJson);
        return;
      }
    }
    if (txt) {
      if (type === "chat") {
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.PRIVATE_MESSAGE_RECEIVED, from, txt, this.myroomjid, stamp);
      } else if (type === "groupchat") {
        const nickEl = jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find(">nick");
        let nick;
        if (nickEl.length > 0) {
          nick = nickEl.text();
        }
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MESSAGE_RECEIVED, from, txt, this.myroomjid, stamp, nick, Boolean(nick));
      }
    }
  }
  onPresenceError(pres, from) {
    var _a;
    let errorDescriptionNode;
    if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>error[type="auth"]>not-authorized[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
      logger.log("on password required", from);
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.PASSWORD_REQUIRED);
    } else if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>error[type="cancel"]>not-allowed[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
      const toDomain = strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.getDomainFromJid(pres.getAttribute("to"));
      if (toDomain === this.xmpp.options.hosts.anonymousdomain) {
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.ROOM_JOIN_ERROR);
      } else {
        logger.warn("onPresError ", pres);
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR);
      }
    } else if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find(">error>service-unavailable").length) {
      logger.warn("Maximum users limit for the room has been reached", pres);
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.ROOM_MAX_USERS_ERROR);
    } else if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>error[type="auth"]>registration-required[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
      const lobbyRoomNode = jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>error[type="auth"]>lobbyroom');
      let lobbyRoomJid;
      if (lobbyRoomNode.length) {
        lobbyRoomJid = lobbyRoomNode.text();
      }
      const waitingForHost = jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>error[type="auth"]>waiting-for-host').length > 0;
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, lobbyRoomJid, waitingForHost);
    } else if ((errorDescriptionNode = jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>error[type="modify"]>displayname-required[xmlns="http://jitsi.org/jitmeet"]')).length) {
      logger.warn("display name required ", pres);
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.DISPLAY_NAME_REQUIRED, (_a = errorDescriptionNode[0].attributes.lobby) === null || _a === void 0 ? void 0 : _a.value);
    } else {
      logger.warn("onPresError ", pres);
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.ROOM_CONNECT_ERROR);
    }
  }
  setAffiliation(jid, affiliation) {
    const grantIQ = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$iq)({
      to: this.roomjid,
      type: "set"
    }).c("query", { xmlns: "http://jabber.org/protocol/muc#admin" }).c("item", {
      affiliation,
      jid: strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.getBareJidFromJid(jid)
    }).c("reason").t(`Your affiliation has been changed to '${affiliation}'.`).up().up().up();
    this.connection.sendIQ(grantIQ, (result) => logger.log("Set affiliation of participant with jid: ", jid, "to", affiliation, result), (error) => logger.log("Set affiliation of participant error: ", error));
  }
  kick(jid, reason = "You have been kicked.") {
    const kickIQ = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$iq)({
      to: this.roomjid,
      type: "set"
    }).c("query", { xmlns: "http://jabber.org/protocol/muc#admin" }).c("item", {
      nick: strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.getResourceFromJid(jid),
      role: "none"
    }).c("reason").t(reason).up().up().up();
    this.connection.sendIQ(kickIQ, (result) => logger.log("Kick participant with jid: ", jid, result), (error) => logger.log("Kick participant error: ", error));
  }
  lockRoom(key, onSuccess, onError, onNotSupported) {
    this.connection.sendIQ((0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$iq)({
      to: this.roomjid,
      type: "get"
    }).c("query", { xmlns: "http://jabber.org/protocol/muc#owner" }), (res) => {
      if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(res).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_roomsecret"]').length) {
        const formsubmit = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$iq)({
          to: this.roomjid,
          type: "set"
        }).c("query", {
          xmlns: "http://jabber.org/protocol/muc#owner"
        });
        formsubmit.c("x", {
          xmlns: "jabber:x:data",
          type: "submit"
        });
        formsubmit.c("field", { "var": "FORM_TYPE" }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up();
        formsubmit.c("field", { "var": "muc#roomconfig_roomsecret" }).c("value").t(key).up().up();
        formsubmit.c("field", { "var": "muc#roomconfig_passwordprotectedroom" }).c("value").t(key === null || key.length === 0 ? "0" : "1").up().up();
        if (this.membersOnlyEnabled) {
          formsubmit.c("field", { "var": "muc#roomconfig_membersonly" }).c("value").t("true").up().up();
        }
        formsubmit.c("field", { "var": "muc#roomconfig_whois" }).c("value").t("anyone").up().up();
        this.connection.sendIQ(formsubmit, () => {
          this.password = key;
          onSuccess();
        }, onError);
      } else {
        onNotSupported();
      }
    }, onError);
  }
  setMembersOnly(enabled, onSuccess, onError) {
    if (enabled && Object.values(this.members).filter((m) => !m.isFocus).length) {
      Object.values(this.members).forEach((m) => {
        if (m.jid && !MEMBERS_AFFILIATIONS.includes(m.affiliation)) {
          this.xmpp.connection.sendIQ((0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$iq)({
            to: this.roomjid,
            type: "set"
          }).c("query", {
            xmlns: "http://jabber.org/protocol/muc#admin"
          }).c("item", {
            "affiliation": "member",
            "jid": strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.getBareJidFromJid(m.jid)
          }).up().up());
        }
      });
    }
    const errorCallback = onError ? onError : () => {
    };
    this.xmpp.connection.sendIQ((0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$iq)({
      to: this.roomjid,
      type: "get"
    }).c("query", { xmlns: "http://jabber.org/protocol/muc#owner" }), (res) => {
      if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(res).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_membersonly"]').length) {
        const formToSubmit = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$iq)({
          to: this.roomjid,
          type: "set"
        }).c("query", { xmlns: "http://jabber.org/protocol/muc#owner" });
        formToSubmit.c("x", {
          xmlns: "jabber:x:data",
          type: "submit"
        });
        formToSubmit.c("field", { "var": "FORM_TYPE" }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up();
        formToSubmit.c("field", { "var": "muc#roomconfig_membersonly" }).c("value").t(enabled ? "true" : "false").up().up();
        if (this.locked) {
          formToSubmit.c("field", { "var": "muc#roomconfig_passwordprotectedroom" }).c("value").t("1").up().up();
        }
        this.xmpp.connection.sendIQ(formToSubmit, onSuccess, errorCallback);
      } else {
        errorCallback(new Error("Setting members only room not supported!"));
      }
    }, errorCallback);
  }
  addToPresence(key, values) {
    return this.addOrReplaceInPresence(key, values);
  }
  addOrReplaceInPresence(key, values) {
    values.tagName = key;
    const matchingNodes = this.presMap.nodes.filter((node) => key === node.tagName);
    if (matchingNodes.length === 1 && lodash_isequal__WEBPACK_IMPORTED_MODULE_2___default()(matchingNodes[0], values)) {
      return false;
    }
    this.removeFromPresence(key);
    this.presMap.nodes.push(values);
    this.presenceUpdateTime = Date.now();
    return true;
  }
  getFromPresence(key) {
    return this.presMap.nodes.find((node) => key === node.tagName);
  }
  removeFromPresence(key) {
    const nodes = this.presMap.nodes.filter((node) => key !== node.tagName);
    this.presMap.nodes = nodes;
    this.presenceUpdateTime = Date.now();
  }
  addPresenceListener(name, handler) {
    if (typeof handler !== "function") {
      throw new Error('"handler" is not a function');
    }
    let tagHandlers = this.presHandlers[name];
    if (!tagHandlers) {
      this.presHandlers[name] = tagHandlers = [];
    }
    if (tagHandlers.indexOf(handler) === -1) {
      tagHandlers.push(handler);
    } else {
      logger.warn(`Trying to add the same handler more than once for: ${name}`);
    }
  }
  removePresenceListener(name, handler) {
    const tagHandlers = this.presHandlers[name];
    const handlerIdx = tagHandlers ? tagHandlers.indexOf(handler) : -1;
    if (handlerIdx !== -1) {
      tagHandlers.splice(handlerIdx, 1);
    } else {
      logger.warn(`Handler for: ${name} was not registered`);
    }
  }
  isFocus(mucJid) {
    const member = this.members[mucJid];
    if (member) {
      return member.isFocus;
    }
    return null;
  }
  isModerator() {
    return this.role === "moderator";
  }
  onVisitorIQ(iq) {
    const visitors = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find('>visitors[xmlns="jitsi:visitors"]');
    const response = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("promotion-response");
    if (visitors.length && response.length && String(response.attr("allow")).toLowerCase() === "true") {
      logger.warn("Redirected back to main room.");
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.REDIRECTED, void 0, visitors.attr("focusjid"), response.attr("username"));
    }
  }
  getMediaPresenceInfo(endpointId, mediaType) {
    const pres = this.lastPresences[`${this.roomjid}/${endpointId}`];
    if (!pres) {
      return null;
    }
    const data = {
      muted: true,
      videoType: mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO ? _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_6__.VideoType.CAMERA : void 0
    };
    let mutedNode = null;
    if (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.AUDIO) {
      mutedNode = filterNodeFromPresenceJSON(pres, "audiomuted");
    } else if (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_5__.MediaType.VIDEO) {
      mutedNode = filterNodeFromPresenceJSON(pres, "videomuted");
      const codecTypeNode = filterNodeFromPresenceJSON(pres, "jitsi_participant_codecType");
      const videoTypeNode = filterNodeFromPresenceJSON(pres, "videoType");
      if (videoTypeNode.length > 0) {
        data.videoType = videoTypeNode[0].value;
      }
      if (codecTypeNode.length > 0) {
        data.codecType = codecTypeNode[0].value;
      }
    } else {
      logger.error(`Unsupported media type: ${mediaType}`);
      return null;
    }
    if (mutedNode.length > 0) {
      data.muted = mutedNode[0].value === "true";
    }
    return data;
  }
  getMemberRole(peerJid) {
    if (this.members[peerJid]) {
      return this.members[peerJid].role;
    }
    return null;
  }
  getLastPresence(mucNick) {
    return this.lastPresences[`${this.roomjid}/${mucNick}`];
  }
  dial(number) {
    return this.connection.rayo.dial(number, "fromnumber", strophe_js__WEBPACK_IMPORTED_MODULE_3__.Strophe.getBareJidFromJid(this.myroomjid), this.password, this.focusMucJid);
  }
  hangup() {
    return this.connection.rayo.hangup();
  }
  getLobby() {
    return this.lobby;
  }
  getAVModeration() {
    return this.avModeration;
  }
  getBreakoutRooms() {
    return this.breakoutRooms;
  }
  getMetadataHandler() {
    return this.roomMetadata;
  }
  getPhoneNumber() {
    return this.phoneNumber;
  }
  getPhonePin() {
    return this.phonePin;
  }
  getMeetingId() {
    return this.meetingId;
  }
  muteParticipant(jid, mute, mediaType) {
    logger.info("set mute", mute, jid);
    const iqToFocus = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$iq)({
      to: this.focusMucJid,
      type: "set"
    }).c("mute", {
      xmlns: `http://jitsi.org/jitmeet/${mediaType}`,
      jid
    }).t(mute.toString()).up();
    this.connection.sendIQ(iqToFocus, (result) => logger.log("set mute", result), (error) => logger.log("set mute error", error));
  }
  onMute(iq) {
    const from = iq.getAttribute("from");
    if (from !== this.focusMucJid) {
      logger.warn("Ignored mute from non focus peer");
      return;
    }
    const mute = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("mute");
    if (mute.length && mute.text() === "true") {
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.AUDIO_MUTED_BY_FOCUS, mute.attr("actor"));
    } else {
      logger.warn("Ignoring a mute request which does not explicitly specify a positive mute command.");
    }
  }
  onMuteVideo(iq) {
    const from = iq.getAttribute("from");
    if (from !== this.focusMucJid) {
      logger.warn("Ignored mute from non focus peer");
      return;
    }
    const mute = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("mute");
    if (mute.length && mute.text() === "true") {
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.VIDEO_MUTED_BY_FOCUS, mute.attr("actor"));
    } else {
      logger.warn("Ignoring a mute request which does not explicitly specify a positive mute command.");
    }
  }
  clean() {
    this._removeConnListeners.forEach((remove) => remove());
    this._removeConnListeners = [];
    this.joined = false;
    this.inProgressEmitted = false;
  }
  leave(reason) {
    var _a;
    this.avModeration.dispose();
    this.breakoutRooms.dispose();
    this.roomMetadata.dispose();
    const promises = [];
    ((_a = this.lobby) === null || _a === void 0 ? void 0 : _a.lobbyRoom) && promises.push(this.lobby.leave());
    promises.push(new Promise((resolve, reject) => {
      let timeout = -1;
      const onMucLeft = (doReject = false) => {
        this.eventEmitter.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_LEFT, onMucLeft);
        clearTimeout(timeout);
        if (doReject) {
          this.connection.emuc.doLeave(this.roomjid);
          reject(new Error("The timeout for the confirmation about leaving the room expired."));
        } else {
          resolve();
        }
      };
      if (this.joined) {
        timeout = setTimeout(() => onMucLeft(true), 5e3);
        this.clean();
        this.eventEmitter.on(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_7__.XMPPEvents.MUC_LEFT, onMucLeft);
        this.doLeave(reason);
      } else {
        this.connection.emuc.doLeave(this.roomjid);
        this.clean();
      }
    }));
    return Promise.allSettled(promises);
  }
  end() {
    if (this.breakoutRooms.isBreakoutRoom()) {
      logger.warn("Cannot end conference: this is a breakout room.");
      return;
    }
    const msg = (0,strophe_js__WEBPACK_IMPORTED_MODULE_3__.$msg)({ to: this.xmpp.endConferenceComponentAddress });
    msg.c("end_conference").up();
    this.xmpp.connection.send(msg);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/ConnectionPlugin.js":
/*!**********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/ConnectionPlugin.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConnectionPluginListenable: () => (/* binding */ ConnectionPluginListenable),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");


function getConnectionPluginDefinition(base = class {
}) {
  return class extends base {
    constructor(...args) {
      super(...args);
      this.connection = null;
    }
    init(connection) {
      this.connection = connection;
    }
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getConnectionPluginDefinition());
const ConnectionPluginListenable = getConnectionPluginDefinition(_util_Listenable__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleHelperFunctions.js":
/*!***************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleHelperFunctions.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   expandSourcesFromJson: () => (/* binding */ expandSourcesFromJson)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");





const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
function _createSourceExtension(owner, sourceCompactJson) {
  const node = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$build)("source", {
    xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
    ssrc: sourceCompactJson.s,
    name: sourceCompactJson.n
  });
  if (sourceCompactJson.m) {
    node.c("parameter", {
      name: "msid",
      value: sourceCompactJson.m
    }).up();
  }
  node.c("ssrc-info", {
    xmlns: "http://jitsi.org/jitmeet",
    owner
  }).up();
  return node.node;
}
function _createSsrcGroupExtension(ssrcGroupCompactJson) {
  const node = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$build)("ssrc-group", {
    xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
    semantics: _getSemantics(ssrcGroupCompactJson[0])
  });
  for (let i = 1; i < ssrcGroupCompactJson.length; i++) {
    node.c("source", {
      xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
      ssrc: ssrcGroupCompactJson[i]
    }).up();
  }
  return node.node;
}
function _getOrCreateRtpDescription(iq, mediaType) {
  const jingle = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("jingle")[0];
  let content = jquery__WEBPACK_IMPORTED_MODULE_1___default()(jingle).find(`content[name="${mediaType}"]`);
  let description;
  if (content.length) {
    content = content[0];
  } else {
    content = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$build)("content", {
      name: mediaType
    }).node;
    jingle.appendChild(content);
  }
  description = jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).find("description");
  if (description.length) {
    description = description[0];
  } else {
    description = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$build)("description", {
      xmlns: "urn:xmpp:jingle:apps:rtp:1",
      media: mediaType
    }).node;
    content.appendChild(description);
  }
  return description;
}
function _getSemantics(str) {
  if (str === "f") {
    return "FID";
  } else if (str === "s") {
    return "SIM";
  }
  return null;
}
function expandSourcesFromJson(iq, jsonMessageXml) {
  var _a, _b;
  let json;
  try {
    json = JSON.parse(jsonMessageXml.textContent);
  } catch (error) {
    logger.error(`json-message XML contained invalid JSON, ignoring: ${jsonMessageXml.textContent}`);
    return null;
  }
  if (!(json === null || json === void 0 ? void 0 : json.sources)) {
    return null;
  }
  const audioRtpDescription = _getOrCreateRtpDescription(iq, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.AUDIO);
  const videoRtpDescription = _getOrCreateRtpDescription(iq, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO);
  const ssrcMap = /* @__PURE__ */ new Map();
  for (const owner in json.sources) {
    if (json.sources.hasOwnProperty(owner)) {
      const ssrcs = [];
      const ownerSources = json.sources[owner];
      const videoSources = (ownerSources === null || ownerSources === void 0 ? void 0 : ownerSources.length) && ownerSources[0];
      const videoSsrcGroups = (ownerSources === null || ownerSources === void 0 ? void 0 : ownerSources.length) > 1 && ownerSources[1];
      const audioSources = (ownerSources === null || ownerSources === void 0 ? void 0 : ownerSources.length) > 2 && ownerSources[2];
      const audioSsrcGroups = (ownerSources === null || ownerSources === void 0 ? void 0 : ownerSources.length) > 3 && ownerSources[3];
      if (videoSources === null || videoSources === void 0 ? void 0 : videoSources.length) {
        for (let i = 0; i < videoSources.length; i++) {
          videoRtpDescription.appendChild(_createSourceExtension(owner, videoSources[i]));
          ssrcs.push((_a = videoSources[i]) === null || _a === void 0 ? void 0 : _a.s);
        }
      }
      if (videoSsrcGroups === null || videoSsrcGroups === void 0 ? void 0 : videoSsrcGroups.length) {
        for (let i = 0; i < videoSsrcGroups.length; i++) {
          videoRtpDescription.appendChild(_createSsrcGroupExtension(videoSsrcGroups[i]));
        }
      }
      if (audioSources === null || audioSources === void 0 ? void 0 : audioSources.length) {
        for (let i = 0; i < audioSources.length; i++) {
          audioRtpDescription.appendChild(_createSourceExtension(owner, audioSources[i]));
          ssrcs.push((_b = audioSources[i]) === null || _b === void 0 ? void 0 : _b.s);
        }
      }
      if (audioSsrcGroups === null || audioSsrcGroups === void 0 ? void 0 : audioSsrcGroups.length) {
        for (let i = 0; i < audioSsrcGroups.length; i++) {
          audioRtpDescription.appendChild(_createSsrcGroupExtension(audioSsrcGroups[i]));
        }
      }
      ssrcMap.set(owner, ssrcs);
    }
  }
  return ssrcMap;
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleSession.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleSession.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JingleSession)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");
/* harmony import */ var _JingleSessionState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JingleSessionState */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleSessionState.js");




const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class JingleSession extends _util_Listenable__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(sid, localJid, remoteJid, connection, mediaConstraints, pcConfig, isInitiator) {
    super();
    this.sid = sid;
    this.localJid = localJid;
    this.remoteJid = remoteJid;
    this.connection = connection;
    this.mediaConstraints = mediaConstraints;
    this.pcConfig = pcConfig;
    this.isInitiator = isInitiator;
    this.usedrip = true;
    this.dripContainer = [];
    this.room = null;
    this._signalingLayer = null;
    this.state = null;
    this.rtc = null;
  }
  get initiatorJid() {
    return this.isInitiator ? this.localJid : this.remoteJid;
  }
  get responderJid() {
    return this.isInitiator ? this.remoteJid : this.localJid;
  }
  initialize(room, rtc, signalingLayer, options) {
    if (this.state !== null) {
      const errmsg = `attempt to initiate on session ${this.sid}
                   in state ${this.state}`;
      logger.error(errmsg);
      throw new Error(errmsg);
    }
    this.room = room;
    this.rtc = rtc;
    this._signalingLayer = signalingLayer;
    this.state = _JingleSessionState__WEBPACK_IMPORTED_MODULE_2__.PENDING;
    this.doInitialize(options);
  }
  doInitialize(options) {
  }
  addIceCandidates(contents) {
  }
  getState() {
    return this.state;
  }
  addSources(contents) {
  }
  removeSources(contents) {
  }
  terminate(success, failure, options) {
  }
  acceptOffer(jingle, success, failure) {
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleSessionPC.js":
/*!*********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleSessionPC.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JingleSessionPC)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../JitsiTrackEvents */ "../../lib-jitsi-meet/dist/esm/JitsiTrackEvents.js");
/* harmony import */ var _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/RTC/CodecMimeType */ "../../lib-jitsi-meet/dist/esm/service/RTC/CodecMimeType.js");
/* harmony import */ var _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../service/RTC/MediaDirection */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaDirection.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _RTC_ScreenObtainer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../RTC/ScreenObtainer */ "../../lib-jitsi-meet/dist/esm/modules/RTC/ScreenObtainer.js");
/* harmony import */ var _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");
/* harmony import */ var _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../sdp/SDP */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SDP.js");
/* harmony import */ var _sdp_SDPDiffer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../sdp/SDPDiffer */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SDPDiffer.js");
/* harmony import */ var _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../sdp/SDPUtil */ "../../lib-jitsi-meet/dist/esm/modules/sdp/SDPUtil.js");
/* harmony import */ var _statistics_statistics__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _util_AsyncQueue__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../util/AsyncQueue */ "../../lib-jitsi-meet/dist/esm/modules/util/AsyncQueue.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _JingleSession__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./JingleSession */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleSession.js");
/* harmony import */ var _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./JingleSessionState */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleSessionState.js");
/* harmony import */ var _MediaSessionEvents__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./MediaSessionEvents */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/MediaSessionEvents.js");
/* harmony import */ var _XmppConnection__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./XmppConnection */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/XmppConnection.js");
























const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const IQ_TIMEOUT = 1e4;
const DEFAULT_MAX_STATS = 300;
const ICE_CAND_GATHERING_TIMEOUT = 150;
function getEndpointId(jidOrEndpointId) {
  return strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getResourceFromJid(jidOrEndpointId) || jidOrEndpointId;
}
function _addSourceElement(description, s, ssrc_, msid) {
  description.c("source", {
    xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
    ssrc: ssrc_,
    name: s.source
  }).c("parameter", {
    name: "msid",
    value: msid
  }).up().c("ssrc-info", {
    xmlns: "http://jitsi.org/jitmeet",
    owner: s.owner
  }).up().up();
}
class JingleSessionPC extends _JingleSession__WEBPACK_IMPORTED_MODULE_19__["default"] {
  static parseVideoSenders(jingleContents) {
    const videoContents = jingleContents.find('>content[name="video"]');
    if (videoContents.length) {
      const senders = videoContents[0].getAttribute("senders");
      if (senders === "both" || senders === "initiator" || senders === "responder" || senders === "none") {
        return senders;
      }
    }
    return null;
  }
  static parseSourceMaxFrameHeight(jingleContents) {
    const receiverConstraints = [];
    const sourceFrameHeightSel = jingleContents.find('>content[name="video"]>source-frame-height');
    let maxHeight, sourceName;
    if (sourceFrameHeightSel.length) {
      sourceFrameHeightSel.each((_, source) => {
        sourceName = source.getAttribute("sourceName");
        maxHeight = source.getAttribute("maxHeight");
        receiverConstraints.push({
          maxHeight,
          sourceName
        });
      });
      return receiverConstraints;
    }
    return null;
  }
  constructor(sid, localJid, remoteJid, connection, mediaConstraints, pcConfig, isP2P, isInitiator) {
    super(sid, localJid, remoteJid, connection, mediaConstraints, pcConfig, isInitiator);
    this._bridgeSessionId = null;
    this._cachedOldLocalSdp = void 0;
    this._cachedNewLocalSdp = void 0;
    this._iceCheckingStartedTimestamp = null;
    this._gatheringStartedTimestamp = null;
    this._sourceReceiverConstraints = void 0;
    this._localVideoActive = true;
    this._remoteVideoActive = true;
    this._gatheringReported = false;
    this.lasticecandidate = false;
    this.closed = false;
    this.isP2P = isP2P;
    this.remoteRecvMaxFrameHeight = void 0;
    this.numRemoteVideoSources = 0;
    this.numRemoteAudioSources = 0;
    this.remoteSourceMaxFrameHeights = void 0;
    this.modificationQueue = new _util_AsyncQueue__WEBPACK_IMPORTED_MODULE_16__["default"]();
    this.modificationQueue.pause();
    this.wasConnected = false;
    this.establishmentDuration = void 0;
    this._xmppListeners = [];
    this._xmppListeners.push(connection.addEventListener(_XmppConnection__WEBPACK_IMPORTED_MODULE_22__["default"].Events.CONN_STATUS_CHANGED, this.onXmppStatusChanged.bind(this)));
    this._removeSenderVideoConstraintsChangeListener = void 0;
  }
  _assertNotEnded() {
    return this.state !== _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.ENDED;
  }
  doInitialize(options) {
    var _a, _b, _c;
    this.failICE = Boolean(options.failICE);
    this.lasticecandidate = false;
    this.options = options;
    this.isReconnect = false;
    this.wasstable = false;
    this.webrtcIceUdpDisable = Boolean(options.webrtcIceUdpDisable);
    this.webrtcIceTcpDisable = Boolean(options.webrtcIceTcpDisable);
    const pcOptions = { disableRtx: options.disableRtx };
    if (options.gatherStats) {
      pcOptions.maxstats = DEFAULT_MAX_STATS;
    }
    pcOptions.capScreenshareBitrate = false;
    pcOptions.codecSettings = options.codecSettings;
    pcOptions.enableInsertableStreams = options.enableInsertableStreams;
    pcOptions.videoQuality = options.videoQuality;
    pcOptions.forceTurnRelay = options.forceTurnRelay;
    pcOptions.audioQuality = options.audioQuality;
    pcOptions.usesUnifiedPlan = this.usesUnifiedPlan = _browser__WEBPACK_IMPORTED_MODULE_18__["default"].supportsUnifiedPlan();
    if (this.isP2P) {
      pcOptions.disableSimulcast = true;
    } else {
      pcOptions.disableSimulcast = options.disableSimulcast || ((_a = options.videoQuality) === null || _a === void 0 ? void 0 : _a.preferredCodec) === _service_RTC_CodecMimeType__WEBPACK_IMPORTED_MODULE_4__["default"].H264;
      pcOptions.capScreenshareBitrate = pcOptions.disableSimulcast || !(typeof ((_b = options.desktopSharingFrameRate) === null || _b === void 0 ? void 0 : _b.max) === "number" && ((_c = options.desktopSharingFrameRate) === null || _c === void 0 ? void 0 : _c.max) > _RTC_ScreenObtainer__WEBPACK_IMPORTED_MODULE_10__.SS_DEFAULT_FRAME_RATE);
    }
    if (options.startSilent) {
      pcOptions.startSilent = true;
    }
    this.peerconnection = this.rtc.createPeerConnection(this._signalingLayer, this.pcConfig, this.isP2P, pcOptions);
    this.peerconnection.onicecandidate = (ev) => {
      if (!ev) {
        return;
      }
      const candidate = ev.candidate;
      const now = window.performance.now();
      if (candidate) {
        if (this._gatheringStartedTimestamp === null) {
          this._gatheringStartedTimestamp = now;
        }
        let protocol = candidate.protocol;
        if (typeof protocol === "string") {
          protocol = protocol.toLowerCase();
          if (protocol === "tcp" || protocol === "ssltcp") {
            if (this.webrtcIceTcpDisable) {
              return;
            }
          } else if (protocol === "udp") {
            if (this.webrtcIceUdpDisable) {
              return;
            }
          }
        }
      } else if (!this._gatheringReported) {
        _statistics_statistics__WEBPACK_IMPORTED_MODULE_15__["default"].sendAnalytics(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_8__.ICE_DURATION, {
          phase: "gathering",
          value: now - this._gatheringStartedTimestamp,
          p2p: this.isP2P,
          initiator: this.isInitiator
        });
        this._gatheringReported = true;
      }
      if (this.isP2P) {
        this.sendIceCandidate(candidate);
      }
    };
    this.peerconnection.onsignalingstatechange = () => {
      if (this.peerconnection.signalingState === "stable") {
        this.wasstable = true;
      } else if (this.peerconnection.signalingState === "closed" || this.peerconnection.connectionState === "closed") {
        this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.SUSPEND_DETECTED, this);
      }
    };
    this.peerconnection.oniceconnectionstatechange = () => {
      const now = window.performance.now();
      let isStable = false;
      if (!this.isP2P) {
        this.room.connectionTimes[`ice.state.${this.peerconnection.iceConnectionState}`] = now;
      }
      logger.log(`(TIME) ICE ${this.peerconnection.iceConnectionState} ${this.isP2P ? "P2P" : "JVB"}:	`, now);
      _statistics_statistics__WEBPACK_IMPORTED_MODULE_15__["default"].sendAnalytics(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_8__.ICE_STATE_CHANGED, {
        p2p: this.isP2P,
        state: this.peerconnection.iceConnectionState,
        "signaling_state": this.peerconnection.signalingState,
        reconnect: this.isReconnect,
        value: now
      });
      this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.ICE_CONNECTION_STATE_CHANGED, this, this.peerconnection.iceConnectionState);
      switch (this.peerconnection.iceConnectionState) {
        case "checking":
          this._iceCheckingStartedTimestamp = now;
          break;
        case "connected":
          if (this.peerconnection.signalingState === "stable") {
            isStable = true;
            const usesTerminateForRestart = !this.options.enableIceRestart && this.room.supportsRestartByTerminate();
            if (this.isReconnect || usesTerminateForRestart) {
              this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.CONNECTION_RESTORED, this);
            }
          }
          if (!this.wasConnected && (this.wasstable || isStable || this.usesUnifiedPlan && this.isInitiator && (_browser__WEBPACK_IMPORTED_MODULE_18__["default"].isChromiumBased() || _browser__WEBPACK_IMPORTED_MODULE_18__["default"].isReactNative()))) {
            _statistics_statistics__WEBPACK_IMPORTED_MODULE_15__["default"].sendAnalytics(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_8__.ICE_DURATION, {
              phase: "checking",
              value: now - this._iceCheckingStartedTimestamp,
              p2p: this.isP2P,
              initiator: this.isInitiator
            });
            const iceStarted = Math.min(this._iceCheckingStartedTimestamp, this._gatheringStartedTimestamp);
            this.establishmentDuration = now - iceStarted;
            _statistics_statistics__WEBPACK_IMPORTED_MODULE_15__["default"].sendAnalytics(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_8__.ICE_DURATION, {
              phase: "establishment",
              value: this.establishmentDuration,
              p2p: this.isP2P,
              initiator: this.isInitiator
            });
            this.wasConnected = true;
            this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.CONNECTION_ESTABLISHED, this);
          }
          this.isReconnect = false;
          break;
        case "disconnected":
          this.isReconnect = true;
          if (this.wasstable) {
            this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.CONNECTION_INTERRUPTED, this);
          }
          break;
        case "failed":
          this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.CONNECTION_ICE_FAILED, this);
          break;
      }
    };
    this.peerconnection.onconnectionstatechange = () => {
      const icestate = this.peerconnection.iceConnectionState;
      switch (this.peerconnection.connectionState) {
        case "failed":
          if (icestate === "disconnected") {
            this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.CONNECTION_ICE_FAILED, this);
          }
          break;
      }
    };
    this.peerconnection.onnegotiationneeded = () => {
      const state = this.peerconnection.signalingState;
      const remoteDescription = this.peerconnection.remoteDescription;
      if (this.usesUnifiedPlan && !this.isP2P && state === "stable" && remoteDescription && typeof remoteDescription.sdp === "string") {
        logger.info(`${this} onnegotiationneeded fired on ${this.peerconnection}`);
        const workFunction = (finishedCallback) => {
          this._renegotiate().then(() => finishedCallback(), (error) => finishedCallback(error));
        };
        this.modificationQueue.push(workFunction, (error) => {
          if (error) {
            logger.error(`${this} onnegotiationneeded error`, error);
          } else {
            logger.debug(`${this} onnegotiationneeded executed - OK`);
          }
        });
      }
    };
  }
  getRemoteRecvMaxFrameHeight() {
    if (this.isP2P) {
      return this.remoteRecvMaxFrameHeight;
    }
    return void 0;
  }
  getRemoteSourcesRecvMaxFrameHeight() {
    if (this.isP2P) {
      return this.remoteSourceMaxFrameHeights;
    }
    return void 0;
  }
  sendIceCandidate(candidate) {
    const localSDP = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
    if (candidate && candidate.candidate.length && !this.lasticecandidate) {
      const ice = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].iceparams(localSDP.media[candidate.sdpMLineIndex], localSDP.session);
      const jcand = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].candidateToJingle(candidate.candidate);
      if (!(ice && jcand)) {
        const errorMesssage = "failed to get ice && jcand";
        _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_17___default().callErrorHandler(new Error(errorMesssage));
        logger.error(errorMesssage);
        return;
      }
      ice.xmlns = "urn:xmpp:jingle:transports:ice-udp:1";
      if (this.usedrip) {
        if (this.dripContainer.length === 0) {
          setTimeout(() => {
            if (this.dripContainer.length === 0) {
              return;
            }
            this.sendIceCandidates(this.dripContainer);
            this.dripContainer = [];
          }, ICE_CAND_GATHERING_TIMEOUT);
        }
        this.dripContainer.push(candidate);
      } else {
        this.sendIceCandidates([candidate]);
      }
    } else {
      logger.log(`${this} sendIceCandidate: last candidate`);
      this.lasticecandidate = true;
    }
  }
  sendIceCandidates(candidates) {
    if (!this._assertNotEnded("sendIceCandidates")) {
      return;
    }
    logger.log(`${this} sendIceCandidates ${JSON.stringify(candidates)}`);
    const cand = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      to: this.remoteJid,
      type: "set"
    }).c("jingle", {
      xmlns: "urn:xmpp:jingle:1",
      action: "transport-info",
      initiator: this.initiatorJid,
      sid: this.sid
    });
    const localSDP = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
    for (let mid = 0; mid < localSDP.media.length; mid++) {
      const cands = candidates.filter((el) => el.sdpMLineIndex === mid);
      const mline = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].parseMLine(localSDP.media[mid].split("\r\n")[0]);
      if (cands.length > 0) {
        const ice = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].iceparams(localSDP.media[mid], localSDP.session);
        ice.xmlns = "urn:xmpp:jingle:transports:ice-udp:1";
        cand.c("content", {
          creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
          name: cands[0].sdpMid ? cands[0].sdpMid : mline.media
        }).c("transport", ice);
        for (let i = 0; i < cands.length; i++) {
          const candidate = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].candidateToJingle(cands[i].candidate);
          if (this.failICE) {
            candidate.ip = "1.1.1.1";
          }
          cand.c("candidate", candidate).up();
        }
        const fingerprintLine = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].findLine(localSDP.media[mid], "a=fingerprint:", localSDP.session);
        if (fingerprintLine) {
          const tmp = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].parseFingerprint(fingerprintLine);
          tmp.required = true;
          cand.c("fingerprint", { xmlns: "urn:xmpp:jingle:apps:dtls:0" }).t(tmp.fingerprint);
          delete tmp.fingerprint;
          cand.attrs(tmp);
          cand.up();
        }
        cand.up();
        cand.up();
      }
    }
    this.connection.sendIQ(cand, null, this.newJingleErrorHandler(cand), IQ_TIMEOUT);
  }
  sendIceFailedNotification() {
    const sessionInfo = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      to: this.remoteJid,
      type: "set"
    }).c("jingle", {
      xmlns: "urn:xmpp:jingle:1",
      action: "session-info",
      initiator: this.initiatorJid,
      sid: this.sid
    }).c("ice-state", { xmlns: "http://jitsi.org/protocol/focus" }).t("failed").up();
    this._bridgeSessionId && sessionInfo.c("bridge-session", {
      xmlns: "http://jitsi.org/protocol/focus",
      id: this._bridgeSessionId
    });
    this.connection.sendIQ2(sessionInfo, {
      timeout: 65
    }).catch(this.newJingleErrorHandler(sessionInfo));
  }
  addIceCandidates(elem) {
    if (this.peerconnection.signalingState === "closed") {
      logger.warn(`${this} Ignored add ICE candidate when in closed state`);
      return;
    }
    const iceCandidates = [];
    elem.find(">content>transport>candidate").each((idx, candidate) => {
      let line = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].candidateFromJingle(candidate);
      line = line.replace("\r\n", "").replace("a=", "");
      const rtcCandidate = new RTCIceCandidate({
        sdpMLineIndex: 0,
        sdpMid: "",
        candidate: line
      });
      iceCandidates.push(rtcCandidate);
    });
    if (!iceCandidates.length) {
      logger.error(`${this} No ICE candidates to add ?`, elem[0] && elem[0].outerHTML);
      return;
    }
    const workFunction = (finishedCallback) => {
      for (const iceCandidate of iceCandidates) {
        this.peerconnection.addIceCandidate(iceCandidate).then(() => logger.debug(`${this} addIceCandidate ok!`), (err) => logger.error(`${this} addIceCandidate failed!`, err));
      }
      finishedCallback();
      logger.debug(`${this} ICE candidates task finished`);
    };
    logger.debug(`${this} Queued add (${iceCandidates.length}) ICE candidates task`);
    this.modificationQueue.push(workFunction);
  }
  readSsrcInfo(contents) {
    const ssrcs = jquery__WEBPACK_IMPORTED_MODULE_1___default()(contents).find('>description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]');
    ssrcs.each((i, ssrcElement) => {
      const ssrc = Number(ssrcElement.getAttribute("ssrc"));
      if (ssrcElement.hasAttribute("name")) {
        const sourceName = ssrcElement.getAttribute("name");
        this._signalingLayer.setTrackSourceName(ssrc, sourceName);
      }
      if (this.isP2P) {
        this._signalingLayer.setSSRCOwner(ssrc, strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getResourceFromJid(this.remoteJid));
      } else {
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(ssrcElement).find('>ssrc-info[xmlns="http://jitsi.org/jitmeet"]').each((i3, ssrcInfoElement) => {
          const owner = ssrcInfoElement.getAttribute("owner");
          if (owner === null || owner === void 0 ? void 0 : owner.length) {
            if (isNaN(ssrc) || ssrc < 0) {
              logger.warn(`${this} Invalid SSRC ${ssrc} value received for ${owner}`);
            } else {
              this._signalingLayer.setSSRCOwner(ssrc, getEndpointId(owner));
            }
          }
        });
      }
    });
  }
  generateRecvonlySsrc() {
    if (this.peerconnection) {
      this.peerconnection.generateRecvonlySsrc();
    } else {
      logger.error(`${this} Unable to generate recvonly SSRC - no peerconnection`);
    }
  }
  getConfiguredVideoCodec() {
    return this.peerconnection.getConfiguredVideoCodec();
  }
  acceptOffer(jingleOffer, success, failure, localTracks) {
    this.setOfferAnswerCycle(jingleOffer, () => {
      this.sendSessionAccept(() => {
        logger.debug("Resuming the modification queue after session is established!");
        this.modificationQueue.resume();
        success();
        this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.SESSION_ACCEPT, this);
        const videoTracks = localTracks.filter((track) => track.getType() === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_6__.MediaType.VIDEO);
        videoTracks.length && videoTracks.splice(0, 1);
        if (_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_11__["default"].isMultiStreamSendSupportEnabled() && videoTracks.length) {
          this.addTracks(videoTracks);
        }
      }, (error) => {
        failure(error);
        this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.SESSION_ACCEPT_ERROR, this, error);
      });
    }, failure, localTracks);
  }
  invite(localTracks = []) {
    if (!this.isInitiator) {
      throw new Error("Trying to invite from the responder session");
    }
    logger.debug(`${this} Executing invite task`);
    const addTracks = [];
    for (const track of localTracks) {
      addTracks.push(this.peerconnection.addTrack(track, this.isInitiator));
    }
    Promise.all(addTracks).then(() => this.peerconnection.createOffer(this.mediaConstraints)).then((offerSdp) => this.peerconnection.setLocalDescription(offerSdp)).then(() => {
      this.peerconnection.processLocalSdpForTransceiverInfo(localTracks);
      let localDescription = this.peerconnection.localDescription;
      if (!_browser__WEBPACK_IMPORTED_MODULE_18__["default"].supportsCodecPreferences()) {
        localDescription = this.peerconnection._mungeCodecOrder(localDescription);
      }
      this.sendSessionInitiate(localDescription.sdp);
    }).then(() => {
      logger.debug(`${this} invite executed - OK`);
    }).catch((error) => {
      logger.error(`${this} invite error`, error);
    });
  }
  sendSessionInitiate(offerSdp) {
    let init = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      to: this.remoteJid,
      type: "set"
    }).c("jingle", {
      xmlns: "urn:xmpp:jingle:1",
      action: "session-initiate",
      initiator: this.initiatorJid,
      sid: this.sid
    });
    new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](offerSdp).toJingle(init, this.isInitiator ? "initiator" : "responder");
    init = init.tree();
    logger.debug(`${this} Session-initiate: `, init);
    this.connection.sendIQ(init, () => {
      logger.info(`${this} Got RESULT for "session-initiate"`);
    }, (error) => {
      logger.error(`${this} "session-initiate" error`, error);
    }, IQ_TIMEOUT);
  }
  setAnswer(jingleAnswer) {
    if (!this.isInitiator) {
      throw new Error("Trying to set an answer on the responder session");
    }
    logger.debug(`${this} Executing setAnswer task`);
    const newRemoteSdp = this._processNewJingleOfferIq(jingleAnswer);
    const oldLocalSdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
    const remoteDescription = new RTCSessionDescription({
      type: "answer",
      sdp: newRemoteSdp.raw
    });
    this.peerconnection.setRemoteDescription(remoteDescription).then(() => {
      if (this.state === _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.PENDING) {
        this.state = _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.ACTIVE;
        logger.debug("Resuming the modification queue after session is established!");
        this.modificationQueue.resume();
        const newLocalSdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
        this.sendContentModify();
        this.notifyMySSRCUpdate(oldLocalSdp, newLocalSdp);
      }
    }).then(() => {
      logger.debug(`${this} setAnswer task done`);
    }).catch((error) => {
      logger.error(`${this} setAnswer task failed: ${error}`);
    });
  }
  setOfferAnswerCycle(jingleOfferAnswerIq, success, failure, localTracks = []) {
    logger.debug(`${this} Executing setOfferAnswerCycle task`);
    const addTracks = [];
    const audioTracks = localTracks.filter((track) => track.getType() === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_6__.MediaType.AUDIO);
    const videoTracks = localTracks.filter((track) => track.getType() === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_6__.MediaType.VIDEO);
    let tracks = localTracks;
    if (_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_11__["default"].isMultiStreamSendSupportEnabled() && videoTracks.length > 1) {
      tracks = [...audioTracks, videoTracks[0]];
    }
    for (const track of tracks) {
      addTracks.push(this.peerconnection.addTrack(track, this.isInitiator));
    }
    const newRemoteSdp = this._processNewJingleOfferIq(jingleOfferAnswerIq);
    const oldLocalSdp = this.peerconnection.localDescription.sdp;
    const bridgeSession = jquery__WEBPACK_IMPORTED_MODULE_1___default()(jingleOfferAnswerIq).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]');
    const bridgeSessionId = bridgeSession.attr("id");
    if (bridgeSessionId !== this._bridgeSessionId) {
      this._bridgeSessionId = bridgeSessionId;
    }
    const remoteDescription = new RTCSessionDescription({
      type: "offer",
      sdp: newRemoteSdp.raw
    });
    Promise.all(addTracks).then(() => this._responderRenegotiate(remoteDescription)).then(() => {
      this.peerconnection.processLocalSdpForTransceiverInfo(tracks);
      if (this.state === _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.PENDING) {
        this.state = _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.ACTIVE;
        if (this.isP2P && (!this._localVideoActive || this._sourceReceiverConstraints)) {
          this.sendContentModify();
        }
      }
      if (oldLocalSdp) {
        const newLocalSdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
        this.notifyMySSRCUpdate(new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](oldLocalSdp), newLocalSdp);
      }
    }).then(() => {
      logger.debug(`${this} setOfferAnswerCycle task done`);
      success();
    }).catch((error) => {
      logger.error(`${this} setOfferAnswerCycle task failed: ${error}`);
      failure(error);
    });
  }
  setVideoCodecs(codecList) {
    if (this._assertNotEnded()) {
      logger.info(`${this} setVideoCodecs: ${codecList}`);
      this.peerconnection.setVideoCodecs(codecList);
      const workFunction = (finishedCallback) => {
        this._renegotiate().then(() => {
          logger.debug(`${this} setVideoCodecs task is done`);
          return finishedCallback();
        }, (error) => {
          logger.error(`${this} setVideoCodecs task failed: ${error}`);
          return finishedCallback(error);
        });
      };
      logger.debug(`${this} Queued setVideoCodecs task`);
      this.modificationQueue.push(workFunction);
    }
  }
  replaceTransport(jingleOfferElem, success, failure) {
    if (this.options.enableForcedReload) {
      const sdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
      this.sendTransportAccept(sdp, success, failure);
      this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.CONNECTION_RESTARTED, this);
      return;
    }
    this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.ICE_RESTARTING, this);
    const originalOffer = jingleOfferElem.clone();
    jingleOfferElem.find(">content[name='data']").attr("senders", "rejected");
    jingleOfferElem.find(">content>description>source").remove();
    jingleOfferElem.find(">content>description>ssrc-group").remove();
    const newFingerprint = jingleOfferElem.find(">content>transport>fingerprint");
    newFingerprint.attr("hash", "sha-1");
    newFingerprint.text("00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00");
    const workFunction = (finishedCallback) => {
      this.setOfferAnswerCycle(jingleOfferElem, () => {
        this.setOfferAnswerCycle(originalOffer, () => {
          const localSDP = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
          if (typeof this.options.channelLastN === "number" && this.options.channelLastN >= 0) {
            localSDP.initialLastN = this.options.channelLastN;
          }
          this.sendTransportAccept(localSDP, success, failure);
          this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.ICE_RESTART_SUCCESS, this, originalOffer);
          finishedCallback();
        }, (error) => finishedCallback(error));
      }, (error) => finishedCallback(error));
    };
    logger.debug(`${this} Queued ICE restart task`);
    this.modificationQueue.push(workFunction, (error) => {
      if (error) {
        logger.error(`${this} ICE restart task failed: ${error}`);
        failure(error);
      } else {
        logger.debug(`${this} ICE restart task done`);
        success();
      }
    });
  }
  sendSessionAccept(success, failure) {
    const localSDP = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
    const accept = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      to: this.remoteJid,
      type: "set"
    }).c("jingle", {
      xmlns: "urn:xmpp:jingle:1",
      action: "session-accept",
      initiator: this.initiatorJid,
      responder: this.responderJid,
      sid: this.sid
    });
    if (this.webrtcIceTcpDisable) {
      localSDP.removeTcpCandidates = true;
    }
    if (this.webrtcIceUdpDisable) {
      localSDP.removeUdpCandidates = true;
    }
    if (this.failICE) {
      localSDP.failICE = true;
    }
    if (typeof this.options.channelLastN === "number" && this.options.channelLastN >= 0) {
      localSDP.initialLastN = this.options.channelLastN;
    }
    localSDP.toJingle(accept, this.initiatorJid === this.localJid ? "initiator" : "responder");
    logger.info(`${this} Sending session-accept`);
    logger.debug(accept.tree());
    this.connection.sendIQ(accept, success, this.newJingleErrorHandler(accept, (error) => {
      failure(error);
      this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.SESSION_ACCEPT_TIMEOUT, this);
    }), IQ_TIMEOUT);
  }
  sendContentModify() {
    const senders = this._localVideoActive ? "both" : "none";
    const sessionModify = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      to: this.remoteJid,
      type: "set"
    }).c("jingle", {
      xmlns: "urn:xmpp:jingle:1",
      action: "content-modify",
      initiator: this.initiatorJid,
      sid: this.sid
    }).c("content", {
      name: _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_6__.MediaType.VIDEO,
      senders
    });
    if (typeof this._sourceReceiverConstraints !== "undefined") {
      this._sourceReceiverConstraints.forEach((maxHeight, sourceName) => {
        sessionModify.c("source-frame-height", { xmlns: "http://jitsi.org/jitmeet/video" }).attrs({
          sourceName,
          maxHeight
        });
        sessionModify.up();
        logger.info(`${this} sending content-modify for source-name: ${sourceName}, maxHeight: ${maxHeight}`);
      });
    }
    logger.debug(sessionModify.tree());
    this.connection.sendIQ(sessionModify, null, this.newJingleErrorHandler(sessionModify), IQ_TIMEOUT);
  }
  setReceiverVideoConstraint(sourceReceiverConstraints) {
    logger.info(`${this} setReceiverVideoConstraint - constraints: ${JSON.stringify(sourceReceiverConstraints)}`);
    this._sourceReceiverConstraints = sourceReceiverConstraints;
    if (this.isP2P) {
      if (this.state === _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.ACTIVE) {
        this.sendContentModify();
      }
    }
  }
  sendTransportAccept(localSDP, success, failure) {
    const transportAccept = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      to: this.remoteJid,
      type: "set"
    }).c("jingle", {
      xmlns: "urn:xmpp:jingle:1",
      action: "transport-accept",
      initiator: this.initiatorJid,
      sid: this.sid
    });
    localSDP.media.forEach((medialines, idx) => {
      const mline = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].parseMLine(medialines.split("\r\n")[0]);
      transportAccept.c("content", {
        creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
        name: mline.media
      });
      localSDP.transportToJingle(idx, transportAccept);
      transportAccept.up();
    });
    logger.info(`${this} Sending transport-accept`);
    logger.debug(transportAccept.tree());
    this.connection.sendIQ(transportAccept, success, this.newJingleErrorHandler(transportAccept, failure), IQ_TIMEOUT);
  }
  sendTransportReject(success, failure) {
    const transportReject = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      to: this.remoteJid,
      type: "set"
    }).c("jingle", {
      xmlns: "urn:xmpp:jingle:1",
      action: "transport-reject",
      initiator: this.initiatorJid,
      sid: this.sid
    });
    logger.info(`${this} Sending 'transport-reject'`);
    logger.debug(transportReject.tree());
    this.connection.sendIQ(transportReject, success, this.newJingleErrorHandler(transportReject, failure), IQ_TIMEOUT);
  }
  setSenderVideoConstraint(maxFrameHeight, sourceName = null) {
    if (this._assertNotEnded()) {
      logger.info(`${this} setSenderVideoConstraint: ${maxFrameHeight}, sourceName: ${sourceName}`);
      const jitsiLocalTrack = sourceName ? this.rtc.getLocalVideoTracks().find((track) => track.getSourceName() === sourceName) : this.rtc.getLocalVideoTrack();
      return this.peerconnection.setSenderVideoConstraints(maxFrameHeight, jitsiLocalTrack);
    }
    return Promise.resolve();
  }
  terminate(success, failure, options) {
    if (this.state === _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.ENDED) {
      return;
    }
    if (!options || Boolean(options.sendSessionTerminate)) {
      const sessionTerminate = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
        to: this.remoteJid,
        type: "set"
      }).c("jingle", {
        xmlns: "urn:xmpp:jingle:1",
        action: "session-terminate",
        initiator: this.initiatorJid,
        sid: this.sid
      }).c("reason").c(options && options.reason || "success").up();
      if (options && options.reasonDescription) {
        sessionTerminate.c("text").t(options.reasonDescription).up().up();
      } else {
        sessionTerminate.up();
      }
      this._bridgeSessionId && sessionTerminate.c("bridge-session", {
        xmlns: "http://jitsi.org/protocol/focus",
        id: this._bridgeSessionId,
        restart: options && options.requestRestart === true
      }).up();
      logger.info(`${this} Sending session-terminate`);
      logger.debug(sessionTerminate.tree());
      this.connection.sendIQ(sessionTerminate, success, this.newJingleErrorHandler(sessionTerminate, failure), IQ_TIMEOUT);
    } else {
      logger.info(`${this} Skipped sending session-terminate`);
    }
    this.connection.jingle.terminate(this.sid);
  }
  onTerminated(reasonCondition, reasonText) {
    logger.info(`${this} Session terminated`, reasonCondition, reasonText);
    this._xmppListeners.forEach((removeListener) => removeListener());
    this._xmppListeners = [];
    if (this._removeSenderVideoConstraintsChangeListener) {
      this._removeSenderVideoConstraintsChangeListener();
    }
    if (_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_11__["default"].isSsrcRewritingSupported() && this.peerconnection) {
      this.peerconnection.getRemoteTracks().forEach((track) => {
        this.room.eventEmitter.emit(_JitsiTrackEvents__WEBPACK_IMPORTED_MODULE_3__.JitsiTrackEvents.TRACK_REMOVED, track);
      });
    }
    this.close();
  }
  onXmppStatusChanged(status) {
    if (status === _XmppConnection__WEBPACK_IMPORTED_MODULE_22__["default"].Status.CONNECTED && this._cachedOldLocalSdp) {
      logger.info(`${this} Sending SSRC update on reconnect`);
      this.notifyMySSRCUpdate(this._cachedOldLocalSdp, this._cachedNewLocalSdp);
    }
  }
  _parseSsrcInfoFromSourceAdd(sourceAddElem, currentRemoteSdp) {
    const addSsrcInfo = [];
    const self = this;
    jquery__WEBPACK_IMPORTED_MODULE_1___default()(sourceAddElem).each((i1, content) => {
      const name = jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).attr("name");
      let lines = "";
      jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(function() {
        const semantics = this.getAttribute("semantics");
        const ssrcs = jquery__WEBPACK_IMPORTED_MODULE_1___default()(this).find(">source").map(function() {
          return this.getAttribute("ssrc");
        }).get();
        if (ssrcs.length) {
          lines += `a=ssrc-group:${semantics} ${ssrcs.join(" ")}\r
`;
        }
      });
      const tmp = jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]');
      tmp.each(function() {
        const ssrc = jquery__WEBPACK_IMPORTED_MODULE_1___default()(this).attr("ssrc");
        if (currentRemoteSdp.containsSSRC(ssrc)) {
          !(self.usesUnifiedPlan && self.isP2P) && logger.warn(`${self} Source-add request for existing SSRC: ${ssrc}`);
          return;
        }
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(this).find(">parameter").each(function() {
          lines += `a=ssrc:${ssrc} ${jquery__WEBPACK_IMPORTED_MODULE_1___default()(this).attr("name")}`;
          if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(this).attr("value") && jquery__WEBPACK_IMPORTED_MODULE_1___default()(this).attr("value").length) {
            lines += `:${jquery__WEBPACK_IMPORTED_MODULE_1___default()(this).attr("value")}`;
          }
          lines += "\r\n";
        });
      });
      let midFound = false;
      currentRemoteSdp.media.forEach((media, i2) => {
        if (!_sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].findLine(media, `a=mid:${name}`)) {
          return;
        }
        if (!addSsrcInfo[i2]) {
          addSsrcInfo[i2] = "";
        }
        addSsrcInfo[i2] += lines;
        midFound = true;
      });
      if (!midFound && this.isP2P) {
        addSsrcInfo[name] = lines;
      }
    });
    return addSsrcInfo;
  }
  addRemoteStream(elem) {
    this._addOrRemoveRemoteStream(true, elem);
  }
  removeRemoteStream(elem) {
    this._addOrRemoveRemoteStream(false, elem);
  }
  processSourceMap(message, mediaType) {
    const newSsrcs = [];
    for (const src of message.mappedSources) {
      let { owner, source, ssrc, videoType } = src;
      const isNewSsrc = this.peerconnection.addRemoteSsrc(ssrc, source);
      let lookupSsrc = ssrc;
      if (isNewSsrc) {
        newSsrcs.push(src);
        const oldSsrc = this.peerconnection.remoteSources.get(source);
        if (oldSsrc) {
          lookupSsrc = oldSsrc;
          owner = void 0;
          source = void 0;
        }
      }
      const track = this.peerconnection.getTrackBySSRC(lookupSsrc);
      if (track) {
        logger.debug(`Existing SSRC ${ssrc}: new owner=${owner}, source-name=${source}`);
        this._signalingLayer.setSSRCOwner(ssrc, owner);
        track.setSourceName(source);
        track.setOwner(owner);
        if (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_6__.MediaType.VIDEO) {
          const type = videoType === "CAMERA" ? _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.CAMERA : _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_7__.VideoType.DESKTOP;
          track._setVideoType(type);
        }
        const peerMediaInfo = this._signalingLayer.getPeerMediaInfo(owner, mediaType, source);
        peerMediaInfo && this.peerconnection._sourceMutedChanged(source, peerMediaInfo.muted);
      }
    }
    if (newSsrcs.length) {
      let node = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$build)("content", {
        xmlns: "urn:xmpp:jingle:1",
        name: mediaType
      }).c("description", {
        xmlns: "urn:xmpp:jingle:apps:rtp:1",
        media: mediaType
      });
      for (const src of newSsrcs) {
        const { rtx, ssrc, source } = src;
        let msid;
        if (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_6__.MediaType.VIDEO) {
          const idx = ++this.numRemoteVideoSources;
          msid = `remote-video-${idx} remote-video-${idx}`;
          if (rtx !== "-1") {
            _addSourceElement(node, src, rtx, msid);
            node.c("ssrc-group", {
              xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
              semantics: "FID"
            }).c("source", {
              xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
              ssrc
            }).up().c("source", {
              xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
              ssrc: rtx
            }).up().up();
          }
        } else {
          const idx = ++this.numRemoteAudioSources;
          msid = `remote-audio-${idx} remote-audio-${idx}`;
        }
        _addSourceElement(node, src, ssrc, msid);
        this.peerconnection.remoteSources.set(source, ssrc);
      }
      node = node.up();
      this._addOrRemoveRemoteStream(true, node.node);
    }
  }
  removeRemoteStreamsOnLeave(id) {
    const workFunction = (finishCallback) => {
      const removeSsrcInfo = this.peerconnection.getRemoteSourceInfoByParticipant(id);
      if (removeSsrcInfo.length) {
        const newRemoteSdp = this._processRemoteRemoveSource(removeSsrcInfo);
        this._renegotiate(newRemoteSdp.raw).then(() => finishCallback(), (error) => finishCallback(error));
      } else {
        finishCallback();
      }
    };
    logger.debug(`${this} Queued removeRemoteStreamsOnLeave task for participant ${id}`);
    this.modificationQueue.push(workFunction, (error) => {
      if (error) {
        logger.error(`${this} removeRemoteStreamsOnLeave error:`, error);
      } else {
        logger.info(`${this} removeRemoteStreamsOnLeave done!`);
      }
    });
  }
  _addOrRemoveRemoteStream(isAdd, elem) {
    const logPrefix = isAdd ? "addRemoteStream" : "removeRemoteStream";
    if (isAdd) {
      this.readSsrcInfo(elem);
    }
    const workFunction = (finishedCallback) => {
      if (!this.peerconnection.localDescription || !this.peerconnection.localDescription.sdp) {
        const errMsg = `${logPrefix} - localDescription not ready yet`;
        logger.error(errMsg);
        finishedCallback(errMsg);
        return;
      }
      logger.log(`${this} Processing ${logPrefix}`);
      const oldLocalSdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
      const sdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.remoteDescription.sdp);
      const addOrRemoveSsrcInfo = isAdd ? this._parseSsrcInfoFromSourceAdd(elem, sdp) : this._parseSsrcInfoFromSourceRemove(elem, sdp);
      const newRemoteSdp = isAdd ? this._processRemoteAddSource(addOrRemoveSsrcInfo) : this._processRemoteRemoveSource(addOrRemoveSsrcInfo);
      const remoteDescription = new RTCSessionDescription({
        type: "offer",
        sdp: newRemoteSdp.raw
      });
      this._responderRenegotiate(remoteDescription).then(() => {
        const newLocalSdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
        logger.log(`${this} ${logPrefix} - OK`);
        this.notifyMySSRCUpdate(oldLocalSdp, newLocalSdp);
        finishedCallback();
      }, (error) => {
        logger.error(`${this} ${logPrefix} failed:`, error);
        finishedCallback(error);
      });
    };
    logger.debug(`${this} Queued ${logPrefix} task`);
    this.modificationQueue.push(workFunction);
  }
  _processNewJingleOfferIq(offerIq) {
    const remoteSdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"]("");
    if (this.webrtcIceTcpDisable) {
      remoteSdp.removeTcpCandidates = true;
    }
    if (this.webrtcIceUdpDisable) {
      remoteSdp.removeUdpCandidates = true;
    }
    if (this.failICE) {
      remoteSdp.failICE = true;
    }
    remoteSdp.fromJingle(offerIq);
    this.readSsrcInfo(jquery__WEBPACK_IMPORTED_MODULE_1___default()(offerIq).find(">content"));
    return remoteSdp;
  }
  _processRemoteRemoveSource(removeSsrcInfo) {
    const remoteSdp = this.usesUnifiedPlan ? new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.peerconnection.remoteDescription.sdp) : new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.remoteDescription.sdp);
    let ssrcs;
    removeSsrcInfo.forEach((lines, idx) => {
      lines = lines.split("\r\n");
      lines.pop();
      ssrcs = lines.map((line) => {
        var _a;
        return Number((_a = line.split("a=ssrc:")[1]) === null || _a === void 0 ? void 0 : _a.split(" ")[0]);
      });
      if (this.usesUnifiedPlan) {
        let mid;
        lines.forEach((line) => {
          var _a;
          mid = remoteSdp.media.findIndex((mLine) => mLine.includes(line));
          if (mid > -1) {
            remoteSdp.media[mid] = remoteSdp.media[mid].replace(`${line}\r
`, "");
            if (this.isP2P) {
              const mediaType = (_a = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].parseMLine(remoteSdp.media[mid].split("\r\n")[0])) === null || _a === void 0 ? void 0 : _a.media;
              const desiredDirection = this.peerconnection.getDesiredMediaDirection(mediaType, false);
              [_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_5__.MediaDirection.SENDRECV, _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_5__.MediaDirection.SENDONLY].forEach((direction) => {
                remoteSdp.media[mid] = remoteSdp.media[mid].replace(`a=${direction}`, `a=${desiredDirection}`);
              });
            } else {
              remoteSdp.media[mid] = remoteSdp.media[mid].replace(`a=${_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_5__.MediaDirection.SENDONLY}`, `a=${_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_5__.MediaDirection.INACTIVE}`);
              const { media, port } = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].parseMLine(remoteSdp.media[mid].split("\r\n")[0]);
              remoteSdp.media[mid] = remoteSdp.media[mid].replace(`m=${media} ${port}`, `m=${media} 0`);
            }
          }
        });
      } else {
        lines.forEach((line) => {
          remoteSdp.media[idx] = remoteSdp.media[idx].replace(`${line}\r
`, "");
        });
      }
    });
    (ssrcs === null || ssrcs === void 0 ? void 0 : ssrcs.length) && this._signalingLayer.removeSSRCOwners(ssrcs);
    remoteSdp.raw = remoteSdp.session + remoteSdp.media.join("");
    return remoteSdp;
  }
  _processRemoteAddSource(addSsrcInfo) {
    let remoteSdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.remoteDescription.sdp);
    if (addSsrcInfo.length > remoteSdp.media.length && this.isP2P && this.usesUnifiedPlan) {
      remoteSdp.addMlineForNewLocalSource(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_6__.MediaType.VIDEO);
      remoteSdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](remoteSdp.raw);
    }
    addSsrcInfo.forEach((lines, idx) => {
      var _a;
      remoteSdp.media[idx] += lines;
      if (this.isP2P && this.usesUnifiedPlan) {
        const mediaType = (_a = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].parseMLine(remoteSdp.media[idx].split("\r\n")[0])) === null || _a === void 0 ? void 0 : _a.media;
        const desiredDirection = this.peerconnection.getDesiredMediaDirection(mediaType, true);
        [_service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_5__.MediaDirection.RECVONLY, _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_5__.MediaDirection.INACTIVE].forEach((direction) => {
          remoteSdp.media[idx] = remoteSdp.media[idx].replace(`a=${direction}`, `a=${desiredDirection}`);
        });
      }
    });
    remoteSdp.raw = remoteSdp.session + remoteSdp.media.join("");
    return remoteSdp;
  }
  _renegotiate(optionalRemoteSdp) {
    if (this.peerconnection.signalingState === "closed") {
      const error = new Error("Attempted to renegotiate in state closed");
      this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.RENEGOTIATION_FAILED, error, this);
      return Promise.reject(error);
    }
    const remoteSdp = optionalRemoteSdp || this.peerconnection.remoteDescription.sdp;
    if (!remoteSdp) {
      const error = new Error(`Can not renegotiate without remote description, current state: ${this.state}`);
      this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.RENEGOTIATION_FAILED, error, this);
      return Promise.reject(error);
    }
    const remoteDescription = new RTCSessionDescription({
      type: this.isInitiator ? "answer" : "offer",
      sdp: remoteSdp
    });
    const promise = this.isInitiator ? this._initiatorRenegotiate(remoteDescription) : this._responderRenegotiate(remoteDescription);
    const oldLocalSDP = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
    return promise.then(() => {
      const newLocalSDP = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
      oldLocalSDP && this.notifyMySSRCUpdate(oldLocalSDP, newLocalSDP);
    });
  }
  _responderRenegotiate(remoteDescription) {
    logger.debug(`${this} Renegotiate: setting remote description`);
    return this.peerconnection.setRemoteDescription(remoteDescription).then(() => {
      logger.debug(`${this} Renegotiate: creating answer`);
      return this.peerconnection.createAnswer(this.mediaConstraints).then((answer) => {
        logger.debug(`${this} Renegotiate: setting local description`);
        return this.peerconnection.setLocalDescription(answer);
      });
    });
  }
  _initiatorRenegotiate(remoteDescription) {
    logger.debug(`${this} Renegotiate: creating offer`);
    return this.peerconnection.createOffer(this.mediaConstraints).then((offer) => {
      logger.debug(`${this} Renegotiate: setting local description`);
      return this.peerconnection.setLocalDescription(offer).then(() => {
        logger.debug(`${this} Renegotiate: setting remote description`);
        return this.peerconnection.setRemoteDescription(remoteDescription);
      });
    });
  }
  addTracks(localTracks = null) {
    if (!_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_11__["default"].isMultiStreamSendSupportEnabled() || !(localTracks === null || localTracks === void 0 ? void 0 : localTracks.length) || localTracks.find((track) => track.getType() !== _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_6__.MediaType.VIDEO)) {
      return Promise.reject(new Error("Multiple tracks of the given media type are not supported"));
    }
    const replaceTracks = [];
    const workFunction = (finishedCallback) => {
      const remoteSdp = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.peerconnection.remoteDescription.sdp);
      const recvOnlyTransceiver = this.peerconnection.peerconnection.getTransceivers().find((t) => t.receiver.track.kind === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_6__.MediaType.VIDEO && t.direction === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_5__.MediaDirection.RECVONLY && t.currentDirection === _service_RTC_MediaDirection__WEBPACK_IMPORTED_MODULE_5__.MediaDirection.RECVONLY);
      for (const track of localTracks) {
        if (!this.isP2P || !recvOnlyTransceiver) {
          remoteSdp.addMlineForNewLocalSource(track.getType());
        }
      }
      const remoteDescription = new RTCSessionDescription({
        type: "offer",
        sdp: remoteSdp.raw
      });
      this._responderRenegotiate(remoteDescription).then(() => {
        for (const track of localTracks) {
          replaceTracks.push(this.peerconnection.replaceTrack(null, track));
        }
        return Promise.all(replaceTracks);
      }).then(() => this._renegotiate()).then(() => finishedCallback(), (error) => finishedCallback(error));
    };
    return new Promise((resolve, reject) => {
      logger.debug(`${this} Queued renegotiation after addTrack`);
      this.modificationQueue.push(workFunction, (error) => {
        if (error) {
          logger.error(`${this} renegotiation after addTrack error`, error);
          reject(error);
        } else {
          logger.debug(`${this} renegotiation after addTrack executed - OK`);
          resolve();
        }
      });
    });
  }
  setMediaTransferActive(active) {
    return this.peerconnection.tpcUtils.setMediaTransferActive(active).then(() => {
      this.peerconnection.audioTransferActive = active;
      this.peerconnection.videoTransferActive = active;
      const promises = [];
      for (const track of this.rtc.getLocalVideoTracks()) {
        promises.push(this.peerconnection.configureSenderVideoEncodings(track));
      }
      return Promise.allSettled(promises);
    });
  }
  replaceTrack(oldTrack, newTrack) {
    const workFunction = (finishedCallback) => {
      logger.debug(`${this} replaceTrack worker started. oldTrack = ${oldTrack}, newTrack = ${newTrack}`);
      const oldLocalSdp = this.peerconnection.localDescription.sdp;
      if (!this.usesUnifiedPlan) {
        if (this.peerconnection.options.capScreenshareBitrate && oldTrack && newTrack && newTrack.isVideoTrack()) {
          this.peerconnection.clearRecvonlySsrc();
        }
        if (!oldTrack && newTrack && newTrack.isVideoTrack()) {
          this.peerconnection.clearRecvonlySsrc();
        } else if (oldTrack && oldTrack.isVideoTrack() && !newTrack) {
          this.peerconnection.clearRecvonlySsrc();
          this.peerconnection.generateRecvonlySsrc();
        }
      }
      this.peerconnection.replaceTrack(oldTrack, newTrack).then((shouldRenegotiate) => {
        let promise = Promise.resolve();
        logger.debug(`${this} TPC.replaceTrack finished. shouldRenegotiate = ${shouldRenegotiate}, JingleSessionState = ${this.state}`);
        if (shouldRenegotiate && (oldTrack || newTrack) && this.state === _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.ACTIVE) {
          const remoteSdp = this.peerconnection.remoteDescription.sdp;
          const remoteDescription = new RTCSessionDescription({
            type: "offer",
            sdp: remoteSdp
          });
          promise = this._responderRenegotiate(remoteDescription).then(() => {
            const newLocalSDP = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
            this.notifyMySSRCUpdate(new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](oldLocalSdp), newLocalSDP);
          });
        }
        return promise.then(() => {
          if (oldTrack && newTrack && oldTrack.isVideoTrack()) {
            newTrack.setSourceName(oldTrack.getSourceName());
          }
        });
      }).then(() => finishedCallback(), (error) => finishedCallback(error));
    };
    return new Promise((resolve, reject) => {
      logger.debug(`${this} Queued replaceTrack task. Old track = ${oldTrack}, new track = ${newTrack}`);
      this.modificationQueue.push(workFunction, (error) => {
        if (error) {
          logger.error(`${this} Replace track error:`, error);
          reject(error);
        } else {
          logger.info(`${this}  Replace track done!`);
          resolve();
        }
      });
    });
  }
  _parseSsrcInfoFromSourceRemove(sourceRemoveElem, currentRemoteSdp) {
    const removeSsrcInfo = [];
    jquery__WEBPACK_IMPORTED_MODULE_1___default()(sourceRemoveElem).each((i1, content) => {
      const name = jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).attr("name");
      let lines = "";
      jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(function() {
        const semantics = this.getAttribute("semantics");
        const ssrcs2 = jquery__WEBPACK_IMPORTED_MODULE_1___default()(this).find(">source").map(function() {
          return this.getAttribute("ssrc");
        }).get();
        if (ssrcs2.length) {
          lines += `a=ssrc-group:${semantics} ${ssrcs2.join(" ")}\r
`;
        }
      });
      const ssrcs = [];
      const tmp = jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]');
      tmp.each(function() {
        const ssrc = jquery__WEBPACK_IMPORTED_MODULE_1___default()(this).attr("ssrc");
        ssrcs.push(ssrc);
      });
      currentRemoteSdp.media.forEach((media, i2) => {
        if (!_sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].findLine(media, `a=mid:${name}`)) {
          return;
        }
        if (!removeSsrcInfo[i2]) {
          removeSsrcInfo[i2] = "";
        }
        ssrcs.forEach((ssrc) => {
          const ssrcLines = _sdp_SDPUtil__WEBPACK_IMPORTED_MODULE_14__["default"].findLines(media, `a=ssrc:${ssrc}`);
          if (ssrcLines.length) {
            removeSsrcInfo[i2] += `${ssrcLines.join("\r\n")}\r
`;
          }
        });
        removeSsrcInfo[i2] += lines;
      });
    });
    return removeSsrcInfo;
  }
  _verifyNoSSRCChanged(operationName, oldSDP) {
    const currentLocalSDP = new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](this.peerconnection.localDescription.sdp);
    let sdpDiff = new _sdp_SDPDiffer__WEBPACK_IMPORTED_MODULE_13__["default"](oldSDP, currentLocalSDP);
    const addedMedia = sdpDiff.getNewMedia();
    if (Object.keys(addedMedia).length) {
      logger.error(`${this} - some SSRC were added on ${operationName}`, addedMedia);
      return false;
    }
    sdpDiff = new _sdp_SDPDiffer__WEBPACK_IMPORTED_MODULE_13__["default"](currentLocalSDP, oldSDP);
    const removedMedia = sdpDiff.getNewMedia();
    if (Object.keys(removedMedia).length) {
      logger.error(`${this} - some SSRCs were removed on ${operationName}`, removedMedia);
      return false;
    }
    return true;
  }
  addTrackToPc(track) {
    return this._addRemoveTrack(false, track).then(() => {
      if (track.isVideoTrack()) {
        return this.peerconnection.configureSenderVideoEncodings(track);
      }
    });
  }
  removeTrackFromPc(track) {
    return this._addRemoveTrack(true, track);
  }
  _addRemoveTrack(isRemove, track) {
    if (!track) {
      return Promise.reject('invalid "track" argument value');
    }
    const operationName = isRemove ? "removeTrack" : "addTrack";
    const workFunction = (finishedCallback) => {
      const tpc = this.peerconnection;
      if (!tpc) {
        finishedCallback(`Error:  tried ${operationName} track with no active peer connection`);
        return;
      }
      const oldLocalSDP = tpc.localDescription.sdp;
      const operationPromise = isRemove ? tpc.removeTrackFromPc(track) : tpc.addTrackToPc(track);
      operationPromise.then((shouldRenegotiate) => {
        if (shouldRenegotiate && oldLocalSDP && tpc.remoteDescription.sdp) {
          this._renegotiate().then(() => {
            !this.usesUnifiedPlan && this._verifyNoSSRCChanged(operationName, new _sdp_SDP__WEBPACK_IMPORTED_MODULE_12__["default"](oldLocalSDP));
            finishedCallback();
          });
        } else {
          finishedCallback();
        }
      }, finishedCallback);
    };
    logger.debug(`${this} Queued ${operationName} task`);
    return new Promise((resolve, reject) => {
      this.modificationQueue.push(workFunction, (error) => {
        if (error) {
          logger.error(`${this} ${operationName} failed`);
          reject(error);
        } else {
          logger.debug(`${this} ${operationName} done`);
          resolve();
        }
      });
    });
  }
  setP2pVideoTransferActive(videoActive) {
    if (!this.peerconnection) {
      return Promise.reject('Can not modify video transfer active state, before "initialize" is called');
    }
    const logVideoStr = videoActive ? "video active" : "video inactive";
    logger.info(`${this} Queued make ${logVideoStr} task`);
    const workFunction = (finishedCallback) => {
      const isSessionActive = this.state === _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.ACTIVE;
      if (this._localVideoActive !== videoActive) {
        this._localVideoActive = videoActive;
        if (this.isP2P && isSessionActive) {
          this.sendContentModify();
        }
      }
      this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive);
      this._renegotiate().then(() => finishedCallback()).catch((error) => finishedCallback(error));
    };
    return new Promise((resolve, reject) => {
      this.modificationQueue.push(workFunction, (error) => {
        if (error) {
          logger.error(`${this} Make ${logVideoStr} task failed!`);
          reject(error);
        } else {
          logger.debug(`${this} Make ${logVideoStr} task done!`);
          resolve();
        }
      });
    });
  }
  modifyContents(jingleContents) {
    const newVideoSenders = JingleSessionPC.parseVideoSenders(jingleContents);
    const sourceMaxFrameHeights = JingleSessionPC.parseSourceMaxFrameHeight(jingleContents);
    if (sourceMaxFrameHeights) {
      this.remoteSourceMaxFrameHeights = sourceMaxFrameHeights;
      this.eventEmitter.emit(_MediaSessionEvents__WEBPACK_IMPORTED_MODULE_21__["default"].REMOTE_SOURCE_CONSTRAINTS_CHANGED, this, sourceMaxFrameHeights);
    }
    if (newVideoSenders === null) {
      logger.error(`${this} - failed to parse video "senders" attribute in "content-modify" action`);
      return;
    }
    const workFunction = (finishedCallback) => {
      if (this._assertNotEnded() && this._modifyRemoteVideoActive(newVideoSenders)) {
        this._renegotiate().then(finishedCallback, finishedCallback);
      } else {
        finishedCallback();
      }
    };
    logger.debug(`${this} queued "content-modify" task(video senders="${newVideoSenders}")`);
    this.modificationQueue.push(workFunction, (error) => {
      if (error) {
        logger.error(`${this} "content-modify" failed`, error);
      } else {
        logger.debug(`${this} "content-modify" task(video senders="${newVideoSenders}") done`);
      }
    });
  }
  _modifyRemoteVideoActive(remoteVideoSenders) {
    const isRemoteVideoActive = remoteVideoSenders === "both" || remoteVideoSenders === "initiator" && this.isInitiator || remoteVideoSenders === "responder" && !this.isInitiator;
    if (isRemoteVideoActive !== this._remoteVideoActive) {
      logger.debug(`${this} new remote video active: ${isRemoteVideoActive}`);
      this._remoteVideoActive = isRemoteVideoActive;
      return this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive);
    }
    return false;
  }
  notifyMySSRCUpdate(oldSDP, newSDP) {
    if (this.state !== _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.ACTIVE) {
      logger.warn(`${this} Skipping SSRC update in '${this.state} ' state.`);
      return;
    }
    if (!this.connection.connected) {
      if (!this._cachedOldLocalSdp) {
        this._cachedOldLocalSdp = oldSDP;
      }
      this._cachedNewLocalSdp = newSDP;
      logger.warn(`${this} Not sending SSRC update while the signaling is disconnected`);
      return;
    }
    this._cachedOldLocalSdp = void 0;
    this._cachedNewLocalSdp = void 0;
    const getSignaledSourceInfo = (sdpDiffer2) => {
      const newMedia = sdpDiffer2.getNewMedia();
      let ssrcs = [];
      let mediaType = null;
      Object.keys(newMedia).forEach((mediaIndex) => {
        const signaledSsrcs = Object.keys(newMedia[mediaIndex].ssrcs);
        mediaType = newMedia[mediaIndex].mid;
        if (signaledSsrcs === null || signaledSsrcs === void 0 ? void 0 : signaledSsrcs.length) {
          ssrcs = ssrcs.concat(signaledSsrcs);
        }
      });
      return {
        mediaType,
        ssrcs
      };
    };
    let sdpDiffer = new _sdp_SDPDiffer__WEBPACK_IMPORTED_MODULE_13__["default"](newSDP, oldSDP);
    const remove = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      to: this.remoteJid,
      type: "set"
    }).c("jingle", {
      xmlns: "urn:xmpp:jingle:1",
      action: "source-remove",
      initiator: this.initiatorJid,
      sid: this.sid
    });
    sdpDiffer.toJingle(remove);
    const ctx = {};
    const removedSsrcInfo = getSignaledSourceInfo(sdpDiffer);
    if (removedSsrcInfo.ssrcs.length) {
      logger.info(`${this} Sending source-remove for ${removedSsrcInfo.mediaType} ssrcs=${removedSsrcInfo.ssrcs}`);
      this.connection.sendIQ(remove, () => {
        this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.SOURCE_REMOVE, this, ctx);
      }, this.newJingleErrorHandler(remove, (error) => {
        this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.SOURCE_REMOVE_ERROR, this, error, ctx);
      }), IQ_TIMEOUT);
    }
    sdpDiffer = new _sdp_SDPDiffer__WEBPACK_IMPORTED_MODULE_13__["default"](oldSDP, newSDP);
    const add = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      to: this.remoteJid,
      type: "set"
    }).c("jingle", {
      xmlns: "urn:xmpp:jingle:1",
      action: "source-add",
      initiator: this.initiatorJid,
      sid: this.sid
    });
    sdpDiffer.toJingle(add);
    const addedSsrcInfo = getSignaledSourceInfo(sdpDiffer);
    if (addedSsrcInfo.ssrcs.length) {
      logger.info(`${this} Sending source-add for ${addedSsrcInfo.mediaType} ssrcs=${addedSsrcInfo.ssrcs}`);
      this.connection.sendIQ(add, () => {
        this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.SOURCE_ADD, this, ctx);
      }, this.newJingleErrorHandler(add, (error) => {
        this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_9__.XMPPEvents.SOURCE_ADD_ERROR, this, error, addedSsrcInfo.mediaType, ctx);
      }), IQ_TIMEOUT);
    }
  }
  newJingleErrorHandler(request, failureCb) {
    return (errResponse) => {
      const error = {};
      const errorElSel = jquery__WEBPACK_IMPORTED_MODULE_1___default()(errResponse).find("error");
      if (errorElSel.length) {
        error.code = errorElSel.attr("code");
        const errorReasonSel = jquery__WEBPACK_IMPORTED_MODULE_1___default()(errResponse).find("error :first");
        if (errorReasonSel.length) {
          error.reason = errorReasonSel[0].tagName;
        }
        const errorMsgSel = errorElSel.find(">text");
        if (errorMsgSel.length) {
          error.msg = errorMsgSel.text();
        }
      }
      if (!errResponse) {
        error.reason = "timeout";
      }
      error.session = this.toString();
      if (failureCb) {
        failureCb(error);
      } else if (this.state === _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.ENDED && error.reason === "item-not-found") {
        logger.debug(`${this} Jingle error: ${JSON.stringify(error)}`);
      } else {
        _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_17___default().callErrorHandler(new Error(`Jingle error: ${JSON.stringify(error)}`));
      }
    };
  }
  getIceConnectionState() {
    return this.peerconnection.getConnectionState();
  }
  close() {
    this.state = _JingleSessionState__WEBPACK_IMPORTED_MODULE_20__.ENDED;
    this.establishmentDuration = void 0;
    if (this.peerconnection) {
      this.peerconnection.onicecandidate = null;
      this.peerconnection.oniceconnectionstatechange = null;
      this.peerconnection.onnegotiationneeded = null;
      this.peerconnection.onsignalingstatechange = null;
    }
    logger.debug(`${this} Clearing modificationQueue`);
    this.modificationQueue.clear();
    logger.debug(`${this} Queued PC close task`);
    this.modificationQueue.push((finishCallback) => {
      this.peerconnection && this.peerconnection.close();
      finishCallback();
      logger.debug(`${this} PC close task done!`);
    });
    logger.debug(`${this} Shutdown modificationQueue!`);
    this.modificationQueue.shutdown();
  }
  toString() {
    return `JingleSessionPC[session=${this.isP2P ? "P2P" : "JVB"},initiator=${this.isInitiator},sid=${this.sid}]`;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleSessionState.js":
/*!************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleSessionState.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ACTIVE: () => (/* binding */ ACTIVE),
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   JingleSessionState: () => (/* binding */ JingleSessionState),
/* harmony export */   PENDING: () => (/* binding */ PENDING)
/* harmony export */ });

var JingleSessionState;
(function(JingleSessionState2) {
  JingleSessionState2["PENDING"] = "pending";
  JingleSessionState2["ACTIVE"] = "active";
  JingleSessionState2["ENDED"] = "ended";
})(JingleSessionState || (JingleSessionState = {}));
;
const PENDING = JingleSessionState.PENDING;
const ACTIVE = JingleSessionState.ACTIVE;
const ENDED = JingleSessionState.ENDED;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/Lobby.js":
/*!***********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/Lobby.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Lobby)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");




const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const EMAIL_COMMAND = "email";
class Lobby {
  constructor(room) {
    this.xmpp = room.xmpp;
    this.mainRoom = room;
    const maybeJoinLobbyRoom = this._maybeJoinLobbyRoom.bind(this);
    this.mainRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.LOCAL_ROLE_CHANGED, maybeJoinLobbyRoom);
    this.mainRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, maybeJoinLobbyRoom);
    this.mainRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, (jid) => {
      this.lobbyRoomJid = jid;
    });
  }
  isSupported() {
    return this.xmpp.lobbySupported;
  }
  enable() {
    if (!this.isSupported()) {
      return Promise.reject(new Error("Lobby not supported!"));
    }
    return new Promise((resolve, reject) => {
      this.mainRoom.setMembersOnly(true, resolve, reject);
    });
  }
  disable() {
    if (!this.isSupported() || !this.mainRoom.isModerator() || !this.lobbyRoom || !this.mainRoom.membersOnlyEnabled) {
      return;
    }
    this.mainRoom.setMembersOnly(false);
  }
  sendMessage(message) {
    if (this.lobbyRoom) {
      this.lobbyRoom.sendMessage(JSON.stringify(message), "json-message");
    }
  }
  sendPrivateMessage(id, message) {
    if (this.lobbyRoom) {
      this.lobbyRoom.sendPrivateMessage(id, JSON.stringify(message), "json-message");
    }
  }
  getLocalId() {
    if (this.lobbyRoom) {
      return strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(this.lobbyRoom.myroomjid);
    }
  }
  addMessageListener(listener) {
    if (this.lobbyRoom) {
      const handler = (participantId, message) => {
        listener(message, strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(participantId));
      };
      this.lobbyRoom.on(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.JSON_MESSAGE_RECEIVED, handler);
      return handler;
    }
  }
  removeMessageHandler(handler) {
    if (this.lobbyRoom) {
      this.lobbyRoom.off(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.JSON_MESSAGE_RECEIVED, handler);
    }
  }
  leave() {
    if (this.lobbyRoom) {
      return this.lobbyRoom.leave().then(() => {
        this.lobbyRoom = void 0;
        logger.info("Lobby room left!");
      }).catch(() => {
      });
    }
    return Promise.reject(new Error("The lobby has already been left"));
  }
  setLobbyRoomJid(jid) {
    this.lobbyRoomJid = jid;
  }
  _maybeJoinLobbyRoom() {
    if (!this.isSupported()) {
      return;
    }
    const isModerator = this.mainRoom.joined && this.mainRoom.isModerator();
    if (isModerator && this.mainRoom.membersOnlyEnabled && !this.lobbyRoom) {
      this.join().then(() => logger.info("Joined lobby room")).catch((e) => logger.error("Failed joining lobby", e));
    }
  }
  join(displayName, email) {
    const isModerator = this.mainRoom.joined && this.mainRoom.isModerator();
    if (!this.lobbyRoomJid) {
      return Promise.reject(new Error("Missing lobbyRoomJid, cannot join lobby room."));
    }
    const roomName = strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getNodeFromJid(this.lobbyRoomJid);
    const customDomain = strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getDomainFromJid(this.lobbyRoomJid);
    this.lobbyRoom = this.xmpp.createRoom(roomName, {
      customDomain,
      disableDiscoInfo: true,
      disableFocus: true,
      enableLobby: false
    });
    if (displayName) {
      this.lobbyRoom.addOrReplaceInPresence("nick", {
        attributes: { xmlns: "http://jabber.org/protocol/nick" },
        value: displayName
      });
    }
    if (isModerator) {
      this.lobbyRoom.addPresenceListener(EMAIL_COMMAND, (node, from) => {
        this.mainRoom.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_LOBBY_MEMBER_UPDATED, from, { email: node.value });
      });
      this.lobbyRoom.addEventListener(
        _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_MEMBER_JOINED,
        (from, nick, role, isHiddenDomain, statsID, status, identity, botType, jid) => {
          if (Object.values(this.mainRoom.members).find((m) => m.jid === jid)) {
            return;
          }
          for (const room of Object.values(this.mainRoom.getBreakoutRooms()._rooms)) {
            if (Object.values(room.participants).find((p) => p.jid === jid)) {
              return;
            }
          }
          this.mainRoom.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_LOBBY_MEMBER_JOINED, strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(from), nick, identity ? identity.avatar : void 0);
        }
      );
      this.lobbyRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_MEMBER_LEFT, (from) => {
        this.mainRoom.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(from));
      });
      this.lobbyRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_DESTROYED, () => {
        Object.keys(this.lobbyRoom.members).forEach((j) => this.mainRoom.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(j)));
        this.lobbyRoom.clean();
        this.lobbyRoom = void 0;
        logger.info("Lobby room left(destroyed)!");
      });
    } else {
      this.lobbyRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.KICKED, (isSelfPresence) => {
        if (isSelfPresence) {
          this.mainRoom.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_DENIED_ACCESS);
          this.lobbyRoom.clean();
          return;
        }
      });
      this.mainRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.INVITE_MESSAGE_RECEIVED, (roomJid, from, txt, invitePassword) => {
        logger.debug(`Received approval to join ${roomJid} ${from} ${txt}`);
        if (roomJid === this.mainRoom.roomjid) {
          this.mainRoom.join(invitePassword);
        }
      });
      this.lobbyRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_DESTROYED, (reason, jid) => {
        if (jid) {
          this.mainRoom.join();
          return;
        }
        this.lobbyRoom.clean();
        this.mainRoom.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_DESTROYED, reason);
      });
      this.mainRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_JOINED, () => {
        this.leave();
      });
    }
    return new Promise((resolve, reject) => {
      this.lobbyRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.MUC_JOINED, () => {
        resolve();
        if (email && !isModerator) {
          this.lobbyRoom.addOrReplaceInPresence(EMAIL_COMMAND, { value: email }) && this.lobbyRoom.sendPresence();
        }
      });
      this.lobbyRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.ROOM_JOIN_ERROR, reject);
      this.lobbyRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR, reject);
      this.lobbyRoom.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_2__.XMPPEvents.ROOM_CONNECT_ERROR, reject);
      this.lobbyRoom.join();
    });
  }
  denyAccess(id) {
    if (!this.isSupported() || !this.mainRoom.isModerator()) {
      return;
    }
    const jid = Object.keys(this.lobbyRoom.members).find((j) => strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(j) === id);
    if (jid) {
      this.lobbyRoom.kick(jid);
    } else {
      logger.error(`Not found member for ${id} in lobby room.`);
    }
  }
  approveAccess(id) {
    if (!this.isSupported() || !this.mainRoom.isModerator()) {
      return;
    }
    let mainRoomJid = this.mainRoom.roomjid;
    if (this.mainRoom.getBreakoutRooms().isBreakoutRoom()) {
      mainRoomJid = this.mainRoom.getBreakoutRooms().getMainRoomJid();
    }
    const memberRoomJid = Object.keys(this.lobbyRoom.members).find((j) => strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(j) === id);
    if (memberRoomJid) {
      const jid = this.lobbyRoom.members[memberRoomJid].jid;
      const msgToSend = (0,strophe_js__WEBPACK_IMPORTED_MODULE_1__.$msg)({ to: mainRoomJid }).c("x", { xmlns: "http://jabber.org/protocol/muc#user" }).c("invite", { to: jid });
      this.xmpp.connection.sendIQ(
        msgToSend,
        () => {
        },
        (e) => {
          logger.error(`Error sending invite for ${jid}`, e);
        }
      );
    } else {
      logger.error(`Not found member for ${memberRoomJid} in lobby room.`);
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/MediaSessionEvents.js":
/*!************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/MediaSessionEvents.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var MediaSessionEvents;
(function(MediaSessionEvents2) {
  MediaSessionEvents2["REMOTE_SOURCE_CONSTRAINTS_CHANGED"] = "media_session.REMOTE_SOURCE_CONSTRAINTS_CHANGED";
})(MediaSessionEvents || (MediaSessionEvents = {}));
;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MediaSessionEvents);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/ResumeTask.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/ResumeTask.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResumeTask)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _connectivity_NetworkInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../connectivity/NetworkInfo */ "../../lib-jitsi-meet/dist/esm/modules/connectivity/NetworkInfo.js");
/* harmony import */ var _util_Retry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Retry */ "../../lib-jitsi-meet/dist/esm/modules/util/Retry.js");




const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class ResumeTask {
  constructor(stropheConnection) {
    this._stropheConn = stropheConnection;
    this._resumeRetryN = 0;
    this._retryDelay = void 0;
  }
  get retryDelay() {
    return this._retryDelay;
  }
  schedule() {
    this._cancelResume();
    this._resumeRetryN += 1;
    this._networkOnlineListener = _connectivity_NetworkInfo__WEBPACK_IMPORTED_MODULE_1__["default"].addEventListener(_connectivity_NetworkInfo__WEBPACK_IMPORTED_MODULE_1__.NETWORK_INFO_EVENT, ({ isOnline }) => {
      if (isOnline) {
        this._scheduleResume();
      } else {
        this._cancelResume();
      }
    });
    _connectivity_NetworkInfo__WEBPACK_IMPORTED_MODULE_1__["default"].isOnline() && this._scheduleResume();
  }
  _scheduleResume() {
    if (this._resumeTimeout) {
      return;
    }
    this._resumeRetryN = Math.min(3, this._resumeRetryN);
    this._retryDelay = (0,_util_Retry__WEBPACK_IMPORTED_MODULE_2__.getJitterDelay)(
      this._resumeRetryN,
      this._resumeRetryN * 1500,
      3
    );
    logger.info(`Will try to resume the XMPP connection in ${this.retryDelay}ms`);
    this._resumeTimeout = setTimeout(() => this._resumeConnection(), this.retryDelay);
  }
  _cancelResume() {
    if (this._resumeTimeout) {
      logger.info("Canceling connection resume task");
      clearTimeout(this._resumeTimeout);
      this._resumeTimeout = void 0;
      this._retryDelay = void 0;
    }
  }
  _resumeConnection() {
    const { streamManagement } = this._stropheConn;
    const resumeToken = streamManagement.getResumeToken();
    if (!resumeToken) {
      return;
    }
    logger.info("Trying to resume the XMPP connection");
    const url = new URL(this._stropheConn.service);
    let { search } = url;
    const pattern = /(previd=)([\w-]+)/;
    const oldToken = search.match(pattern);
    if (oldToken && oldToken.indexOf(resumeToken) === -1) {
      search = search.replace(pattern, `$1${resumeToken}`);
    } else if (!oldToken) {
      search += search.indexOf("?") === -1 ? `?previd=${resumeToken}` : `&previd=${resumeToken}`;
    }
    url.search = search;
    this._stropheConn.service = url.toString();
    streamManagement.resume();
  }
  cancel() {
    this._cancelResume();
    this._resumeRetryN = 0;
    if (this._networkOnlineListener) {
      this._networkOnlineListener();
      this._networkOnlineListener = null;
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/RoomMetadata.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/RoomMetadata.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RoomMetadata)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.isequal */ "../../lib-jitsi-meet/node_modules/lodash.isequal/index.js");
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _xmpp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./xmpp */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/xmpp.js");






const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class RoomMetadata {
  constructor(room) {
    this.room = room;
    this._handleMessages = this._handleMessages.bind(this);
    this.room.xmpp.addListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.ROOM_METADATA_EVENT, this._handleMessages);
    this._metadata = {};
  }
  dispose() {
    this.room.xmpp.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.ROOM_METADATA_EVENT, this._handleMessages);
  }
  setMetadata(key, data) {
    if (!this.isSupported() || !this.room.isModerator()) {
      logger.error(`Cannot set room metadata - supported:${this.isSupported()},
                moderator:${this.room.isModerator()}`);
      return;
    }
    const message = {
      key,
      data
    };
    this._sendMessage(message);
  }
  getMetadata() {
    return this._metadata;
  }
  isSupported() {
    return Boolean(this.getComponentAddress());
  }
  getComponentAddress() {
    return this.room.xmpp.roomMetadataComponentAddress;
  }
  _handleMessages(payload) {
    const { metadata } = payload;
    if (!metadata || lodash_isequal__WEBPACK_IMPORTED_MODULE_1___default()(this._metadata, metadata)) {
      return;
    }
    this._metadata = metadata;
    this.room.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.ROOM_METADATA_UPDATED, metadata);
  }
  _sendMessage(message) {
    message[_xmpp__WEBPACK_IMPORTED_MODULE_4__.JITSI_MEET_MUC_TYPE] = "room_metadata";
    const msg = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$msg)({ to: this.getComponentAddress() });
    msg.c("room_metadata", {
      room: this.room.roomjid,
      xmlns: "http://jitsi.org/jitmeet"
    }, JSON.stringify(message)).up();
    this.room.xmpp.connection.send(msg);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/SignalingLayerImpl.js":
/*!************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/SignalingLayerImpl.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SOURCE_INFO_PRESENCE_ELEMENT: () => (/* binding */ SOURCE_INFO_PRESENCE_ELEMENT),
/* harmony export */   "default": () => (/* binding */ SignalingLayerImpl)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/SignalingEvents */ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingEvents.js");
/* harmony import */ var _service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/RTC/SignalingLayer */ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingLayer.js");
/* harmony import */ var _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../service/RTC/VideoType */ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js");
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");
/* harmony import */ var _ChatRoom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ChatRoom */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/ChatRoom.js");










const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const SOURCE_INFO_PRESENCE_ELEMENT = "SourceInfo";
class SignalingLayerImpl extends _service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_4__["default"] {
  constructor() {
    super();
    this.ssrcOwners = /* @__PURE__ */ new Map();
    this.chatRoom = null;
    this._localSourceState = {};
    this._remoteSourceState = {};
    this._sourceNames = /* @__PURE__ */ new Map();
  }
  _addLocalSourceInfoToPresence() {
    if (this.chatRoom) {
      return this.chatRoom.addOrReplaceInPresence(SOURCE_INFO_PRESENCE_ELEMENT, { value: JSON.stringify(this._localSourceState) });
    }
    return false;
  }
  _bindChatRoomEventHandlers(room) {
    const emitAudioMutedEvent = (endpointId, muted) => {
      this.eventEmitter.emit(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_3__.PEER_MUTED_CHANGED, endpointId, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.AUDIO, muted);
    };
    this._audioMuteHandler = (node, from) => {
      if (!this._doesEndpointSendNewSourceInfo(from)) {
        emitAudioMutedEvent(from, node.value === "true");
      }
    };
    room.addPresenceListener("audiomuted", this._audioMuteHandler);
    const emitVideoMutedEvent = (endpointId, muted) => {
      this.eventEmitter.emit(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_3__.PEER_MUTED_CHANGED, endpointId, _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO, muted);
    };
    this._videoMuteHandler = (node, from) => {
      if (!this._doesEndpointSendNewSourceInfo(from)) {
        emitVideoMutedEvent(from, node.value === "true");
      }
    };
    room.addPresenceListener("videomuted", this._videoMuteHandler);
    const emitVideoTypeEvent = (endpointId, videoType) => {
      this.eventEmitter.emit(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_3__.PEER_VIDEO_TYPE_CHANGED, endpointId, videoType);
    };
    this._videoTypeHandler = (node, from) => {
      if (!this._doesEndpointSendNewSourceInfo(from)) {
        emitVideoTypeEvent(from, node.value);
      }
    };
    room.addPresenceListener("videoType", this._videoTypeHandler);
    this._sourceInfoHandler = (node, mucNick) => {
      var _a;
      const endpointId = mucNick;
      const { value } = node;
      const sourceInfoJSON = JSON.parse(value);
      const emitEventsFromHere = this._doesEndpointSendNewSourceInfo(endpointId);
      const endpointSourceState = this._remoteSourceState[endpointId] || (this._remoteSourceState[endpointId] = {});
      for (const sourceName of Object.keys(sourceInfoJSON)) {
        let sourceChanged = false;
        const mediaType = (0,_service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_4__.getMediaTypeFromSourceName)(sourceName);
        const newMutedState = Boolean(sourceInfoJSON[sourceName].muted);
        const oldSourceState = endpointSourceState[sourceName] || (endpointSourceState[sourceName] = { sourceName });
        if (oldSourceState.muted !== newMutedState) {
          sourceChanged = true;
          oldSourceState.muted = newMutedState;
          if (emitEventsFromHere && !this._localSourceState[sourceName]) {
            this.eventEmitter.emit(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_3__.SOURCE_MUTED_CHANGED, sourceName, newMutedState);
          }
        }
        const newVideoType = mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO ? (_a = sourceInfoJSON[sourceName].videoType) !== null && _a !== void 0 ? _a : _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__.VideoType.CAMERA : void 0;
        if (oldSourceState.videoType !== newVideoType) {
          oldSourceState.videoType = newVideoType;
          sourceChanged = true;
          if (emitEventsFromHere && !this._localSourceState[sourceName]) {
            this.eventEmitter.emit(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_3__.SOURCE_VIDEO_TYPE_CHANGED, sourceName, newVideoType);
          }
        }
        if (sourceChanged && _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_7__["default"].isSsrcRewritingSupported()) {
          this.eventEmitter.emit(_service_RTC_SignalingEvents__WEBPACK_IMPORTED_MODULE_3__.SOURCE_UPDATED, sourceName, mucNick, newMutedState, newVideoType);
        }
      }
      const newSourceNames = Object.keys(sourceInfoJSON);
      for (const sourceName of Object.keys(endpointSourceState)) {
        if (newSourceNames.indexOf(sourceName) === -1) {
          delete endpointSourceState[sourceName];
        }
      }
    };
    room.addPresenceListener("SourceInfo", this._sourceInfoHandler);
    this._memberLeftHandler = (jid) => {
      const endpointId = strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getResourceFromJid(jid);
      delete this._remoteSourceState[endpointId];
      for (const [key, value] of this.ssrcOwners.entries()) {
        if (value === endpointId) {
          delete this._sourceNames[key];
        }
      }
    };
    room.addEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__.XMPPEvents.MUC_MEMBER_LEFT, this._memberLeftHandler);
  }
  _doesEndpointSendNewSourceInfo(endpointId) {
    var _a;
    const presence = (_a = this.chatRoom) === null || _a === void 0 ? void 0 : _a.getLastPresence(endpointId);
    return Boolean(presence && presence.find((node) => node.tagName === SOURCE_INFO_PRESENCE_ELEMENT));
  }
  _logOwnerChangedMessage(message) {
    if (_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_7__["default"].isSsrcRewritingSupported()) {
      logger.debug(message);
    } else {
      logger.error(message);
    }
  }
  getPeerMediaInfo(owner, mediaType, sourceName) {
    var _a, _b, _c;
    const legacyGetPeerMediaInfo = () => {
      if (this.chatRoom) {
        return this.chatRoom.getMediaPresenceInfo(owner, mediaType);
      }
      logger.warn("Requested peer media info, before room was set");
    };
    const lastPresence = (_a = this.chatRoom) === null || _a === void 0 ? void 0 : _a.getLastPresence(owner);
    if (!lastPresence) {
      logger.warn(`getPeerMediaInfo - no presence stored for: ${owner}`);
      return;
    }
    if (!this._doesEndpointSendNewSourceInfo(owner)) {
      return legacyGetPeerMediaInfo();
    }
    if (sourceName) {
      return this.getPeerSourceInfo(owner, sourceName);
    }
    const mediaInfo = {
      muted: true
    };
    if (mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO) {
      mediaInfo.videoType = void 0;
      const codecListNode = (0,_ChatRoom__WEBPACK_IMPORTED_MODULE_8__.filterNodeFromPresenceJSON)(lastPresence, "jitsi_participant_codecList");
      const codecTypeNode = (0,_ChatRoom__WEBPACK_IMPORTED_MODULE_8__.filterNodeFromPresenceJSON)(lastPresence, "jitsi_participant_codecType");
      if (codecListNode.length) {
        mediaInfo.codecList = (_c = (_b = codecListNode[0].value) === null || _b === void 0 ? void 0 : _b.split(",")) !== null && _c !== void 0 ? _c : [];
      } else if (codecTypeNode.length > 0) {
        mediaInfo.codecType = codecTypeNode[0].value;
      }
    }
    return mediaInfo;
  }
  getPeerSourceInfo(owner, sourceName) {
    var _a;
    const mediaType = (0,_service_RTC_SignalingLayer__WEBPACK_IMPORTED_MODULE_4__.getMediaTypeFromSourceName)(sourceName);
    const mediaInfo = {
      muted: true,
      videoType: mediaType === _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_2__.MediaType.VIDEO ? _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__.VideoType.CAMERA : void 0
    };
    return this._remoteSourceState[owner] ? (_a = this._remoteSourceState[owner][sourceName]) !== null && _a !== void 0 ? _a : mediaInfo : void 0;
  }
  getSSRCOwner(ssrc) {
    return this.ssrcOwners.get(ssrc);
  }
  getTrackSourceName(ssrc) {
    return this._sourceNames.get(ssrc);
  }
  removeSSRCOwners(ssrcList) {
    if (!(ssrcList === null || ssrcList === void 0 ? void 0 : ssrcList.length)) {
      return;
    }
    for (const ssrc of ssrcList) {
      this.ssrcOwners.delete(ssrc);
    }
  }
  setChatRoom(room) {
    const oldChatRoom = this.chatRoom;
    this.chatRoom = room;
    if (oldChatRoom) {
      oldChatRoom.removePresenceListener("audiomuted", this._audioMuteHandler);
      oldChatRoom.removePresenceListener("videomuted", this._videoMuteHandler);
      oldChatRoom.removePresenceListener("videoType", this._videoTypeHandler);
      this._sourceInfoHandler && oldChatRoom.removePresenceListener(SOURCE_INFO_PRESENCE_ELEMENT, this._sourceInfoHandler);
      this._memberLeftHandler && oldChatRoom.removeEventListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__.XMPPEvents.MUC_MEMBER_LEFT, this._memberLeftHandler);
    }
    if (room) {
      this._bindChatRoomEventHandlers(room);
      this._addLocalSourceInfoToPresence();
    }
  }
  setSSRCOwner(ssrc, endpointId) {
    if (typeof ssrc !== "number") {
      throw new TypeError(`SSRC(${ssrc}) must be a number`);
    }
    const existingOwner = this.ssrcOwners.get(ssrc);
    if (existingOwner && existingOwner !== endpointId) {
      this._logOwnerChangedMessage(`SSRC owner re-assigned from ${existingOwner} to ${endpointId}`);
    }
    this.ssrcOwners.set(ssrc, endpointId);
  }
  setTrackMuteStatus(sourceName, muted) {
    if (!this._localSourceState[sourceName]) {
      this._localSourceState[sourceName] = {};
    }
    this._localSourceState[sourceName].muted = muted;
    logger.debug(`Mute state of ${sourceName} changed to muted=${muted}`);
    if (this.chatRoom) {
      return this._addLocalSourceInfoToPresence();
    }
    return false;
  }
  setTrackSourceName(ssrc, sourceName) {
    if (typeof ssrc !== "number") {
      throw new TypeError(`SSRC(${ssrc}) must be a number`);
    }
    const existingName = this._sourceNames.get(ssrc);
    if (existingName && existingName !== sourceName) {
      this._logOwnerChangedMessage(`SSRC(${ssrc}) sourceName re-assigned from ${existingName} to ${sourceName}`);
    }
    this._sourceNames.set(ssrc, sourceName);
  }
  setTrackVideoType(sourceName, videoType) {
    if (!this._localSourceState[sourceName]) {
      this._localSourceState[sourceName] = {};
    }
    if (this._localSourceState[sourceName].videoType !== videoType) {
      this._localSourceState[sourceName].videoType = videoType === _service_RTC_VideoType__WEBPACK_IMPORTED_MODULE_5__.VideoType.CAMERA ? void 0 : videoType;
      return this._addLocalSourceInfoToPresence();
    }
    return false;
  }
  updateSsrcOwnersOnLeave(id) {
    const ssrcs = Array.from(this.ssrcOwners).filter((entry) => entry[1] === id).map((entry) => entry[0]);
    if (!(ssrcs === null || ssrcs === void 0 ? void 0 : ssrcs.length)) {
      return;
    }
    this.removeSSRCOwners(ssrcs);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/StropheLastSuccess.js":
/*!************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/StropheLastSuccess.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LastRequestTracker)
/* harmony export */ });

class LastRequestTracker {
  constructor() {
    this._lastSuccess = null;
    this._lastFailedMessage = null;
  }
  startTracking(xmppConnection, stropheConnection) {
    const originalRawInput = stropheConnection.rawInput;
    stropheConnection.rawInput = (...args) => {
      const rawMessage = args[0];
      if (rawMessage.includes("failure")) {
        this._lastFailedMessage = rawMessage;
      }
      if (xmppConnection.connected) {
        this._lastSuccess = Date.now();
      }
      originalRawInput.apply(stropheConnection, args);
    };
  }
  getLastFailedMessage() {
    return this._lastFailedMessage;
  }
  getTimeSinceLastSuccess() {
    return this._lastSuccess ? Date.now() - this._lastSuccess : null;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/XmppConnection.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/XmppConnection.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ XmppConnection)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var strophejs_plugin_stream_management__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strophejs-plugin-stream-management */ "../../lib-jitsi-meet/node_modules/strophejs-plugin-stream-management/lib/strophe.stream-management.js");
/* harmony import */ var strophejs_plugin_stream_management__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(strophejs_plugin_stream_management__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");
/* harmony import */ var _ResumeTask__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ResumeTask */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/ResumeTask.js");
/* harmony import */ var _StropheLastSuccess__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./StropheLastSuccess */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/StropheLastSuccess.js");
/* harmony import */ var _strophe_ping__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./strophe.ping */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.ping.js");








const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class XmppConnection extends _util_Listenable__WEBPACK_IMPORTED_MODULE_3__["default"] {
  static get Events() {
    return {
      CONN_STATUS_CHANGED: "CONN_STATUS_CHANGED",
      CONN_SHARD_CHANGED: "CONN_SHARD_CHANGED"
    };
  }
  static get Status() {
    return strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status;
  }
  constructor({ enableWebsocketResume, websocketKeepAlive, websocketKeepAliveUrl, serviceUrl, shard, xmppPing }) {
    super();
    this._options = {
      enableWebsocketResume: typeof enableWebsocketResume === "undefined" ? true : enableWebsocketResume,
      pingOptions: xmppPing,
      shard,
      websocketKeepAlive: typeof websocketKeepAlive === "undefined" ? 60 * 1e3 : Number(websocketKeepAlive),
      websocketKeepAliveUrl
    };
    this._stropheConn = new strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Connection(serviceUrl);
    this._usesWebsocket = serviceUrl.startsWith("ws:") || serviceUrl.startsWith("wss:");
    this._stropheConn.maxRetries = 3;
    this._rawInputTracker = new _StropheLastSuccess__WEBPACK_IMPORTED_MODULE_5__["default"]();
    this._rawInputTracker.startTracking(this, this._stropheConn);
    this._resumeTask = new _ResumeTask__WEBPACK_IMPORTED_MODULE_4__["default"](this._stropheConn);
    this._deferredIQs = [];
    this.addConnectionPlugin("ping", new _strophe_ping__WEBPACK_IMPORTED_MODULE_6__["default"]({
      getTimeSinceLastServerResponse: () => this.getTimeSinceLastSuccess(),
      onPingThresholdExceeded: () => this._onPingErrorThresholdExceeded(),
      pingOptions: xmppPing
    }));
    this._oneSuccessfulConnect = false;
  }
  get connected() {
    const websocket = this._stropheConn && this._stropheConn._proto && this._stropheConn._proto.socket;
    return (this._status === strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.CONNECTED || this._status === strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.ATTACHED) && (!this.isUsingWebSocket || websocket && websocket.readyState === WebSocket.OPEN);
  }
  get disco() {
    return this._stropheConn.disco;
  }
  get disconnecting() {
    return this._stropheConn.disconnecting === true;
  }
  get domain() {
    return this._stropheConn.domain;
  }
  get isUsingWebSocket() {
    return this._usesWebsocket;
  }
  get jid() {
    return this._stropheConn.jid;
  }
  get lastResponseHeaders() {
    return this._stropheConn._proto && this._stropheConn._proto.lastResponseHeaders;
  }
  get logger() {
    return this._stropheConn.logger;
  }
  get options() {
    return this._stropheConn.options;
  }
  get pingDomain() {
    var _a;
    return ((_a = this._options.pingOptions) === null || _a === void 0 ? void 0 : _a.domain) || this.domain;
  }
  get service() {
    return this._stropheConn.service;
  }
  set shard(value) {
    this._options.shard = value;
    if (this._oneSuccessfulConnect) {
      this._maybeStartWSKeepAlive();
    }
  }
  get status() {
    return this._status;
  }
  addConnectionPlugin(name, plugin) {
    this[name] = plugin;
    plugin.init(this);
  }
  addHandler(...args) {
    return this._stropheConn.addHandler(...args);
  }
  deleteHandler(...args) {
    this._stropheConn.deleteHandler(...args);
  }
  attach(jid, sid, rid, callback, ...args) {
    this._stropheConn.attach(jid, sid, rid, this._stropheConnectionCb.bind(this, callback), ...args);
  }
  connect(jid, pass, callback, ...args) {
    this._stropheConn.connect(jid, pass, this._stropheConnectionCb.bind(this, callback), ...args);
  }
  _stropheConnectionCb(targetCallback, status, ...args) {
    var _a;
    this._status = status;
    let blockCallback = false;
    if (status === strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.CONNECTED || status === strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.ATTACHED) {
      this._maybeEnableStreamResume();
      if (this._usesWebsocket && this._oneSuccessfulConnect) {
        this._keepAliveAndCheckShard();
      }
      this._oneSuccessfulConnect = true;
      this._maybeStartWSKeepAlive();
      this._processDeferredIQs();
      this._resumeTask.cancel();
      this.ping.startInterval(((_a = this._options.pingOptions) === null || _a === void 0 ? void 0 : _a.domain) || this.domain);
    } else if (status === strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.DISCONNECTED) {
      this.ping.stopInterval();
      blockCallback = this._tryResumingConnection();
      if (!blockCallback) {
        clearTimeout(this._wsKeepAlive);
      }
    }
    if (!blockCallback) {
      targetCallback(status, ...args);
      this.eventEmitter.emit(XmppConnection.Events.CONN_STATUS_CHANGED, status);
    }
  }
  _clearDeferredIQs() {
    for (const deferred of this._deferredIQs) {
      deferred.reject(new Error("disconnect"));
    }
    this._deferredIQs = [];
  }
  closeWebsocket() {
    if (this._stropheConn && this._stropheConn._proto) {
      this._stropheConn._proto._closeSocket();
      this._stropheConn._proto._onClose(null);
    }
  }
  disconnect(...args) {
    this._resumeTask.cancel();
    clearTimeout(this._wsKeepAlive);
    this._clearDeferredIQs();
    this._stropheConn.disconnect(...args);
  }
  flush(...args) {
    this._stropheConn.flush(...args);
  }
  getTimeSinceLastSuccess() {
    return this._rawInputTracker.getTimeSinceLastSuccess();
  }
  getLastFailedMessage() {
    return this._rawInputTracker.getLastFailedMessage();
  }
  _maybeEnableStreamResume() {
    if (!this._options.enableWebsocketResume) {
      return;
    }
    const { streamManagement } = this._stropheConn;
    if (!this.isUsingWebSocket) {
      logger.warn("Stream resume enabled, but WebSockets are not enabled");
    } else if (!streamManagement) {
      logger.warn("Stream resume enabled, but Strophe streamManagement plugin is not installed");
    } else if (!streamManagement.isSupported()) {
      logger.warn("Stream resume enabled, but XEP-0198 is not supported by the server");
    } else if (!streamManagement.getResumeToken()) {
      logger.info("Enabling XEP-0198 stream management");
      streamManagement.enable(true);
    }
  }
  _maybeStartWSKeepAlive() {
    const { websocketKeepAlive } = this._options;
    if (this._usesWebsocket && websocketKeepAlive > 0) {
      this._wsKeepAlive || logger.info(`WebSocket keep alive interval: ${websocketKeepAlive}ms`);
      clearTimeout(this._wsKeepAlive);
      const intervalWithJitter = websocketKeepAlive + Math.random() * 60 * 1e3;
      logger.debug(`Scheduling next WebSocket keep-alive in ${intervalWithJitter}ms`);
      this._wsKeepAlive = setTimeout(() => this._keepAliveAndCheckShard().then(() => this._maybeStartWSKeepAlive()), intervalWithJitter);
    }
  }
  _keepAliveAndCheckShard() {
    const { shard, websocketKeepAliveUrl } = this._options;
    const url = websocketKeepAliveUrl ? websocketKeepAliveUrl : this.service.replace("wss://", "https://").replace("ws://", "http://");
    return fetch(url).then((response) => {
      if (!shard) {
        return;
      }
      const responseShard = response.headers.get("x-jitsi-shard");
      if (responseShard !== shard) {
        logger.error(`Detected that shard changed from ${shard} to ${responseShard}`);
        this.eventEmitter.emit(XmppConnection.Events.CONN_SHARD_CHANGED);
      }
    }).catch((error) => {
      logger.error(`Websocket Keep alive failed for url: ${url}`, { error });
    });
  }
  _processDeferredIQs() {
    for (const deferred of this._deferredIQs) {
      if (deferred.iq) {
        clearTimeout(deferred.timeout);
        const timeLeft = Date.now() - deferred.start;
        this.sendIQ(deferred.iq, (result) => deferred.resolve(result), (error) => deferred.reject(error), timeLeft);
      }
    }
    this._deferredIQs = [];
  }
  send(stanza) {
    var _a, _b, _c;
    if (!this.connected) {
      logger.error(`Trying to send stanza while not connected. Status:${this._status} Proto:${this.isUsingWebSocket ? (_c = (_b = (_a = this._stropheConn) === null || _a === void 0 ? void 0 : _a._proto) === null || _b === void 0 ? void 0 : _b.socket) === null || _c === void 0 ? void 0 : _c.readyState : "bosh"}`);
      throw new Error("Not connected");
    }
    this._stropheConn.send(stanza);
  }
  sendIQ(elem, callback, errback, timeout) {
    if (!this.connected) {
      errback("Not connected");
      return;
    }
    return this._stropheConn.sendIQ(elem, callback, errback, timeout);
  }
  sendIQ2(iq, { timeout }) {
    return new Promise((resolve, reject) => {
      if (this.connected) {
        this.sendIQ(iq, (result) => resolve(result), (error) => reject(error), timeout);
      } else {
        const deferred = {
          iq,
          resolve,
          reject,
          start: Date.now(),
          timeout: setTimeout(() => {
            deferred.iq = void 0;
            reject(void 0);
          }, timeout)
        };
        this._deferredIQs.push(deferred);
      }
    });
  }
  _onPingErrorThresholdExceeded() {
    if (this.isUsingWebSocket) {
      logger.warn("Ping error threshold exceeded - killing the WebSocket");
      this.closeWebsocket();
    }
  }
  sendPresence(elem, callback, errback, timeout) {
    if (!this.connected) {
      errback("Not connected");
      return;
    }
    this._stropheConn.sendPresence(elem, callback, errback, timeout);
  }
  sendUnavailableBeacon() {
    if (!navigator.sendBeacon || this._stropheConn.disconnecting || !this._stropheConn.connected) {
      return false;
    }
    this._stropheConn._changeConnectStatus(strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.DISCONNECTING);
    this._stropheConn.disconnecting = true;
    const body = this._stropheConn._proto._buildBody().attrs({
      type: "terminate"
    });
    const pres = (0,strophe_js__WEBPACK_IMPORTED_MODULE_1__.$pres)({
      xmlns: strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.NS.CLIENT,
      type: "unavailable"
    });
    body.cnode(pres.tree());
    const res = navigator.sendBeacon(this.service.indexOf("https://") === -1 ? `https:${this.service}` : this.service, strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.serialize(body.tree()));
    logger.info(`Successfully send unavailable beacon ${res}`);
    this._stropheConn._proto._abortAllRequests();
    this._stropheConn._doDisconnect();
    return true;
  }
  _tryResumingConnection() {
    const { streamManagement } = this._stropheConn;
    const resumeToken = streamManagement && streamManagement.getResumeToken();
    if (resumeToken) {
      this._resumeTask.schedule();
      return true;
    }
    return false;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/moderator.js":
/*!***************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/moderator.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Moderator)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");
/* harmony import */ var _settings_Settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../settings/Settings */ "../../lib-jitsi-meet/dist/esm/modules/settings/Settings.js");






const AuthenticationEvents = __webpack_require__(/*! ../../service/authentication/AuthenticationEvents */ "../../lib-jitsi-meet/dist/esm/service/authentication/AuthenticationEvents.js");
const { XMPPEvents } = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
const GlobalOnErrorHandler = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
function createExpBackoffTimer(step) {
  let count = 1;
  const maxTimeout = 12e4;
  return function(reset) {
    if (reset) {
      count = 1;
      return;
    }
    const timeout = Math.pow(2, count - 1);
    count += 1;
    return Math.min(timeout * step, maxTimeout);
  };
}
function Moderator(roomName, xmpp, emitter, options) {
  var _a, _b;
  this.roomName = roomName;
  this.getNextTimeout = createExpBackoffTimer(1e3);
  this.getNextErrorTimeout = createExpBackoffTimer(1e3);
  this.options = options;
  this.externalAuthEnabled = false;
  this.sipGatewayEnabled = false;
  this.eventEmitter = emitter;
  this.connection = xmpp.connection;
  this.targetJid = (_a = this.options.hosts) === null || _a === void 0 ? void 0 : _a.focus;
  if (!this.targetJid) {
    this.targetJid = `focus.${(_b = this.options.hosts) === null || _b === void 0 ? void 0 : _b.domain}`;
  }
  this.targetUrl = this.options.conferenceRequestUrl;
  this.mode = this.targetUrl ? "http" : "xmpp";
  logger.info(`Using ${this.mode} for conference requests.`);
  this.focusUserJids = /* @__PURE__ */ new Set();
  if (options.focusUserJid) {
    this.focusUserJids.add(options.focusUserJid);
  }
  function listener(event) {
    if (event.data && event.data.sessionId) {
      if (event.origin !== window.location.origin) {
        logger.warn(`Ignoring sessionId from different origin: ${event.origin}`);
        return;
      }
      _settings_Settings__WEBPACK_IMPORTED_MODULE_4__["default"].sessionId = event.data.sessionId;
    }
  }
  if (window.addEventListener) {
    window.addEventListener("message", listener, false);
  } else {
    window.attachEvent("onmessage", listener);
  }
}
Moderator.prototype.isFocusJid = function(jid) {
  if (!jid) {
    return false;
  }
  for (const focusJid of this.focusUserJids) {
    if (jid.indexOf(`${focusJid}/`) === 0) {
      return true;
    }
  }
  return false;
};
Moderator.prototype.isExternalAuthEnabled = function() {
  return this.externalAuthEnabled;
};
Moderator.prototype.isSipGatewayEnabled = function() {
  return this.sipGatewayEnabled;
};
Moderator.prototype._createConferenceRequest = function() {
  var _a, _b;
  const { sessionId } = _settings_Settings__WEBPACK_IMPORTED_MODULE_4__["default"];
  const config = this.options;
  const properties = {};
  if (config.startAudioMuted !== void 0) {
    properties.startAudioMuted = config.startAudioMuted;
  }
  if (config.startVideoMuted !== void 0) {
    properties.startVideoMuted = config.startVideoMuted;
  }
  const rtcstatsEnabled = (_b = (_a = config === null || config === void 0 ? void 0 : config.analytics) === null || _a === void 0 ? void 0 : _a.rtcstatsEnabled) !== null && _b !== void 0 ? _b : false;
  if (!rtcstatsEnabled) {
    properties.rtcstatsEnabled = false;
  }
  const conferenceRequest = {
    properties,
    machineUid: _settings_Settings__WEBPACK_IMPORTED_MODULE_4__["default"].machineId,
    room: this.roomName
  };
  if (sessionId) {
    conferenceRequest.sessionId = sessionId;
  }
  return conferenceRequest;
};
Moderator.prototype._createConferenceIq = function() {
  const conferenceRequest = this._createConferenceRequest();
  const elem = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
    to: this.targetJid,
    type: "set"
  });
  elem.c("conference", {
    xmlns: "http://jitsi.org/protocol/focus",
    room: this.roomName,
    "machine-uid": conferenceRequest.machineUid
  });
  if (conferenceRequest.sessionId) {
    elem.attrs({ "session-id": conferenceRequest.sessionId });
  }
  for (const k in conferenceRequest.properties) {
    if (conferenceRequest.properties.hasOwnProperty(k)) {
      elem.c("property", {
        name: k,
        value: conferenceRequest.properties[k]
      }).up();
    }
  }
  if (_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_3__["default"].isJoinAsVisitorSupported()) {
    elem.c("property", {
      name: "visitors-version",
      value: 1
    }).up();
  }
  return elem;
};
Moderator.prototype._parseConferenceIq = function(resultIq) {
  const conferenceRequest = { properties: {} };
  conferenceRequest.focusJid = jquery__WEBPACK_IMPORTED_MODULE_1___default()(resultIq).find("conference").attr("focusjid");
  conferenceRequest.sessionId = jquery__WEBPACK_IMPORTED_MODULE_1___default()(resultIq).find("conference").attr("session-id");
  conferenceRequest.identity = jquery__WEBPACK_IMPORTED_MODULE_1___default()(resultIq).find(">conference").attr("identity");
  conferenceRequest.ready = jquery__WEBPACK_IMPORTED_MODULE_1___default()(resultIq).find("conference").attr("ready") === "true";
  conferenceRequest.vnode = jquery__WEBPACK_IMPORTED_MODULE_1___default()(resultIq).find("conference").attr("vnode");
  if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(resultIq).find(">conference>property[name='authentication'][value='true']").length > 0) {
    conferenceRequest.properties.authentication = "true";
  }
  if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(resultIq).find(">conference>property[name='externalAuth'][value='true']").length > 0) {
    conferenceRequest.properties.externalAuth = "true";
  }
  if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(resultIq).find(">conference>property[name='sipGatewayEnabled'][value='true']").length > 0) {
    conferenceRequest.properties.sipGatewayEnabled = "true";
  }
  return conferenceRequest;
};
Moderator.prototype.sendConferenceRequest = function() {
  return new Promise((resolve) => {
    if (this.mode === "xmpp") {
      logger.info(`Sending conference request over XMPP to ${this.targetJid}`);
      this.connection.sendIQ(this._createConferenceIq(), (result) => this._handleIqSuccess(result, resolve), (error) => this._handleIqError(error, resolve));
      this.connection.flush();
    } else {
      logger.info(`Sending conference request over HTTP to ${this.targetUrl}`);
      fetch(this.targetUrl, {
        method: "POST",
        body: JSON.stringify(this._createConferenceRequest()),
        headers: { "Content-Type": "application/json" }
      }).then((response) => {
        if (!response.ok) {
          response.text().then((text) => {
            logger.warn(`Received HTTP ${response.status} ${response.statusText}. Body: ${text}`);
            const sessionError = response.status === 400 && text.indexOf("400 invalid-session") > 0;
            const notAuthorized = response.status === 403;
            this._handleError(sessionError, notAuthorized, resolve);
          }).catch((error) => {
            logger.warn(`Error: ${error}`);
            this._handleError();
          });
          return;
        }
        response.json().then((resultJson) => {
          this._handleSuccess(resultJson, resolve);
        });
      }).catch((error) => {
        logger.warn(`Error: ${error}`);
        this._handleError();
      });
    }
  });
};
Moderator.prototype._handleSuccess = function(conferenceRequest, callback) {
  this.getNextErrorTimeout(true);
  if (conferenceRequest.focusJid) {
    logger.info(`Adding focus JID: ${conferenceRequest.focusJid}`);
    this.focusUserJids.add(conferenceRequest.focusJid);
  } else {
    logger.warn("Conference request response contained no focusJid.");
  }
  const authenticationEnabled = conferenceRequest.properties.authentication === "true";
  logger.info(`Authentication enabled: ${authenticationEnabled}`);
  this.externalAuthEnabled = conferenceRequest.properties.externalAuth === "true";
  logger.info(`External authentication enabled: ${this.externalAuthEnabled}`);
  if (!this.externalAuthEnabled && conferenceRequest.sessionId) {
    logger.info(`Received sessionId: ${conferenceRequest.sessionId}`);
    _settings_Settings__WEBPACK_IMPORTED_MODULE_4__["default"].sessionId = conferenceRequest.sessionId;
  }
  this.eventEmitter.emit(AuthenticationEvents.IDENTITY_UPDATED, authenticationEnabled, conferenceRequest.identity);
  this.sipGatewayEnabled = conferenceRequest.properties.sipGatewayEnabled;
  logger.info(`Sip gateway enabled: ${this.sipGatewayEnabled}`);
  if (conferenceRequest.ready) {
    this.getNextTimeout(true);
    if (conferenceRequest.vnode && !this.options.iAmRecorder && !this.options.iAmSipGateway) {
      logger.warn(`Redirected to: ${conferenceRequest.vnode} with focusJid ${conferenceRequest.focusJid} }`);
      this.eventEmitter.emit(XMPPEvents.REDIRECTED, conferenceRequest.vnode, conferenceRequest.focusJid);
      return;
    }
    logger.info("Conference-request successful, ready to join the MUC.");
    callback();
  } else {
    const waitMs = this.getNextTimeout();
    logger.info(`Not ready yet, will retry in ${waitMs} ms.`);
    window.setTimeout(() => this.sendConferenceRequest().then(callback), waitMs);
  }
};
Moderator.prototype._handleError = function(sessionError, notAuthorized, callback) {
  if (sessionError) {
    logger.info("Session expired! - removing");
    _settings_Settings__WEBPACK_IMPORTED_MODULE_4__["default"].sessionId = void 0;
  }
  if (notAuthorized) {
    logger.warn("Unauthorized to start the conference");
    this.eventEmitter.emit(XMPPEvents.AUTHENTICATION_REQUIRED);
    return;
  }
  const waitMs = this.getNextErrorTimeout();
  if (sessionError && waitMs < 6e4) {
    logger.info(`Invalid session, will retry after ${waitMs} ms.`);
    this.getNextTimeout(true);
    window.setTimeout(() => this.sendConferenceRequest().then(callback), waitMs);
  } else {
    const errmsg = "Failed to get a successful response, giving up.";
    const error = new Error(errmsg);
    logger.error(errmsg, error);
    GlobalOnErrorHandler.callErrorHandler(error);
    this.eventEmitter.emit(XMPPEvents.FOCUS_DISCONNECTED);
  }
};
Moderator.prototype._handleIqError = function(error, callback) {
  const reservationErr = jquery__WEBPACK_IMPORTED_MODULE_1___default()(error).find(">error>reservation-error");
  if (reservationErr.length) {
    const errorCode = reservationErr.attr("error-code");
    const errorTextNode = jquery__WEBPACK_IMPORTED_MODULE_1___default()(error).find(">error>text");
    let errorMsg;
    if (errorTextNode) {
      errorMsg = errorTextNode.text();
    }
    this.eventEmitter.emit(XMPPEvents.RESERVATION_ERROR, errorCode, errorMsg);
    return;
  }
  const invalidSession = Boolean(jquery__WEBPACK_IMPORTED_MODULE_1___default()(error).find(">error>session-invalid").length || jquery__WEBPACK_IMPORTED_MODULE_1___default()(error).find(">error>not-acceptable").length);
  const notAuthorized = jquery__WEBPACK_IMPORTED_MODULE_1___default()(error).find(">error>not-authorized").length > 0;
  if (notAuthorized && strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getDomainFromJid(error.getAttribute("to")) !== this.options.hosts.anonymousdomain) {
    this.externalAuthEnabled = true;
  }
  this._handleError(invalidSession, notAuthorized, callback);
};
Moderator.prototype._handleIqSuccess = function(result, callback) {
  const conferenceRequest = this._parseConferenceIq(result);
  this._handleSuccess(conferenceRequest, callback);
};
Moderator.prototype.authenticate = function() {
  return new Promise((resolve, reject) => {
    this.connection.sendIQ(this._createConferenceIq(), (result) => {
      const sessionId = jquery__WEBPACK_IMPORTED_MODULE_1___default()(result).find("conference").attr("session-id");
      if (sessionId) {
        logger.info(`Received sessionId:  ${sessionId}`);
        _settings_Settings__WEBPACK_IMPORTED_MODULE_4__["default"].sessionId = sessionId;
      } else {
        logger.warn("Response did not contain a session-id");
      }
      resolve();
    }, (errorIq) => reject({
      error: jquery__WEBPACK_IMPORTED_MODULE_1___default()(errorIq).find("iq>error :first").prop("tagName"),
      message: jquery__WEBPACK_IMPORTED_MODULE_1___default()(errorIq).find("iq>error>text").text()
    }));
  });
};
Moderator.prototype.getLoginUrl = function(urlCallback, failureCallback) {
  this._getLoginUrl(false, urlCallback, failureCallback);
};
Moderator.prototype._getLoginUrl = function(popup, urlCb, failureCb) {
  const iq = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
    to: this.targetJid,
    type: "get"
  });
  const attrs = {
    xmlns: "http://jitsi.org/protocol/focus",
    room: this.roomName,
    "machine-uid": _settings_Settings__WEBPACK_IMPORTED_MODULE_4__["default"].machineId
  };
  let str = "auth url";
  if (popup) {
    attrs.popup = true;
    str = `POPUP ${str}`;
  }
  iq.c("login-url", attrs);
  function reportError(errmsg, err) {
    GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));
    logger.error(errmsg, err);
    failureCb(err);
  }
  this.connection.sendIQ(iq, (result) => {
    let url = jquery__WEBPACK_IMPORTED_MODULE_1___default()(result).find("login-url").attr("url");
    url = decodeURIComponent(url);
    if (url) {
      logger.info(`Got ${str}: ${url}`);
      urlCb(url);
    } else {
      reportError(`Failed to get ${str} from the focus`, result);
    }
  }, reportError.bind(void 0, `Get ${str} error`));
};
Moderator.prototype.getPopupLoginUrl = function(urlCallback, failureCallback) {
  this._getLoginUrl(true, urlCallback, failureCallback);
};
Moderator.prototype.logout = function(callback) {
  const iq = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
    to: this.targetJid,
    type: "set"
  });
  const { sessionId } = _settings_Settings__WEBPACK_IMPORTED_MODULE_4__["default"];
  if (!sessionId) {
    callback();
    return;
  }
  iq.c("logout", {
    xmlns: "http://jitsi.org/protocol/focus",
    "session-id": sessionId
  });
  this.connection.sendIQ(iq, (result) => {
    let logoutUrl = jquery__WEBPACK_IMPORTED_MODULE_1___default()(result).find("logout").attr("logout-url");
    if (logoutUrl) {
      logoutUrl = decodeURIComponent(logoutUrl);
    }
    logger.info(`Log out OK, url: ${logoutUrl}`, result);
    _settings_Settings__WEBPACK_IMPORTED_MODULE_4__["default"].sessionId = void 0;
    callback(logoutUrl);
  }, (error) => {
    const errmsg = "Logout error";
    GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));
    logger.error(errmsg, error);
  });
};


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/sha1.js":
/*!**********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/sha1.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SHA1)
/* harmony export */ });

function core_sha1(x, len) {
  x[len >> 5] |= 128 << 24 - len % 32;
  x[(len + 64 >> 9 << 4) + 15] = len;
  var w = new Array(80);
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  var e = -1009589776;
  var i, j, t, olda, oldb, oldc, oldd, olde;
  for (i = 0; i < x.length; i += 16) {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;
    olde = e;
    for (j = 0; j < 80; j++) {
      if (j < 16) {
        w[j] = x[i + j];
      } else {
        w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
      }
      t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }
    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return [a, b, c, d, e];
}
function sha1_ft(t, b, c, d) {
  if (t < 20) {
    return b & c | ~b & d;
  }
  if (t < 40) {
    return b ^ c ^ d;
  }
  if (t < 60) {
    return b & c | b & d | c & d;
  }
  return b ^ c ^ d;
}
function sha1_kt(t) {
  return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
}
function core_hmac_sha1(key, data) {
  var bkey = str2binb(key);
  if (bkey.length > 16) {
    bkey = core_sha1(bkey, key.length * 8);
  }
  var ipad = new Array(16), opad = new Array(16);
  for (var i = 0; i < 16; i++) {
    ipad[i] = bkey[i] ^ 909522486;
    opad[i] = bkey[i] ^ 1549556828;
  }
  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
  return core_sha1(opad.concat(hash), 512 + 160);
}
function safe_add(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function rol(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function str2binb(str) {
  var bin = [];
  var mask = 255;
  for (var i = 0; i < str.length * 8; i += 8) {
    bin[i >> 5] |= (str.charCodeAt(i / 8) & mask) << 24 - i % 32;
  }
  return bin;
}
function binb2b64(binarray) {
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  var triplet, j;
  for (var i = 0; i < binarray.length * 4; i += 3) {
    triplet = (binarray[i >> 2] >> 8 * (3 - i % 4) & 255) << 16 | (binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4) & 255) << 8 | binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4) & 255;
    for (j = 0; j < 4; j++) {
      if (i * 8 + j * 6 > binarray.length * 32) {
        str += "=";
      } else {
        str += tab.charAt(triplet >> 6 * (3 - j) & 63);
      }
    }
  }
  return str;
}
function binb2str(bin) {
  var str = "";
  var mask = 255;
  for (var i = 0; i < bin.length * 32; i += 8) {
    str += String.fromCharCode(bin[i >> 5] >>> 24 - i % 32 & mask);
  }
  return str;
}
const SHA1 = {
  b64_hmac_sha1: function(key, data) {
    return binb2b64(core_hmac_sha1(key, data));
  },
  b64_sha1: function(s) {
    return binb2b64(core_sha1(str2binb(s), s.length * 8));
  },
  binb2str,
  core_hmac_sha1,
  str_hmac_sha1: function(key, data) {
    return binb2str(core_hmac_sha1(key, data));
  },
  str_sha1: function(s) {
    return binb2str(core_sha1(str2binb(s), s.length * 8));
  }
};



/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.emuc.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.emuc.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MucConnectionPlugin)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _ChatRoom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ChatRoom */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/ChatRoom.js");
/* harmony import */ var _ConnectionPlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ConnectionPlugin */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/ConnectionPlugin.js");







const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
class MucConnectionPlugin extends _ConnectionPlugin__WEBPACK_IMPORTED_MODULE_5__.ConnectionPluginListenable {
  constructor(xmpp) {
    super();
    this.xmpp = xmpp;
    this.rooms = {};
  }
  init(connection) {
    super.init(connection);
    this.connection.addHandler(this.onPresence.bind(this), null, "presence", null, null, null, null);
    this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, "presence", "unavailable", null);
    this.connection.addHandler(this.onPresenceError.bind(this), null, "presence", "error", null);
    this.connection.addHandler(this.onMessage.bind(this), null, "message", null, null);
    this.connection.addHandler(this.onMute.bind(this), "http://jitsi.org/jitmeet/audio", "iq", "set", null, null);
    this.connection.addHandler(this.onMuteVideo.bind(this), "http://jitsi.org/jitmeet/video", "iq", "set", null, null);
    this.connection.addHandler(this.onVisitors.bind(this), "jitsi:visitors", "iq", "set", null, null);
  }
  createRoom(jid, password, options) {
    const roomJid = strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getBareJidFromJid(jid);
    if (this.isRoomCreated(roomJid)) {
      const errmsg = "You are already in the room!";
      logger.error(errmsg);
      throw new Error(errmsg);
    }
    this.rooms[roomJid] = new _ChatRoom__WEBPACK_IMPORTED_MODULE_4__["default"](this.connection, jid, password, this.xmpp, options);
    this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.EMUC_ROOM_ADDED, this.rooms[roomJid]);
    return this.rooms[roomJid];
  }
  isRoomCreated(roomJid) {
    return roomJid in this.rooms;
  }
  doLeave(jid) {
    this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_3__.XMPPEvents.EMUC_ROOM_REMOVED, this.rooms[jid]);
    delete this.rooms[jid];
  }
  onPresence(pres) {
    const from = pres.getAttribute("from");
    if (pres.getAttribute("type")) {
      return true;
    }
    const room = this.rooms[strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getBareJidFromJid(from)];
    if (!room) {
      return true;
    }
    if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(pres).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="201"]').length) {
      room.createNonAnonymousRoom();
    }
    room.onPresence(pres);
    return true;
  }
  onPresenceUnavailable(pres) {
    const from = pres.getAttribute("from");
    const room = this.rooms[strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getBareJidFromJid(from)];
    if (!room) {
      return true;
    }
    room.onPresenceUnavailable(pres, from);
    return true;
  }
  onPresenceError(pres) {
    const from = pres.getAttribute("from");
    const room = this.rooms[strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getBareJidFromJid(from)];
    if (!room) {
      return true;
    }
    room.onPresenceError(pres, from);
    return true;
  }
  onMessage(msg) {
    const from = msg.getAttribute("from");
    const room = this.rooms[strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getBareJidFromJid(from)];
    if (!room) {
      return true;
    }
    room.onMessage(msg, from);
    return true;
  }
  onMute(iq) {
    const from = iq.getAttribute("from");
    const room = this.rooms[strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getBareJidFromJid(from)];
    if (!room) {
      return true;
    }
    room.onMute(iq);
    return true;
  }
  onMuteVideo(iq) {
    const from = iq.getAttribute("from");
    const room = this.rooms[strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getBareJidFromJid(from)];
    if (!room) {
      return true;
    }
    room.onMuteVideo(iq);
    return true;
  }
  onVisitors(iq) {
    const from = iq.getAttribute("from");
    const room = this.rooms[strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getBareJidFromJid(from)];
    room === null || room === void 0 ? void 0 : room.onVisitorIQ(iq);
    return true;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.jingle.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.jingle.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JingleConnectionPlugin)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");
/* harmony import */ var _service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../service/statistics/AnalyticsEvents */ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js");
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _statistics_statistics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _util_RandomUtil__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/RandomUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/RandomUtil.js");
/* harmony import */ var _util_RandomUtil__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_util_RandomUtil__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _ConnectionPlugin__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ConnectionPlugin */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/ConnectionPlugin.js");
/* harmony import */ var _JingleHelperFunctions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./JingleHelperFunctions */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleHelperFunctions.js");
/* harmony import */ var _JingleSessionPC__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./JingleSessionPC */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/JingleSessionPC.js");













const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
function _parseIceCandidates(transport) {
  const candidates = jquery__WEBPACK_IMPORTED_MODULE_1___default()(transport).find(">candidate");
  const parseCandidates = [];
  candidates.each((_, candidate) => {
    const attributes = candidate.attributes;
    const candidateAttrs = [];
    for (let i = 0; i < attributes.length; i++) {
      const attr = attributes[i];
      candidateAttrs.push(`${attr.name}: ${attr.value}`);
    }
    parseCandidates.push(candidateAttrs.join(" "));
  });
  return parseCandidates;
}
class JingleConnectionPlugin extends _ConnectionPlugin__WEBPACK_IMPORTED_MODULE_9__["default"] {
  constructor(xmpp, eventEmitter, iceConfig) {
    super();
    this.xmpp = xmpp;
    this.eventEmitter = eventEmitter;
    this.sessions = {};
    this.jvbIceConfig = iceConfig.jvb;
    this.p2pIceConfig = iceConfig.p2p;
    this.mediaConstraints = {
      offerToReceiveAudio: true,
      offerToReceiveVideo: true
    };
  }
  init(connection) {
    super.init(connection);
    this.connection.addHandler(this.onJingle.bind(this), "urn:xmpp:jingle:1", "iq", "set", null, null);
  }
  onJingle(iq) {
    var _a;
    const sid = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("jingle").attr("sid");
    const action = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("jingle").attr("action");
    const fromJid = iq.getAttribute("from");
    const ack = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      type: "result",
      to: fromJid,
      id: iq.getAttribute("id")
    });
    let sess = this.sessions[sid];
    if (action !== "session-initiate") {
      if (!sess) {
        ack.attrs({ type: "error" });
        ack.c("error", { type: "cancel" }).c("item-not-found", {
          xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
        }).up().c("unknown-session", {
          xmlns: "urn:xmpp:jingle:errors:1"
        });
        logger.warn(`invalid session id: ${sid}`);
        logger.debug(iq);
        this.connection.send(ack);
        return true;
      }
      if (fromJid !== sess.remoteJid) {
        logger.warn("jid mismatch for session id", sid, sess.remoteJid, iq);
        ack.attrs({ type: "error" });
        ack.c("error", { type: "cancel" }).c("item-not-found", {
          xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
        }).up().c("unknown-session", {
          xmlns: "urn:xmpp:jingle:errors:1"
        });
        this.connection.send(ack);
        return true;
      }
    } else if (sess !== void 0) {
      ack.attrs({ type: "error" });
      ack.c("error", { type: "cancel" }).c("service-unavailable", {
        xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
      }).up();
      logger.warn("duplicate session id", sid, iq);
      this.connection.send(ack);
      return true;
    }
    const now = window.performance.now();
    const isP2P = strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getResourceFromJid(fromJid) !== "focus";
    const jsonMessages = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("jingle>json-message");
    if (jsonMessages === null || jsonMessages === void 0 ? void 0 : jsonMessages.length) {
      let audioVideoSsrcs;
      logger.info(`Found a JSON-encoded element in ${action}, translating to standard Jingle.`);
      for (let i = 0; i < jsonMessages.length; i++) {
        audioVideoSsrcs = (0,_JingleHelperFunctions__WEBPACK_IMPORTED_MODULE_10__.expandSourcesFromJson)(iq, jsonMessages[i]);
      }
      if (audioVideoSsrcs === null || audioVideoSsrcs === void 0 ? void 0 : audioVideoSsrcs.size) {
        const logMessage = [];
        for (const endpoint of audioVideoSsrcs.keys()) {
          logMessage.push(`${endpoint}:[${audioVideoSsrcs.get(endpoint)}]`);
        }
        logger.debug(`Received ${action} from ${fromJid} with sources=${logMessage.join(", ")}`);
      }
    }
    switch (action) {
      case "session-initiate": {
        logger.log("(TIME) received session-initiate:	", now);
        const startMuted = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("jingle>startmuted");
        isP2P && logger.debug(`Received ${action} from ${fromJid}`);
        if (startMuted === null || startMuted === void 0 ? void 0 : startMuted.length) {
          const audioMuted = startMuted.attr(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.AUDIO);
          const videoMuted = startMuted.attr(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_3__.MediaType.VIDEO);
          this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_5__.XMPPEvents.START_MUTED_FROM_FOCUS, audioMuted === "true", videoMuted === "true");
        }
        const pcConfig = isP2P ? this.p2pIceConfig : this.jvbIceConfig;
        sess = new _JingleSessionPC__WEBPACK_IMPORTED_MODULE_11__["default"](
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("jingle").attr("sid"),
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).attr("to"),
          fromJid,
          this.connection,
          this.mediaConstraints,
          JSON.parse(JSON.stringify(pcConfig)),
          isP2P,
          false
        );
        this.sessions[sess.sid] = sess;
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_5__.XMPPEvents.CALL_INCOMING, sess, jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find(">jingle"), now);
        break;
      }
      case "session-accept": {
        const ssrcs = [];
        const contents = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("jingle>content");
        for (const content of contents) {
          const ssrc = jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).find("description").attr("ssrc");
          ssrc && ssrcs.push(ssrc);
        }
        logger.debug(`Received ${action} from ${fromJid} with ssrcs=${ssrcs}`);
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_5__.XMPPEvents.CALL_ACCEPTED, sess, jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find(">jingle"));
        break;
      }
      case "content-modify": {
        logger.debug(`Received ${action} from ${fromJid}`);
        sess.modifyContents(jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find(">jingle"));
        break;
      }
      case "transport-info": {
        const candidates = _parseIceCandidates(jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("jingle>content>transport"));
        logger.debug(`Received ${action} from ${fromJid} for candidates=${candidates.join(", ")}`);
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_5__.XMPPEvents.TRANSPORT_INFO, sess, jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find(">jingle"));
        break;
      }
      case "session-terminate": {
        logger.log("terminating...", sess.sid);
        let reasonCondition = null;
        let reasonText = null;
        if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find(">jingle>reason").length) {
          reasonCondition = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find(">jingle>reason>:first")[0].tagName;
          reasonText = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find(">jingle>reason>text").text();
        }
        logger.debug(`Received ${action} from ${fromJid} disconnect reason=${reasonText}`);
        this.terminate(sess.sid, reasonCondition, reasonText);
        this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_5__.XMPPEvents.CALL_ENDED, sess, reasonCondition, reasonText);
        break;
      }
      case "transport-replace": {
        logger.info("(TIME) Start transport replace:	", now);
        const transport = jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find("jingle>content>transport");
        const candidates = _parseIceCandidates(transport);
        const iceUfrag = jquery__WEBPACK_IMPORTED_MODULE_1___default()(transport).attr("ufrag");
        const icePwd = jquery__WEBPACK_IMPORTED_MODULE_1___default()(transport).attr("pwd");
        const dtlsFingerprint = (_a = jquery__WEBPACK_IMPORTED_MODULE_1___default()(transport).find(">fingerprint")) === null || _a === void 0 ? void 0 : _a.text();
        logger.debug(`Received ${action} from ${fromJid} with iceUfrag=${iceUfrag}, icePwd=${icePwd}, DTLS fingerprint=${dtlsFingerprint}, candidates=${candidates.join(", ")}`);
        _statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__.createJingleEvent)(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__.ACTION_JINGLE_TR_RECEIVED, {
          p2p: isP2P,
          value: now
        }));
        sess.replaceTransport(jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find(">jingle"), () => {
          const successTime = window.performance.now();
          logger.info("(TIME) Transport replace success:	", successTime);
          _statistics_statistics__WEBPACK_IMPORTED_MODULE_6__["default"].sendAnalytics((0,_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__.createJingleEvent)(_service_statistics_AnalyticsEvents__WEBPACK_IMPORTED_MODULE_4__.ACTION_JINGLE_TR_SUCCESS, {
            p2p: isP2P,
            value: successTime
          }));
        }, (error) => {
          _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_7___default().callErrorHandler(error);
          logger.error("Transport replace failed", error);
          sess.sendTransportReject();
        });
        break;
      }
      case "source-add":
        sess.addRemoteStream(jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find(">jingle>content"));
        break;
      case "source-remove":
        sess.removeRemoteStream(jquery__WEBPACK_IMPORTED_MODULE_1___default()(iq).find(">jingle>content"));
        break;
      default:
        logger.warn("jingle action not implemented", action);
        ack.attrs({ type: "error" });
        ack.c("error", { type: "cancel" }).c("bad-request", { xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas" }).up();
        break;
    }
    this.connection.send(ack);
    return true;
  }
  newP2PJingleSession(me, peer) {
    const sess = new _JingleSessionPC__WEBPACK_IMPORTED_MODULE_11__["default"](
      _util_RandomUtil__WEBPACK_IMPORTED_MODULE_8___default().randomHexString(12),
      me,
      peer,
      this.connection,
      this.mediaConstraints,
      this.p2pIceConfig,
      true,
      true
    );
    this.sessions[sess.sid] = sess;
    return sess;
  }
  terminate(sid, reasonCondition, reasonText) {
    if (this.sessions.hasOwnProperty(sid)) {
      if (this.sessions[sid].state !== "ended") {
        this.sessions[sid].onTerminated(reasonCondition, reasonText);
      }
      delete this.sessions[sid];
    }
  }
  getStunAndTurnCredentials() {
    this.connection.sendIQ((0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
      type: "get",
      to: this.xmpp.options.hosts.domain
    }).c("services", { xmlns: "urn:xmpp:extdisco:2" }), (v2Res) => this.onReceiveStunAndTurnCredentials(v2Res), () => {
      logger.warn("getting turn credentials with extdisco:2 failed, trying extdisco:1");
      this.connection.sendIQ((0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
        type: "get",
        to: this.xmpp.options.hosts.domain
      }).c("services", { xmlns: "urn:xmpp:extdisco:1" }), (v1Res) => this.onReceiveStunAndTurnCredentials(v1Res), () => {
        logger.warn("getting turn credentials failed");
        logger.warn("is mod_turncredentials or similar installed and configured?");
      });
    });
  }
  onReceiveStunAndTurnCredentials(res) {
    const iceservers = [];
    jquery__WEBPACK_IMPORTED_MODULE_1___default()(res).find(">services>service").each((idx, el) => {
      el = jquery__WEBPACK_IMPORTED_MODULE_1___default()(el);
      const dict = {};
      const type = el.attr("type");
      switch (type) {
        case "stun":
          dict.urls = `stun:${el.attr("host")}`;
          if (el.attr("port")) {
            dict.urls += `:${el.attr("port")}`;
          }
          iceservers.push(dict);
          break;
        case "turn":
        case "turns": {
          dict.urls = `${type}:`;
          dict.username = el.attr("username");
          dict.urls += el.attr("host");
          const port = el.attr("port");
          if (port) {
            dict.urls += `:${el.attr("port")}`;
          }
          const transport = el.attr("transport");
          if (transport && transport !== "udp") {
            dict.urls += `?transport=${transport}`;
          }
          dict.credential = el.attr("password") || dict.credential;
          iceservers.push(dict);
          break;
        }
      }
    });
    const options = this.xmpp.options;
    for (let i = iceservers.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      const temp = iceservers[i];
      iceservers[i] = iceservers[j];
      iceservers[j] = temp;
    }
    let filter;
    if (options.useTurnUdp) {
      filter = (s) => s.urls.startsWith("turn");
    } else {
      filter = (s) => s.urls.startsWith("turn") && s.urls.indexOf("transport=tcp") >= 0;
    }
    this.jvbIceConfig.iceServers = iceservers.filter(filter);
    this.p2pIceConfig.iceServers = iceservers;
    return iceservers.length > 0;
  }
  getLog() {
    const data = {};
    Object.keys(this.sessions).forEach((sid) => {
      const session = this.sessions[sid];
      const pc = session.peerconnection;
      if (pc && pc.updateLog) {
        data[`jingle_${sid}`] = {
          updateLog: pc.updateLog,
          stats: pc.stats,
          url: window.location.href
        };
      }
    });
    return data;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.logger.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.logger.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ConnectionPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ConnectionPlugin */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/ConnectionPlugin.js");



class StropheLogger extends _ConnectionPlugin__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super();
    this.log = [];
  }
  init(connection) {
    super.init(connection);
    this.connection.rawInput = this.logIncoming.bind(this);
    this.connection.rawOutput = this.logOutgoing.bind(this);
  }
  logIncoming(stanza) {
    this.log.push([new Date().getTime(), "incoming", stanza]);
  }
  logOutgoing(stanza) {
    this.log.push([new Date().getTime(), "outgoing", stanza]);
  }
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  strophe_js__WEBPACK_IMPORTED_MODULE_0__.Strophe.addConnectionPlugin("logger", new StropheLogger());
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.ping.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.ping.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PingConnectionPlugin)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _ConnectionPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ConnectionPlugin */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/ConnectionPlugin.js");





const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const PING_DEFAULT_INTERVAL = 1e4;
const PING_DEFAULT_TIMEOUT = 5e3;
const PING_DEFAULT_THRESHOLD = 2;
class PingConnectionPlugin extends _ConnectionPlugin__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor({ getTimeSinceLastServerResponse, onPingThresholdExceeded, pingOptions = {} }) {
    super();
    this.failedPings = 0;
    this._onPingThresholdExceeded = onPingThresholdExceeded;
    this._getTimeSinceLastServerResponse = getTimeSinceLastServerResponse;
    this.pingInterval = typeof pingOptions.interval === "number" ? pingOptions.interval : PING_DEFAULT_INTERVAL;
    this.pingTimeout = typeof pingOptions.timeout === "number" ? pingOptions.timeout : PING_DEFAULT_TIMEOUT;
    this.pingThreshold = typeof pingOptions.threshold === "number" ? pingOptions.threshold : PING_DEFAULT_THRESHOLD;
    this.pingTimestampsToKeep = Math.round(12e4 / this.pingInterval);
    this.pingExecIntervals = new Array(this.pingTimestampsToKeep);
  }
  init(connection) {
    super.init(connection);
    strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.addNamespace("PING", "urn:xmpp:ping");
  }
  ping(jid, success, error, timeout) {
    this._addPingExecutionTimestamp();
    const iq = (0,strophe_js__WEBPACK_IMPORTED_MODULE_1__.$iq)({
      type: "get",
      to: jid
    });
    iq.c("ping", { xmlns: strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.NS.PING });
    this.connection.sendIQ2(iq, { timeout }).then(success, error);
  }
  startInterval(remoteJid) {
    clearInterval(this.intervalId);
    this.intervalId = window.setInterval(() => {
      const now = Date.now();
      if (this._getTimeSinceLastServerResponse() < now - this._lastServerCheck) {
        this._addPingExecutionTimestamp();
        this._lastServerCheck = now;
        this.failedPings = 0;
        return;
      }
      this.ping(remoteJid, () => {
        this._lastServerCheck = this._getTimeSinceLastServerResponse() + Date.now();
        this.failedPings = 0;
      }, (error) => {
        this.failedPings += 1;
        const errmsg = `Ping ${error ? "error" : "timeout"}`;
        if (this.failedPings >= this.pingThreshold) {
          _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_2___default().callErrorHandler(new Error(errmsg));
          logger.error(errmsg, error);
          this._onPingThresholdExceeded && this._onPingThresholdExceeded();
        } else {
          logger.warn(errmsg, error);
        }
      }, this.pingTimeout);
    }, this.pingInterval);
    logger.info(`XMPP pings will be sent every ${this.pingInterval} ms`);
  }
  stopInterval() {
    if (this.intervalId) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
      this.failedPings = 0;
      logger.info("Ping interval cleared");
    }
  }
  _addPingExecutionTimestamp() {
    this.pingExecIntervals.push(new Date().getTime());
    if (this.pingExecIntervals.length > this.pingTimestampsToKeep) {
      this.pingExecIntervals.shift();
    }
  }
  getPingSuspendTime() {
    const pingIntervals = this.pingExecIntervals.slice();
    pingIntervals.push(new Date().getTime());
    let maxInterval = 0;
    let previousTS = pingIntervals[0];
    pingIntervals.forEach((e) => {
      const currentInterval = e - previousTS;
      if (currentInterval > maxInterval) {
        maxInterval = currentInterval;
      }
      previousTS = e;
    });
    maxInterval -= this.pingInterval;
    return Math.max(maxInterval, 0);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.rayo.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.rayo.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RayoConnectionPlugin)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _ConnectionPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ConnectionPlugin */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/ConnectionPlugin.js");





const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const RAYO_XMLNS = "urn:xmpp:rayo:1";
class RayoConnectionPlugin extends _ConnectionPlugin__WEBPACK_IMPORTED_MODULE_3__["default"] {
  init(connection) {
    super.init(connection);
    this.connection.addHandler(this.onRayo.bind(this), RAYO_XMLNS, "iq", "set", null, null);
  }
  onRayo(iq) {
    logger.info("Rayo IQ", iq);
  }
  dial(to, from, roomName, roomPass, focusMucJid) {
    return new Promise((resolve, reject) => {
      if (!focusMucJid) {
        reject(new Error("Internal error!"));
        return;
      }
      const req = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
        type: "set",
        to: focusMucJid
      });
      req.c("dial", {
        xmlns: RAYO_XMLNS,
        to,
        from
      });
      req.c("header", {
        name: "JvbRoomName",
        value: roomName
      }).up();
      if (roomPass && roomPass.length) {
        req.c("header", {
          name: "JvbRoomPassword",
          value: roomPass
        }).up();
      }
      this.connection.sendIQ(req, (result) => {
        logger.info("Dial result ", result);
        const resource = jquery__WEBPACK_IMPORTED_MODULE_1___default()(result).find("ref").attr("uri");
        this.callResource = resource.substr("xmpp:".length);
        logger.info(`Received call resource: ${this.callResource}`);
        resolve();
      }, (error) => {
        logger.info("Dial error ", error);
        reject(error);
      });
    });
  }
  hangup() {
    return new Promise((resolve, reject) => {
      if (!this.callResource) {
        reject(new Error("No call in progress"));
        logger.warn("No call in progress");
        return;
      }
      const req = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$iq)({
        type: "set",
        to: this.callResource
      });
      req.c("hangup", {
        xmlns: RAYO_XMLNS
      });
      this.connection.sendIQ(req, (result) => {
        logger.info("Hangup result ", result);
        this.callResource = null;
        resolve();
      }, (error) => {
        logger.info("Hangup error ", error);
        this.callResource = null;
        reject(new Error("Hangup error "));
      });
    });
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.util.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.util.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_2__);




const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
let lastErrorStatus = -1;
const resetLastErrorStatusRegExpr = /request id \d+.\d+ got 200/;
const lastErrorStatusRegExpr = /request errored, status: (\d+), number of errors: \d+/;
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.log = function(level, msg) {
    logger.trace("Strophe", level, msg);
    if (typeof msg === "string" && msg.indexOf("Request ") !== -1 && msg.indexOf("timed out (secondary), restarting") !== -1) {
      level = strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.LogLevel.WARN;
    }
    switch (level) {
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.LogLevel.DEBUG:
        if (lastErrorStatus !== -1 && resetLastErrorStatusRegExpr.test(msg)) {
          logger.debug("Reset lastErrorStatus");
          lastErrorStatus = -1;
        }
        break;
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.LogLevel.WARN:
        logger.warn(`Strophe: ${msg}`);
        const errStatusCapture = lastErrorStatusRegExpr.exec(msg);
        if (errStatusCapture && errStatusCapture.length === 2) {
          lastErrorStatus = parseInt(errStatusCapture[1], 10);
          logger.debug(`lastErrorStatus set to: ${lastErrorStatus}`);
        }
        break;
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.LogLevel.ERROR:
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.LogLevel.FATAL:
        msg = `Strophe: ${msg}`;
        _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_2___default().callErrorHandler(new Error(msg));
        logger.error(msg);
        break;
    }
  };
  strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getLastErrorStatus = function() {
    return lastErrorStatus;
  };
  strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.getStatusString = function(status) {
    switch (status) {
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.BINDREQUIRED:
        return "BINDREQUIRED";
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.ERROR:
        return "ERROR";
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.CONNECTING:
        return "CONNECTING";
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.CONNFAIL:
        return "CONNFAIL";
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.AUTHENTICATING:
        return "AUTHENTICATING";
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.AUTHFAIL:
        return "AUTHFAIL";
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.CONNECTED:
        return "CONNECTED";
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.DISCONNECTED:
        return "DISCONNECTED";
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.DISCONNECTING:
        return "DISCONNECTING";
      case strophe_js__WEBPACK_IMPORTED_MODULE_1__.Strophe.Status.ATTACHED:
        return "ATTACHED";
      default:
        return "unknown";
    }
  };
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/modules/xmpp/xmpp.js":
/*!**********************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/modules/xmpp/xmpp.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_STUN_SERVERS: () => (/* binding */ DEFAULT_STUN_SERVERS),
/* harmony export */   FEATURE_E2EE: () => (/* binding */ FEATURE_E2EE),
/* harmony export */   FEATURE_JIGASI: () => (/* binding */ FEATURE_JIGASI),
/* harmony export */   JITSI_MEET_MUC_TYPE: () => (/* binding */ JITSI_MEET_MUC_TYPE),
/* harmony export */   "default": () => (/* binding */ XMPP)
/* harmony export */ });
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jitsi/logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js");
/* harmony import */ var _jitsi_logger__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js");
/* harmony import */ var strophe_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(strophe_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var strophejs_plugin_disco__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! strophejs-plugin-disco */ "../../lib-jitsi-meet/node_modules/strophejs-plugin-disco/lib/strophe.disco.js");
/* harmony import */ var strophejs_plugin_disco__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(strophejs_plugin_disco__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _JitsiConnectionErrors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../JitsiConnectionErrors */ "../../lib-jitsi-meet/dist/esm/JitsiConnectionErrors.js");
/* harmony import */ var _JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../JitsiConnectionEvents */ "../../lib-jitsi-meet/dist/esm/JitsiConnectionEvents.js");
/* harmony import */ var _service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../service/xmpp/XMPPEvents */ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js");
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../browser */ "../../lib-jitsi-meet/dist/esm/modules/browser/index.js");
/* harmony import */ var _e2ee_E2EEncryption__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../e2ee/E2EEncryption */ "../../lib-jitsi-meet/dist/esm/modules/e2ee/E2EEncryption.js");
/* harmony import */ var _flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../flags/FeatureFlags */ "../../lib-jitsi-meet/dist/esm/modules/flags/FeatureFlags.js");
/* harmony import */ var _statistics_statistics__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../statistics/statistics */ "../../lib-jitsi-meet/dist/esm/modules/statistics/statistics.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/GlobalOnErrorHandler */ "../../lib-jitsi-meet/dist/esm/modules/util/GlobalOnErrorHandler.js");
/* harmony import */ var _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _util_Listenable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");
/* harmony import */ var _util_RandomUtil__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../util/RandomUtil */ "../../lib-jitsi-meet/dist/esm/modules/util/RandomUtil.js");
/* harmony import */ var _util_RandomUtil__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_util_RandomUtil__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _Caps__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Caps */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/Caps.js");
/* harmony import */ var _XmppConnection__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./XmppConnection */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/XmppConnection.js");
/* harmony import */ var _strophe_emuc__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./strophe.emuc */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.emuc.js");
/* harmony import */ var _strophe_jingle__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./strophe.jingle */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.jingle.js");
/* harmony import */ var _strophe_logger__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./strophe.logger */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.logger.js");
/* harmony import */ var _strophe_rayo__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./strophe.rayo */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.rayo.js");
/* harmony import */ var _strophe_util__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./strophe.util */ "../../lib-jitsi-meet/dist/esm/modules/xmpp/strophe.util.js");






















const logger = (0,_jitsi_logger__WEBPACK_IMPORTED_MODULE_0__.getLogger)(__filename);
const FAILURE_REGEX = /<failure.*><not-allowed\/><text>(.*)<\/text><\/failure>/gi;
function createConnection({ enableWebsocketResume, serviceUrl = "/http-bind", shard, token, websocketKeepAlive, websocketKeepAliveUrl, xmppPing }) {
  if (token) {
    serviceUrl += `${serviceUrl.indexOf("?") === -1 ? "?" : "&"}token=${token}`;
  }
  return new _XmppConnection__WEBPACK_IMPORTED_MODULE_15__["default"]({
    enableWebsocketResume,
    serviceUrl,
    websocketKeepAlive,
    websocketKeepAliveUrl,
    xmppPing,
    shard
  });
}
function initStropheNativePlugins() {
  (0,_strophe_util__WEBPACK_IMPORTED_MODULE_20__["default"])();
  (0,_strophe_logger__WEBPACK_IMPORTED_MODULE_18__["default"])();
}
const DEFAULT_STUN_SERVERS = [
  { urls: "stun:meet-jit-si-turnrelay.jitsi.net:443" }
];
const JITSI_MEET_MUC_TYPE = "type";
const FEATURE_JIGASI = "http://jitsi.org/protocol/jigasi";
const FEATURE_E2EE = "https://jitsi.org/meet/e2ee";
class XMPP extends _util_Listenable__WEBPACK_IMPORTED_MODULE_12__["default"] {
  constructor(options, token) {
    super();
    this.connection = null;
    this.disconnectInProgress = false;
    this.connectionTimes = {};
    this.options = options;
    this.token = token;
    this.authenticatedUser = false;
    if (!this.options.deploymentInfo) {
      this.options.deploymentInfo = {};
    }
    this._components = [];
    initStropheNativePlugins();
    const xmppPing = options.xmppPing || {};
    xmppPing.domain = options.hosts.domain;
    this.connection = createConnection({
      enableWebsocketResume: options.enableWebsocketResume,
      serviceUrl: options.serviceUrl || options.bosh,
      token,
      websocketKeepAlive: options.websocketKeepAlive,
      websocketKeepAliveUrl: options.websocketKeepAliveUrl,
      xmppPing,
      shard: options.deploymentInfo.shard
    });
    this.connection.on(_XmppConnection__WEBPACK_IMPORTED_MODULE_15__["default"].Events.CONN_SHARD_CHANGED, () => {
      const details = {
        shard_changed: true,
        suspend_time: this.connection.ping.getPingSuspendTime(),
        time_since_last_success: this.connection.getTimeSinceLastSuccess()
      };
      this.eventEmitter.emit(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__.CONNECTION_FAILED, _JitsiConnectionErrors__WEBPACK_IMPORTED_MODULE_4__.OTHER_ERROR, void 0, void 0, details);
    });
    this._initStrophePlugins();
    this.caps = new _Caps__WEBPACK_IMPORTED_MODULE_14__["default"](this.connection, "https://jitsi.org/jitsi-meet");
    this.initFeaturesList();
    jquery__WEBPACK_IMPORTED_MODULE_1___default()(window).on(`${this.options.disableBeforeUnloadHandlers ? "" : "beforeunload "}unload`, (ev) => {
      this.disconnect(ev).catch(() => {
      });
    });
  }
  initFeaturesList() {
    this.caps.addFeature("urn:xmpp:jingle:1");
    this.caps.addFeature("urn:xmpp:jingle:apps:rtp:1");
    this.caps.addFeature("urn:xmpp:jingle:transports:ice-udp:1");
    this.caps.addFeature("urn:xmpp:jingle:apps:dtls:0");
    this.caps.addFeature("urn:xmpp:jingle:transports:dtls-sctp:1");
    this.caps.addFeature("urn:xmpp:jingle:apps:rtp:audio");
    this.caps.addFeature("urn:xmpp:jingle:apps:rtp:video");
    this.caps.addFeature("http://jitsi.org/json-encoded-sources");
    if (!(this.options.disableRtx || !_browser__WEBPACK_IMPORTED_MODULE_7__["default"].supportsRTX())) {
      this.caps.addFeature("urn:ietf:rfc:4588");
    }
    if (this.options.enableOpusRed === true && _browser__WEBPACK_IMPORTED_MODULE_7__["default"].supportsAudioRed()) {
      this.caps.addFeature("http://jitsi.org/opus-red");
    }
    if (typeof this.options.enableRemb === "undefined" || this.options.enableRemb) {
      this.caps.addFeature("http://jitsi.org/remb");
    }
    if (!_browser__WEBPACK_IMPORTED_MODULE_7__["default"].isFirefox() && (typeof this.options.enableTcc === "undefined" || this.options.enableTcc)) {
      this.caps.addFeature("http://jitsi.org/tcc");
    }
    if (_browser__WEBPACK_IMPORTED_MODULE_7__["default"].isChromiumBased() && this.options.enableLipSync === true) {
      logger.info("Lip-sync enabled !");
      this.caps.addFeature("http://jitsi.org/meet/lipsync");
    }
    if (this.connection.rayo) {
      this.caps.addFeature("urn:xmpp:rayo:client:1");
    }
    if (_e2ee_E2EEncryption__WEBPACK_IMPORTED_MODULE_8__.E2EEncryption.isSupported(this.options)) {
      this.caps.addFeature(FEATURE_E2EE, false, true);
    }
    logger.debug("Source-name signaling is enabled");
    this.caps.addFeature("http://jitsi.org/source-name");
    logger.debug("Receiving multiple video streams is enabled");
    this.caps.addFeature("http://jitsi.org/receive-multiple-video-streams");
    if (_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_9__["default"].isSsrcRewritingSupported()) {
      this.caps.addFeature("http://jitsi.org/ssrc-rewriting-1");
    }
    if (_flags_FeatureFlags__WEBPACK_IMPORTED_MODULE_9__["default"].isJoinAsVisitorSupported()) {
      this.caps.addFeature("http://jitsi.org/visitors-1");
    }
  }
  getConnection() {
    return this.connection;
  }
  connectionHandler(credentials = {}, status, msg) {
    const now = window.performance.now();
    const statusStr = strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getStatusString(status).toLowerCase();
    this.connectionTimes[statusStr] = now;
    logger.log(`(TIME) Strophe ${statusStr}${msg ? `[${msg}]` : ""}:	`, now);
    this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__.XMPPEvents.CONNECTION_STATUS_CHANGED, credentials, status, msg);
    this._maybeSendDeploymentInfoStat();
    if (status === strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.CONNECTED || status === strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.ATTACHED) {
      if (this._sysMessageHandler) {
        this.connection._stropheConn.deleteHandler(this._sysMessageHandler);
        this._sysMessageHandler = null;
      }
      this.sendDiscoInfo && this.connection.jingle.getStunAndTurnCredentials();
      logger.info(`My Jabber ID: ${this.connection.jid}`);
      this._resetState();
      this.sendDeploymentInfo = false;
      this.sendDiscoInfo && this.caps.getFeaturesAndIdentities(this.options.hosts.domain).then(({ features, identities }) => {
        if (!features.has(strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.NS.PING)) {
          logger.error(`Ping NOT supported by ${this.options.hosts.domain} - please enable ping in your XMPP server config`);
        }
        this._processDiscoInfoIdentities(identities, void 0);
      }).catch((error) => {
        const errmsg = "Feature discovery error";
        _util_GlobalOnErrorHandler__WEBPACK_IMPORTED_MODULE_11___default().callErrorHandler(new Error(`${errmsg}: ${error}`));
        logger.error(errmsg, error);
        this._maybeSendDeploymentInfoStat(true);
      });
      this.sendDiscoInfo = false;
      if (credentials.password) {
        this.authenticatedUser = true;
      }
      if (this.connection && this.connection.connected && strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getResourceFromJid(this.connection.jid)) {
        this.eventEmitter.emit(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__.CONNECTION_ESTABLISHED, strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getResourceFromJid(this.connection.jid));
      }
    } else if (status === strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.CONNFAIL) {
      if (msg === "x-strophe-bad-non-anon-jid") {
        this.anonymousConnectionFailed = true;
      } else {
        this.connectionFailed = true;
      }
      this.lastErrorMsg = msg;
      if (msg === "giving-up") {
        this.eventEmitter.emit(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__.CONNECTION_FAILED, _JitsiConnectionErrors__WEBPACK_IMPORTED_MODULE_4__.OTHER_ERROR, msg);
      }
    } else if (status === strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.ERROR) {
      this.lastErrorMsg = msg;
    } else if (status === strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.DISCONNECTED) {
      this.connection.ping.stopInterval();
      const wasIntentionalDisconnect = Boolean(this.disconnectInProgress);
      const errMsg = msg || this.lastErrorMsg;
      if (this.anonymousConnectionFailed) {
        this.eventEmitter.emit(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__.CONNECTION_FAILED, _JitsiConnectionErrors__WEBPACK_IMPORTED_MODULE_4__.PASSWORD_REQUIRED);
      } else if (this.connectionFailed) {
        this.eventEmitter.emit(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__.CONNECTION_FAILED, _JitsiConnectionErrors__WEBPACK_IMPORTED_MODULE_4__.OTHER_ERROR, errMsg, void 0, this._getConnectionFailedReasonDetails());
      } else if (wasIntentionalDisconnect) {
        this.eventEmitter.emit(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__.CONNECTION_DISCONNECTED, errMsg);
      } else {
        logger.error("XMPP connection dropped!");
        const lastErrorStatus = strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.getLastErrorStatus();
        if (lastErrorStatus >= 500 && lastErrorStatus < 600) {
          this.eventEmitter.emit(
            _JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__.CONNECTION_FAILED,
            _JitsiConnectionErrors__WEBPACK_IMPORTED_MODULE_4__.SERVER_ERROR,
            errMsg || "server-error",
            void 0,
            this._getConnectionFailedReasonDetails()
          );
        } else {
          this.eventEmitter.emit(
            _JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__.CONNECTION_FAILED,
            _JitsiConnectionErrors__WEBPACK_IMPORTED_MODULE_4__.CONNECTION_DROPPED_ERROR,
            errMsg || "connection-dropped-error",
            void 0,
            this._getConnectionFailedReasonDetails()
          );
        }
      }
    } else if (status === strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.AUTHFAIL) {
      const lastFailedRawMessage = this.getConnection().getLastFailedMessage();
      this.eventEmitter.emit(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__.CONNECTION_FAILED, _JitsiConnectionErrors__WEBPACK_IMPORTED_MODULE_4__.PASSWORD_REQUIRED, msg || this._parseConnectionFailedMessage(lastFailedRawMessage), credentials);
    }
  }
  _processDiscoInfoIdentities(identities, features) {
    identities.forEach((identity) => {
      if (identity.type === "av_moderation") {
        this.avModerationComponentAddress = identity.name;
        this._components.push(this.avModerationComponentAddress);
      }
      if (identity.type === "end_conference") {
        this.endConferenceComponentAddress = identity.name;
        this._components.push(this.endConferenceComponentAddress);
      }
      if (identity.type === "speakerstats") {
        this.speakerStatsComponentAddress = identity.name;
        this._components.push(this.speakerStatsComponentAddress);
      }
      if (identity.type === "conference_duration") {
        this.conferenceDurationComponentAddress = identity.name;
        this._components.push(this.conferenceDurationComponentAddress);
      }
      if (identity.type === "lobbyrooms") {
        this.lobbySupported = true;
        const processLobbyFeatures = (f) => {
          f.forEach((fr) => {
            if (fr.endsWith("#displayname_required")) {
              this.eventEmitter.emit(_JitsiConnectionEvents__WEBPACK_IMPORTED_MODULE_5__.DISPLAY_NAME_REQUIRED);
            }
          });
        };
        if (features) {
          processLobbyFeatures(features);
        } else {
          identity.name && this.caps.getFeaturesAndIdentities(identity.name, identity.type).then(({ features: f }) => processLobbyFeatures(f)).catch((e) => logger.warn("Error getting features from lobby.", e && e.message));
        }
      }
      if (identity.type === "shard") {
        this.options.deploymentInfo.shard = this.connection.shard = identity.name;
      }
      if (identity.type === "region") {
        this.options.deploymentInfo.region = this.connection.region = identity.name;
      }
      if (identity.type === "release") {
        this.options.deploymentInfo.backendRelease = identity.name;
      }
      if (identity.type === "breakout_rooms") {
        this.breakoutRoomsComponentAddress = identity.name;
        this._components.push(this.breakoutRoomsComponentAddress);
      }
      if (identity.type === "room_metadata") {
        this.roomMetadataComponentAddress = identity.name;
        this._components.push(this.roomMetadataComponentAddress);
      }
    });
    this._maybeSendDeploymentInfoStat(true);
    if (this._components.length > 0) {
      this.connection.addHandler(this._onPrivateMessage.bind(this), null, "message", null, null);
    }
  }
  _parseConnectionFailedMessage(msg) {
    if (!msg) {
      return null;
    }
    const matches = FAILURE_REGEX.exec(msg);
    return matches ? matches[1] : null;
  }
  _connect(jid, password) {
    this._resetState();
    this.sendDiscoInfo = true;
    this.sendDeploymentInfo = true;
    if (this.connection._stropheConn && this.connection._stropheConn._addSysHandler) {
      this._sysMessageHandler = this.connection._stropheConn._addSysHandler(this._onSystemMessage.bind(this), null, "message");
    } else {
      logger.warn("Cannot attach strophe system handler, jiconop cannot operate");
    }
    this.connection.connect(jid, password, this.connectionHandler.bind(this, {
      jid,
      password
    }));
  }
  _onSystemMessage(msg) {
    if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find(">services").length === 0 && jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find(">query").length === 0) {
      return;
    }
    this.sendDiscoInfo = false;
    const foundIceServers = this.connection.jingle.onReceiveStunAndTurnCredentials(msg);
    const { features, identities } = (0,_Caps__WEBPACK_IMPORTED_MODULE_14__.parseDiscoInfo)(msg);
    this._processDiscoInfoIdentities(identities, features);
    if (foundIceServers || identities.size > 0 || features.size > 0) {
      this.connection._stropheConn.deleteHandler(this._sysMessageHandler);
      this._sysMessageHandler = null;
    }
  }
  attach(options) {
    this._resetState();
    this.sendDiscoInfo = true;
    const now = this.connectionTimes.attaching = window.performance.now();
    logger.log("(TIME) Strophe Attaching:	", now);
    this.connection.attach(options.jid, options.sid, parseInt(options.rid, 10) + 1, this.connectionHandler.bind(this, {
      jid: options.jid,
      password: options.password
    }));
  }
  _resetState() {
    this.anonymousConnectionFailed = false;
    this.connectionFailed = false;
    this.lastErrorMsg = void 0;
    this.disconnectInProgress = void 0;
  }
  connect(jid, password) {
    if (!jid) {
      const { anonymousdomain, domain } = this.options.hosts;
      let configDomain = anonymousdomain || domain;
      const { location } = window;
      if (anonymousdomain) {
        const search = location && location.search;
        if (search && search.indexOf("login=true") !== -1 || this.token) {
          configDomain = domain;
        }
      }
      jid = configDomain || location && location.hostname;
    }
    return this._connect(jid, password);
  }
  createRoom(roomName, options, onCreateResource) {
    const domain = roomName.domain || options.customDomain;
    let roomjid = `${this.getRoomJid(roomName, domain)}/`;
    const mucNickname = onCreateResource ? onCreateResource(this.connection.jid, this.authenticatedUser) : _util_RandomUtil__WEBPACK_IMPORTED_MODULE_13___default().randomHexString(8).toLowerCase();
    logger.info(`JID ${this.connection.jid} using MUC nickname ${mucNickname}`);
    roomjid += mucNickname;
    return this.connection.emuc.createRoom(roomjid, null, options);
  }
  getRoomJid(roomName, domain) {
    return `${roomName}@${domain ? domain : this.options.hosts.muc.toLowerCase()}`;
  }
  isRoomCreated(roomName, domain) {
    return this.connection.emuc.isRoomCreated(this.getRoomJid(roomName, domain));
  }
  getJid() {
    return this.connection.jid;
  }
  getJingleLog() {
    const jingle = this.connection.jingle;
    return jingle ? jingle.getLog() : {};
  }
  getXmppLog() {
    return (this.connection.logger || {}).log || null;
  }
  dial(...args) {
    this.connection.rayo.dial(...args);
  }
  ping(timeout) {
    return new Promise((resolve, reject) => {
      this.connection.ping.ping(this.connection.pingDomain, resolve, reject, timeout);
    });
  }
  getSessions() {
    return this.connection.jingle.sessions;
  }
  disconnect(ev) {
    if (this.disconnectInProgress) {
      return this.disconnectInProgress;
    } else if (!this.connection) {
      return Promise.resolve();
    }
    this.disconnectInProgress = new Promise((resolve) => {
      const disconnectListener = (credentials, status) => {
        if (status === strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.DISCONNECTED) {
          this.eventEmitter.removeListener(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__.XMPPEvents.CONNECTION_STATUS_CHANGED, disconnectListener);
          resolve();
        }
      };
      this.eventEmitter.on(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__.XMPPEvents.CONNECTION_STATUS_CHANGED, disconnectListener);
    });
    this._cleanupXmppConnection(ev);
    return this.disconnectInProgress;
  }
  _cleanupXmppConnection(ev) {
    !this.connection.isUsingWebSocket && this.connection.flush();
    if (!this.connection.isUsingWebSocket && ev !== null && typeof ev !== "undefined") {
      const evType = ev.type;
      if (evType === "beforeunload" || evType === "unload") {
        this.connection.options.sync = true;
        if (this.connection.sendUnavailableBeacon()) {
          return;
        }
      }
    }
    this.connection.disconnect();
    if (this.connection.options.sync !== true) {
      this.connection.flush();
    }
  }
  _initStrophePlugins() {
    const iceConfig = {
      jvb: { iceServers: [] },
      p2p: { iceServers: [] }
    };
    const p2pStunServers = this.options.p2p && this.options.p2p.stunServers || DEFAULT_STUN_SERVERS;
    if (Array.isArray(p2pStunServers)) {
      logger.info("P2P STUN servers: ", p2pStunServers);
      iceConfig.p2p.iceServers = p2pStunServers;
    }
    if (this.options.p2p && this.options.p2p.iceTransportPolicy) {
      logger.info("P2P ICE transport policy: ", this.options.p2p.iceTransportPolicy);
      iceConfig.p2p.iceTransportPolicy = this.options.p2p.iceTransportPolicy;
    }
    this.connection.addConnectionPlugin("emuc", new _strophe_emuc__WEBPACK_IMPORTED_MODULE_16__["default"](this));
    this.connection.addConnectionPlugin("jingle", new _strophe_jingle__WEBPACK_IMPORTED_MODULE_17__["default"](this, this.eventEmitter, iceConfig));
    this.connection.addConnectionPlugin("rayo", new _strophe_rayo__WEBPACK_IMPORTED_MODULE_19__["default"]());
  }
  _getConnectionFailedReasonDetails() {
    const details = {};
    if (this.options.deploymentInfo && this.options.deploymentInfo.shard && this.connection.lastResponseHeaders) {
      const headersArr = this.connection.lastResponseHeaders.trim().split(/[\r\n]+/);
      const headers = {};
      headersArr.forEach((line) => {
        const parts = line.split(": ");
        const header = parts.shift();
        const value = parts.join(": ");
        headers[header] = value;
      });
      details.shard_changed = this.options.deploymentInfo.shard !== headers["x-jitsi-shard"];
    }
    details.suspend_time = this.connection.ping.getPingSuspendTime();
    details.time_since_last_success = this.connection.getTimeSinceLastSuccess();
    return details;
  }
  sendDominantSpeakerEvent(roomJid, silence) {
    if (!this.speakerStatsComponentAddress || !roomJid) {
      return;
    }
    const msg = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$msg)({ to: this.speakerStatsComponentAddress });
    msg.c("speakerstats", {
      xmlns: "http://jitsi.org/jitmeet",
      room: roomJid,
      silence
    }).up();
    this.connection.send(msg);
  }
  sendFaceLandmarksEvent(roomJid, payload) {
    if (!this.speakerStatsComponentAddress || !roomJid) {
      return;
    }
    const msg = (0,strophe_js__WEBPACK_IMPORTED_MODULE_2__.$msg)({ to: this.speakerStatsComponentAddress });
    msg.c("faceLandmarks", {
      xmlns: "http://jitsi.org/jitmeet",
      room: roomJid,
      faceExpression: payload.faceExpression,
      timestamp: payload.timestamp,
      duration: payload.duration
    }).up();
    this.connection.send(msg);
  }
  tryParseJSONAndVerify(jsonString) {
    if (!jsonString) {
      return false;
    }
    try {
      const json = JSON.parse(jsonString);
      if (json && typeof json === "object") {
        const type = json[JITSI_MEET_MUC_TYPE];
        if (typeof type !== "undefined") {
          return json;
        }
        logger.debug("parsing valid json but does not have correct structure", "topic: ", type);
      }
    } catch (e) {
      logger.error(`Error parsing json ${jsonString}`, e);
      return false;
    }
    return false;
  }
  _onPrivateMessage(msg) {
    const from = msg.getAttribute("from");
    if (!this._components.includes(from)) {
      return true;
    }
    const jsonMessage = jquery__WEBPACK_IMPORTED_MODULE_1___default()(msg).find(">json-message").text();
    const parsedJson = this.tryParseJSONAndVerify(jsonMessage);
    if (!parsedJson) {
      return true;
    }
    if (parsedJson[JITSI_MEET_MUC_TYPE] === "speakerstats" && parsedJson.users) {
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__.XMPPEvents.SPEAKER_STATS_RECEIVED, parsedJson.users);
    } else if (parsedJson[JITSI_MEET_MUC_TYPE] === "conference_duration" && parsedJson.created_timestamp) {
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__.XMPPEvents.CONFERENCE_TIMESTAMP_RECEIVED, parsedJson.created_timestamp);
    } else if (parsedJson[JITSI_MEET_MUC_TYPE] === "av_moderation") {
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__.XMPPEvents.AV_MODERATION_RECEIVED, parsedJson);
    } else if (parsedJson[JITSI_MEET_MUC_TYPE] === "breakout_rooms") {
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__.XMPPEvents.BREAKOUT_ROOMS_EVENT, parsedJson);
    } else if (parsedJson[JITSI_MEET_MUC_TYPE] === "room_metadata") {
      this.eventEmitter.emit(_service_xmpp_XMPPEvents__WEBPACK_IMPORTED_MODULE_6__.XMPPEvents.ROOM_METADATA_EVENT, parsedJson);
    }
    return true;
  }
  _maybeSendDeploymentInfoStat(force) {
    const acceptedStatuses = [
      strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.ERROR,
      strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.CONNFAIL,
      strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.AUTHFAIL,
      strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.DISCONNECTED,
      strophe_js__WEBPACK_IMPORTED_MODULE_2__.Strophe.Status.CONNTIMEOUT
    ];
    if (!force && !(acceptedStatuses.includes(this.connection.status) && this.sendDeploymentInfo)) {
      return;
    }
    const aprops = this.options.deploymentInfo;
    if (aprops && Object.keys(aprops).length > 0) {
      const logObject = {};
      for (const attr in aprops) {
        if (aprops.hasOwnProperty(attr)) {
          logObject[attr] = aprops[attr];
        }
      }
      _statistics_statistics__WEBPACK_IMPORTED_MODULE_10__["default"].analytics.addPermanentProperties(Object.assign({}, logObject));
      logObject.id = "deployment_info";
      const entry = JSON.stringify(logObject);
      _statistics_statistics__WEBPACK_IMPORTED_MODULE_10__["default"].sendLog(entry);
      logger.info(entry);
    }
    this.sendDeploymentInfo = false;
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/RTC/BridgeVideoType.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/RTC/BridgeVideoType.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";

const BridgeVideoType = {
  CAMERA: "camera",
  DESKTOP: "desktop",
  DESKTOP_HIGH_FPS: "desktop_high_fps",
  NONE: "none"
};
module.exports = BridgeVideoType;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/RTC/CameraFacingMode.js":
/*!*********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/RTC/CameraFacingMode.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";

const CameraFacingMode = {
  ENVIRONMENT: "environment",
  USER: "user"
};
module.exports = CameraFacingMode;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/RTC/CodecMimeType.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/RTC/CodecMimeType.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodecMimeType: () => (/* binding */ CodecMimeType),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

const CodecMimeType = {
  AV1: "av1",
  H264: "h264",
  OPUS: "opus",
  ULPFEC: "ulpfec",
  VP8: "vp8",
  VP9: "vp9"
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CodecMimeType);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaDirection.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/RTC/MediaDirection.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MediaDirection: () => (/* binding */ MediaDirection)
/* harmony export */ });

var MediaDirection;
(function(MediaDirection2) {
  MediaDirection2["INACTIVE"] = "inactive";
  MediaDirection2["RECVONLY"] = "recvonly";
  MediaDirection2["SENDONLY"] = "sendonly";
  MediaDirection2["SENDRECV"] = "sendrecv";
})(MediaDirection || (MediaDirection = {}));
;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MediaType: () => (/* binding */ MediaType)
/* harmony export */ });

var MediaType;
(function(MediaType2) {
  MediaType2["AUDIO"] = "audio";
  MediaType2["VIDEO"] = "video";
})(MediaType || (MediaType = {}));


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/RTC/RTCEvents.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AUDIO_OUTPUT_DEVICE_CHANGED: () => (/* binding */ AUDIO_OUTPUT_DEVICE_CHANGED),
/* harmony export */   AUDIO_SSRCS_REMAPPED: () => (/* binding */ AUDIO_SSRCS_REMAPPED),
/* harmony export */   CREATE_ANSWER_FAILED: () => (/* binding */ CREATE_ANSWER_FAILED),
/* harmony export */   CREATE_OFFER_FAILED: () => (/* binding */ CREATE_OFFER_FAILED),
/* harmony export */   DATA_CHANNEL_CLOSED: () => (/* binding */ DATA_CHANNEL_CLOSED),
/* harmony export */   DATA_CHANNEL_OPEN: () => (/* binding */ DATA_CHANNEL_OPEN),
/* harmony export */   DEVICE_LIST_AVAILABLE: () => (/* binding */ DEVICE_LIST_AVAILABLE),
/* harmony export */   DEVICE_LIST_CHANGED: () => (/* binding */ DEVICE_LIST_CHANGED),
/* harmony export */   DEVICE_LIST_WILL_CHANGE: () => (/* binding */ DEVICE_LIST_WILL_CHANGE),
/* harmony export */   DOMINANT_SPEAKER_CHANGED: () => (/* binding */ DOMINANT_SPEAKER_CHANGED),
/* harmony export */   ENDPOINT_CONN_STATUS_CHANGED: () => (/* binding */ ENDPOINT_CONN_STATUS_CHANGED),
/* harmony export */   ENDPOINT_MESSAGE_RECEIVED: () => (/* binding */ ENDPOINT_MESSAGE_RECEIVED),
/* harmony export */   ENDPOINT_STATS_RECEIVED: () => (/* binding */ ENDPOINT_STATS_RECEIVED),
/* harmony export */   FORWARDED_SOURCES_CHANGED: () => (/* binding */ FORWARDED_SOURCES_CHANGED),
/* harmony export */   LASTN_VALUE_CHANGED: () => (/* binding */ LASTN_VALUE_CHANGED),
/* harmony export */   LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED: () => (/* binding */ LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED),
/* harmony export */   LOCAL_TRACK_SSRC_UPDATED: () => (/* binding */ LOCAL_TRACK_SSRC_UPDATED),
/* harmony export */   LOCAL_UFRAG_CHANGED: () => (/* binding */ LOCAL_UFRAG_CHANGED),
/* harmony export */   PERMISSIONS_CHANGED: () => (/* binding */ PERMISSIONS_CHANGED),
/* harmony export */   REMOTE_TRACK_ADDED: () => (/* binding */ REMOTE_TRACK_ADDED),
/* harmony export */   REMOTE_TRACK_MUTE: () => (/* binding */ REMOTE_TRACK_MUTE),
/* harmony export */   REMOTE_TRACK_REMOVED: () => (/* binding */ REMOTE_TRACK_REMOVED),
/* harmony export */   REMOTE_TRACK_UNMUTE: () => (/* binding */ REMOTE_TRACK_UNMUTE),
/* harmony export */   REMOTE_UFRAG_CHANGED: () => (/* binding */ REMOTE_UFRAG_CHANGED),
/* harmony export */   RTCEvents: () => (/* binding */ RTCEvents),
/* harmony export */   SENDER_VIDEO_CONSTRAINTS_CHANGED: () => (/* binding */ SENDER_VIDEO_CONSTRAINTS_CHANGED),
/* harmony export */   SET_LOCAL_DESCRIPTION_FAILED: () => (/* binding */ SET_LOCAL_DESCRIPTION_FAILED),
/* harmony export */   SET_REMOTE_DESCRIPTION_FAILED: () => (/* binding */ SET_REMOTE_DESCRIPTION_FAILED),
/* harmony export */   TRACK_ATTACHED: () => (/* binding */ TRACK_ATTACHED),
/* harmony export */   VIDEO_SSRCS_REMAPPED: () => (/* binding */ VIDEO_SSRCS_REMAPPED),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var RTCEvents;
(function(RTCEvents2) {
  RTCEvents2["CREATE_ANSWER_FAILED"] = "rtc.create_answer_failed";
  RTCEvents2["CREATE_OFFER_FAILED"] = "rtc.create_offer_failed";
  RTCEvents2["DATA_CHANNEL_OPEN"] = "rtc.data_channel_open";
  RTCEvents2["DATA_CHANNEL_CLOSED"] = "rtc.data_channel_closed";
  RTCEvents2["ENDPOINT_CONN_STATUS_CHANGED"] = "rtc.endpoint_conn_status_changed";
  RTCEvents2["DOMINANT_SPEAKER_CHANGED"] = "rtc.dominant_speaker_changed";
  RTCEvents2["FORWARDED_SOURCES_CHANGED"] = "rtc.forwarded_sources_changed";
  RTCEvents2["PERMISSIONS_CHANGED"] = "rtc.permissions_changed";
  RTCEvents2["SENDER_VIDEO_CONSTRAINTS_CHANGED"] = "rtc.sender_video_constraints_changed";
  RTCEvents2["LASTN_VALUE_CHANGED"] = "rtc.lastn_value_changed";
  RTCEvents2["LOCAL_TRACK_SSRC_UPDATED"] = "rtc.local_track_ssrc_updated";
  RTCEvents2["LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED"] = "rtc.local_track_max_enabled_resolution_changed";
  RTCEvents2["TRACK_ATTACHED"] = "rtc.track_attached";
  RTCEvents2["REMOTE_TRACK_ADDED"] = "rtc.remote_track_added";
  RTCEvents2["REMOTE_TRACK_MUTE"] = "rtc.remote_track_mute";
  RTCEvents2["REMOTE_TRACK_REMOVED"] = "rtc.remote_track_removed";
  RTCEvents2["REMOTE_TRACK_UNMUTE"] = "rtc.remote_track_unmute";
  RTCEvents2["SET_LOCAL_DESCRIPTION_FAILED"] = "rtc.set_local_description_failed";
  RTCEvents2["SET_REMOTE_DESCRIPTION_FAILED"] = "rtc.set_remote_description_failed";
  RTCEvents2["AUDIO_OUTPUT_DEVICE_CHANGED"] = "rtc.audio_output_device_changed";
  RTCEvents2["DEVICE_LIST_CHANGED"] = "rtc.device_list_changed";
  RTCEvents2["DEVICE_LIST_WILL_CHANGE"] = "rtc.device_list_will_change";
  RTCEvents2["DEVICE_LIST_AVAILABLE"] = "rtc.device_list_available";
  RTCEvents2["ENDPOINT_MESSAGE_RECEIVED"] = "rtc.endpoint_message_received";
  RTCEvents2["ENDPOINT_STATS_RECEIVED"] = "rtc.endpoint_stats_received";
  RTCEvents2["LOCAL_UFRAG_CHANGED"] = "rtc.local_ufrag_changed";
  RTCEvents2["REMOTE_UFRAG_CHANGED"] = "rtc.remote_ufrag_changed";
  RTCEvents2["VIDEO_SSRCS_REMAPPED"] = "rtc.video_ssrcs_remapped";
  RTCEvents2["AUDIO_SSRCS_REMAPPED"] = "rtc.audio_ssrcs_remapped";
})(RTCEvents || (RTCEvents = {}));
;
const CREATE_ANSWER_FAILED = RTCEvents.CREATE_ANSWER_FAILED;
const CREATE_OFFER_FAILED = RTCEvents.CREATE_OFFER_FAILED;
const DATA_CHANNEL_OPEN = RTCEvents.DATA_CHANNEL_OPEN;
const DATA_CHANNEL_CLOSED = RTCEvents.DATA_CHANNEL_CLOSED;
const ENDPOINT_CONN_STATUS_CHANGED = RTCEvents.ENDPOINT_CONN_STATUS_CHANGED;
const DOMINANT_SPEAKER_CHANGED = RTCEvents.DOMINANT_SPEAKER_CHANGED;
const FORWARDED_SOURCES_CHANGED = RTCEvents.FORWARDED_SOURCES_CHANGED;
const PERMISSIONS_CHANGED = RTCEvents.PERMISSIONS_CHANGED;
const SENDER_VIDEO_CONSTRAINTS_CHANGED = RTCEvents.SENDER_VIDEO_CONSTRAINTS_CHANGED;
const LASTN_VALUE_CHANGED = RTCEvents.LASTN_VALUE_CHANGED;
const LOCAL_TRACK_SSRC_UPDATED = RTCEvents.LOCAL_TRACK_SSRC_UPDATED;
const LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED = RTCEvents.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED;
const TRACK_ATTACHED = RTCEvents.TRACK_ATTACHED;
const REMOTE_TRACK_ADDED = RTCEvents.REMOTE_TRACK_ADDED;
const REMOTE_TRACK_MUTE = RTCEvents.REMOTE_TRACK_MUTE;
const REMOTE_TRACK_REMOVED = RTCEvents.REMOTE_TRACK_REMOVED;
const REMOTE_TRACK_UNMUTE = RTCEvents.REMOTE_TRACK_UNMUTE;
const SET_LOCAL_DESCRIPTION_FAILED = RTCEvents.SET_LOCAL_DESCRIPTION_FAILED;
const SET_REMOTE_DESCRIPTION_FAILED = RTCEvents.SET_REMOTE_DESCRIPTION_FAILED;
const AUDIO_OUTPUT_DEVICE_CHANGED = RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED;
const DEVICE_LIST_CHANGED = RTCEvents.DEVICE_LIST_CHANGED;
const DEVICE_LIST_WILL_CHANGE = RTCEvents.DEVICE_LIST_WILL_CHANGE;
const DEVICE_LIST_AVAILABLE = RTCEvents.DEVICE_LIST_AVAILABLE;
const ENDPOINT_MESSAGE_RECEIVED = RTCEvents.ENDPOINT_MESSAGE_RECEIVED;
const ENDPOINT_STATS_RECEIVED = RTCEvents.ENDPOINT_STATS_RECEIVED;
const LOCAL_UFRAG_CHANGED = RTCEvents.LOCAL_UFRAG_CHANGED;
const REMOTE_UFRAG_CHANGED = RTCEvents.REMOTE_UFRAG_CHANGED;
const VIDEO_SSRCS_REMAPPED = RTCEvents.VIDEO_SSRCS_REMAPPED;
const AUDIO_SSRCS_REMAPPED = RTCEvents.AUDIO_SSRCS_REMAPPED;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RTCEvents);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/RTC/Resolutions.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/RTC/Resolutions.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";

const Resolutions = {
  "2160": {
    width: 3840,
    height: 2160
  },
  "4k": {
    width: 3840,
    height: 2160
  },
  "1080": {
    width: 1920,
    height: 1080
  },
  "fullhd": {
    width: 1920,
    height: 1080
  },
  "720": {
    width: 1280,
    height: 720
  },
  "hd": {
    width: 1280,
    height: 720
  },
  "540": {
    width: 960,
    height: 540
  },
  "qhd": {
    width: 960,
    height: 540
  },
  "480": {
    width: 640,
    height: 480
  },
  "vga": {
    width: 640,
    height: 480
  },
  "360": {
    width: 640,
    height: 360
  },
  "240": {
    width: 320,
    height: 240
  },
  "180": {
    width: 320,
    height: 180
  }
};
module.exports = Resolutions;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingEvents.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/RTC/SignalingEvents.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PEER_MUTED_CHANGED: () => (/* binding */ PEER_MUTED_CHANGED),
/* harmony export */   PEER_VIDEO_TYPE_CHANGED: () => (/* binding */ PEER_VIDEO_TYPE_CHANGED),
/* harmony export */   SOURCE_MUTED_CHANGED: () => (/* binding */ SOURCE_MUTED_CHANGED),
/* harmony export */   SOURCE_UPDATED: () => (/* binding */ SOURCE_UPDATED),
/* harmony export */   SOURCE_VIDEO_TYPE_CHANGED: () => (/* binding */ SOURCE_VIDEO_TYPE_CHANGED),
/* harmony export */   SignalingEvents: () => (/* binding */ SignalingEvents)
/* harmony export */ });

var SignalingEvents;
(function(SignalingEvents2) {
  SignalingEvents2["PEER_MUTED_CHANGED"] = "signaling.peerMuted";
  SignalingEvents2["PEER_VIDEO_TYPE_CHANGED"] = "signaling.peerVideoType";
  SignalingEvents2["SOURCE_MUTED_CHANGED"] = "signaling.sourceMuted";
  SignalingEvents2["SOURCE_UPDATED"] = "signaling.sourceUpdated";
  SignalingEvents2["SOURCE_VIDEO_TYPE_CHANGED"] = "signaling.sourceVideoType";
})(SignalingEvents || (SignalingEvents = {}));
const PEER_MUTED_CHANGED = SignalingEvents.PEER_MUTED_CHANGED;
const PEER_VIDEO_TYPE_CHANGED = SignalingEvents.PEER_VIDEO_TYPE_CHANGED;
const SOURCE_MUTED_CHANGED = SignalingEvents.SOURCE_MUTED_CHANGED;
const SOURCE_UPDATED = SignalingEvents.SOURCE_UPDATED;
const SOURCE_VIDEO_TYPE_CHANGED = SignalingEvents.SOURCE_VIDEO_TYPE_CHANGED;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/RTC/SignalingLayer.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/RTC/SignalingLayer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SignalingLayer),
/* harmony export */   getMediaTypeFromSourceName: () => (/* binding */ getMediaTypeFromSourceName),
/* harmony export */   getSourceIndexFromSourceName: () => (/* binding */ getSourceIndexFromSourceName),
/* harmony export */   getSourceNameForJitsiTrack: () => (/* binding */ getSourceNameForJitsiTrack)
/* harmony export */ });
/* harmony import */ var _modules_util_Listenable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/util/Listenable */ "../../lib-jitsi-meet/dist/esm/modules/util/Listenable.js");
/* harmony import */ var _service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../service/RTC/MediaType */ "../../lib-jitsi-meet/dist/esm/service/RTC/MediaType.js");



function getSourceNameForJitsiTrack(endpointId, mediaType, trackIdx) {
  const firstLetterOfMediaType = mediaType.substring(0, 1);
  return `${endpointId}-${firstLetterOfMediaType}${trackIdx}`;
}
function getMediaTypeFromSourceName(sourceName) {
  const firstLetterOfMediaTypeIdx = sourceName.lastIndexOf("-") + 1;
  if (firstLetterOfMediaTypeIdx <= 0) {
    throw new Error(`Invalid source name: ${sourceName}`);
  }
  const firstLetterOfMediaType = sourceName.substr(firstLetterOfMediaTypeIdx, 1);
  for (const type of Object.values(_service_RTC_MediaType__WEBPACK_IMPORTED_MODULE_1__.MediaType)) {
    if (type.substr(0, 1) === firstLetterOfMediaType) {
      return type;
    }
  }
  throw new Error(`Invalid source name: ${sourceName}`);
}
function getSourceIndexFromSourceName(sourceName) {
  const nameParts = sourceName.split("-");
  const trackIdx = Number(nameParts[nameParts.length - 1].substring(1));
  if (Number.isNaN(trackIdx)) {
    throw new Error(`Failed to parse track idx for source name: ${sourceName}`);
  }
  return trackIdx;
}
class SignalingLayer extends _modules_util_Listenable__WEBPACK_IMPORTED_MODULE_0__["default"] {
  getPeerMediaInfo(owner, mediaType, sourceName) {
    throw new Error("not implemented");
  }
  getPeerSourceInfo(owner, sourceName) {
    throw new Error("not implemented");
  }
  getSSRCOwner(ssrc) {
    throw new Error("not implemented");
  }
  getTrackSourceName(ssrc) {
    throw new Error("not implemented");
  }
  removeSSRCOwners(ssrcList) {
  }
  setSSRCOwner(ssrc, endpointId) {
  }
  setTrackMuteStatus(sourceName, muted) {
  }
  setTrackSourceName(ssrc, sourceName) {
  }
  setTrackVideoType(sourceName, videoType) {
  }
  updateSsrcOwnersOnLeave(id) {
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/RTC/VideoType.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VideoType: () => (/* binding */ VideoType)
/* harmony export */ });

var VideoType;
(function(VideoType2) {
  VideoType2["CAMERA"] = "camera";
  VideoType2["DESKTOP"] = "desktop";
})(VideoType || (VideoType = {}));
;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/authentication/AuthenticationEvents.js":
/*!************************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/authentication/AuthenticationEvents.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";

const AuthenticationEvents = {
  IDENTITY_UPDATED: "authentication.identity_updated"
};
module.exports = AuthenticationEvents;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/connectivity/ConnectionQualityEvents.js":
/*!*************************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/connectivity/ConnectionQualityEvents.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConnectionQualityEvents: () => (/* binding */ ConnectionQualityEvents),
/* harmony export */   LOCAL_STATS_UPDATED: () => (/* binding */ LOCAL_STATS_UPDATED),
/* harmony export */   REMOTE_STATS_UPDATED: () => (/* binding */ REMOTE_STATS_UPDATED)
/* harmony export */ });

var ConnectionQualityEvents;
(function(ConnectionQualityEvents2) {
  ConnectionQualityEvents2["LOCAL_STATS_UPDATED"] = "cq.local_stats_updated";
  ConnectionQualityEvents2["REMOTE_STATS_UPDATED"] = "cq.remote_stats_updated";
})(ConnectionQualityEvents || (ConnectionQualityEvents = {}));
;
const LOCAL_STATS_UPDATED = ConnectionQualityEvents.LOCAL_STATS_UPDATED;
const REMOTE_STATS_UPDATED = ConnectionQualityEvents.REMOTE_STATS_UPDATED;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/e2eping/E2ePingEvents.js":
/*!**********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/e2eping/E2ePingEvents.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E2E_RTT_CHANGED: () => (/* binding */ E2E_RTT_CHANGED),
/* harmony export */   E2ePingEvents: () => (/* binding */ E2ePingEvents)
/* harmony export */ });

var E2ePingEvents;
(function(E2ePingEvents2) {
  E2ePingEvents2["E2E_RTT_CHANGED"] = "e2eping.e2e_rtt_changed";
})(E2ePingEvents || (E2ePingEvents = {}));
;
const E2E_RTT_CHANGED = E2ePingEvents.E2E_RTT_CHANGED;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js":
/*!***************************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/statistics/AnalyticsEvents.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ACTION_JINGLE_RESTART: () => (/* binding */ ACTION_JINGLE_RESTART),
/* harmony export */   ACTION_JINGLE_SA_TIMEOUT: () => (/* binding */ ACTION_JINGLE_SA_TIMEOUT),
/* harmony export */   ACTION_JINGLE_SI_RECEIVED: () => (/* binding */ ACTION_JINGLE_SI_RECEIVED),
/* harmony export */   ACTION_JINGLE_SI_TIMEOUT: () => (/* binding */ ACTION_JINGLE_SI_TIMEOUT),
/* harmony export */   ACTION_JINGLE_TERMINATE: () => (/* binding */ ACTION_JINGLE_TERMINATE),
/* harmony export */   ACTION_JINGLE_TR_RECEIVED: () => (/* binding */ ACTION_JINGLE_TR_RECEIVED),
/* harmony export */   ACTION_JINGLE_TR_SUCCESS: () => (/* binding */ ACTION_JINGLE_TR_SUCCESS),
/* harmony export */   ACTION_P2P_DECLINED: () => (/* binding */ ACTION_P2P_DECLINED),
/* harmony export */   ACTION_P2P_ESTABLISHED: () => (/* binding */ ACTION_P2P_ESTABLISHED),
/* harmony export */   ACTION_P2P_FAILED: () => (/* binding */ ACTION_P2P_FAILED),
/* harmony export */   ACTION_P2P_SWITCH_TO_JVB: () => (/* binding */ ACTION_P2P_SWITCH_TO_JVB),
/* harmony export */   AVAILABLE_DEVICE: () => (/* binding */ AVAILABLE_DEVICE),
/* harmony export */   AnalyticsEvents: () => (/* binding */ AnalyticsEvents),
/* harmony export */   CONNECTION_DISCONNECTED: () => (/* binding */ CONNECTION_DISCONNECTED),
/* harmony export */   FEEDBACK: () => (/* binding */ FEEDBACK),
/* harmony export */   ICE_DURATION: () => (/* binding */ ICE_DURATION),
/* harmony export */   ICE_ESTABLISHMENT_DURATION_DIFF: () => (/* binding */ ICE_ESTABLISHMENT_DURATION_DIFF),
/* harmony export */   ICE_STATE_CHANGED: () => (/* binding */ ICE_STATE_CHANGED),
/* harmony export */   NO_BYTES_SENT: () => (/* binding */ NO_BYTES_SENT),
/* harmony export */   TRACK_UNMUTED: () => (/* binding */ TRACK_UNMUTED),
/* harmony export */   TYPE_OPERATIONAL: () => (/* binding */ TYPE_OPERATIONAL),
/* harmony export */   TYPE_PAGE: () => (/* binding */ TYPE_PAGE),
/* harmony export */   TYPE_TRACK: () => (/* binding */ TYPE_TRACK),
/* harmony export */   TYPE_UI: () => (/* binding */ TYPE_UI),
/* harmony export */   createAudioOutputProblemEvent: () => (/* binding */ createAudioOutputProblemEvent),
/* harmony export */   createBridgeChannelClosedEvent: () => (/* binding */ createBridgeChannelClosedEvent),
/* harmony export */   createBridgeDownEvent: () => (/* binding */ createBridgeDownEvent),
/* harmony export */   createConferenceEvent: () => (/* binding */ createConferenceEvent),
/* harmony export */   createConnectionFailedEvent: () => (/* binding */ createConnectionFailedEvent),
/* harmony export */   createConnectionStageReachedEvent: () => (/* binding */ createConnectionStageReachedEvent),
/* harmony export */   createE2eRttEvent: () => (/* binding */ createE2eRttEvent),
/* harmony export */   createFocusLeftEvent: () => (/* binding */ createFocusLeftEvent),
/* harmony export */   createGetUserMediaEvent: () => (/* binding */ createGetUserMediaEvent),
/* harmony export */   createJingleEvent: () => (/* binding */ createJingleEvent),
/* harmony export */   createNoDataFromSourceEvent: () => (/* binding */ createNoDataFromSourceEvent),
/* harmony export */   createP2PEvent: () => (/* binding */ createP2PEvent),
/* harmony export */   createParticipantConnectionStatusEvent: () => (/* binding */ createParticipantConnectionStatusEvent),
/* harmony export */   createRemotelyMutedEvent: () => (/* binding */ createRemotelyMutedEvent),
/* harmony export */   createRtpStatsEvent: () => (/* binding */ createRtpStatsEvent),
/* harmony export */   createRttByRegionEvent: () => (/* binding */ createRttByRegionEvent),
/* harmony export */   createTrackStreamingStatusEvent: () => (/* binding */ createTrackStreamingStatusEvent),
/* harmony export */   createTransportStatsEvent: () => (/* binding */ createTransportStatsEvent),
/* harmony export */   createTtfmEvent: () => (/* binding */ createTtfmEvent)
/* harmony export */ });

var AnalyticsEvents;
(function(AnalyticsEvents2) {
  AnalyticsEvents2["TYPE_OPERATIONAL"] = "operational";
  AnalyticsEvents2["TYPE_PAGE"] = "page";
  AnalyticsEvents2["TYPE_TRACK"] = "track";
  AnalyticsEvents2["TYPE_UI"] = "ui";
  AnalyticsEvents2["ACTION_JINGLE_RESTART"] = "restart";
  AnalyticsEvents2["ACTION_JINGLE_SA_TIMEOUT"] = "session-accept.timeout";
  AnalyticsEvents2["ACTION_JINGLE_SI_RECEIVED"] = "session-initiate.received";
  AnalyticsEvents2["ACTION_JINGLE_SI_TIMEOUT"] = "session-initiate.timeout";
  AnalyticsEvents2["ACTION_JINGLE_TERMINATE"] = "terminate";
  AnalyticsEvents2["ACTION_JINGLE_TR_RECEIVED"] = "transport-replace.received";
  AnalyticsEvents2["ACTION_JINGLE_TR_SUCCESS"] = "transport-replace.success";
  AnalyticsEvents2["ACTION_P2P_DECLINED"] = "decline";
  AnalyticsEvents2["ACTION_P2P_ESTABLISHED"] = "established";
  AnalyticsEvents2["ACTION_P2P_FAILED"] = "failed";
  AnalyticsEvents2["ACTION_P2P_SWITCH_TO_JVB"] = "switch.to.jvb";
  AnalyticsEvents2["AVAILABLE_DEVICE"] = "available.device";
  AnalyticsEvents2["CONNECTION_DISCONNECTED"] = "connection.disconnected";
  AnalyticsEvents2["FEEDBACK"] = "feedback";
  AnalyticsEvents2["ICE_DURATION"] = "ice.duration";
  AnalyticsEvents2["ICE_ESTABLISHMENT_DURATION_DIFF"] = "ice.establishment.duration.diff";
  AnalyticsEvents2["ICE_STATE_CHANGED"] = "ice.state.changed";
  AnalyticsEvents2["NO_BYTES_SENT"] = "track.no-bytes-sent";
  AnalyticsEvents2["TRACK_UNMUTED"] = "track.unmuted";
})(AnalyticsEvents || (AnalyticsEvents = {}));
const TYPE_OPERATIONAL = AnalyticsEvents.TYPE_OPERATIONAL;
const TYPE_PAGE = AnalyticsEvents.TYPE_PAGE;
const TYPE_TRACK = AnalyticsEvents.TYPE_TRACK;
const TYPE_UI = AnalyticsEvents.TYPE_UI;
const ACTION_JINGLE_RESTART = AnalyticsEvents.ACTION_JINGLE_RESTART;
const ACTION_JINGLE_SA_TIMEOUT = AnalyticsEvents.ACTION_JINGLE_SA_TIMEOUT;
const ACTION_JINGLE_SI_RECEIVED = AnalyticsEvents.ACTION_JINGLE_SI_RECEIVED;
const ACTION_JINGLE_SI_TIMEOUT = AnalyticsEvents.ACTION_JINGLE_SI_TIMEOUT;
const ACTION_JINGLE_TERMINATE = AnalyticsEvents.ACTION_JINGLE_TERMINATE;
const ACTION_JINGLE_TR_RECEIVED = AnalyticsEvents.ACTION_JINGLE_TR_RECEIVED;
const ACTION_JINGLE_TR_SUCCESS = AnalyticsEvents.ACTION_JINGLE_TR_SUCCESS;
const ACTION_P2P_DECLINED = AnalyticsEvents.ACTION_P2P_DECLINED;
const ACTION_P2P_ESTABLISHED = AnalyticsEvents.ACTION_P2P_ESTABLISHED;
const ACTION_P2P_FAILED = AnalyticsEvents.ACTION_P2P_FAILED;
const ACTION_P2P_SWITCH_TO_JVB = AnalyticsEvents.ACTION_P2P_SWITCH_TO_JVB;
const AVAILABLE_DEVICE = AnalyticsEvents.AVAILABLE_DEVICE;
const CONNECTION_DISCONNECTED = AnalyticsEvents.CONNECTION_DISCONNECTED;
const FEEDBACK = AnalyticsEvents.FEEDBACK;
const ICE_DURATION = AnalyticsEvents.ICE_DURATION;
const ICE_ESTABLISHMENT_DURATION_DIFF = AnalyticsEvents.ICE_ESTABLISHMENT_DURATION_DIFF;
const ICE_STATE_CHANGED = AnalyticsEvents.ICE_STATE_CHANGED;
const NO_BYTES_SENT = AnalyticsEvents.NO_BYTES_SENT;
const TRACK_UNMUTED = AnalyticsEvents.TRACK_UNMUTED;
const createBridgeDownEvent = () => ({
  action: "bridge.down",
  actionSubject: "bridge.down",
  type: TYPE_OPERATIONAL
});
const createConnectionFailedEvent = (errorType, errorMessage, details) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  action: "connection.failed",
  attributes: Object.assign({ "error_type": errorType, "error_message": errorMessage }, details)
});
const createConferenceEvent = (action, attributes) => ({
  action,
  attributes,
  source: "conference",
  type: AnalyticsEvents.TYPE_OPERATIONAL
});
const createConnectionStageReachedEvent = (stage, attributes) => ({
  action: "connection.stage.reached",
  actionSubject: stage,
  attributes,
  source: "connection.stage.reached",
  type: AnalyticsEvents.TYPE_OPERATIONAL
});
const createE2eRttEvent = (participantId, region, rtt) => ({
  attributes: {
    "participant_id": participantId,
    region,
    rtt
  },
  name: "e2e_rtt",
  type: AnalyticsEvents.TYPE_OPERATIONAL
});
const createFocusLeftEvent = () => ({
  action: "focus.left",
  actionSubject: "focus.left",
  type: AnalyticsEvents.TYPE_OPERATIONAL
});
const createGetUserMediaEvent = (action, attributes = {}) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  source: "get.user.media",
  action,
  attributes
});
const createParticipantConnectionStatusEvent = (attributes = {}) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  source: "peer.conn.status",
  action: "duration",
  attributes
});
const createTrackStreamingStatusEvent = (attributes = {}) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  source: "track.streaming.status",
  action: "duration",
  attributes
});
const createJingleEvent = (action, attributes = {}) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  action,
  source: "jingle",
  attributes
});
const createNoDataFromSourceEvent = (mediaType, value) => ({
  attributes: {
    "media_type": mediaType,
    value
  },
  action: "track.no.data.from.source",
  type: AnalyticsEvents.TYPE_OPERATIONAL
});
const createP2PEvent = (action, attributes = {}) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  action,
  source: "p2p",
  attributes
});
const createRemotelyMutedEvent = (mediaType) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  action: "remotely.muted",
  mediaType
});
const createRtpStatsEvent = (attributes) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  action: "rtp.stats",
  attributes
});
const createRttByRegionEvent = (attributes) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  action: "rtt.by.region",
  attributes
});
const createTransportStatsEvent = (attributes) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  action: "transport.stats",
  attributes
});
const createAudioOutputProblemEvent = (userID, localAudioLevels, remoteAudioLevels) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  action: "audio.output.problem",
  attributes: {
    userID,
    localAudioLevels,
    remoteAudioLevels
  }
});
const createBridgeChannelClosedEvent = (code, reason) => ({
  type: AnalyticsEvents.TYPE_OPERATIONAL,
  action: "bridge-channel.error",
  attributes: {
    code,
    reason
  }
});
const createTtfmEvent = (attributes) => createConnectionStageReachedEvent("ttfm", attributes);


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/statistics/Events.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/statistics/Events.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AUDIO_LEVEL: () => (/* binding */ AUDIO_LEVEL),
/* harmony export */   BEFORE_DISPOSED: () => (/* binding */ BEFORE_DISPOSED),
/* harmony export */   BYTE_SENT_STATS: () => (/* binding */ BYTE_SENT_STATS),
/* harmony export */   CONNECTION_STATS: () => (/* binding */ CONNECTION_STATS),
/* harmony export */   Events: () => (/* binding */ Events),
/* harmony export */   LONG_TASKS_STATS: () => (/* binding */ LONG_TASKS_STATS)
/* harmony export */ });

var Events;
(function(Events2) {
  Events2["AUDIO_LEVEL"] = "statistics.audioLevel";
  Events2["BEFORE_DISPOSED"] = "statistics.before_disposed";
  Events2["BYTE_SENT_STATS"] = "statistics.byte_sent_stats";
  Events2["CONNECTION_STATS"] = "statistics.connectionstats";
  Events2["LONG_TASKS_STATS"] = "statistics.long_tasks_stats";
})(Events || (Events = {}));
;
const AUDIO_LEVEL = Events.AUDIO_LEVEL;
const BEFORE_DISPOSED = Events.BEFORE_DISPOSED;
const BYTE_SENT_STATS = Events.BYTE_SENT_STATS;
const CONNECTION_STATS = Events.CONNECTION_STATS;
const LONG_TASKS_STATS = Events.LONG_TASKS_STATS;


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/statistics/constants.js":
/*!*********************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/statistics/constants.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LOCAL_JID: () => (/* binding */ LOCAL_JID)
/* harmony export */ });

const LOCAL_JID = "local";


/***/ }),

/***/ "../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/dist/esm/service/xmpp/XMPPEvents.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XMPPEvents: () => (/* binding */ XMPPEvents)
/* harmony export */ });

var XMPPEvents;
(function(XMPPEvents2) {
  XMPPEvents2["ADD_ICE_CANDIDATE_FAILED"] = "xmpp.add_ice_candidate_failed";
  XMPPEvents2["AUDIO_MUTED_BY_FOCUS"] = "xmpp.audio_muted_by_focus";
  XMPPEvents2["VIDEO_MUTED_BY_FOCUS"] = "xmpp.video_muted_by_focus";
  XMPPEvents2["AUTHENTICATION_REQUIRED"] = "xmpp.authentication_required";
  XMPPEvents2["BRIDGE_DOWN"] = "xmpp.bridge_down";
  XMPPEvents2["CALL_ACCEPTED"] = "xmpp.callaccepted.jingle";
  XMPPEvents2["CALL_INCOMING"] = "xmpp.callincoming.jingle";
  XMPPEvents2["CALL_ENDED"] = "xmpp.callended.jingle";
  XMPPEvents2["CHAT_ERROR_RECEIVED"] = "xmpp.chat_error_received";
  XMPPEvents2["SETTINGS_ERROR_RECEIVED"] = "xmpp.settings_error_received";
  XMPPEvents2["CONFERENCE_PROPERTIES_CHANGED"] = "xmpp.conference_properties_changed";
  XMPPEvents2["CONNECTION_ESTABLISHED"] = "xmpp.connection.connected";
  XMPPEvents2["CONNECTION_FAILED"] = "xmpp.connection.failed";
  XMPPEvents2["CONNECTION_INTERRUPTED"] = "xmpp.connection.interrupted";
  XMPPEvents2["CONNECTION_RESTORED"] = "xmpp.connection.restored";
  XMPPEvents2["CONNECTION_ICE_FAILED"] = "xmpp.connection.ice.failed";
  XMPPEvents2["CONNECTION_RESTARTED"] = "xmpp.connection.restart";
  XMPPEvents2["CONNECTION_STATUS_CHANGED"] = "xmpp.connection.status.changed";
  XMPPEvents2["DISPLAY_NAME_CHANGED"] = "xmpp.display_name_changed";
  XMPPEvents2["DISPLAY_NAME_REQUIRED"] = "xmpp.display_name_required";
  XMPPEvents2["EMUC_ROOM_ADDED"] = "xmpp.emuc_room_added";
  XMPPEvents2["EMUC_ROOM_REMOVED"] = "xmpp.emuc_room_removed";
  XMPPEvents2["ETHERPAD"] = "xmpp.etherpad";
  XMPPEvents2["FOCUS_DISCONNECTED"] = "xmpp.focus_disconnected";
  XMPPEvents2["FOCUS_LEFT"] = "xmpp.focus_left";
  XMPPEvents2["GRACEFUL_SHUTDOWN"] = "xmpp.graceful_shutdown";
  XMPPEvents2["ICE_RESTARTING"] = "rtc.ice_restarting";
  XMPPEvents2["ICE_RESTART_SUCCESS"] = "rtc.ice_restart_success";
  XMPPEvents2["KICKED"] = "xmpp.kicked";
  XMPPEvents2["LOCAL_ROLE_CHANGED"] = "xmpp.localrole_changed";
  XMPPEvents2["MEETING_ID_SET"] = "xmpp.meeting_id_set";
  XMPPEvents2["MESSAGE_RECEIVED"] = "xmpp.message_received";
  XMPPEvents2["INVITE_MESSAGE_RECEIVED"] = "xmpp.invite_message_received";
  XMPPEvents2["PRIVATE_MESSAGE_RECEIVED"] = "xmpp.private_message_received";
  XMPPEvents2["MUC_MEMBER_BOT_TYPE_CHANGED"] = "xmpp.muc_member_bot_type_changed";
  XMPPEvents2["MUC_DESTROYED"] = "xmpp.muc_destroyed";
  XMPPEvents2["MUC_JOIN_IN_PROGRESS"] = "xmpp.muc_join_in_progress";
  XMPPEvents2["MUC_JOINED"] = "xmpp.muc_joined";
  XMPPEvents2["MUC_MEMBER_JOINED"] = "xmpp.muc_member_joined";
  XMPPEvents2["MUC_MEMBER_LEFT"] = "xmpp.muc_member_left";
  XMPPEvents2["MUC_LOBBY_MEMBER_JOINED"] = "xmpp.muc_lobby_member_joined";
  XMPPEvents2["MUC_LOBBY_MEMBER_UPDATED"] = "xmpp.muc_lobby_member_updated";
  XMPPEvents2["MUC_LOBBY_MEMBER_LEFT"] = "xmpp.muc_lobby_member_left";
  XMPPEvents2["MUC_DENIED_ACCESS"] = "xmpp.muc_denied access";
  XMPPEvents2["MUC_LEFT"] = "xmpp.muc_left";
  XMPPEvents2["MUC_ROLE_CHANGED"] = "xmpp.muc_role_changed";
  XMPPEvents2["MUC_LOCK_CHANGED"] = "xmpp.muc_lock_changed";
  XMPPEvents2["MUC_MEMBERS_ONLY_CHANGED"] = "xmpp.muc_members_only_changed";
  XMPPEvents2["PARTICIPANT_AUDIO_MUTED"] = "xmpp.audio_muted";
  XMPPEvents2["PARTICIPANT_VIDEO_MUTED"] = "xmpp.video_muted";
  XMPPEvents2["PARTICIPANT_VIDEO_TYPE_CHANGED"] = "xmpp.video_type";
  XMPPEvents2["PARTICIPANT_FEATURES_CHANGED"] = "xmpp.participant_features_changed";
  XMPPEvents2["PASSWORD_REQUIRED"] = "xmpp.password_required";
  XMPPEvents2["PHONE_NUMBER_CHANGED"] = "conference.phoneNumberChanged";
  XMPPEvents2["PRESENCE_RECEIVED"] = "xmpp.presence_received";
  XMPPEvents2["PRESENCE_STATUS"] = "xmpp.presence_status";
  XMPPEvents2["PROMPT_FOR_LOGIN"] = "xmpp.prompt_for_login";
  XMPPEvents2["READY_TO_JOIN"] = "xmpp.ready_to_join";
  XMPPEvents2["RECORDER_STATE_CHANGED"] = "xmpp.recorderStateChanged";
  XMPPEvents2["REDIRECTED"] = "xmpp.redirected";
  XMPPEvents2["REMOTE_STATS"] = "xmpp.remote_stats";
  XMPPEvents2["RENEGOTIATION_FAILED"] = "xmpp.renegotiation_failed";
  XMPPEvents2["RESERVATION_ERROR"] = "xmpp.room_reservation_error";
  XMPPEvents2["ROOM_CONNECT_ERROR"] = "xmpp.room_connect_error";
  XMPPEvents2["ROOM_CONNECT_NOT_ALLOWED_ERROR"] = "xmpp.room_connect_error.not_allowed";
  XMPPEvents2["ROOM_JOIN_ERROR"] = "xmpp.room_join_error";
  XMPPEvents2["ROOM_CONNECT_MEMBERS_ONLY_ERROR"] = "xmpp.room_connect_error.members_only";
  XMPPEvents2["ROOM_MAX_USERS_ERROR"] = "xmpp.room_max_users_error";
  XMPPEvents2["SENDING_CHAT_MESSAGE"] = "xmpp.sending_chat_message";
  XMPPEvents2["SENDING_PRIVATE_CHAT_MESSAGE"] = "xmpp.sending_private_chat_message";
  XMPPEvents2["SESSION_ACCEPT"] = "xmpp.session_accept";
  XMPPEvents2["SESSION_ACCEPT_ERROR"] = "xmpp.session_accept_error";
  XMPPEvents2["SESSION_ACCEPT_TIMEOUT"] = "xmpp.session_accept_timeout";
  XMPPEvents2["SOURCE_ADD"] = "xmpp.source_add";
  XMPPEvents2["SOURCE_ADD_ERROR"] = "xmpp.source_add_error";
  XMPPEvents2["SOURCE_REMOVE"] = "xmpp.source_remove";
  XMPPEvents2["SOURCE_REMOVE_ERROR"] = "xmpp.source_remove_error";
  XMPPEvents2["SPEAKER_STATS_RECEIVED"] = "xmpp.speaker_stats_received";
  XMPPEvents2["CONFERENCE_TIMESTAMP_RECEIVED"] = "xmpp.conference_timestamp_received";
  XMPPEvents2["AV_MODERATION_APPROVED"] = "xmpp.av_moderation.approved";
  XMPPEvents2["AV_MODERATION_REJECTED"] = "xmpp.av_moderation.rejected";
  XMPPEvents2["AV_MODERATION_RECEIVED"] = "xmpp.av_moderation.received";
  XMPPEvents2["AV_MODERATION_CHANGED"] = "xmpp.av_moderation.changed";
  XMPPEvents2["AV_MODERATION_PARTICIPANT_APPROVED"] = "xmpp.av_moderation.participant.approved";
  XMPPEvents2["AV_MODERATION_PARTICIPANT_REJECTED"] = "xmpp.av_moderation.participant.rejected";
  XMPPEvents2["BREAKOUT_ROOMS_MOVE_TO_ROOM"] = "xmpp.breakout-rooms.move-to-room";
  XMPPEvents2["BREAKOUT_ROOMS_EVENT"] = "xmpp.breakout-rooms.event";
  XMPPEvents2["BREAKOUT_ROOMS_UPDATED"] = "xmpp.breakout-rooms.updated";
  XMPPEvents2["ROOM_METADATA_EVENT"] = "xmpp.room-metadata.event";
  XMPPEvents2["ROOM_METADATA_UPDATED"] = "xmpp.room-metadata.updated";
  XMPPEvents2["START_MUTED_FROM_FOCUS"] = "xmpp.start_muted_from_focus";
  XMPPEvents2["SUBJECT_CHANGED"] = "xmpp.subject_changed";
  XMPPEvents2["SUSPEND_DETECTED"] = "xmpp.suspend_detected";
  XMPPEvents2["TRANSCRIPTION_STATUS_CHANGED"] = "xmpp.transcription_status_changed";
  XMPPEvents2["TRANSPORT_INFO"] = "xmpp.transportinfo.jingle";
  XMPPEvents2["VIDEO_SIP_GW_AVAILABILITY_CHANGED"] = "xmpp.videoSIPGWAvailabilityChanged";
  XMPPEvents2["VIDEO_SIP_GW_SESSION_STATE_CHANGED"] = "xmpp.videoSIPGWSessionStateChanged";
  XMPPEvents2["ICE_CONNECTION_STATE_CHANGED"] = "xmpp.ice_connection_state_changed";
  XMPPEvents2["JSON_MESSAGE_RECEIVED"] = "xmmp.json_message_received";
})(XMPPEvents || (XMPPEvents = {}));
;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/LogCollector.js":
/*!***************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/LogCollector.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* Copyright @ 2016-present 8x8, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Logger = __webpack_require__(/*! ./Logger.js */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/Logger.js");

/**
 * Creates new <tt>LogCollector</tt>. Class implements <tt>LoggerTransport</tt>
 * and thus can be added as global transport in order to capture all the logs.
 *
 * It captures subsequent log lines created whenever <tt>Logger</tt> logs
 * a message and stores them in a queue in order to batch log entries. There are
 * time and size limit constraints which determine how often batch entries are
 * stored. Whenever one of these limits is exceeded the <tt>LogCollector</tt>
 * will use the <tt>logStorage</tt> object given as an argument to save
 * the batch log entry.
 *
 * @param {Object} logStorage an object which allows to store the logs collected
 * @param {function(string|object[])} logStorage.storeLogs a method called when
 * this <tt>LogCollector</tt> requests log entry storage. The method's argument
 * is an array which can contain <tt>string</tt>s and <tt>object</tt>s. If given
 * item is an object it means that it's an aggregated message. That is a message
 * which is the same as the previous one and it's representation has
 * the following format:
 * {
 *   {string} text: 'the text of some duplicated message'
 *   {number} count: 3 // how many times the message appeared in a row
 * }
 * If a message "B" after an aggregated message "A" is different, then it breaks
 * the sequence of "A". Which means that even if the next message "C" is
 * the same as "A" it will start a new aggregated message "C".
 * @param {function()} logStorage.isReady a method which should return
 * a <tt>boolean</tt> to tell the collector that it's ready to store. During the
 * time storage is not ready log batches will be cached and stored on the next
 * occasion (flush or interval timeout).
 *
 * @param {Object} options the <tt>LogCollector</tt> configuration options.
 * @param {number} options.maxEntryLength the size limit for a single log entry
 * to be stored. The <tt>LogCollector</tt> will push the entry as soon as it
 * reaches or exceeds this limit given that <tt>logStorage.isReady</tt>
 * returns <tt>true</tt>. Otherwise the log entry will be cached until the log
 * storage becomes ready. Note that the "is ready" condition is checked every
 * <tt>options.storeInterval</tt> milliseconds.
 * @param {number} options.storeInterval how often the logs should be stored in
 * case <tt>maxEntryLength</tt> was not exceeded.
 * @param {boolean} options.stringifyObjects indicates whether or not object
 * arguments should be "stringified" with <tt>JSON.stringify</tt> when a log
 * message is composed. Note that objects logged on the error log level are
 * always stringified.
 *
 * @constructor
 */
function LogCollector(logStorage, options) {
    this.logStorage = logStorage;
    this.stringifyObjects = options && options.stringifyObjects ? options.stringifyObjects : false;
    this.storeInterval = options && options.storeInterval ? options.storeInterval: 30000;
    this.maxEntryLength = options && options.maxEntryLength ? options.maxEntryLength : 10000;
    // Bind the log method for each level to the corresponding method name
    // in order to implement "global log transport" object.
    Object.keys(Logger.levels).forEach(
    function (logLevel) {
        var methodName = Logger.levels[logLevel];
        this[methodName] = function () {
            this._log.apply(this, arguments);
        }.bind(this, logLevel);
    }.bind(this));
    /**
     * The ID of store logs interval if one is currently scheduled or
     * <tt>null</tt> otherwise.
     * @type {number|null}
     */
    this.storeLogsIntervalID = null;
    /**
     * The log messages that are to be batched into log entry when
     * {@link LogCollector._flush} method is called.
     * @type {string[]}
     */
    this.queue = [];
    /**
     * The total length of all messages currently stored in the {@link queue}.
     * @type {number}
     */
    this.totalLen = 0;
    /**
     * An array used to temporarily store log batches, before the storage gets
     * ready.
     * @type {string[]}
     */
    this.outputCache = [];
}

/**
 * Method called inside of {@link formatLogMessage} in order to covert an
 * <tt>Object</tt> argument to string. The conversion will happen when either
 * 'stringifyObjects' option is enabled or on the {@link Logger.levels.ERROR}
 * log level. The default implementation uses <tt>JSON.stringify</tt> and
 * returns "[object with circular refs?]" instead of an object if it fails.
 *
 * @param {object} someObject the <tt>object</tt> to be stringified.
 *
 * @return {string} the result of <tt>JSON.stringify</tt> or
 * "[object with circular refs?]" if any error occurs during "stringification".
 *
 * @protected
 */
LogCollector.prototype.stringify = function (someObject) {
    try {
        return JSON.stringify(someObject);
    } catch (error) {
        return '[object with circular refs?]';
    }
};

/**
 * Formats log entry for the given logging level and arguments passed to the
 * <tt>Logger</tt>'s log method. The first argument is log level and the next
 * arguments have to be captured using JS built-in 'arguments' variable.
 *
 * @param {Logger.levels} logLevel provides the logging level of the message to
 * be logged.
 * @param {Date} timestamp - The {@code Date} when a message has been logged.
 *
 * @return {string|null} a non-empty string representation of the log entry
 * crafted from the log arguments. If the return value is <tt>null</tt> then
 * the message wil be discarded by this <tt>LogCollector</tt>.
 *
 * @protected
 */
LogCollector.prototype.formatLogMessage = function (
logLevel /* timestamp, arg2, arg3, arg4... */) {
    var msg = '';
    for (var i = 1, len = arguments.length; i < len; i++) {
        var arg = arguments[i];
        // objects logged on error level are always converted to JSON
        if ((this.stringifyObjects || logLevel === Logger.levels.ERROR) &&
            typeof arg === 'object') {
            arg = this.stringify(arg);
        }
        msg += arg;
        if (i !== len - 1) {
            msg += ' ';
        }
    }
    return msg.length ? msg : null;
};

/**
 * The log method bound to each of the logging levels in order to implement
 * "global log transport" object.
 *
 * @private
 */
LogCollector.prototype._log = function() {

    // var logLevel = arguments[0]; first argument is the log level
    var timestamp = arguments[1];
    var msg = this.formatLogMessage.apply(this, arguments);
    if (msg) {
        // The same as the previous message aggregation logic
        var prevMessage = this.queue[this.queue.length - 1];
        var prevMessageText = prevMessage && prevMessage.text;
        if (prevMessageText === msg) {
            prevMessage.count += 1;
        } else {
            this.queue.push({
                text: msg,
                timestamp: timestamp,
                count: 1
            });
            this.totalLen += msg.length;
        }
    }

    if (this.totalLen >= this.maxEntryLength) {
        this._flush(true /* force */, true /* reschedule */);
    }
};

/**
 * Starts periodical "store logs" task which will be triggered at the interval
 * specified in the constructor options.
 */
LogCollector.prototype.start = function () {
    this._reschedulePublishInterval();
};

/**
 * Reschedules the periodical "store logs" task which will store the next batch
 * log entry in the storage.
 * @private
 */
LogCollector.prototype._reschedulePublishInterval = function () {
    if (this.storeLogsIntervalID) {
        window.clearTimeout(this.storeLogsIntervalID);
        this.storeLogsIntervalID = null;
    }
    // It's actually a timeout, because it is rescheduled on every flush
    this.storeLogsIntervalID = window.setTimeout(
        this._flush.bind(
            this, false /* do not force */, true /* reschedule */),
        this.storeInterval);
};

/**
 * Call this method to flush the log entry buffer and store it in the log
 * storage immediately (given that the storage is ready).
 */
LogCollector.prototype.flush = function() {
    this._flush(
        false /* do not force, as it will not be stored anyway */,
        true /* reschedule next update */ );
};

/**
 * Stores the next batch log entry in the log storage.
 * @param {boolean} force enforce current logs batch to be stored or cached if
 * there is anything to be logged, but the storage is not ready yet. One of
 * legitimate reasons to force is when the logs length exceeds size limit which
 * could result in truncation.
 * @param {boolean} reschedule <tt>true</tt> if the next periodic task should be
 * scheduled after the log entry is stored. <tt>false</tt> will end the periodic
 * task cycle.
 * @private
 */
LogCollector.prototype._flush = function(force, reschedule) {
    // Publish only if there's anything to be logged
    if (this.totalLen > 0 && (this.logStorage.isReady() || force)) {
        //FIXME avoid truncating
        // right now we don't care if the message size is "slightly" exceeded
        if (this.logStorage.isReady()) {
            // Sends all cached logs
            if (this.outputCache.length) {
                this.outputCache.forEach(
                    function (cachedQueue) {
                        this.logStorage.storeLogs(cachedQueue);
                    }.bind(this)
                );
                // Clear the cache
                this.outputCache = [];
            }
            // Send current batch
            this.logStorage.storeLogs(this.queue);
        } else {
            this.outputCache.push(this.queue);
        }

        this.queue = [];
        this.totalLen = 0;
    }

    if (reschedule) {
        this._reschedulePublishInterval();
    }
};

/**
 * Stops the periodical "store logs" task and immediately stores any pending
 * log entries as a batch.
 */
LogCollector.prototype.stop = function() {
    // Flush and stop publishing logs
    this._flush(false /* do not force */, false /* do not reschedule */);
};

module.exports = LogCollector;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/Logger.js":
/*!*********************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/Logger.js ***!
  \*********************************************************************/
/***/ ((module) => {

/* Copyright @ 2015-present 8x8, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*jslint latedef:false*/

/**
 * Ordered log levels.
 */
var levels = {
    "trace": 0,
    "debug": 1,
    "info": 2,
    "log": 3,
    "warn": 4,
    "error": 5
};

/**
 * The default transport - console
 * @type LoggerTransport
 */
Logger.consoleTransport = console;

/**
 * The array which stores currently registered global transports.
 * @type {[LoggerTransport]}
 */
var globalTransports = [ Logger.consoleTransport ];

/**
 * Adds given {@link LoggerTransport} instance to the list of global
 * transports which means that it'll be used by all {@link Logger}s
 * @param {LoggerTransport} transport
 */
Logger.addGlobalTransport = function(transport) {
    if (globalTransports.indexOf(transport) === -1) {
        globalTransports.push(transport);
    }
};

/**
 * Removes given {@link LoggerTransport} instance from the list of global
 * transports
 * @param {LoggerTransport} transport
 */
Logger.removeGlobalTransport = function(transport) {
    var transportIdx = globalTransports.indexOf(transport);
    if (transportIdx !== -1) {
        globalTransports.splice(transportIdx, 1);
    }
};

/**
 * The global configuration options.
 */
var globalOptions = {};

/**
 * Sets global options which will be used by all loggers. Changing these works
 * even after other loggers are created.
 */
Logger.setGlobalOptions = function(options) {
    globalOptions = options || {};
};

/**
 * Parses Error's object stack trace and extracts information about the last
 * caller before the log method was called.
 * @returns JS object with info about the caller - method name, file location,
 * line and column.
 */
function getCallerInfo() {
    var callerInfo = {
        methodName: "",
        fileLocation: "",
        line: null,
        column: null
    };
    //gets the part of the stack without the logger wrappers
    var error = new Error();
    var stack = error.stack? error.stack.split("\n") : [];
    if(!stack || stack.length < 3) {
        return callerInfo;
    }
    var m = null;
    if(stack[3]) {
        m = stack[3].match(/\s*at\s*(.+?)\s*\((\S*)\s*:(\d*)\s*:(\d*)\)/);
    }
    if(!m || m.length <= 4) {
        //Firefox && Safari
        if(stack[2].indexOf("log@") === 0){
            //Safari
            callerInfo.methodName = stack[3].substr(0, stack[3].indexOf("@"));
        } else {
            //Firefox
            callerInfo.methodName = stack[2].substr(0, stack[2].indexOf("@"));
        }
        return callerInfo;
    }

    callerInfo.methodName = m[1];
    callerInfo.fileLocation = m[2];
    callerInfo.line = m[3];
    callerInfo.column = m[4];
    return callerInfo;
}

/**
 * Logs messages using the transports and level from the logger.
 * @param logger a logger instance.
 * @param level the log level of the message. See the levels variable.
 * @param arguments array with arguments that will be logged.
 */
function log() {
    var logger = arguments[0], level = arguments[1],
        args = Array.prototype.slice.call(arguments, 2);
    if(levels[level] < logger.level) {
        return;
    }

    var callerInfo
        = !(logger.options.disableCallerInfo || globalOptions.disableCallerInfo) &&
            getCallerInfo();
    var transports = globalTransports.concat(logger.transports);
    for(var i = 0; i < transports.length; i++) {
        var t = transports[i];
        var l = t[level];
        if(l && typeof(l) === "function") {
            var logPrefixes = [];

            logPrefixes.push(new Date().toISOString());

            if (logger.id) {
                logPrefixes.push("[" + logger.id + "]");
            }

            if (callerInfo && callerInfo.methodName.length > 1) {
                logPrefixes.push("<" + callerInfo.methodName + ">: ");
            }

            var fullLogParts = logPrefixes.concat(args);

            l.bind(t).apply(t, fullLogParts);
        }
    }
}

/**
 *
 * Constructs new logger object.
 * @param level the logging level for the new logger
 * @param id optional identifier for the logger instance.
 * @param {LoggerTransport} transports optional list of handlers(objects) for
 * the logs. The handlers must support - log, warn, error, debug, info, trace.
 * @param options optional configuration file for how the logger should behave.
 * @param {boolean} options.disableCallerInfo Whether the call site of a logger
 * method invocation should be included in the log. Defaults to false, so the
 * call site will be included.
 */
function Logger(level, id, transports, options) {
    this.id = id;
    this.options = options || {};
    this.transports = transports;
    if(!this.transports) {
        this.transports = [];
    }
    this.level = levels[level];
    var methods = Object.keys(levels);
    for(var i = 0; i < methods.length; i++){
        this[methods[i]] =
            log.bind(null, this, methods[i]);
    }
}

/**
 * Sets the log level for the logger.
 * @param level the new log level.
 */
Logger.prototype.setLevel = function (level) {
    this.level = levels[level];
};
module.exports = Logger;

/**
 * Enum for the supported log levels.
 */
Logger.levels = {
    TRACE: "trace",
    DEBUG: "debug",
    INFO: "info",
    LOG: "log",
    WARN: "warn",
    ERROR: "error"
};


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* Copyright @ 2015-present 8x8, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Logger = __webpack_require__(/*! ./Logger */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/Logger.js");
var LogCollector = __webpack_require__(/*! ./LogCollector */ "../../lib-jitsi-meet/node_modules/@jitsi/logger/lib/LogCollector.js");

/**
 * Definition of the log method
 * @name log_method
 * @function
 * @param {...*} log_args the arguments to be logged
 */
/**
 * The logger's transport type definition.
 *
 * @typedef {object} LoggerTransport
 *
 * @property {log_method} trace method called to log on {@link Logger.levels.TRACE} logging level
 * @property {log_method} debug method called to log on {@link Logger.levels.DEBUG} logging level
 * @property {log_method} info method called to log on {@link Logger.levels.INFO} logging level
 * @property {log_method} log method called to log on {@link Logger.levels.LOG} logging level
 * @property {log_method} warn method called to log on {@link Logger.levels.WARN} logging level
 * @property {log_method} error method called to log on {@link Logger.levels.ERROR} logging level
 */

/**
 * Map with the created loggers with ID.
 */
var idLoggers = {};

/**
 * Array with the loggers without id.
 */
var loggers = [];

/**
 * Log level for the lbrary.
 */
var curLevel = Logger.levels.TRACE;


module.exports = {
    /**
     * Adds given {@link LoggerTransport} instance to the list of global
     * transports which means that it'll be used by all {@link Logger}s
     * @param {LoggerTransport} transport
     */
    addGlobalTransport: function(transport) {
        Logger.addGlobalTransport(transport);
    },
    /**
     * Removes given {@link LoggerTransport} instance from the list of global
     * transports
     * @param {LoggerTransport} transport
     */
    removeGlobalTransport: function(transport) {
        Logger.removeGlobalTransport(transport);
    },
    /**
    * Sets global options which will be used by all loggers. Changing these
    * works even after other loggers are created.
    */
    setGlobalOptions: function(options) {
        Logger.setGlobalOptions(options);
    },
    /**
     * Creates new logger.
     * @arguments the same as Logger constructor
     */
    getLogger: function(id, transports, options) {
        var logger = new Logger(curLevel, id, transports, options);
        if(id) {
            idLoggers[id] = idLoggers[id] || [];
            idLoggers[id].push(logger);
        } else {
            loggers.push(logger);
        }
        return logger;
    },
    /**
     * Changes the log level for the existing loggers by id.
     * @param level the new log level.
     * @param id if specified the level will be changed only for loggers with the
     * same id. Otherwise the operation will affect all loggers that don't
     * have id.
     */
    setLogLevelById: function(level, id) {
        var l = id? (idLoggers[id] || []) : loggers;
        for(var i = 0; i < l.length; i++) {
            l[i].setLevel(level);
        }
    },
    /**
     * Changes the log level for all existing loggers.
     * @param level the new log level.
     */
    setLogLevel: function (level) {
        curLevel = level;
        var i = 0;
        for(; i < loggers.length; i++) {
            loggers[i].setLevel(level);
        }

        for(var id in idLoggers) {
            var l = idLoggers[id] || [];
            for(i = 0; i < l.length; i++) {
                l[i].setLevel(level);
            }
        }
    },
    /**
     * The supported log levels.
     */
    levels: Logger.levels,
    /**
     * Exports the <tt>LogCollector</tt>.
     */
    LogCollector: LogCollector
};


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/grammar.js":
/*!******************************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/grammar.js ***!
  \******************************************************************************************************/
/***/ ((module) => {

var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{
    // b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [
    {
      // a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding)
          ? 'rtpmap:%d %s/%s/%s'
          : o.rate
            ? 'rtpmap:%d %s/%s'
            : 'rtpmap:%d %s';
      }
    },
    {
      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      // a=fmtp:111 minptime=10; useinbandfec=1
      push: 'fmtp',
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ['payload', 'config'],
      format: 'fmtp:%d %s'
    },
    {
      // a=control:streamid=0
      name: 'control',
      reg: /^control:(.*)/,
      format: 'control:%s'
    },
    {
      // a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null)
          ? 'rtcp:%d %s IP%d %s'
          : 'rtcp:%d';
      }
    },
    {
      // a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: 'rtcp-fb:%s trr-int %d'
    },
    {
      // a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null)
          ? 'rtcp-fb:%s %s %s'
          : 'rtcp-fb:%s %s';
      }
    },
    {
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:1/recvonly URI-gps-string
      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
      push: 'ext',
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
      format: function (o) {
        return (
          'extmap:%d' +
          (o.direction ? '/%s' : '%v') +
          (o['encrypt-uri'] ? ' %s' : '%v') +
          ' %s' +
          (o.config ? ' %s' : '')
        );
      }
    },
    {
      // a=extmap-allow-mixed
      name: 'extmapAllowMixed',
      reg: /^(extmap-allow-mixed)/
    },
    {
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null)
          ? 'crypto:%d %s %s %s'
          : 'crypto:%d %s %s';
      }
    },
    {
      // a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: 'setup:%s'
    },
    {
      // a=connection:new
      name: 'connectionType',
      reg: /^connection:(new|existing)/,
      format: 'connection:%s'
    },
    {
      // a=mid:1
      name: 'mid',
      reg: /^mid:([^\s]*)/,
      format: 'mid:%s'
    },
    {
      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: 'msid',
      reg: /^msid:(.*)/,
      format: 'msid:%s'
    },
    {
      // a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: 'ptime:%d'
    },
    {
      // a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: 'maxptime:%d'
    },
    {
      // a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      // a=ice-lite
      name: 'icelite',
      reg: /^(ice-lite)/
    },
    {
      // a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: 'ice-ufrag:%s'
    },
    {
      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: 'ice-pwd:%s'
    },
    {
      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: 'fingerprint:%s %s'
    },
    {
      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
      format: function (o) {
        var str = 'candidate:%s %d %s %d %s %d typ %s';

        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

        // NB: candidate has three optional chunks, so %void middles one if it's missing
        str += (o.tcptype != null) ? ' tcptype %s' : '%v';

        if (o.generation != null) {
          str += ' generation %d';
        }

        str += (o['network-id'] != null) ? ' network-id %d' : '%v';
        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
        return str;
      }
    },
    {
      // a=end-of-candidates (keep after the candidates line for readability)
      name: 'endOfCandidates',
      reg: /^(end-of-candidates)/
    },
    {
      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: 'remote-candidates:%s'
    },
    {
      // a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: 'ice-options:%s'
    },
    {
      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: 'ssrcs',
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ['id', 'attribute', 'value'],
      format: function (o) {
        var str = 'ssrc:%d';
        if (o.attribute != null) {
          str += ' %s';
          if (o.value != null) {
            str += ':%s';
          }
        }
        return str;
      }
    },
    {
      // a=ssrc-group:FEC 1 2
      // a=ssrc-group:FEC-FR 3004364195 1080772241
      push: 'ssrcGroups',
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ['semantics', 'ssrcs'],
      format: 'ssrc-group:%s %s'
    },
    {
      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: 'msidSemantic',
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: 'msid-semantic: %s %s' // space after ':' is not accidental
    },
    {
      // a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: 'group:%s %s'
    },
    {
      // a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    {
      // a=rtcp-rsize
      name: 'rtcpRsize',
      reg: /^(rtcp-rsize)/
    },
    {
      // a=sctpmap:5000 webrtc-datachannel 1024
      name: 'sctpmap',
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ['sctpmapNumber', 'app', 'maxMessageSize'],
      format: function (o) {
        return (o.maxMessageSize != null)
          ? 'sctpmap:%s %s %s'
          : 'sctpmap:%s %s';
      }
    },
    {
      // a=x-google-flag:conference
      name: 'xGoogleFlag',
      reg: /^x-google-flag:([^\s]*)/,
      format: 'x-google-flag:%s'
    },
    {
      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: 'rids',
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ['id', 'direction', 'params'],
      format: function (o) {
        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
      }
    },
    {
      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      // a=imageattr:* send [x=800,y=640] recv *
      // a=imageattr:100 recv [x=320,y=240]
      push: 'imageattrs',
      reg: new RegExp(
        // a=imageattr:97
        '^imageattr:(\\d+|\\*)' +
        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
        '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
        // recv [x=330,y=250]
        '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
      ),
      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
      format: function (o) {
        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    {
      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      // a=simulcast:recv 1;4,5 send 6;7
      name: 'simulcast',
      reg: new RegExp(
        // a=simulcast:
        '^simulcast:' +
        // send 1,2,3;~4,~5
        '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
        // space + recv 6;~7,~8
        '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
        // end
        '$'
      ),
      names: ['dir1', 'list1', 'dir2', 'list2'],
      format: function (o) {
        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    {
      // old simulcast draft 03 (implemented by Firefox)
      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      // a=simulcast: recv pt=97;98 send pt=97
      // a=simulcast: send rid=5;6;7 paused=6,7
      name: 'simulcast_03',
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ['value'],
      format: 'simulcast: %s'
    },
    {
      // a=framerate:25
      // a=framerate:29.97
      name: 'framerate',
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: 'framerate:%s'
    },
    {
      // RFC4570
      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: 'sourceFilter',
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
      format: 'source-filter: %s %s %s %s %s'
    },
    {
      // a=bundle-only
      name: 'bundleOnly',
      reg: /^(bundle-only)/
    },
    {
      // a=label:1
      name: 'label',
      reg: /^label:(.+)/,
      format: 'label:%s'
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
      name: 'sctpPort',
      reg: /^sctp-port:(\d+)$/,
      format: 'sctp-port:%s'
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
      name: 'maxMessageSize',
      reg: /^max-message-size:(\d+)$/,
      format: 'max-message-size:%s'
    },
    {
      // RFC7273
      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
      push:'tsRefClocks',
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ['clksrc', 'clksrcExt'],
      format: function (o) {
        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
      }
    },
    {
      // RFC7273
      // a=mediaclk:direct=963214424
      name:'mediaClk',
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
      format: function (o) {
        var str = 'mediaclk:';
        str += (o.id != null ? 'id=%s %s' : '%v%s');
        str += (o.mediaClockValue != null ? '=%s' : '');
        str += (o.rateNumerator != null ? ' rate=%s' : '');
        str += (o.rateDenominator != null ? '/%s' : '');
        return str;
      }
    },
    {
      // a=keywds:keywords
      name: 'keywords',
      reg: /^keywds:(.+)$/,
      format: 'keywds:%s'
    },
    {
      // a=content:main
      name: 'content',
      reg: /^content:(.+)/,
      format: 'content:%s'
    },
    // BFCP https://tools.ietf.org/html/rfc4583
    {
      // a=floorctrl:c-s
      name: 'bfcpFloorCtrl',
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: 'floorctrl:%s'
    },
    {
      // a=confid:1
      name: 'bfcpConfId',
      reg: /^confid:(\d+)/,
      format: 'confid:%s'
    },
    {
      // a=userid:1
      name: 'bfcpUserId',
      reg: /^userid:(\d+)/,
      format: 'userid:%s'
    },
    {
      // a=floorid:1
      name: 'bfcpFloorId',
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ['id', 'mStream'],
      format: 'floorid:%s mstrm:%s'
    },
    {
      // any a= that we don't understand is kept verbatim on media.invalid
      push: 'invalid',
      names: ['value']
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/index.js":
/*!****************************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/index.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var parser = __webpack_require__(/*! ./parser */ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/parser.js");
var writer = __webpack_require__(/*! ./writer */ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/writer.js");

exports.write = writer;
exports.parse = parser.parse;
exports.parseParams = parser.parseParams;
exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/parser.js":
/*!*****************************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/parser.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = __webpack_require__(/*! ./grammar */ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/grammar.js");
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var paramReducer = function (acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  } else if (s.length === 1 && expr.length > 1) {
    acc[s[0]] = undefined;
  }
  return acc;
};

exports.parseParams = function (str) {
  return str.split(/;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;

exports.parsePayloads = function (str) {
  return str.toString().split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
  });
};

exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid, paused = false;

      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }

      return {
        scid: scid,
        paused: paused
      };
    });
  });
};


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/writer.js":
/*!*****************************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/writer.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var grammar = __webpack_require__(/*! ./grammar */ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/grammar.js");

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
    case '%%':
      return '%';
    case '%s':
      return String(arg);
    case '%d':
      return Number(arg);
    case '%v':
      return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-simulcast/lib/index.js":
/*!***************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/sdp-simulcast/lib/index.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* Copyright @ 2016 Atlassian Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var transform = __webpack_require__(/*! sdp-transform */ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/index.js");
var transformUtils = __webpack_require__(/*! ./transform-utils */ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-simulcast/lib/transform-utils.js");
var parseSsrcs = transformUtils.parseSsrcs;
var writeSsrcs = transformUtils.writeSsrcs;

//region Constants

var DEFAULT_NUM_OF_LAYERS = 3;

//endregion

function getSsrcAttribute (mLine, ssrc, attributeName) {
    return mLine
        .ssrcs
        .filter(function(ssrcInfo) { return ssrcInfo.id === ssrc; })
        .filter(function(ssrcInfo) { return ssrcInfo.attribute === attributeName; })
        .map(function(ssrcInfo) { return ssrcInfo.value; })[0];
}

//region Ctor

function Simulcast(options) {

    this.options = options ? options : {};

    if (!this.options.numOfLayers) {
        this.options.numOfLayers = DEFAULT_NUM_OF_LAYERS;
    }
    console.log("SdpSimulcast: using " + this.options.numOfLayers + " layers");

    /**
     * An IN-ORDER list of the simulcast ssrcs
     * @type {list<number>}
     */
    this.ssrcCache = [];
}

//endregion

//region Stateless private utility functions

/**
 * Returns a random integer between min (included) and max (excluded)
 * Using Math.round() gives a non-uniform distribution!
 * @returns {number}
 */
function generateSSRC() {
    var min = 0, max = 0xffffffff;
    return Math.floor(Math.random() * (max - min)) + min;
};

function processVideo(session, action) {
    if (session == null || !Array.isArray(session.media)) {
        return;
    }

    session.media.forEach(function (mLine) {
        if (mLine.type === 'video') {
            action(mLine);
        }
    });
};

function validateDescription(desc)
{
    return desc && desc != null
        && desc.type && desc.type != ''
        && desc.sdp && desc.sdp != '';
}

function explodeRemoteSimulcast(mLine) {

    if (!mLine || !Array.isArray(mLine.ssrcGroups)) {
        return;
    }

    var sources = parseSsrcs(mLine);
    var order = [];

    // Find the SIM group and explode its sources.
    var j = mLine.ssrcGroups.length;
    while (j--) {

        if (mLine.ssrcGroups[j].semantics !== 'SIM') {
            continue;
        }

        var simulcastSsrcs = mLine.ssrcGroups[j].ssrcs.split(' ');

        for (var i = 0; i < simulcastSsrcs.length; i++) {

            var ssrc = simulcastSsrcs[i];
            order.push(ssrc);

            var parts = sources[ssrc].msid.split(' ');
            sources[ssrc].msid = [parts[0], '/', i, ' ', parts[1], '/', i].join('');
            sources[ssrc].cname = [sources[ssrc].cname, '/', i].join('');

            // Remove all the groups that this SSRC participates in.
            mLine.ssrcGroups.forEach(function (relatedGroup) {
                if (relatedGroup.semantics === 'SIM') {
                    return;
                }

                var relatedSsrcs = relatedGroup.ssrcs.split(' ');
                if (relatedSsrcs.indexOf(ssrc) === -1) {
                    return;
                }

                // Nuke all the related SSRCs.
                relatedSsrcs.forEach(function (relatedSSRC) {
                    sources[relatedSSRC].msid = sources[ssrc].msid;
                    sources[relatedSSRC].cname = sources[ssrc].cname;
                    if (relatedSSRC !== ssrc) {
                        order.push(relatedSSRC);
                    }
                });

                // Schedule the related group for nuking.
            })
        }

        mLine.ssrcs = writeSsrcs(sources, order);
        mLine.ssrcGroups.splice(j, 1);
    };
}

function implodeRemoteSimulcast(mLine) {

    if (!mLine || !Array.isArray(mLine.ssrcGroups)) {
        console.info('Halt: There are no SSRC groups in the remote ' +
                'description.');
        return;
    }

    var sources = parseSsrcs(mLine);

    // Find the SIM group and nuke it.
    mLine.ssrcGroups.forEach(function (simulcastGroup) {
        if (simulcastGroup.semantics !== 'SIM') {
            return;
        }

        console.info("Imploding SIM group: " + simulcastGroup.ssrcs);
        // Schedule the SIM group for nuking.
        simulcastGroup.nuke = true;

        var simulcastSsrcs = simulcastGroup.ssrcs.split(' ');

        // Nuke all the higher layer SSRCs.
        for (var i = 1; i < simulcastSsrcs.length; i++) {

            var ssrc = simulcastSsrcs[i];
            delete sources[ssrc];

            // Remove all the groups that this SSRC participates in.
            mLine.ssrcGroups.forEach(function (relatedGroup) {
                if (relatedGroup.semantics === 'SIM') {
                    return;
                }

                var relatedSsrcs = relatedGroup.ssrcs.split(' ');
                if (relatedSsrcs.indexOf(ssrc) === -1) {
                    return;
                }

                // Nuke all the related SSRCs.
                relatedSsrcs.forEach(function (relatedSSRC) {
                    delete sources[relatedSSRC];
                });

                // Schedule the related group for nuking.
                relatedGroup.nuke = true;
            })
        }

        return;
    });

    mLine.ssrcs = writeSsrcs(sources);

    // Nuke all the scheduled groups.
    var i = mLine.ssrcGroups.length;
    while (i--) {
        if (mLine.ssrcGroups[i].nuke) {
            mLine.ssrcGroups.splice(i, 1);
        }
    }
}

function removeGoogConference(mLine) {
    if (!mLine || typeof mLine.xGoogleFlag === 'undefined') {
        return;
    }

    mLine.xGoogleFlag = undefined;
}

function assertGoogConference(mLine) {
    if (!mLine) {
        return;
    }

    if (!Array.isArray(mLine.invalid)) {
        mLine.invalid = [];
    }

    if (!mLine.invalid.some(
            function (i) { return i.value === 'x-google-flag:conference' })) {
        mLine.invalid.push({'value': 'x-google-flag:conference'});
    }
}

Simulcast.prototype.clearSsrcCache = function() {
    this.ssrcCache = [];
}

/**
 * When we start as video muted, all of the video
 *  ssrcs get generated so we can include them as part
 *  of the original session-accept.  That means we
 *  need this library to restore to those same ssrcs
 *  the first time we unmute, so we need the ability to
 *  force its cache
 */
Simulcast.prototype.setSsrcCache = function(ssrcs) {
    this.ssrcCache = ssrcs;
}

//endregion

//region "Private" functions

/**
 * Given a video mLine, return a list of the video ssrcs
 *  in simulcast layer order (returns a list of just
 *  the primary ssrc if there are no simulcast layers)
 */
Simulcast.prototype._parseSimLayers = function (mLine) {
    var simGroup = mLine.ssrcGroups &&
        mLine.ssrcGroups.find(function(group) { return group.semantics === "SIM"; });
    if (simGroup) {
        return simGroup.ssrcs
            .split(" ")
            .map(function(ssrcStr) { return parseInt(ssrcStr) });
    } else {
        return [mLine.ssrcs[0].id];
    }
}

Simulcast.prototype._buildNewToOldSsrcMap = function (newSsrcList, oldSsrcList) {
    var ssrcMap = {};
    for (var i = 0; i < newSsrcList.length; ++i) {
        var newSsrc = newSsrcList[i];
        var oldSsrc = oldSsrcList[i] || null;
        ssrcMap[newSsrc] = oldSsrc;
    }
    return ssrcMap;
}

Simulcast.prototype._fillInSourceDataFromCache = function(mLine) {
    console.log("SdpSimulcast restoring from cache: ", this.ssrcCache);
    var newSimSsrcs = this._parseSimLayers(mLine);
    console.log("SdpSimulcast Parsed new sim ssrcs: ", newSimSsrcs);
    var newMsid = getSsrcAttribute(mLine, newSimSsrcs[0], "msid");
    var newCname = getSsrcAttribute(mLine, newSimSsrcs[0], "cname");
    var ssrcsToReplace = this._buildNewToOldSsrcMap(newSimSsrcs, this.ssrcCache);
    console.log("SdpSimulcast built replacement map: ", ssrcsToReplace);
    // New sdp might only have 1 layer, so not every cached ssrc will have a new one
    //  to replace directly
    var ssrcsToAdd = this.ssrcCache
        .filter(function(ssrc) { return Object.values(ssrcsToReplace).indexOf(ssrc) === -1; });
    console.log("SdpSimulcast built ssrcs to add: ", ssrcsToAdd);

    // First do the replacements
    mLine.ssrcs.forEach(function(ssrc) {
        if (ssrcsToReplace[ssrc.id]) {
            ssrc.id = ssrcsToReplace[ssrc.id];
        }
    });
    // Now the adds
    ssrcsToAdd.forEach(function(ssrc) {
        mLine.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: newMsid
        });
        mLine.ssrcs.push({
            id: ssrc,
            attribute: "cname",
            value: newCname
        });
    });
    mLine.ssrcGroups = mLine.ssrcGroups || [];
    mLine.ssrcGroups.push({
        semantics: "SIM",
        ssrcs: this.ssrcCache.join(" ")
    });
    return mLine;
}

Simulcast.prototype._generateSourceData = function(mLine, primarySsrc) {
    var addAssociatedStream = function(mLine, ssrc) {
        mLine.ssrcs.push({
            id: ssrc,
            attribute: "cname",
            value: primarySsrcCname
        });
        mLine.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: primarySsrcMsid
        });
    }
    var primarySsrcMsid = getSsrcAttribute(mLine, primarySsrc, "msid");
    var primarySsrcCname = getSsrcAttribute(mLine, primarySsrc, "cname");

    // In Unified-plan mode, the a=ssrc lines with the msid attribute are not present
    // in the answers that Chrome and Safari generate for an offer received from Jicofo.
    // Generate these a=ssrc lines using the msid values from the a=msid line.
    if (this.options.usesUnifiedPlan && !primarySsrcMsid) {
        primarySsrcMsid = mLine.msid;
        var primarySsrcs = mLine.ssrcs;
        primarySsrcs.forEach(ssrc => {
            mLine.ssrcs.push({
                id: ssrc.id,
                attribute: "msid",
                value: primarySsrcMsid
            });
        });
    }

    // Generate sim layers
    var simSsrcs = [];
    for (var i = 0; i < this.options.numOfLayers - 1; ++i) {
        var simSsrc = generateSSRC();
        addAssociatedStream(mLine, simSsrc);
        simSsrcs.push(simSsrc);
    }
    mLine.ssrcGroups = mLine.ssrcGroups || [];
    mLine.ssrcGroups.push({
        semantics: "SIM",
        ssrcs: primarySsrc + " " + simSsrcs.join(" ")
    });
    return mLine;
}



// Assumptions:
//  1) 'mLine' contains only a single primary video source
//   (i.e. it will not already have simulcast streams inserted)
//  2) 'mLine' MAY already contain an RTX stream for its video source
//  3) 'mLine' is in sendrecv or sendonly state
// Guarantees:
//  1) return mLine will contain 2 additional simulcast layers
//   generated
//  2) if the base video ssrc in mLine has been seen before,
//   then the same generated simulcast streams from before will
//   be used again
//  3) if rtx is enabled for the mLine, all generated simulcast
//   streams will have rtx streams generated as well
//  4) if rtx has been generated for a src before, we will generate
//   the same rtx stream again
Simulcast.prototype._restoreSimulcast = function(mLine) {
    // First, find the primary video source in the given
    // mLine and see if we've seen it before.
    var primarySsrc;
    var numSsrcs = mLine.ssrcs && mLine.ssrcs
        .map(function(ssrcInfo) { return ssrcInfo.id; })
        .filter(function(ssrc, index, array) {
            return array.indexOf(ssrc) === index;
        })
        .length || 0;
    var numGroups = (mLine.ssrcGroups && mLine.ssrcGroups.length) || 0;

    if (numSsrcs === 0 || numSsrcs > 2) {
        // Unsupported scenario
        return mLine;
    }
    if (numSsrcs == 2 && numGroups === 0) {
        // Unsupported scenario
        return mLine;
    }

    if (numSsrcs === 1) {
        primarySsrc = mLine.ssrcs[0].id;
    } else {
        // There must be an FID group, so parse
        //  that and pull the primary ssrc from there
        var fidGroup = mLine.ssrcGroups.filter(function(group) { return group.semantics === "FID"; })[0];
        if (fidGroup) {
            primarySsrc = parseInt(fidGroup.ssrcs.split(" ")[0]);
        } else {
            // Unsupported scenario
            return mLine;
        }
    }
    console.log("SdpSimulcast: current ssrc cache: ", this.ssrcCache);
    console.log("SdpSimulcast: parsed primary ssrc " + primarySsrc);

    var seenPrimarySsrc = this.ssrcCache.indexOf(primarySsrc) !== -1;

    if (seenPrimarySsrc) {
        console.log("SdpSimulcast: Have seen primary ssrc before, " +
            "filling in data from cache");
        mLine = this._fillInSourceDataFromCache(mLine);
    } else {
        console.log("SdpSimulcast: Have not seen primary ssrc before, " +
            "generating source data");
        mLine = this._generateSourceData(mLine, primarySsrc);
    }
    // Now update the cache to match whatever we've just put into this sdp
    this.ssrcCache = this._parseSimLayers(mLine);
    return mLine;
}

//endregion

//region "Public" functions

/**
 *
 * @param desc
 * @param enableConferenceFlag
 * @returns {RTCSessionDescription}
 */
Simulcast.prototype.mungeRemoteDescription = function (desc, enableConferenceFlag) {

    if (!validateDescription(desc)) {
        return desc;
    }

    var session = transform.parse(desc.sdp);

    var self = this;
    processVideo(session, function (mLine) {

        // Handle simulcast reception.
        if (self.options.explodeRemoteSimulcast) {
            explodeRemoteSimulcast(mLine);
        } else {
            implodeRemoteSimulcast(mLine);
        }

        // Add or remove "x-google-conference" from the remote description based on whether the client
        // has enabled simulcast for the local video source. For cases where we disable simulcast for desktop share,
        // it is necessary to remove the flag so that Chrome stops sending T1 temporal layers. It also fixes other
        // issues related to screensharing like https://bugs.chromium.org/p/chromium/issues/detail?id=1093819.
        if (!self.options.usesUnifiedPlan && enableConferenceFlag) {
            assertGoogConference(mLine);
        } else {
            removeGoogConference(mLine);
        }
    });

    return new RTCSessionDescription({
        type: desc.type,
        sdp: transform.write(session)
    });
};

/**
 *
 * NOTE this method should be called only if simulcast is supported by
 * the current browser, otherwise local SDP should not be munged.
 * @param desc
 * @returns {RTCSessionDescription}
 */
Simulcast.prototype.mungeLocalDescription = function (desc) {

    if (!validateDescription(desc)) {
        return desc;
    }

    var session = transform.parse(desc.sdp);

    var self = this;
    processVideo(session, function (mLine) {
        if (mLine.direction == 'recvonly' || mLine.direction == 'inactive')
        {
            return;
        }
        self._restoreSimulcast(mLine);
    });

    return new RTCSessionDescription({
        type: desc.type,
        sdp: transform.write(session)
    });
};

//endregion

module.exports = Simulcast;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-simulcast/lib/transform-utils.js":
/*!*************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/sdp-simulcast/lib/transform-utils.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* Copyright @ 2015 Atlassian Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * FIXME
 * @param sources FIXME
 * @param order An array of SSRCs which will be used to order the entries in
 * the returned array. Sources whose SSRC appears in 'order' will be added first,
 * in the specified order, and all other sources will be added afterwards (in
 * no specific order).
 * @returns {Array} FIXME
 */
exports.writeSsrcs = function(sources, order) {
  var ssrcs = [];

  // expand sources to ssrcs
  if (typeof sources !== 'undefined' &&
      Object.keys(sources).length !== 0) {

    if (!Array.isArray(order)) {
      order = []
    }

    // Add the sources that appear in 'order' first.
    for (var i = 0; i < order.length; i++) {
      var ssrc = order[i];
      var source = sources[ssrc];
      Object.keys(source).forEach(function (attribute) {
        ssrcs.push({
          id: ssrc,
          attribute: attribute,
          value: source[attribute]
        });
      });
    }

    // Now add the rest of the sources.
    Object.keys(sources).forEach(function (ssrc) {
      ssrc = parseInt(ssrc); // Object.keys() returns string
      if (order.indexOf(ssrc) >= 0) {
        // Already added.
        return;
      }

      var source = sources[ssrc];
      Object.keys(source).forEach(function (attribute) {
        ssrcs.push({
          id: ssrc,
          attribute: attribute,
          value: source[attribute]
        });
      });
    });
  }

  return ssrcs;
};

exports.parseSsrcs = function (mLine) {
  var sources = {};
  // group sources attributes by ssrc.
  if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {
    mLine.ssrcs.forEach(function (ssrc) {
      if (!sources[ssrc.id])
        sources[ssrc.id] = {};
      sources[ssrc.id][ssrc.attribute] = ssrc.value;
    });
  }
  return sources;
};



/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@testrtc/watchrtc-sdk/lib/index.js":
/*!****************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@testrtc/watchrtc-sdk/lib/index.js ***!
  \****************************************************************************/
/***/ ((module) => {

!function(e,a){ true?module.exports=a():0}(self,(function(){return(()=>{var e={607:(e,a,n)=>{"use strict";a.ap=a.Tk=a.Vk=a.b1=a.zP=a.$j=a.dL=a.aM=a.vP=a.xt=a.Zt=a.UN=a.IO=a.zl=a.v6=a.S1=void 0,n(699);var r=n(231);a.S1=function(e,a){(0,r.initSDK)(e||{},[""],a)},a.v6=function(e){(0,r.setConfig)(e)},a.zl=function(e){},a.IO=function(e,a){(0,r.setUserRating)(e,a)},a.UN=function(e){(0,r.addKeys)(e)},a.Zt=function(){(0,r.disableDataCollection)()},a.xt=function(){(0,r.enableDataCollection)()},a.vP=function(e){(0,r.addEvent)(e)},a.aM=function(e,a){(0,r.mapStream)(e,a)},a.dL=function(e,a){(0,r.mapTrack)(e,a)},a.$j=function(){(0,r.connect)()},a.zP=function(){(0,r.disconnect)()},a.b1=function(e){(0,r.registerOnStatsListener)(e)},a.Vk=function(e){(0,r.persistentEnd)(e)},a.Tk=function(e,a){(0,r.persistentStart)(e,a)},a.ap=function(e){(0,r.registerStateListener)(e)},a.default={init:a.S1,addTags:a.zl,setUserRating:a.IO,addKeys:a.UN,setConfig:a.v6,disableDataCollection:a.Zt,enableDataCollection:a.xt,addEvent:a.vP,mapStream:a.aM,mapTrack:a.dL,connect:a.$j,disconnect:a.zP,addStatsListener:a.b1,persistentEnd:a.Vk,persistentStart:a.Tk,addStateListener:a.ap}},231:function(e,a,n){"use strict";var r=this&&this.__assign||function(){return r=Object.assign||function(e){for(var a,n=1,r=arguments.length;n<r;n++)for(var o in a=arguments[n])Object.prototype.hasOwnProperty.call(a,o)&&(e[o]=a[o]);return e},r.apply(this,arguments)},o=this&&this.__awaiter||function(e,a,n,r){return new(n||(n=Promise))((function(o,d){function i(e){try{g(r.next(e))}catch(e){d(e)}}function t(e){try{g(r.throw(e))}catch(e){d(e)}}function g(e){var a;e.done?o(e.value):(a=e.value,a instanceof n?a:new n((function(e){e(a)}))).then(i,t)}g((r=r.apply(e,a||[])).next())}))},d=this&&this.__generator||function(e,a){var n,r,o,d,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return d={next:t(0),throw:t(1),return:t(2)},"function"==typeof Symbol&&(d[Symbol.iterator]=function(){return this}),d;function t(d){return function(t){return function(d){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(o=2&d[0]?r.return:d[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,d[1])).done)return o;switch(r=0,o&&(d=[2&d[0],o.value]),d[0]){case 0:case 1:o=d;break;case 4:return i.label++,{value:d[1],done:!1};case 5:i.label++,r=d[1],d=[0];continue;case 7:d=i.ops.pop(),i.trys.pop();continue;default:if(!((o=(o=i.trys).length>0&&o[o.length-1])||6!==d[0]&&2!==d[0])){i=0;continue}if(3===d[0]&&(!o||d[1]>o[0]&&d[1]<o[3])){i.label=d[1];break}if(6===d[0]&&i.label<o[1]){i.label=o[1],o=d;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(d);break}o[2]&&i.ops.pop(),i.trys.pop();continue}d=a.call(e,i)}catch(e){d=[6,e],r=0}finally{n=o=0}if(5&d[0])throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}([d,t])}}},i=this&&this.__spreadArray||function(e,a,n){if(n||2===arguments.length)for(var r,o=0,d=a.length;o<d;o++)!r&&o in a||(r||(r=Array.prototype.slice.call(a,0,o)),r[o]=a[o]);return e.concat(r||Array.prototype.slice.call(a))};Object.defineProperty(a,"__esModule",{value:!0}),a.persistentStart=a.persistentEnd=a.registerStateListener=a.registerOnStatsListener=a.disconnect=a.connect=a.mapTrack=a.mapStream=a.addEvent=a.enableDataCollection=a.disableDataCollection=a.addKeys=a.setUserRating=a.setConfig=a.initSDK=void 0;var t,g,m,c,l,s,p=n(85),v=n(911),f=n(593),u=n(412),x=!!window.mozRTCPeerConnection,h=(!x&&window.RTCPeerConnection&&window.navigator.webkitGetUserMedia,{}),b=0,y={},w={rtcRoomId:void 0,rtcPeerId:void 0,projectId:void 0},k=null,q=null,S=null,z=0,C=!1,_=!1,I=!1,P=!1,T=null,j=f.debugLog.bind(null,(function(){return null==k?void 0:k.debug})),O={},R=function(e){var a,n=e.forceRecreate,o=void 0!==n&&n,d=e.reconnecting,g=void 0!==d&&d,c=e.pcId,s=void 0===c?"PC_unknown":c;if(j("info","maybeOpenWebsocketConnection called: [".concat(s,"]"),{forceRecreate:o,reconnecting:g,isManualDisconnect:P,tryingToConnectSocket:C,watchrtcConfig:k,openChannels:JSON.stringify(h)}),P=!1,(null===(a=null==S?void 0:S.connection)||void 0===a?void 0:a.readyState)===WebSocket.OPEN){if(!(0,f.isRoomIdOrPeerIdChanged)(w,k)||!o)return void j("info","maybeOpenWebsocketConnection. WS connection already opened [".concat(s,"]"));j("info","maybeOpenWebsocketConnection. Closing WS connection. [".concat(s,"]")),null==S||S.close()}var p=(0,f.countOfValidConnections)(h);if(!I&&p<1&&!C)j("info","maybeOpenWebsocketConnection. WS connection not opened - previous connect call not finished or missing peer connection [".concat(s,"]"),{openChannels:JSON.stringify(h),connectionCount:p,tryingToConnectSocket:C,isManualConnect:I});else{var v=(0,f.validateConfig)(k),x=Object.keys(h)[p-1];if(!v)return C=!1,void j("info","maybeOpenWebsocketConnection. WS connection not opened - invalid config [".concat(s,"]"),{watchrtcConfig:k});k.keys&&Object.keys(k.keys||{}).forEach((function(e){"string"==typeof k.keys[e]&&(k.keys[e]=[k.keys[e]])}));var b=!!k.rtcToken,q=(0,f.getConnectionData)("ws",b?k.rtcToken:k.rtcApiKey,k.proxyUrl);S||j("error","maybeOpenWebsocketConnection. WS socket wasn't initialized [".concat(s,"]")),C=!0,z=Date.now(),j("info","maybeOpenWebsocketConnection. Opening websocket connection [".concat(s,"]")),D();var O=Date.now();null==S||S.connect({url:"".concat(q.url,"?").concat(b?"token":"apiKey","=").concat(q.key,"&timestamp=").concat(Date.now()),onData:function(e){for(var a,n=0,o=Object.entries(e);n<o.length;n++){var d=o[n],c=d[0],l=d[1];y[c]=l}if(w.projectId=e.projectId,C=!1,k.allowBrowserLogCollection=Boolean(e.collectConsoleLogEnabled),k.allowBrowserLogCollection?!(null===(a=null==k?void 0:k.console)||void 0===a?void 0:a.override)&&e.collectConsoleLogLevel&&(0,f.setConsoleLevel)(e.collectConsoleLogLevel,t):((0,f.restoreOriginalConsoleMethods)(),(null==S?void 0:S.buffer)&&(S.buffer=S.buffer.filter((function(e){return"log"!==e[0]})))),console.info.apply(console,i(i([],(0,f.logPrefix)("info"),!1),["Connection established. watchRTCConnectionId: ".concat(e.connectionId," sdkVersion:").concat(u.default," [").concat(s,"]")],!1)),t({data:["watchrtc",x,r(r(r({},k),e),{sdkVersion:u.default})]}),g&&t({data:["reconnect",null,null]}),m&&t({data:["hardware",null,m]}),t({data:["sessionId",null,window.watchRTCSessionId]}),e.interval!==k.collectionInterval){var p=k.collectionInterval;k.collectionInterval=e.interval,A(),D(),console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["Collection interval missmatch - connection state reset"],!1)),t({data:["collectionIntervalChange",null,{oldInterval:p}]})}},onError:function(e,a){"auth"===a&&(_=!0),C=!1,z=0},onOpen:function(){T&&T({connectionStatus:"connected"}),_=!1,l&&(clearInterval(l),l=void 0);var e=Date.now()-O;j("info","maybeOpenWebsocketConnection. Connection opened. Opening time - ".concat(e," ms [").concat(s,"]"))},onClose:function(e){T&&T({connectionStatus:"disconnected"});var a=e.code,n=e.reason,r=e.wasClean;j("info","close event",{authFailed:_,code:a,reason:n,wasClean:r}),_?l&&clearInterval(l):l||P||(R({reconnecting:!0,pcId:s}),l=setInterval((function(){R({reconnecting:!0,pcId:s})}),3e4))}})}},D=function(){window.clearInterval(g),g=window.setInterval((function(){return o(this,void 0,void 0,(function(){var e,a,n,o,t,m,c;return d(this,(function(d){switch(d.label){case 0:return I||0!==(0,f.countOfValidConnections)(h)?[3,1]:(j("info","getStatsInterval. No valid connections at this time"),z&&z+2e4<Date.now()&&(window.clearInterval(g),null==S||S.close(),console.info.apply(console,i(i([],(0,f.logPrefix)("info"),!1),["Last connection closed. watchRTCConnectionId: ".concat(null==y?void 0:y.connectionId," sdkVersion: ").concat(u.default)],!1))),[3,6]);case 1:z=Date.now(),e={connections:{},streams:{}},a=0,n=Object.values(h),d.label=2;case 2:return a<n.length?(o=n[a],j("info","getStatsInterval. ".concat(o.id," signalingState: ").concat(o.pc.signalingState)),"closed"===o.pc.signalingState?[3,4]:[4,E(o)]):[3,5];case 3:t=d.sent(),m=t.peer,c=t.streams,e.connections=r(r({},e.connections),m),e.streams=r(r({},e.streams),c),d.label=4;case 4:return a++,[3,2];case 5:s&&s(e),d.label=6;case 6:return[2]}}))}))}),k.collectionInterval)},E=function(e){return new Promise((function(a,n){if(e){var r=e.id,o=e.pc,d=e.prev;o.getStats(null).then((function(n){(null==k?void 0:k.logGetStats)&&j("info","getStats res",{res:n});var o={};x?n.forEach((function(e){o["".concat(e.type,"_").concat(e.id)]=e})):o=(0,f.map2obj)(n);var i=JSON.parse(JSON.stringify(o));o=(0,f.applyPatchForRTT)(d,o);var g=(0,f.deltaCompression)(d,o);(null==k?void 0:k.logGetStats)&&j("info","getStats(null) [".concat(r,"]"),{data:g}),null!==(null==g?void 0:g.timestamp)&&(null==g?void 0:g.timestamp)!==-1/0&&t({data:["getstats",r,g]}),e.prev=i,a((0,f.exposeApplicationStatsForPC)(r,d,o,O))}))}}))};a.initSDK=function(e,a,n){var o,d;if(!window.watchRTCInitialized){-1!==RTCPeerConnection.toString().indexOf("[native code]")||console.warn.apply(console,i(i([],(0,f.logPrefix)("info"),!1),["init. RTCPeerConnection object has been already overridden"],!1)),window.watchRTCInitialized=!0,window.watchRTCSessionId=(0,f.generateID)(),setTimeout((function(){var e=Date.now();(0,f.getHardwareInfo)().then((function(a){var n=Date.now()-e;n<=5e4?j("info","getHardware",{hardwareInfo:m=a}):j("info","getHardware failure: getHardwareTime: ".concat(n),{hardwareInfo:m})})).catch((function(e){console.error("Error. Get hardware info: ".concat(e.message))}))}),0);var g=new URLSearchParams(location.search);if(g.has("watchrtc")&&"debug"===g.get("watchrtc")&&(e.debug=!0),S=(null==n?void 0:n.socketService)||new p.default({debug:null==e?void 0:e.debug}),q=(null==n?void 0:n.httpService)||new v.default({debug:null==e?void 0:e.debug}),e.collectionInterval=null!==(o=e.collectionInterval)&&void 0!==o?o:8e3,k=e,w.rtcRoomId=k.rtcRoomId,w.rtcPeerId=k.rtcPeerId,t=S.trace,k.wsUrl&&console.warn.apply(console,i(i([],(0,f.logPrefix)("info"),!1),['"wsUrl" config property is deprecated. Use "proxyUrl" instead of it'],!1)),k.proxyUrl&&console.info.apply(console,i(i([],(0,f.logPrefix)("info"),!1),['"proxyUrl" is used'],!1)),a.forEach((function(e){if(window[e+"RTCPeerConnection"]){var a=window[e+"RTCPeerConnection"],n=function(e,n){(null==e?void 0:e.watchrtc)&&(k=r(r({},k),e.watchrtc)),j("info","new RTCPeerConnection called.",{config:e,constraints:n});var o=new a(e,n),d="PC_"+b++;return o.__rtcStatsId=d,h[d]={id:d,pc:o,validConnection:!1},e||(e={nullConfig:!0}),((e=JSON.parse(JSON.stringify(e)))&&e.iceServers||[]).forEach((function(e){delete e.credential})),(null==e?void 0:e.watchrtc)&&delete e.watchrtc,e.browserType=x?"moz":"webkit",t({data:["create",d,e]}),n&&t({data:["constraints",d,n]}),o.addEventListener("icecandidate",(function(e){t({data:["onicecandidate",d,e.candidate]})})),o.addEventListener("icecandidateerror",(function(e){t({data:["onicecandidateerror",d,e]})})),o.addEventListener("addstream",(function(e){t({data:["onaddstream",d,e.stream.id+" "+e.stream.getTracks().map((function(e){return e.kind+":"+e.id}))]})})),o.addEventListener("track",(function(e){t({data:["ontrack",d,e.track.kind+":"+e.track.id+" state:"+e.track.readyState+" muted:"+e.track.muted+" "+e.streams.map((function(e){return"stream:"+e.id}))]}),e.track.onended=function(){t({data:["ontrack",d,e.track.kind+":"+e.track.id+" state:"+e.track.readyState+" "+e.streams.map((function(e){return"stream:"+e.id}))]})},e.track.onmute=function(){t({data:["ontrack",d,e.track.kind+":"+e.track.id+" state:"+e.track.readyState+" muted:"+e.track.muted+" "+e.streams.map((function(e){return"stream:"+e.id}))]})},e.track.onunmute=function(){t({data:["ontrack",d,e.track.kind+":"+e.track.id+" state:"+e.track.readyState+" muted:"+e.track.muted+" "+e.streams.map((function(e){return"stream:"+e.id}))]})}})),o.addEventListener("removestream",(function(e){t({data:["onremovestream",d,e.stream.id+" "+e.stream.getTracks().map((function(e){return e.kind+":"+e.id}))]})})),o.addEventListener("signalingstatechange",(function(){h[d]&&!h[d].validConnection?(h[d].validConnection=!0,setTimeout((function(){R({forceRecreate:!0,pcId:d})}),5e3)):j("info","signalingstatechage. WS connection opening not triggered - peer connection not in channels or was already opened [".concat(d,"]"),{openChannels:JSON.stringify(h)}),t({data:["onsignalingstatechange",d,o.signalingState]})})),o.addEventListener("iceconnectionstatechange",(function(){t({data:["oniceconnectionstatechange",d,o.iceConnectionState]})})),o.addEventListener("icegatheringstatechange",(function(){t({data:["onicegatheringstatechange",d,o.iceGatheringState]})})),o.addEventListener("connectionstatechange",(function(){t({data:["onconnectionstatechange",d,o.connectionState]})})),o.addEventListener("negotiationneeded",(function(){t({data:["onnegotiationneeded",d,void 0]})})),o.addEventListener("datachannel",(function(e){t({data:["ondatachannel",d,[e.channel.id,e.channel.label]]})})),o};if("HTMLMediaElement"in window&&"setSinkId"in HTMLMediaElement.prototype){var o=HTMLMediaElement.prototype.setSinkId;HTMLMediaElement.prototype.setSinkId=function(){var e=arguments[0];return navigator.mediaDevices.enumerateDevices().then((function(a){var n=a.find((function(a){return a.deviceId===e}));n&&n.deviceId!==c&&t({data:["audioOutputChange",null,n.label]}),c=e})).catch((function(e){j("error",e.message,{error:e})})),o.apply(this,arguments)}}if("RTCRtpTransceiver"in window&&"setCodecPreferences"in window.RTCRtpTransceiver.prototype){var d=window.RTCRtpTransceiver,i=d.prototype.setCodecPreferences;d.prototype.setCodecPreferences=function(){return t({data:["setCodecPreferences",this.__pcId,arguments]}),i.apply(this,arguments)}}if("RTCRtpSender"in window&&"setParameters"in window.RTCRtpSender.prototype){var g=(m=window.RTCRtpSender).prototype.setParameters;m.prototype.setParameters=function(){return t({data:["setParameters",this.__pcId,arguments]}),g.apply(this,arguments)}}if("RTCRtpSender"in window&&"replaceTrack"in window.RTCRtpSender.prototype){var m,l=(m=window.RTCRtpSender).prototype.replaceTrack;m.prototype.replaceTrack=function(){var e=arguments[0];return t(e?{data:["replaceTrack",this.__pcId,e.kind+":"+e.id+" state:"+e.readyState+" muted:"+e.muted+" label:"+e.label]}:{data:["replaceTrack",this.__pcId,null]}),l.apply(this,arguments)}}["addTransceiver"].forEach((function(e){var n=a.prototype[e];n&&(a.prototype[e]=function(){var a=this,o="";arguments[1]&&arguments[1].streams&&(o=arguments[1].streams.map((function(e){return"stream:"+e.id})).join(";"));var d="string"==typeof arguments[0]?arguments[0]:arguments[0].kind+":"+arguments[0].id+" "+arguments[0].label,i=arguments[1]?r(r({},arguments[1]),{streams:o}):null;t({data:[e,this.__rtcStatsId,[d,i]]});var g=n.apply(this,arguments);g.sender.__pcId=this.__rtcStatsId;var m=arguments[0];return"object"==typeof m&&(t({data:["onlocaltrack",this.__rtcStatsId,m.kind+":"+m.id+" state:"+m.readyState+" muted:"+m.muted+" label:"+m.label]}),m.onended=function(){t({data:["onlocaltrack",a.__rtcStatsId,m.kind+":"+m.id+" state:"+m.readyState+" label:"+m.label]})},m.onmute=function(){t({data:["onlocaltrack",a.__rtcStatsId,m.kind+":"+m.id+" state:"+m.readyState+" muted:"+m.muted+" label:"+m.label]})},m.onunmute=function(){t({data:["onlocaltrack",a.__rtcStatsId,m.kind+":"+m.id+" state:"+m.readyState+" muted:"+m.muted+" label:"+m.label]})}),g})})),["createDataChannel","restartIce"].forEach((function(e){var n=a.prototype[e];n&&(a.prototype[e]=function(){return t({data:[e,this.__rtcStatsId,arguments]}),n.apply(this,arguments)})})),["close"].forEach((function(e){var n=a.prototype[e];n&&(a.prototype[e]=function(){return t({data:[e,this.__rtcStatsId,arguments]}),delete h[this.__rtcStatsId],P=!0,j("info","on RTCPeerConnection(".concat(this.__rtcStatsId,") close")),n.apply(this,arguments)})})),["addStream","removeStream"].forEach((function(e){var n=a.prototype[e];n&&(a.prototype[e]=function(){var a=this,r=arguments[0],o=r.getTracks().map((function(e){return e.kind+":"+e.id})).join(",");return t({data:[e,this.__rtcStatsId,r.id+" "+o]}),"addStream"===e&&r.getTracks().map((function(e){t({data:["onlocaltrack",a.__rtcStatsId,e.kind+":"+e.id+" state:"+e.readyState+" muted:"+e.muted+" label:"+e.label+" "+r.id]}),e.onended=function(){t({data:["onlocaltrack",a.__rtcStatsId,e.kind+":"+e.id+" state:"+e.readyState+" label:"+e.label+" "+r.id]})},e.onmute=function(){t({data:["onlocaltrack",a.__rtcStatsId,e.kind+":"+e.id+" state:"+e.readyState+" muted:"+e.muted+" label:"+e.label+" "+r.id]})},e.onunmute=function(){t({data:["onlocaltrack",a.__rtcStatsId,e.kind+":"+e.id+" state:"+e.readyState+" muted:"+e.muted+" label:"+e.label+" "+r.id]})}})),n.apply(this,arguments)})})),["addTrack"].forEach((function(e){var n=a.prototype[e];n&&(a.prototype[e]=function(){var a=this,r=arguments[0],o=[].slice.call(arguments,1);t({data:[e,this.__rtcStatsId,r.kind+":"+r.id+" "+r.label+" "+(o.map((function(e){return"stream:"+e.id})).join(";")||"-")]}),t({data:["onlocaltrack",this.__rtcStatsId,r.kind+":"+r.id+" state:"+r.readyState+" muted:"+r.muted+" label:"+r.label+" "+o.map((function(e){return"stream:"+e.id}))]}),r.onended=function(){t({data:["onlocaltrack",a.__rtcStatsId,r.kind+":"+r.id+" state:"+r.readyState+" label:"+r.label+" "+o.map((function(e){return"stream:"+e.id}))]})},r.onmute=function(){t({data:["onlocaltrack",a.__rtcStatsId,r.kind+":"+r.id+" state:"+r.readyState+" muted:"+r.muted+" label:"+r.label+" "+o.map((function(e){return"stream:"+e.id}))]})},r.onunmute=function(){t({data:["onlocaltrack",a.__rtcStatsId,r.kind+":"+r.id+" state:"+r.readyState+" muted:"+r.muted+" label:"+r.label+" "+o.map((function(e){return"stream:"+e.id}))]})};var d=n.apply(this,arguments);d.__pcId=this.__rtcStatsId;var i=this.getTransceivers();return i&&i.forEach((function(e){e.__pcId=a.__rtcStatsId})),d})})),["removeTrack"].forEach((function(e){var n=a.prototype[e];n&&(a.prototype[e]=function(){var a=arguments[0].track;return t({data:[e,this.__rtcStatsId,a?a.kind+":"+a.id+" "+a.label:"null"]}),n.apply(this,arguments)})})),["createOffer","createAnswer"].forEach((function(e){var n=a.prototype[e];n&&(a.prototype[e]=function(){var a,r=this.__rtcStatsId,o=arguments;return 1===arguments.length&&"object"==typeof arguments[0]?a=arguments[0]:3===arguments.length&&"object"==typeof arguments[2]&&(a=arguments[2]),t({data:[e,this.__rtcStatsId,a]}),n.apply(this,a?[a]:void 0).then((function(a){if(t({data:[e+"OnSuccess",r,a]}),!(o.length>0&&"function"==typeof o[0]))return a;o[0].apply(null,[a])}),(function(a){if(t({data:[e+"OnFailure",r,a.toString()]}),!(o.length>1&&"function"==typeof o[1]))throw a;o[1].apply(null,[a])}))})})),["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach((function(e){var n=a.prototype[e];n&&(a.prototype[e]=function(){var a=this.__rtcStatsId,r=arguments,o=this,d="setLocalDescription"===e&&(!r[0]||r[0]&&!r[0].sdp);return t({data:[e,this.__rtcStatsId,d?{parameterless:!0}:r[0]]}),n.apply(this,[r[0]]).then((function(){t({data:[e+"OnSuccess",a,d?null==o?void 0:o.localDescription:void 0]}),r.length>=2&&"function"==typeof r[1]&&r[1].apply(null,[])}),(function(n){if(t({data:[e+"OnFailure",a,n.toString()]}),!(r.length>=3&&"function"==typeof r[2]))throw n;r[2].apply(null,[n])}))})})),a.generateCertificate&&Object.defineProperty(n,"generateCertificate",{get:function(){return arguments.length?a.generateCertificate.apply(null,arguments):a.generateCertificate}}),window[e+"RTCPeerConnection"]=n,window[e+"RTCPeerConnection"].prototype=a.prototype}})),a.forEach((function(e){var a=e+(e.length?"GetUserMedia":"getUserMedia");if(navigator[a]){var n=navigator[a].bind(navigator);navigator[a]=function(){t({data:["getUserMedia",null,arguments[0]]});var e=arguments[1],a=arguments[2];n(arguments[0],(function(a){t({data:["getUserMediaOnSuccess",null,(0,f.dumpStream)(a)]}),e&&e(a)}),(function(e){var n=["getUserMediaOnFailure",null,e.name];t({data:n}),L(n),a&&a(e)}))}.bind(navigator)}})),navigator.mediaDevices&&navigator.mediaDevices.getUserMedia){var l=navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getUserMedia=function(){return t({data:["navigator.mediaDevices.getUserMedia",null,arguments[0]]}),l.apply(navigator.mediaDevices,arguments).then((function(e){return t({data:["navigator.mediaDevices.getUserMediaOnSuccess",null,(0,f.dumpStream)(e)]}),e}),(function(e){var a=["navigator.mediaDevices.getUserMediaOnFailure",null,e.name];return t({data:a}),L(a),Promise.reject(e)}))}.bind(navigator.mediaDevices)}if(navigator.mediaDevices&&navigator.mediaDevices.getDisplayMedia){var s=navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getDisplayMedia=function(){return t({data:["navigator.mediaDevices.getDisplayMedia",null,arguments[0]]}),s.apply(navigator.mediaDevices,arguments).then((function(e){return t({data:["navigator.mediaDevices.getDisplayMediaOnSuccess",null,(0,f.dumpStream)(e)]}),e}),(function(e){var a=["navigator.mediaDevices.getDisplayMediaOnFailure",null,e.name];return t({data:a}),L(a),Promise.reject(e)}))}.bind(navigator.mediaDevices)}(null===(d=e.console)||void 0===d?void 0:d.level)&&(0,f.setConsoleLevel)(e.console.level,t)}},a.setConfig=function(e){var a;window.watchRTCInitialized?(!(!1===(null==k?void 0:k.allowBrowserLogCollection))&&!0===(null===(a=null==e?void 0:e.console)||void 0===a?void 0:a.override)&&e.console.level&&(0,f.setConsoleLevel)(e.console.level,t),"collectionInterval"in e&&delete e.collectionInterval,k=r(r({},k),e),w.rtcRoomId=k.rtcRoomId,w.rtcPeerId=k.rtcPeerId,j("info","setConfig",{newWatchrtcConfig:e,watchrtcConfig:k}),R({})):console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["SDK is not initialized. Use 'init' function first."],!1))},a.setUserRating=function(e,a){var n;if(!window.watchRTCInitialized)return console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["SDK is not initialized. Use 'init' function first."],!1)),Promise.resolve({error:"SDK is not initialized. Use 'init' function first."});if(!(0,f.validateRating)(e))return Promise.resolve({error:"Rating is invalid"});var r=(null===(n=null==S?void 0:S.connection)||void 0===n?void 0:n.readyState)===WebSocket.OPEN,o=["userRating",null,{rating:e,ratingComment:a}];return new Promise((function(e,a){r?t({data:o,options:{promiseFuncs:{resolve:e,reject:a}}}):M.apply(void 0,o).then((function(){return e({})})).catch((function(a){return e({error:a})}))}))},a.addKeys=function(e){var a;if(window.watchRTCInitialized){Object.keys(e||{}).forEach((function(a){"string"==typeof e[a]&&(e[a]=[e[a]])}));var n=["keys",null,e],r=(null===(a=null==S?void 0:S.connection)||void 0===a?void 0:a.readyState)===WebSocket.OPEN,o=null==S?void 0:S.wasConnected;return new Promise((function(e,a){var d={promiseFuncs:{resolve:e,reject:a}};r?t({data:n,options:d}):o?M.apply(void 0,n).then((function(){return e({})})).catch((function(a){return e({error:a})})):t({data:n,options:d})}))}console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["SDK is not initialized. Use 'init' function first."],!1))},a.disableDataCollection=function(){window.watchRTCInitialized?null==S||S.disableDataCollection():console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["SDK is not initialized. Use 'init' function first."],!1))},a.enableDataCollection=function(){window.watchRTCInitialized?null==S||S.enableDataCollection():console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["SDK is not initialized. Use 'init' function first."],!1))},a.addEvent=function(e){if(window.watchRTCInitialized){if((0,f.validateEvent)(e)){var a=["event",null,e];return new Promise((function(e,n){t({data:a,options:{promiseFuncs:{resolve:e,reject:n}}})}))}}else console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["addEvent error. SDK is not initialized. Use 'init' function first."],!1))},a.mapStream=function(e,a){if(window.watchRTCInitialized){if(e&&a){var n=["mapStream",null,{id:e,name:a}];console.info.apply(console,i(i([],(0,f.logPrefix)("info"),!1),["mapStream method is deprecated. Please use mapTrack instead."],!1)),t({data:n})}}else console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["mapStream error. SDK is not initialized. Use 'init' function first."],!1))},a.mapTrack=function(e,a){window.watchRTCInitialized?!e||!a||(O[e]=a,t({data:["mapTrack",null,{id:e,name:a}]})):console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["mapTrack error. SDK is not initialized. Use 'init' function first."],!1))},a.connect=function(){window.watchRTCInitialized?(I=!0,j("info","manual connect"),R({})):console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["connect error. SDK is not initialized. Use 'init' function first."],!1))},a.disconnect=function(){window.watchRTCInitialized?(I=!1,P=!0,null==S||S.close(),j("info","manual disconnect")):console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["disconnect error. SDK is not initialized. Use 'init' function first."],!1))},a.registerOnStatsListener=function(e){s=e},a.registerStateListener=function(e){T=e};var M=function(){for(var e,a=[],n=0;n<arguments.length;n++)a[n]=arguments[n];if(!w.rtcRoomId||!w.rtcPeerId){var r="Cannot do http without room and peer ids";return console.log.apply(console,i(i([],(0,f.logPrefix)("info"),!1),[r],!1)),Promise.reject(r)}if(!w.projectId&&!k.rtcApiKey)return r="Missing apiKey to enable trace before connection establishment",console.log.apply(console,i(i([],(0,f.logPrefix)("info"),!1),[r],!1)),Promise.reject(r);var o=(0,f.getConnectionData)("http",k.rtcApiKey,k.proxyUrl);return q?q.trace.apply(q,i(["".concat(o.url,"/trace"),null!==(e=w.projectId)&&void 0!==e?e:o.key,w.rtcRoomId,w.rtcPeerId],a,!1)):Promise.reject("Invalid configuration of http service")},L=function(e){var a=null==k?void 0:k.rtcApiKey,n=null==k?void 0:k.rtcRoomId,r=null==k?void 0:k.rtcPeerId;if(a&&n&&r){var o=(0,f.getConnectionData)("http",null==k?void 0:k.rtcApiKey,k.proxyUrl);e=e||(null==S?void 0:S.buffer)||[],null==q||q.trace("".concat(o.url,"/error"),o.key,n,r,e)}else console.log.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["Cannot report an error. Please provide apiKey, rtcRoomId and rtcPeerId "],!1))};a.persistentEnd=function(e){window.watchRTCInitialized?(clearInterval(g),I=!1,P=!0,null==S||S.close(e),j("info","persistentEnd. sessionId: ".concat(window.watchRTCSessionId))):console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["persistentEnd error. SDK is not initialized. Use 'init' function first."],!1))};var A=function(){for(var e,a=0,n=Object.values(h);a<n.length;a++)n[a].prev=null;(null===(e=null==S?void 0:S.buffer)||void 0===e?void 0:e.length)&&(S.buffer=[])};a.persistentStart=function(e,a){window.watchRTCInitialized?(k=r(r({},k),{rtcRoomId:e,rtcPeerId:a}),w.rtcRoomId=e,w.rtcPeerId=a,A(),R({}),j("info","persistentStart. sessionId: ".concat(window.watchRTCSessionId),{watchrtcConfig:k})):console.info.apply(console,i(i([],(0,f.logPrefix)("error"),!1),["persistentStart error. SDK is not initialized. Use 'init' function first."],!1))}},527:(e,a)=>{"use strict";Object.defineProperty(a,"__esModule",{value:!0}),a.getStreamsFromStats=a.getTransportFromStats=void 0,a.getTransportFromStats=function(e,a){if(!a)return null;var n=Object.keys(a),r=n.filter((function(e){return"candidate-pair"===a[e].type&&a[e].nominated}));if(r.length>0){var o=a[r[0]],d=o.localCandidateId,i=o.remoteCandidateId,t=n.find((function(e){return"local-candidate"===a[e].type&&a[e].id===d})),g=n.find((function(e){return"remote-candidate"===a[e].type&&a[e].id===i}));if(t&&g){var m=a[t],c=a[g],l={};return l[e]={connection:"relay"===m.candidateType?"relay":"direct",transport:"relay"===m.candidateType?m.relayProtocol:"udp",address:"".concat(c.address,":").concat(c.port)},l}}return null},a.getStreamsFromStats=function(e,a,n,r){var o={},d=Object.keys(n);return d.filter((function(e){return"inbound-rtp"===n[e].type||"outbound-rtp"===n[e].type})).forEach((function(i){var t=n[i],g=a&&i in a?a[i]:null,m="inbound-rtp"===t.type?"inbound":"outbound",c=t.kind,l=t.remoteId in n?n[t.remoteId]:null,s=g&&g.remoteId in a?a[g.remoteId]:null,p=g?(t.timestamp-g.timestamp)/1e3:null,v={direction:m,kind:c,peerId:e};if("video"===c&&(v.frameWidth=t.frameWidth,v.frameHeight=t.frameHeight,v.framerate=t.framesPerSecond),"inbound-rtp"===t.type)v.jitter=t.jitter,v.mappedName=t.trackIdentifier in r?r[t.trackIdentifier]:null,v.bytesReceived=g?t.bytesReceived-g.bytesReceived:null,v.packetsReceived=g?t.packetsReceived-g.packetsReceived:null,v.packetsLost=g?t.packetsLost-g.packetsLost:null,v.packetsLoss=v.packetsLost+v.packetsReceived>0?100*v.packetsLost/(v.packetsLost+v.packetsReceived):null,v.bitrate=p?8*v.bytesReceived/p:null,v.roundTripTime=l&&"roundTripTime"in l?l.roundTripTime:null;else{v.bytesSent=g?t.bytesSent-g.bytesSent:null,v.packetsSent=g?t.packetsSent-g.packetsSent:null,v.bitrate=p?8*v.bytesSent/p:null,v.roundTripTime=l&&"roundTripTime"in l?l.roundTripTime:null,v.jitter=l&&"jitter"in l?l.jitter:null,v.packetsLost=l&&s?l.packetsLost-s.packetsLost:null,v.packetsLoss=l&&"fractionLost"in l?l.fractionLost:null;var f=d.find((function(e){return n[e].id===t.mediaSourceId}));if(f){var u=n[f].trackIdentifier;v.mappedName=u in r?r[u]:null}}o[n[i].id]=v})),o}},699:(e,a)=>{"use strict";Object.defineProperty(a,"__esModule",{value:!0})},593:function(e,a,n){"use strict";var r=this&&this.__assign||function(){return r=Object.assign||function(e){for(var a,n=1,r=arguments.length;n<r;n++)for(var o in a=arguments[n])Object.prototype.hasOwnProperty.call(a,o)&&(e[o]=a[o]);return e},r.apply(this,arguments)},o=this&&this.__awaiter||function(e,a,n,r){return new(n||(n=Promise))((function(o,d){function i(e){try{g(r.next(e))}catch(e){d(e)}}function t(e){try{g(r.throw(e))}catch(e){d(e)}}function g(e){var a;e.done?o(e.value):(a=e.value,a instanceof n?a:new n((function(e){e(a)}))).then(i,t)}g((r=r.apply(e,a||[])).next())}))},d=this&&this.__generator||function(e,a){var n,r,o,d,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return d={next:t(0),throw:t(1),return:t(2)},"function"==typeof Symbol&&(d[Symbol.iterator]=function(){return this}),d;function t(d){return function(t){return function(d){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(o=2&d[0]?r.return:d[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,d[1])).done)return o;switch(r=0,o&&(d=[2&d[0],o.value]),d[0]){case 0:case 1:o=d;break;case 4:return i.label++,{value:d[1],done:!1};case 5:i.label++,r=d[1],d=[0];continue;case 7:d=i.ops.pop(),i.trys.pop();continue;default:if(!((o=(o=i.trys).length>0&&o[o.length-1])||6!==d[0]&&2!==d[0])){i=0;continue}if(3===d[0]&&(!o||d[1]>o[0]&&d[1]<o[3])){i.label=d[1];break}if(6===d[0]&&i.label<o[1]){i.label=o[1],o=d;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(d);break}o[2]&&i.ops.pop(),i.trys.pop();continue}d=a.call(e,i)}catch(e){d=[6,e],r=0}finally{n=o=0}if(5&d[0])throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}([d,t])}}},i=this&&this.__spreadArray||function(e,a,n){if(n||2===arguments.length)for(var r,o=0,d=a.length;o<d;o++)!r&&o in a||(r||(r=Array.prototype.slice.call(a,0,o)),r[o]=a[o]);return e.concat(r||Array.prototype.slice.call(a))};Object.defineProperty(a,"__esModule",{value:!0}),a.generateID=a.applyPatchForRTT=a.exposeApplicationStatsForPC=a.restoreOriginalConsoleMethods=a.setConsoleLevel=a.getHardwareInfo=a.validateEvent=a.validateRating=a.isRoomIdOrPeerIdChanged=a.countOfValidConnections=a.validateConfig=a.getConnectionData=a.dumpStream=a.map2obj=a.mangleChromeStats=a.deltaCompression=a.debugLog=a.logPrefix=void 0;var t=n(240),g=n(527);a.logPrefix=function(e){return void 0===e&&(e="info"),"error"===e?["%cwatchRTC %cERROR","background: ".concat("gold","; color: black; padding: 2px 0.5em; border-radius: 0.5em;"),"background: ".concat("red","; color: white; padding: 2px 0.5em; border-radius: 0.5em;")]:["%cwatchRTC","background: ".concat("gold","; color: black; padding: 2px 0.5em; border-radius: 0.5em;")]},a.debugLog=function(e,n,r,o){if(e()){var d=i(i([],(0,a.logPrefix)(n),!0),[r],!1);o&&d.push(o),console.log.apply(console,d)}},a.deltaCompression=function(e,a){e=e||{},a=a||{},a=JSON.parse(JSON.stringify(a)),Object.keys(a).forEach((function(n){var r=a[n];delete r.id,e[n]&&Object.keys(r).forEach((function(o){r.timestamp&&"string"==typeof r.timestamp&&(r.timestamp=new Date(r.timestamp).getTime()),(r[o]===e[n][o]||Array.isArray(r[o])&&JSON.stringify(r[o])===JSON.stringify(e[n][o]))&&delete a[n][o],(0===Object.keys(r).length||1===Object.keys(r).length&&r.timestamp)&&delete a[n]}))}));var n=-1/0;return Object.keys(a).forEach((function(e){var r=a[e];r.timestamp>n&&(n=r.timestamp)})),Object.keys(a).forEach((function(e){var r=a[e];r.timestamp===n&&(r.timestamp=0)})),a.timestamp=n,a},a.mangleChromeStats=function(e,a){var n={};return a.result().forEach((function(e){var a={id:e.id,timestamp:e.timestamp.getTime(),type:e.type};e.names().forEach((function(n){a[n]=e.stat(n)})),n[a.id]=a})),n},a.map2obj=function(e){if(!e.entries)return e;var a={};return e.forEach((function(e,n){a[n]=e})),a},a.dumpStream=function(e){return{id:e.id,tracks:e.getTracks().map((function(e){return{id:e.id,kind:e.kind,label:e.label,enabled:e.enabled,muted:e.muted,readyState:e.readyState}}))}},a.getConnectionData=function(e,a,n){var r="".concat("ws"==e?"ws":"http","://localhost:9101"),o="".concat("ws"==e?"wss":"https","://watchrtc-staging1.testrtc.com"),d="".concat("ws"==e?"wss":"https","://watchrtc-staging2.testrtc.com"),i="".concat("ws"==e?"wss":"https","://watchrtc.testrtc.com"),t="".concat("ws"==e?"wss":"https","://watchrtc-app1.testrtc.com");n&&"http"===e&&(n=n.includes("wss://")?n.replace("wss://","https://"):n.replace("ws://","http://"));var g=a.split(":");return-1!==a.indexOf("local")?{url:n||r,key:g[1]}:-1!==a.indexOf("staging1")?{url:n||o,key:g[1]}:-1!==a.indexOf("staging")?{url:n||d,key:g[1]}:-1!==a.indexOf("production1")?{url:n||t,key:g[1]}:-1!==a.indexOf("production")?{url:n||i,key:g[1]}:{url:n||i,key:g[0]}},a.validateConfig=function(e){return!(null==e?void 0:e.rtcApiKey)&&(null==e?void 0:e.debug)?(console.info.apply(console,i(i([],(0,a.logPrefix)("error"),!1),["config.rtcApiKey or config.rtcToken need to be provided."],!1)),!1):!(!(null==e?void 0:e.rtcRoomId)||!(null==e?void 0:e.rtcPeerId))||((null==e?void 0:e.debug)&&console.info.apply(console,i(i([],(0,a.logPrefix)("info"),!1),["config.rtcRoomId or config.rtcPeerId is empty."],!1)),!1)},a.countOfValidConnections=function(e){return Object.keys(e).filter((function(a){return e[a].validConnection})).length},a.isRoomIdOrPeerIdChanged=function(e,n){var r=!1;return n.rtcRoomId&&e.rtcRoomId&&e.rtcRoomId!==n.rtcRoomId&&(r=!0),n.rtcPeerId&&e.rtcPeerId&&e.rtcPeerId!==n.rtcPeerId&&(r=!0),r&&n.debug&&console.log.apply(console,i(i([],(0,a.logPrefix)("info"),!1),["maybeOpenWebsocketConnection. rtcRoomId or rtcPeerId has been changed",{old:{rtcRoomId:e.rtcRoomId,rtcPeerId:e.rtcPeerId},new:{rtcRoomId:n.rtcRoomId,rtcPeerId:n.rtcPeerId}}],!1)),r},a.validateRating=function(e){return e?!("number"!=typeof e||e<1||e>5)||(console.info.apply(console,i(i([],(0,a.logPrefix)("error"),!1),["rating parameter should be number from 1 to 5"],!1)),!1):(console.info.apply(console,i(i([],(0,a.logPrefix)("error"),!1),["rating parameter is required"],!1)),!1)},a.validateEvent=function(e){return e?"global"!==e.type&&"local"!==e.type&&"log"!==e.type?(console.info.apply(console,i(i([],(0,a.logPrefix)("error"),!1),['event.type should be either "global" or "local" or "log"'],!1)),!1):!e.parameters||"object"==typeof e.parameters||(console.info.apply(console,i(i([],(0,a.logPrefix)("error"),!1),['event.parameters should be JSON object"'],!1)),!1):(console.info.apply(console,i(i([],(0,a.logPrefix)("error"),!1),["event parameter is required"],!1)),!1)},a.getHardwareInfo=function(){return o(void 0,void 0,void 0,(function(){function e(e){return(Math.round(100*e)/100).toFixed(2)}var a,i,g,m;return d(this,(function(c){switch(c.label){case 0:return a=function(e){return o(void 0,void 0,void 0,(function(){return d(this,(function(a){switch(a.label){case 0:return[4,new Promise((function(a){try{var r=n(804)("./".concat(e));return r.shift(),a(r)}catch(n){console.error("Error. getHardwareInfo. loadBenchmarks",{err:n.stack,fileName:e}),a([])}}))];case 1:return[2,a.sent()]}}))}))},[4,t.getGPUTier({override:{loadBenchmarks:a}})];case 1:return i=c.sent(),g=r(r({},i),{cores_count:window.navigator.hardwareConcurrency}),(m=window.performance.memory)&&(g.jsHeapSizeLimit=e(m.jsHeapSizeLimit/1048576),g.totalJSHeapSize=e(m.totalJSHeapSize/1048576),g.usedJSHeapSize=e(m.usedJSHeapSize/1048576)),[2,g]}}))}))};var m={originalMethodPrefix:"_original_",methodsToPatch:["log","debug","info","warn","error"],level:""},c=function(e,a){var n=console[e];n&&(console[m.originalMethodPrefix+e]=n,console[e]=function(){for(var r=[],o=0;o<arguments.length;o++)r[o]=arguments[o];if(m.level&&r.length&&a){var d=m.methodsToPatch.indexOf(e),i=m.methodsToPatch.indexOf(m.level),t=d>=0&&d>=i;if(t){var g=l(r);a({data:["log",null,{type:e,text:g}]})}}n.apply(console,r)})};a.setConsoleLevel=function(e,a){if(e&&m.methodsToPatch.includes(e)&&e!==m.level){var n=m.methodsToPatch.indexOf(e),r=m.methodsToPatch.indexOf(m.level);if(r<0)for(var o=0,d=m.methodsToPatch.slice(n);o<d.length;o++){var i=d[o];c(i,a)}else if(n<r)for(var t=0,g=m.methodsToPatch.slice(n,r);t<g.length;t++)i=g[t],c(i,a);m.level=e}},a.restoreOriginalConsoleMethods=function(){if("console"in window)for(var e=0,a=m.methodsToPatch;e<a.length;e++){var n=a[e],r=console[m.originalMethodPrefix+n];r&&(console[n]=r.bind(console),delete console[m.originalMethodPrefix+n])}},a.exposeApplicationStatsForPC=function(e,a,n,r){return{peer:(0,g.getTransportFromStats)(e,n),streams:(0,g.getStreamsFromStats)(e,a,n,r)}};var l=function(e){try{return e.map((function(e){return"string"==typeof e?e:JSON.stringify(e,s())})).join(" ")}catch(e){return""}},s=function(){var e=new WeakSet;return function(a,n){if("object"==typeof n&&null!==n){if(e.has(n))return;e.add(n)}return n}};a.applyPatchForRTT=function(e,a){e=e||{},a=a||{};var n=!0;return 0===Object.keys(e).length&&(n=!1),Object.keys(a).filter((function(e){return"remote-outbound-rtp"===a[e].type||"remote-inbound-rtp"===a[e].type})).forEach((function(r){if("roundTripTime"in a[r]){var o="roundTripTimeMeasurements"in a[r]&&Boolean(e[r])&&"roundTripTimeMeasurements"in e[r];n&&o&&a[r].roundTripTimeMeasurements===e[r].roundTripTimeMeasurements&&(a[r].roundTripTime=NaN)}else a[r].roundTripTime=NaN})),a},a.generateID=function(){return Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15)}},412:(e,a)=>{"use strict";Object.defineProperty(a,"__esModule",{value:!0}),a.default="1.36.3"},911:function(e,a,n){"use strict";var r=this&&this.__spreadArray||function(e,a,n){if(n||2===arguments.length)for(var r,o=0,d=a.length;o<d;o++)!r&&o in a||(r||(r=Array.prototype.slice.call(a,0,o)),r[o]=a[o]);return e.concat(r||Array.prototype.slice.call(a))};Object.defineProperty(a,"__esModule",{value:!0});var o=n(593),d=function(){function e(a){this.debug=!1,e._instance?console.info.apply(console,r(r([],(0,o.logPrefix)("info"),!1),["WatchRTCSocket instance already created"],!1)):(e._instance=this,this.debug=!!a.debug)}return e.prototype.trace=function(e,a,n,d){for(var i=[],t=4;t<arguments.length;t++)i[t-4]=arguments[t];var g=Array.prototype.slice.call(i);g.push(Date.now()),g[1]instanceof RTCPeerConnection&&(g[1]=g[1].__rtcStatsId);var m=fetch(e,{method:"POST",mode:"cors",cache:"no-cache",credentials:"same-origin",headers:{"Content-Type":"application/json"},body:JSON.stringify({data:i,projectId:a,rtcRoomId:n,rtcPeerId:d})});return m.then((function(){return{}})).catch((function(e){return console.log.apply(console,r(r([],(0,o.logPrefix)("error"),!1),[e.message,{err:e.stack}],!1)),{error:e}}))},e}();a.default=d},85:function(e,a,n){"use strict";var r=this&&this.__spreadArray||function(e,a,n){if(n||2===arguments.length)for(var r,o=0,d=a.length;o<d;o++)!r&&o in a||(r||(r=Array.prototype.slice.call(a,0,o)),r[o]=a[o]);return e.concat(r||Array.prototype.slice.call(a))};Object.defineProperty(a,"__esModule",{value:!0});var o=n(593),d=n(354),i=function(){function e(a){this.connection=null,this.wasConnected=!1,this.buffer=[],this.sendInterval=1,this.onClose=function(){},this.debug=!1,this.dataCollection=!0,this.sendPromises=[],this.trace=function(a){var n,i=a.data,t=a.options,g=Array.prototype.slice.call(i);if(g.push(Date.now()),g[1]instanceof RTCPeerConnection&&(g[1]=g[1].__rtcStatsId),e._instance.dataCollection){if(!e._instance.connection)return e._instance.buffer.length>1e3?void((null==t?void 0:t.promiseFuncs)&&t.promiseFuncs.resolve({error:"Message buffer size exceeded"})):(e._instance.buffer.push(g),void((null==t?void 0:t.promiseFuncs)&&e._instance.sendPromises.push(t.promiseFuncs)));if(e._instance.connection.readyState===WebSocket.OPEN&&(e._instance.buffer.push(g),(null==t?void 0:t.promiseFuncs)&&e._instance.sendPromises.push(t.promiseFuncs),e._instance.buffer.length>=e._instance.sendInterval)){var m=JSON.stringify(e._instance.buffer),c=d.compressToEncodedURIComponent(m);if(e._instance.debug){var l=null!==(n=console._original_log)&&void 0!==n?n:console.log;l.apply(void 0,r(r([],(0,o.logPrefix)("info"),!1),["lines: ".concat(m.length)],!1)),l.apply(void 0,r(r([],(0,o.logPrefix)("info"),!1),["compressedMessage: ".concat(c.length)],!1))}e._instance.buffer=[],e._instance.connection.send(c),e._instance.sendPromises.forEach((function(e){return(0,e.resolve)({})})),e._instance.sendPromises=[]}}else(null==t?void 0:t.promiseFuncs)&&t.promiseFuncs.resolve({error:"Data collection disabled"})},e._instance?console.info.apply(console,r(r([],(0,o.logPrefix)("info"),!1),["WatchRTCSocket instance already created"],!1)):(e._instance=this,this.debug=!!a.debug)}return e.prototype.connect=function(a){var n=a.url,d=a.onData,i=a.onError,t=a.onOpen,g=a.onClose;e._instance.connection&&e._instance.connection.close();var m=e._instance;e._instance.connection=new WebSocket(n,"2.0"),e._instance.connection.onopen=t||null,e._instance.connection.onclose=g||null,e._instance.connection.onmessage=function(a){var n;try{var t=JSON.parse(a.data);t.error?(null===(n=null==m?void 0:m.connection)||void 0===n||n.close(),m.connection=null,console.info.apply(console,r(r([],(0,o.logPrefix)("error"),!1),["\n"+t.error],!1)),i(t.error,"auth")):(t.sendInterval&&(e._instance.sendInterval=t.sendInterval),d(t),e._instance.wasConnected=!0)}catch(e){console.info.apply(console,r(r([],(0,o.logPrefix)("error"),!1),[{err:e.stack}],!1)),i(e.message)}},e._instance.connection.onerror=function(e){console.info.apply(console,r(r([],(0,o.logPrefix)("error"),!1),["\n",e],!1)),i(e,"connection")}},e.prototype.close=function(a){var n,r;if(a&&(null===(r=null===(n=e._instance)||void 0===n?void 0:n.connection)||void 0===r?void 0:r.readyState)===WebSocket.OPEN){var o=JSON.stringify(["nailUpCallEnd",null,null]),i=d.compressToEncodedURIComponent(o);e._instance.connection.send(i)}e._instance.buffer=[],e._instance.sendPromises.forEach((function(e){return(0,e.resolve)({error:"Connection was close"})})),e._instance.sendPromises=[],e._instance.connection&&(e._instance.connection.close(),e._instance.onClose(),e._instance.connection=null)},e.prototype.disableDataCollection=function(){e._instance.debug&&console.log.apply(console,r(r([],(0,o.logPrefix)("info"),!1),["Data collection disabled."],!1)),e._instance.dataCollection=!1},e.prototype.enableDataCollection=function(){e._instance.debug&&console.log.apply(console,r(r([],(0,o.logPrefix)("info"),!1),["Data collection enabled."],!1)),e._instance.dataCollection=!0},e.prototype.toggleDebug=function(a){e._instance.debug=a},e}();a.default=i},240:function(e,a){!function(e){"use strict";var a=function(e,n){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,a){e.__proto__=a}||function(e,a){for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])})(e,n)};function n(e,a,n,r){return new(n||(n=Promise))((function(o,d){function i(e){try{g(r.next(e))}catch(e){d(e)}}function t(e){try{g(r.throw(e))}catch(e){d(e)}}function g(e){var a;e.done?o(e.value):(a=e.value,a instanceof n?a:new n((function(e){e(a)}))).then(i,t)}g((r=r.apply(e,a||[])).next())}))}function r(e,a){var n,r,o,d,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return d={next:t(0),throw:t(1),return:t(2)},"function"==typeof Symbol&&(d[Symbol.iterator]=function(){return this}),d;function t(d){return function(t){return function(d){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(o=2&d[0]?r.return:d[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,d[1])).done)return o;switch(r=0,o&&(d=[2&d[0],o.value]),d[0]){case 0:case 1:o=d;break;case 4:return i.label++,{value:d[1],done:!1};case 5:i.label++,r=d[1],d=[0];continue;case 7:d=i.ops.pop(),i.trys.pop();continue;default:if(!((o=(o=i.trys).length>0&&o[o.length-1])||6!==d[0]&&2!==d[0])){i=0;continue}if(3===d[0]&&(!o||d[1]>o[0]&&d[1]<o[3])){i.label=d[1];break}if(6===d[0]&&i.label<o[1]){i.label=o[1],o=d;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(d);break}o[2]&&i.ops.pop(),i.trys.pop();continue}d=a.call(e,i)}catch(e){d=[6,e],r=0}finally{n=o=0}if(5&d[0])throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}([d,t])}}}var o=["geforce 320m","geforce 8600","geforce 8600m gt","geforce 8800 gs","geforce 8800 gt","geforce 9400","geforce 9400m g","geforce 9400m","geforce 9600m gt","geforce 9600m","geforce fx go5200","geforce gt 120","geforce gt 130","geforce gt 330m","geforce gtx 285","google swiftshader","intel g41","intel g45","intel gma 4500mhd","intel gma x3100","intel hd 3000","intel q45","legacy","mali-2","mali-3","mali-4","quadro fx 1500","quadro fx 4","quadro fx 5","radeon hd 2400","radeon hd 2600","radeon hd 4670","radeon hd 4850","radeon hd 4870","radeon hd 5670","radeon hd 5750","radeon hd 6290","radeon hd 6300","radeon hd 6310","radeon hd 6320","radeon hd 6490m","radeon hd 6630m","radeon hd 6750m","radeon hd 6770m","radeon hd 6970m","sgx 543","sgx543"];function d(e){return e.toLowerCase().replace(/^angle ?\((.+)\)*$/,"$1").replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g,"")}var i="undefined"==typeof window,t=function(){if(!i){var e=window.navigator,a=e.userAgent,n=e.platform,r=e.maxTouchPoints,o=/(iphone|ipod|ipad)/i.test(a),d="iPad"===n||"MacIntel"===n&&r>0&&!window.MSStream;return{isIpad:d,isMobile:/android/i.test(a)||o||d,isSafari12:/Version\/12.+Safari/.test(a)}}}();function g(e,a,n){if(!n)return[a];var r,o=function(e){var a=e.createShader(35633),n=e.createShader(35632),r=e.createProgram();if(n&&a&&r){e.shaderSource(a,"\n    precision highp float;\n    attribute vec3 aPosition;\n    varying float vvv;\n    void main() {\n      vvv = 0.31622776601683794;\n      gl_Position = vec4(aPosition, 1.0);\n    }\n  "),e.shaderSource(n,"\n    precision highp float;\n    varying float vvv;\n    void main() {\n      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;\n      enc = fract(enc);\n      enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n      gl_FragColor = enc;\n    }\n  "),e.compileShader(a),e.compileShader(n),e.attachShader(r,a),e.attachShader(r,n),e.linkProgram(r),e.detachShader(r,a),e.detachShader(r,n),e.deleteShader(a),e.deleteShader(n),e.useProgram(r);var o=e.createBuffer();e.bindBuffer(34962,o),e.bufferData(34962,new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),35044);var d=e.getAttribLocation(r,"aPosition");e.vertexAttribPointer(d,3,5126,!1,0,0),e.enableVertexAttribArray(d),e.clearColor(1,1,1,1),e.clear(16384),e.viewport(0,0,1,1),e.drawArrays(4,0,3);var i=new Uint8Array(4);return e.readPixels(0,0,1,1,6408,5121,i),e.deleteProgram(r),e.deleteBuffer(o),i.join("")}}(e),d="801621810",i="8016218135",g="80162181161",m=(null==t?void 0:t.isIpad)?[["a7",g,12],["a8",i,15],["a8x",i,15],["a9",i,15],["a9x",i,15],["a10",i,15],["a10x",i,15],["a12",d,15],["a12x",d,15],["a12z",d,15],["a14",d,15],["m1",d,15]]:[["a7",g,12],["a8",i,12],["a9",i,15],["a10",i,15],["a11",d,15],["a12",d,15],["a13",d,15],["a14",d,15]];return"80162181255"===o?r=m.filter((function(e){return e[2]>=14})):(r=m.filter((function(e){return e[1]===o}))).length||(r=m),r.map((function(e){var a=e[0];return"apple ".concat(a," gpu")}))}var m=[],c=[];function l(e,a){if(e===a)return 0;var n=e;e.length>a.length&&(e=a,a=n);for(var r=e.length,o=a.length;r>0&&e.charCodeAt(~-r)===a.charCodeAt(~-o);)r--,o--;for(var d,i=0;i<r&&e.charCodeAt(i)===a.charCodeAt(i);)i++;if(o-=i,0==(r-=i))return o;for(var t,g,l=0,s=0,p=0;s<r;)c[s]=e.charCodeAt(i+s),m[s]=++s;for(;p<o;)for(d=a.charCodeAt(i+p),t=p++,l=p,s=0;s<r;s++)g=d===c[s]?t:t+1,t=m[s],l=m[s]=t>l?g>l?l+1:g:g>t?t+1:g;return l}function s(e){return null!=e}var p=function(e){function n(a){var n=this.constructor,r=e.call(this,a)||this;return Object.setPrototypeOf(r,n.prototype),r}return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function r(){this.constructor=e}a(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}(n,e),n}(Error);e.getGPUTier=function(e){var a=void 0===e?{}:e,m=a.mobileTiers,c=void 0===m?[0,15,30,60]:m,v=a.desktopTiers,f=void 0===v?[0,15,30,60]:v,u=a.override,x=void 0===u?{}:u,h=a.glContext,b=a.failIfMajorPerformanceCaveat,y=void 0!==b&&b,w=a.benchmarksURL,k=void 0===w?"https://unpkg.com/detect-gpu@".concat("4.0.8","/dist/benchmarks"):w;return n(void 0,void 0,void 0,(function(){var e,a,m,v,u,b,w,q,S,z,C,_,I,P,T,j,O,R,D,E,M,L,A,U,N,F;return r(this,(function(J){switch(J.label){case 0:if(e={},i)return[2,{tier:0,type:"SSR"}];if(a=x.isIpad,m=void 0===a?!!(null==t?void 0:t.isIpad):a,v=x.isMobile,u=void 0===v?!!(null==t?void 0:t.isMobile):v,b=x.screenSize,w=void 0===b?window.screen:b,q=x.loadBenchmarks,S=void 0===q?function(e){return n(void 0,void 0,void 0,(function(){var a;return r(this,(function(n){switch(n.label){case 0:return[4,fetch("".concat(k,"/").concat(e)).then((function(e){return e.json()}))];case 1:if(a=n.sent(),parseInt(a.shift().split(".")[0],10)<4)throw new p("Detect GPU benchmark data is out of date. Please update to version 4x");return[2,a]}}))}))}:q,z=x.renderer,C=function(e){for(var a=0,n=u?["adreno","apple","mali-t","mali","nvidia","powervr"]:["intel","apple","amd","radeon","nvidia","geforce"];a<n.length;a++){var r=n[a];if(e.includes(r))return r}},_=function(a){return n(void 0,void 0,void 0,(function(){var n,o,d,i,t,g,c,s,v,f,x,h,b,y,k,q,z,_,I,P,T,j,O,R,D,E;return r(this,(function(r){switch(r.label){case 0:if(!(n=C(a)))return[2];o="".concat(u?"m":"d","-").concat(n).concat(m?"-ipad":"",".json"),d=e[o]=null!==(E=e[o])&&void 0!==E?E:S(o),r.label=1;case 1:return r.trys.push([1,3,,4]),[4,d];case 2:return i=r.sent(),[3,4];case 3:if((t=r.sent())instanceof p)throw t;return[2];case 4:if(g=function(e){var a,n=(e=e.replace(/\([^)]+\)/,"")).match(/\d+/)||e.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);return null!==(a=null==n?void 0:n.join("").replace(/\W|amd/g,""))&&void 0!==a?a:""}(a),(c=i.filter((function(e){return e[1]===g}))).length||(c=i.filter((function(e){return e[0].includes(a)}))),0===(s=c.length))return[2];for(v=s>1?c.map((function(e){return[e,l(a,e[0])]})).sort((function(e,a){return e[1]-a[1]}))[0][0]:c[0],f=v[0],x=v[3],h=Number.MAX_VALUE,y=window.devicePixelRatio,k=w.width*y*w.height*y,q=0,z=x;q<z.length;q++)_=z[q],I=_[0],P=_[1],T=I*P,(j=Math.abs(k-T))<h&&(h=j,b=_);return b?(R=(O=b)[2],D=O[3],[2,[h,R,f,D]]):[2]}}))}))},I=function(e,a,n,r,o){return{device:o,fps:r,gpu:n,isMobile:u,tier:e,type:a}},T="",z)z=d(z),P=[z];else{if(!(j=h||function(e,a){void 0===a&&(a=!1);var n={alpha:!1,antialias:!1,depth:!1,failIfMajorPerformanceCaveat:a,powerPreference:"high-performance",stencil:!1};e&&delete n.powerPreference;var r=window.document.createElement("canvas"),o=r.getContext("webgl",n)||r.getContext("experimental-webgl",n);return null!=o?o:void 0}(null==t?void 0:t.isSafari12,y)))return[2,I(0,"WEBGL_UNSUPPORTED")];if((O=j.getExtension("WEBGL_debug_renderer_info"))&&(z=j.getParameter(O.UNMASKED_RENDERER_WEBGL)),!z)return[2,I(1,"FALLBACK")];T=z,z=d(z),P=function(e,a,n){return"apple gpu"===a?g(e,a,n):[a]}(j,z,u)}return[4,Promise.all(P.map(_))];case 1:if(!(R=J.sent().filter(s).sort((function(e,a){var n=e[0],r=void 0===n?Number.MAX_VALUE:n,o=e[1],d=a[0],i=void 0===d?Number.MAX_VALUE:d,t=a[1];return r===i?o-t:r-i}))).length)return[2,(D=o.find((function(e){return z.includes(e)})))?I(0,"BLOCKLISTED",D):I(1,"FALLBACK","".concat(z," (").concat(T,")"))];if(E=R[0],M=E[1],L=E[2],A=E[3],-1===M)return[2,I(0,"BLOCKLISTED",L,M,A)];for(U=u?c:f,N=0,F=0;F<U.length;F++)M>=U[F]&&(N=F);return[2,I(N,"BENCHMARK",L,M,A)]}}))}))},Object.defineProperty(e,"__esModule",{value:!0})}(a)},622:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["qualcomm adreno 540","540",0,[[1919,1279,19]]],["qualcomm adreno 540 gpu","540",0,[[1919,1279,24]]],["qualcomm adreno 618 gpu","618",0,[[1920,1080,20]]],["qualcomm adreno 630 gpu","630",0,[[1920,1080,21]]],["qualcomm adreno 680 gpu","680",0,[[2880,1920,25]]],["qualcomm adreno 685 gpu","685",0,[[1920,1080,28]]],["qualcomm adreno 690 gpu","690",0,[[1920,1280,28]]],["qualcomm adreno 8cx gen 3","8",0,[[1920,1080,22]]]]')},183:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["amd ???","",0,[[1920,1080,144]]],["amd [amd/ati] fiji [radeon r9 fury / nano series]","9",0,[[1920,1200,162]]],["amd 15dd","15",0,[[3840,2160,14]]],["amd 66af:f1","66",0,[[3840,2160,181]]],["amd 67df:c4","67",0,[[2560,1600,59]]],["amd 67e8:00","67",0,[[1920,1080,59]]],["amd 67ef:c5","67",0,[[1920,1080,52]]],["amd 67ef:cf","67",0,[[1920,1080,74]]],["amd 67ef:e7","67",0,[[1920,1080,60]]],["amd 67ff:08","67",0,[[1920,1200,31]]],["amd 694c:c0","694",0,[[1919,1080,28],[3840,2160,12]]],["amd 694e:c0","694",0,[[3840,2160,27]]],["amd 6980:00","6980",0,[[1920,1200,59]]],["amd 699f:c1","699",0,[[1920,1080,48]]],["amd 7310:00","7310",0,[[3840,2160,55]]],["amd 731f:c1","731",0,[[1920,1080,60]]],["amd 7340:c5","7340",0,[[2560,1600,44]]],["amd advanced micro devices [amd] nee ati device","nee",0,[[1920,1200,157]]],["amd asus amd radeon r9-990x","9",0,[[1920,1080,60]]],["amd asus eah5450","5450",0,[[1600,900,12],[1680,1050,11],[1920,1200,12]]],["amd asus eah5670","5670",0,[[1920,1080,28]]],["amd asus eah6450","6450",0,[[1920,1080,12]]],["amd asus hd7750","7750",0,[[1920,1080,105]]],["amd asus hd7770","7770",0,[[1680,1050,60]]],["amd asus hd7850","7850",0,[[1920,1080,60]]],["amd asus hd7970","7970",0,[[3840,2160,50]]],["amd asus hd8760","8760",0,[[1680,1050,59]]],["amd asus r5 230","5",0,[[1920,1080,12]]],["amd asus r7 240","7",0,[[1600,900,28],[1920,1080,31]]],["amd asus r7 250","7",0,[[1920,1080,59]]],["amd asus r7 250x","7",0,[[1920,1080,60]]],["amd asus r7 265","7",0,[[1920,1080,60]]],["amd asus r7 360","7",0,[[1920,1080,78]]],["amd asus r7 370","7",0,[[1600,900,60],[1920,1080,143]]],["amd asus r9 270","9",0,[[1600,900,60]]],["amd asus r9 280x","9",0,[[1920,1080,146]]],["amd asus r9 295x2","9",0,[[2560,1440,93]]],["amd asus r9 380","9",0,[[1920,1080,60]]],["amd asus r9 390","9",0,[[1920,1080,235]]],["amd asus radeon r7 250","7",0,[[800,638,60]]],["amd asus radeon r7 260x","7",0,[[2560,1080,65]]],["amd asus radeon r9 270x","9",0,[[1024,768,85],[1920,1080,60]]],["amd asus radeon r9 280","9",0,[[1920,1080,60]]],["amd asus radeon rx 460","460",0,[[1360,768,104]]],["amd asus radeon rx 470","470",0,[[1920,1080,60]]],["amd asus radeon rx 480","480",0,[[1920,1080,124]]],["amd asus radeon rx 550","550",0,[[1440,900,60],[1920,1080,49]]],["amd asus radeon rx 5500 xt","5500",0,[[1920,1080,325]]],["amd asus radeon rx 560","560",0,[[1360,768,60],[1920,1080,85]]],["amd asus radeon rx 570","570",0,[[1600,900,202],[1920,1080,60]]],["amd asus radeon rx 5700","5700",0,[[1920,1080,327]]],["amd asus radeon rx 5700 xt","5700",0,[[1920,1080,224],[2560,1440,60]]],["amd asus radeon rx 580","580",0,[[1920,1080,177],[2560,1080,60]]],["amd asus radeon rx vega","rx",0,[[2560,1440,117]]],["amd asus rx 6600xt macos","6600",0,[[3840,2160,60]]],["amd ati mobility radeon hd 5870","5870",0,[[1920,1200,19]]],["amd baffin amd radeon rx 560","560",0,[[1920,1080,60]]],["amd barco mxrt 5600","5600",0,[[2800,2100,30]]],["amd carrizo 9874","9874",0,[[1920,1200,11]]],["amd cezanne","",0,[[1920,1080,162]]],["amd device","",0,[[1920,1080,188]]],["amd ellesmere radeon rx 570","570",0,[[1920,1080,60]]],["amd embedded radeon e9171","9171",0,[[3840,2160,26]]],["amd embedded radeon e9173","9173",0,[[3840,2160,16]]],["amd firepro 2270","2270",0,[[1245,768,19],[1920,1200,9]]],["amd firepro 3800 graphics adapter","3800",0,[[1920,1080,18]]],["amd firepro d300","300",0,[[1920,1080,60],[2560,1440,60],[3440,1440,60],[3840,2160,30]]],["amd firepro d500","500",0,[[1600,900,60],[2560,1440,59],[2560,1600,87],[3840,2160,57]]],["amd firepro d700","700",0,[[2048,1152,59],[2560,1440,59]]],["amd firepro m2000","2000",0,[[1600,900,28],[1920,1080,24]]],["amd firepro m4000","4000",0,[[1920,1080,57]]],["amd firepro m4000 mobility pro","4000",0,[[1920,1080,57]]],["amd firepro m4100","4100",0,[[1920,1080,58]]],["amd firepro m4100 firegl v","4100",0,[[1920,1080,24]]],["amd firepro m4150","4150",0,[[1600,900,51]]],["amd firepro m4170","4170",0,[[1920,1080,43]]],["amd firepro m5100","5100",0,[[1920,1080,60]]],["amd firepro m5100 firegl v","5100",0,[[1920,1080,29]]],["amd firepro m5950","5950",0,[[1920,1080,42]]],["amd firepro m6000 mobility pro","6000",0,[[1600,900,33],[1920,1080,60]]],["amd firepro m6100","6100",0,[[1920,1080,60]]],["amd firepro m6100 firegl v","6100",0,[[1920,1080,60]]],["amd firepro m7820","7820",0,[[1680,1050,44]]],["amd firepro r5000","5000",0,[[1920,1080,60]]],["amd firepro s10000","10000",0,[[2560,1440,58]]],["amd firepro s7150","7150",0,[[1440,900,70]]],["amd firepro s9000","9000",0,[[1920,1080,60]]],["amd firepro s9050","9050",0,[[1920,1080,101]]],["amd firepro v graphics adapter","v",0,[[1680,1050,53],[1920,1080,54]]],["amd firepro v3800","3800",0,[[1280,992,28],[1680,1050,25]]],["amd firepro v3900","3900",0,[[1920,1080,28],[2560,1440,26]]],["amd firepro v4800","4800",0,[[1440,900,37],[1920,1080,50]]],["amd firepro v4800 graphics adapter","4800",0,[[1920,1080,46]]],["amd firepro v4900","4900",0,[[1600,900,76],[1920,1080,53]]],["amd firepro v4900 graphics adapter","4900",0,[[1920,1200,40]]],["amd firepro v5800","5800",0,[[1366,768,60],[1920,1200,62]]],["amd firepro v5800 graphics adapter","5800",0,[[1360,768,83],[1280,1024,58]]],["amd firepro v5900","5900",0,[[1920,1080,53],[1920,1200,58],[3440,1440,34]]],["amd firepro v5900 graphics adapter","5900",0,[[1600,1200,54],[1920,1080,65]]],["amd firepro v7800 graphics adapter","7800",0,[[1680,1050,60],[1920,1080,60]]],["amd firepro v7900","7900",0,[[1920,1080,135],[1920,1200,60],[2560,1080,124]]],["amd firepro v7900 graphics adapter","7900",0,[[1920,1080,58]]],["amd firepro v8800","8800",0,[[2560,1440,58]]],["amd firepro w2100","2100",0,[[1920,1080,33]]],["amd firepro w4100","4100",0,[[1920,1080,55]]],["amd firepro w4100 graphics adapter","4100",0,[[1600,1200,70],[1920,1080,56]]],["amd firepro w4150m firegl v","4150",0,[[1920,1080,45]]],["amd firepro w4170m","4170",0,[[1366,768,11]]],["amd firepro w4190m","4190",0,[[1920,1080,42]]],["amd firepro w4300","4300",0,[[1280,1024,116]]],["amd firepro w5000","5000",0,[[1920,1080,60],[2560,1600,75]]],["amd firepro w5000 graphics adapter","5000",0,[[1280,1024,60],[1920,1080,117]]],["amd firepro w5100","5100",0,[[1920,1080,60],[1920,1200,59]]],["amd firepro w5100 graphics adapter","5100",0,[[1920,1080,89],[3840,2160,29]]],["amd firepro w5130m","5130",0,[[1920,1080,60]]],["amd firepro w5170m","5170",0,[[1920,1080,84],[2560,1440,51]]],["amd firepro w600","600",0,[[3840,2160,25]]],["amd firepro w6150m","6150",0,[[1920,1080,45]]],["amd firepro w7000","7000",0,[[1920,1080,60],[1920,1200,136]]],["amd firepro w7000 graphics adapter","7000",0,[[1920,1080,60]]],["amd firepro w7100","7100",0,[[1920,1080,60],[1920,1200,141]]],["amd firepro w7100 graphics adapter","7100",0,[[1200,900,60]]],["amd firepro w7170m","7170",0,[[1920,1080,60]]],["amd firepro w8000","8000",0,[[1920,1200,110],[2560,1440,60]]],["amd firepro w8100","8100",0,[[1920,1080,60],[1920,1200,60]]],["amd firepro w8100 graphic adapter","8100",0,[[1280,1024,113]]],["amd firepro w9100","9100",0,[[1920,1080,60],[1920,1200,188],[2560,1600,59]]],["amd gigabyte radeon rx 580","580",0,[[1920,1080,60]]],["amd gigabyte vega 64 macos","64",0,[[1920,1080,60]]],["amd hd7950 martin rev.","7950",0,[[2560,1440,101]]],["amd hd7950 martin ver.","7950",0,[[2560,1440,104]]],["amd kamen rider black rx","rx",0,[[1920,1080,60]]],["amd kaveri","",0,[[1920,1080,9]]],["amd madison [mobility radeon hd 5650 / 6530m/6550m]","5650",0,[[1366,768,43]]],["amd matrox c680 pcie x16","680",0,[[2560,1440,49]]],["amd matrox c900 pcie x16","900",0,[[5760,3240,9]]],["amd metal","",0,[[1920,1080,120]]],["amd mobility radeon hd 4250","4250",0,[[963,722,26]]],["amd mobility radeon hd 5000","5000",0,[[1366,768,47]]],["amd mobility radeon hd 5400","5400",0,[[1366,768,24]]],["amd mobility radeon hd 5430","5430",0,[[1600,900,15],[1920,1080,60]]],["amd mobility radeon hd 5470","5470",0,[[1366,768,24]]],["amd mobility radeon hd 5570","5570",0,[[1920,1080,27]]],["amd mobility radeon hd 5730 / 6570m","5730",0,[[1366,768,58]]],["amd mobility radeon hd 5850","5850",0,[[1600,900,55]]],["amd mobility radeon hd 5870","5870",0,[[1600,900,64],[1920,1200,53]]],["amd msi / amd rx 560","560",0,[[1920,1080,60]]],["amd msi / amd rx 560 4g","560",0,[[1920,1080,60]]],["amd msi baffin rx650","650",0,[[1920,1080,399]]],["amd msi rx560","560",0,[[1920,1080,343]]],["amd msi rx650","650",0,[[1920,1080,60]]],["amd mxgpu","",0,[[1920,1012,67],[1920,1080,106]]],["amd navi 10 5700 xt","10",0,[[3840,2160,60]]],["amd opal xt/gl","xt",0,[[1366,768,60]]],["amd park [mobility radeon hd 5430","5430",0,[[1280,720,11]]],["amd picasso","",0,[[1920,1080,48]]],["amd pitcairn pro radeon hd 7850","7850",0,[[1920,1080,60]]],["amd powercolor radeon r9 280","9",0,[[1920,1080,60]]],["amd r9 270x devil","9",0,[[1920,1080,60]]],["amd r9 280x dual-x","9",0,[[1920,1080,60]]],["amd r9 380","9",0,[[2560,1440,119]]],["amd r9 xxx","9",0,[[1920,1080,60]]],["amd radeon","",0,[[1920,1080,299],[3440,1440,60]]],["amd radeon 500","500",0,[[1920,1080,73]]],["amd radeon 520","520",0,[[1920,1080,35],[2560,1440,29]]],["amd radeon 530","530",0,[[1366,768,60],[1920,1080,30]]],["amd radeon 535","535",0,[[1920,1080,35]]],["amd radeon 535dx","535",0,[[1366,768,31],[1920,1080,37]]],["amd radeon 540","540",0,[[1920,1080,38]]],["amd radeon 540 / rx 540x/550/550x","540",0,[[2560,1440,88]]],["amd radeon 540x","540",0,[[1920,1080,59]]],["amd radeon 550","550",0,[[1920,1080,115]]],["amd radeon 550x","550",0,[[1920,1080,28]]],["amd radeon 610","610",0,[[1920,1080,29]]],["amd radeon 620","620",0,[[1920,1080,18]]],["amd radeon 625","625",0,[[1366,768,55],[1920,1080,47]]],["amd radeon 630","630",0,[[1920,1080,29]]],["amd radeon 6600m and 6700m","6600",0,[[1366,768,36],[1440,900,60]]],["amd radeon 6800","6800",0,[[3440,1440,100]]],["amd radeon 7500m/7600m","7500",0,[[1366,768,37]]],["amd radeon 7950 x2","7950",0,[[2560,1440,174]]],["amd radeon d700","700",0,[[2560,1440,120]]],["amd radeon e6460","6460",0,[[1600,1200,13]]],["amd radeon e6760","6760",0,[[1200,900,54],[1920,1080,42]]],["amd radeon e8860","8860",0,[[1920,1200,27],[2560,1374,88]]],["amd radeon e8870","8870",0,[[1920,1080,81]]],["amd radeon e8870mxm","8870",0,[[1920,1080,60]]],["amd radeon e9260","9260",0,[[1680,1050,60],[3840,2160,38]]],["amd radeon e9550","9550",0,[[1680,1050,60],[3840,2160,58]]],["amd radeon embedded e9560","9560",0,[[1920,1200,60]]],["amd radeon fury","",0,[[1920,1080,60]]],["amd radeon fury x","x",0,[[1920,1080,60],[2560,1440,144]]],["amd radeon hd - firepro d300","300",0,[[1920,1080,60]]],["amd radeon hd - firepro d300 opengl engine","300",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd - firepro d500 opengl engine","500",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd - firepro d700 opengl engine","700",0,[[3840,2160,52]]],["amd radeon hd 2600 xt","2600",1,[[2560,1600,-1]]],["amd radeon hd 5000","5000",0,[[1920,1080,8]]],["amd radeon hd 5400","5400",0,[[1920,1080,12]]],["amd radeon hd 5450","5450",0,[[1920,1080,13]]],["amd radeon hd 5470","5470",0,[[1280,1024,16]]],["amd radeon hd 5500","5500",0,[[1920,1080,27]]],["amd radeon hd 5570","5570",0,[[1920,1080,60],[2048,1152,31]]],["amd radeon hd 5600","5600",0,[[1920,1080,56]]],["amd radeon hd 5650","5650",0,[[1366,768,53]]],["amd radeon hd 5670","5670",1,[[1920,1080,-1],[2560,1440,-1]]],["amd radeon hd 5670 opengl engine","5670",1,[[2560,1440,-1]]],["amd radeon hd 5700","5700",0,[[1920,1080,59]]],["amd radeon hd 5730","5730",0,[[1366,768,46],[1680,1050,40]]],["amd radeon hd 5750","5750",1,[[1920,1080,-1],[1920,1200,-1],[2560,1440,-1]]],["amd radeon hd 5750 opengl engine","5750",1,[[2560,1440,-1]]],["amd radeon hd 5770","5770",0,[[1776,1000,43],[1920,1080,59]]],["amd radeon hd 5800","5800",0,[[1366,768,60],[1920,1200,102]]],["amd radeon hd 5850","5850",0,[[1920,1080,60]]],["amd radeon hd 5870","5870",0,[[1280,960,75],[1920,1080,60],[2048,1280,60]]],["amd radeon hd 5870m","5870",0,[[2560,1080,31]]],["amd radeon hd 5970","5970",0,[[1360,768,60],[1920,1080,60]]],["amd radeon hd 6230","6230",0,[[1366,768,13]]],["amd radeon hd 6250","6250",0,[[1280,800,8],[1366,768,8]]],["amd radeon hd 6290","6290",1,[[1366,768,-1]]],["amd radeon hd 6300m","6300",1,[[1366,768,-1]]],["amd radeon hd 6310","6310",1,[[1366,768,-1]]],["amd radeon hd 6320","6320",1,[[1366,768,-1]]],["amd radeon hd 6350","6350",0,[[1280,1024,18],[1920,1080,14]]],["amd radeon hd 6370d","6370",0,[[1920,1080,14]]],["amd radeon hd 6370m","6370",0,[[1366,768,25]]],["amd radeon hd 6380g","6380",0,[[1366,768,19]]],["amd radeon hd 6400","6400",0,[[1920,1080,13]]],["amd radeon hd 6400m","6400",0,[[1366,768,28]]],["amd radeon hd 6400m/7400m","6400",0,[[1366,768,28]]],["amd radeon hd 6410d","6410",0,[[1920,1080,11]]],["amd radeon hd 6450","6450",0,[[1920,1080,14]]],["amd radeon hd 6450 / r5 230","6450",0,[[1440,900,12]]],["amd radeon hd 6450 230","6450",0,[[1920,1080,15]]],["amd radeon hd 6470m","6470",0,[[1366,768,27],[1600,900,21]]],["amd radeon hd 6470m/7400m","6470",0,[[1366,768,44]]],["amd radeon hd 6480g","6480",0,[[1280,768,19],[1366,768,27],[1600,900,18]]],["amd radeon hd 6490m","6490",1,[[1366,768,-1],[1440,900,-1],[1680,1050,-1]]],["amd radeon hd 6500","6500",0,[[1920,1080,25]]],["amd radeon hd 6500m/5600","6500",0,[[1920,1080,27]]],["amd radeon hd 6510","6510",0,[[1600,900,32]]],["amd radeon hd 6520g","6520",0,[[1366,768,21],[1600,900,20]]],["amd radeon hd 6530d","6530",0,[[1366,768,31],[1440,900,36],[1920,1080,24]]],["amd radeon hd 6540","6540",0,[[1600,1200,13]]],["amd radeon hd 6550d","6550",0,[[1920,1080,28]]],["amd radeon hd 6570","6570",0,[[1920,1080,52],[2560,1440,17]]],["amd radeon hd 6620g","6620",0,[[1360,768,43],[1366,768,28]]],["amd radeon hd 6630m","6630",1,[[1366,768,-1],[1600,900,-1],[1920,1080,-1]]],["amd radeon hd 6630m/6650m/6750m/7670m/7690m","6630",1,[[1366,768,-1],[1920,1080,-1]]],["amd radeon hd 6650m","6650",0,[[1366,768,51],[1600,900,31]]],["amd radeon hd 6670","6670",0,[[1920,1080,55]]],["amd radeon hd 6700","6700",0,[[1920,1080,56]]],["amd radeon hd 6700 green","6700",0,[[1360,768,89]]],["amd radeon hd 6700m/7700m/7900m","6700",0,[[1366,768,59]]],["amd radeon hd 6730m/6770m","6730",0,[[1366,768,58],[1920,1080,46]]],["amd radeon hd 6730m/6770m/7690m xt","6730",0,[[1920,1080,48]]],["amd radeon hd 6750","6750",0,[[1440,900,72],[1920,1080,60]]],["amd radeon hd 6750m","6750",1,[[1440,900,-1],[1920,1080,-1],[1920,1200,-1]]],["amd radeon hd 6770","6770",0,[[1920,1080,60]]],["amd radeon hd 6770m","6770",1,[[1440,900,-1],[2560,1440,-1]]],["amd radeon hd 6770m opengl engine","6770",1,[[2560,1440,-1]]],["amd radeon hd 6790","6790",0,[[1920,1080,59]]],["amd radeon hd 6800","6800",0,[[1280,1024,89],[1920,1080,60]]],["amd radeon hd 6800m","6800",0,[[1600,900,18],[1920,1080,40]]],["amd radeon hd 6850","6850",0,[[1920,1080,59],[2560,1600,54]]],["amd radeon hd 6870","6870",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd 6900","6900",0,[[1920,1080,60]]],["amd radeon hd 6900m","6900",0,[[1920,1080,60]]],["amd radeon hd 6950","6950",0,[[1680,1050,60],[1920,1080,41]]],["amd radeon hd 6970","6970",0,[[1920,1080,60]]],["amd radeon hd 6970m","6970",1,[[2560,1440,-1]]],["amd radeon hd 6970m opengl engine","6970",1,[[2560,1440,-1]]],["amd radeon hd 6990","6990",0,[[1920,1080,60]]],["amd radeon hd 7000","7000",0,[[1920,1080,24]]],["amd radeon hd 7290","7290",0,[[1366,768,9]]],["amd radeon hd 7310","7310",0,[[1366,768,14]]],["amd radeon hd 7340","7340",0,[[1366,768,17],[1920,1080,10]]],["amd radeon hd 7340g","7340",0,[[1366,768,15]]],["amd radeon hd 7340m","7340",0,[[1366,768,15]]],["amd radeon hd 7350","7350",0,[[1920,1080,13]]],["amd radeon hd 7400","7400",0,[[1920,1080,18]]],["amd radeon hd 7400g","7400",0,[[963,768,31]]],["amd radeon hd 7400m","7400",0,[[1366,768,44]]],["amd radeon hd 7420g","7420",0,[[1366,768,28],[1600,900,26]]],["amd radeon hd 7450","7450",0,[[1920,1080,15]]],["amd radeon hd 7450a","7450",0,[[1920,1080,15]]],["amd radeon hd 7450m","7450",0,[[1366,768,30]]],["amd radeon hd 7470","7470",0,[[1680,1050,22],[1920,1080,144]]],["amd radeon hd 7470m","7470",0,[[1366,768,31],[1600,900,23]]],["amd radeon hd 7480d","7480",0,[[1280,1024,25],[1920,1080,24],[1920,1200,18]]],["amd radeon hd 7500","7500",0,[[1366,696,49],[1366,768,49]]],["amd radeon hd 7500g","7500",0,[[1366,768,26]]],["amd radeon hd 7500m/7600m","7500",0,[[1366,768,46]]],["amd radeon hd 7520g","7520",0,[[1366,768,33]]],["amd radeon hd 7520g + hd 7400m dual","7520",0,[[1366,768,34]]],["amd radeon hd 7520g + hd 7600m dual","7520",0,[[1366,768,31],[1600,900,41]]],["amd radeon hd 7540d","7540",0,[[1024,768,55],[1280,1024,44],[1920,1080,22]]],["amd radeon hd 7540d + hd 6670 dual","7540",0,[[1280,1024,36]]],["amd radeon hd 7550m/7650m","7550",0,[[1366,768,57]]],["amd radeon hd 7560d","7560",0,[[1920,1080,34]]],["amd radeon hd 7560d + hd 6570 dual","7560",0,[[1680,1050,44]]],["amd radeon hd 7560d + hd 6670 dual","7560",0,[[800,638,60]]],["amd radeon hd 7570","7570",0,[[1024,768,72],[1920,1080,52]]],["amd radeon hd 7570m","7570",0,[[1366,768,35]]],["amd radeon hd 7570m/hd 7670m","7570",0,[[1366,768,50],[1600,900,29]]],["amd radeon hd 7600","7600",0,[[1920,1080,60]]],["amd radeon hd 7600a","7600",0,[[1920,1080,28]]],["amd radeon hd 7600g","7600",0,[[1366,768,29]]],["amd radeon hd 7600g + 7500m/7600m dual","7600",0,[[1366,768,19]]],["amd radeon hd 7600g + hd 8670m dual","7600",0,[[1366,768,29]]],["amd radeon hd 7600g + hd dual","7600",0,[[1366,768,20]]],["amd radeon hd 7600m","7600",0,[[1366,768,56]]],["amd radeon hd 7600m/7700m","7600",0,[[1366,768,31]]],["amd radeon hd 7610m","7610",0,[[1366,768,43]]],["amd radeon hd 7620g","7620",0,[[1366,768,22],[1920,1080,19]]],["amd radeon hd 7640g","7640",0,[[1366,768,38]]],["amd radeon hd 7640g + 7470m dual","7640",0,[[1366,768,32]]],["amd radeon hd 7640g + 7600m dual","7640",0,[[1366,768,23]]],["amd radeon hd 7640g + 7670m dual","7640",0,[[1600,900,15]]],["amd radeon hd 7640g + 8500m dual","7640",0,[[1366,768,35]]],["amd radeon hd 7640g + hd 7400m dual","7640",0,[[1366,768,37]]],["amd radeon hd 7640g + hd 7500 dual","7640",0,[[1366,768,35]]],["amd radeon hd 7640g + hd 7670m dual","7640",0,[[1366,768,34]]],["amd radeon hd 7640g + hd 8500m dual","7640",0,[[1366,768,40]]],["amd radeon hd 7640g + hd 8570m dual","7640",0,[[1366,768,31]]],["amd radeon hd 7650a","7650",0,[[1680,1050,43],[1920,1080,15]]],["amd radeon hd 7650m","7650",0,[[1366,768,41],[1600,900,45]]],["amd radeon hd 7660d","7660",0,[[1680,1050,40],[1920,1008,60],[1920,1080,38]]],["amd radeon hd 7660d + hd 6570 dual","7660",0,[[1200,900,32]]],["amd radeon hd 7660d + hd 6670 dual","7660",0,[[1360,768,57],[1920,1080,53]]],["amd radeon hd 7660g","7660",0,[[1366,768,44],[1600,900,41],[1920,1080,34],[1920,1200,27]]],["amd radeon hd 7660g + 7600m dual","7660",0,[[1366,768,53],[1600,900,45]]],["amd radeon hd 7660g + 7670m dual","7660",0,[[1366,768,52]]],["amd radeon hd 7660g + 8670m dual","7660",0,[[1600,900,46]]],["amd radeon hd 7660g + hd 7600m dual","7660",0,[[1366,768,50]]],["amd radeon hd 7660g + hd 7670m dual","7660",0,[[1366,768,35]]],["amd radeon hd 7660g + hd 8600m dual","7660",0,[[1600,900,29]]],["amd radeon hd 7670","7670",0,[[1920,1080,39]]],["amd radeon hd 7670m","7670",0,[[1366,768,49],[1920,1080,36]]],["amd radeon hd 7700","7700",0,[[1400,1050,45],[1920,1080,60]]],["amd radeon hd 7700m","7700",0,[[1920,1080,54]]],["amd radeon hd 7730m","7730",0,[[1920,1080,57]]],["amd radeon hd 7750","7750",0,[[1280,1024,60],[1600,900,60],[1400,1050,98],[1920,1080,60],[3840,2160,23]]],["amd radeon hd 7750 / r7 250e","7750",0,[[2560,1080,69]]],["amd radeon hd 7750m","7750",0,[[1680,1050,57]]],["amd radeon hd 7770","7770",0,[[1920,1080,60]]],["amd radeon hd 7770 / r7 250x","7770",0,[[1680,1050,78]]],["amd radeon hd 7770 ghz","7770",0,[[1920,1080,78]]],["amd radeon hd 7790","7790",0,[[1920,1080,16]]],["amd radeon hd 7790 / r7 360 / r9 260/360","7790",0,[[1280,1024,131]]],["amd radeon hd 7800","7800",0,[[1920,1080,60]]],["amd radeon hd 7800m","7800",0,[[1920,1080,57]]],["amd radeon hd 7850","7850",0,[[1920,1080,60]]],["amd radeon hd 7850 / r7 265 / r9 270 1024sp","7850",0,[[1280,1024,87]]],["amd radeon hd 7870","7870",0,[[1920,1080,120],[2560,1440,60],[2560,1600,114],[3840,2160,30]]],["amd radeon hd 7870 ghz","7870",0,[[1920,1080,75]]],["amd radeon hd 7870 xt","7870",0,[[1920,1080,57],[3840,2160,53]]],["amd radeon hd 7870m","7870",0,[[1920,1080,22],[2732,1536,40]]],["amd radeon hd 7900","7900",0,[[2560,1600,59]]],["amd radeon hd 7950","7950",0,[[1920,1080,50]]],["amd radeon hd 7950 / r9 280","7950",0,[[1920,1080,59]]],["amd radeon hd 7950 oem / r9 280","7950",0,[[1920,1080,60]]],["amd radeon hd 7970","7970",0,[[1920,1080,60]]],["amd radeon hd 7970 / r9 280x","7970",0,[[1920,1080,193]]],["amd radeon hd 7970m","7970",0,[[1366,768,60],[1920,1080,60]]],["amd radeon hd 7970x/8970 280x","7970",0,[[1920,1080,60]]],["amd radeon hd 7990","7990",0,[[1920,1080,60],[5120,2880,63]]],["amd radeon hd 7xxx","7",0,[[1920,1080,60]]],["amd radeon hd 8180","8180",0,[[1366,768,10]]],["amd radeon hd 8200 / r3","8200",0,[[1366,768,21],[1600,900,13],[1680,1050,13]]],["amd radeon hd 8210","8210",0,[[1366,768,18]]],["amd radeon hd 8240","8240",0,[[1600,900,17]]],["amd radeon hd 8240 / r3","8240",0,[[1366,768,14]]],["amd radeon hd 8250","8250",0,[[1366,768,14],[1920,1200,10]]],["amd radeon hd 8280","8280",0,[[1600,900,60]]],["amd radeon hd 8280 / r3","8280",0,[[1366,768,22]]],["amd radeon hd 8280e","8280",0,[[2880,1620,6]]],["amd radeon hd 8330","8330",0,[[1366,768,24]]],["amd radeon hd 8350","8350",0,[[1920,1080,57]]],["amd radeon hd 8350g","8350",0,[[1366,768,18]]],["amd radeon hd 8370d","8370",0,[[1366,768,60],[1280,1024,26],[1920,1080,22]]],["amd radeon hd 8400","8400",0,[[1366,768,30],[1920,1080,16]]],["amd radeon hd 8400 / r3","8400",0,[[1360,768,19],[1366,768,22],[1920,1080,12]]],["amd radeon hd 8400e","8400",0,[[1680,1050,17],[1920,1080,16],[1920,1200,14]]],["amd radeon hd 8410g","8410",0,[[1366,768,32]]],["amd radeon hd 8450g","8450",0,[[1366,768,23]]],["amd radeon hd 8450g + hd 8750m dual","8450",0,[[1366,768,21]]],["amd radeon hd 8470","8470",0,[[1920,1080,17]]],["amd radeon hd 8470 + 7660d dual","8470",0,[[1920,1080,60]]],["amd radeon hd 8470d","8470",0,[[1280,1024,44],[1920,1080,21]]],["amd radeon hd 8470d + hd 6450 dual","8470",0,[[1600,900,37]]],["amd radeon hd 8490","8490",0,[[1920,1080,18],[1920,1200,20]]],["amd radeon hd 8500m","8500",0,[[1366,768,41],[1920,1080,19]]],["amd radeon hd 8500m/8700m","8500",0,[[1920,1080,30]]],["amd radeon hd 8510g","8510",0,[[1366,768,29],[1920,1080,17]]],["amd radeon hd 8550","8550",0,[[1920,1080,25]]],["amd radeon hd 8550g","8550",0,[[1366,768,34],[1600,900,41],[1920,1080,34]]],["amd radeon hd 8550g + 8500m dual","8550",0,[[1366,768,42]]],["amd radeon hd 8550g + 8600 dual","8550",0,[[1920,1080,27]]],["amd radeon hd 8550g + hd 8570m dual","8550",0,[[1366,768,32]]],["amd radeon hd 8550g + hd 8600 dual","8550",0,[[1366,768,60]]],["amd radeon hd 8550g + hd 8750m dual","8550",0,[[1366,768,37]]],["amd radeon hd 8550g + r5 m230 dual","8550",0,[[1366,768,29]]],["amd radeon hd 8570","8570",0,[[1280,1024,60],[1680,1050,54],[1920,1080,50]]],["amd radeon hd 8570 / r5 430 / r7 240 / radeon 520","8570",0,[[1920,1080,25]]],["amd radeon hd 8570d","8570",0,[[1920,1080,16]]],["amd radeon hd 8570d + r7 240 dual","8570",0,[[1920,1080,45]]],["amd radeon hd 8570m","8570",0,[[1366,768,40]]],["amd radeon hd 8600","8600",0,[[1366,768,41]]],["amd radeon hd 8600m","8600",0,[[1366,768,42],[1920,1080,14]]],["amd radeon hd 8610g","8610",0,[[1366,768,31],[1920,1080,16]]],["amd radeon hd 8610g + 8600m dual","8610",0,[[1366,768,22]]],["amd radeon hd 8610g + hd 8600m dual","8610",0,[[1366,768,41]]],["amd radeon hd 8610g + hd 8670m dual","8610",0,[[1366,768,33]]],["amd radeon hd 8650g","8650",0,[[1360,768,44],[1366,768,44]]],["amd radeon hd 8650g + 8500m dual","8650",0,[[1366,768,35]]],["amd radeon hd 8650g + 8600 dual","8650",0,[[1920,1080,38]]],["amd radeon hd 8650g + 8600m dual","8650",0,[[1366,768,21]]],["amd radeon hd 8650g + 8670m dual","8650",0,[[1366,768,66]]],["amd radeon hd 8650g + 8750m dual","8650",0,[[1920,1080,28]]],["amd radeon hd 8650g + hd 7600m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + hd 8500m dual","8650",0,[[1366,768,23]]],["amd radeon hd 8650g + hd 8570m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + hd 8600m dual","8650",0,[[1366,768,46],[1600,900,29]]],["amd radeon hd 8650g + hd 8750m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + r5 m200 dual","8650",0,[[1366,768,35]]],["amd radeon hd 8670 / r7 250","8670",0,[[1024,768,1]]],["amd radeon hd 8670a/8670m/8690m","8670",0,[[1366,768,47]]],["amd radeon hd 8670a/8670m/8750m","8670",0,[[1366,768,60]]],["amd radeon hd 8670d","8670",0,[[1024,768,45],[1280,1024,69],[1920,1080,38]]],["amd radeon hd 8670d + 7700 dual","8670",0,[[1680,1050,58]]],["amd radeon hd 8670d + hd 6670 dual","8670",0,[[1680,1050,33]]],["amd radeon hd 8670d + r5 200 dual","8670",0,[[2560,1080,14]]],["amd radeon hd 8670d + r7 200 dual","8670",0,[[1920,1080,37]]],["amd radeon hd 8670m","8670",0,[[1366,768,41]]],["amd radeon hd 8690a","8690",0,[[1920,1080,31]]],["amd radeon hd 8690m","8690",0,[[1600,900,35]]],["amd radeon hd 8700m","8700",0,[[1366,768,60]]],["amd radeon hd 8730m","8730",0,[[1366,768,59]]],["amd radeon hd 8750m","8750",0,[[1366,768,60]]],["amd radeon hd 8770","8770",0,[[1920,1080,111]]],["amd radeon hd 8790m","8790",0,[[1600,900,78],[1920,1080,60]]],["amd radeon hd 8800m","8800",0,[[1920,1080,60],[2880,1800,45]]],["amd radeon hd 8830m","8830",0,[[1920,1080,82]]],["amd radeon hd 8850m","8850",0,[[1366,768,45]]],["amd radeon hd 8870m","8870",0,[[1280,1024,60],[1600,900,60]]],["amd radeon hd 8950","8950",0,[[1920,1080,60],[1920,1200,59]]],["amd radeon hd 8970","8970",0,[[2560,1600,60]]],["amd radeon hd 8970m","8970",0,[[1920,1080,146],[1920,1200,60]]],["amd radeon hd 8xxx","8",0,[[1920,1080,120],[2560,1440,58]]],["amd radeon hd5450","5450",0,[[1280,720,24]]],["amd radeon hd6870","6870",0,[[1920,1080,60]]],["amd radeon hd7970m","7970",0,[[2560,1440,116]]],["amd radeon hd8530m","8530",0,[[1366,768,40]]],["amd radeon hd8730","8730",0,[[1680,1050,42]]],["amd radeon hd8970m","8970",0,[[1920,1080,74]]],["amd radeon hybrid","",0,[[1366,768,27]]],["amd radeon infoshock rx 460","460",0,[[1360,768,102]]],["amd radeon instinct mi25","25",0,[[1920,1200,26]]],["amd radeon instinct mi25 mxgpu","25",0,[[1920,1080,20],[1920,1200,32]]],["amd radeon m535dx","535",0,[[1366,768,58]]],["amd radeon navi14","14",0,[[3840,2160,60]]],["amd radeon polaris","",0,[[3840,2160,60],[5120,2880,44]]],["amd radeon polaris 10","10",0,[[1920,1200,60]]],["amd radeon pro","pro",0,[[1920,1080,114]]],["amd radeon pro 270x","270",0,[[2560,1440,74]]],["amd radeon pro 450","450",0,[[1920,1080,30],[2880,1800,43],[3360,2100,36],[5120,2880,30]]],["amd radeon pro 450 opengl engine","450",0,[[1920,1200,60]]],["amd radeon pro 455","455",0,[[2879,1800,54],[2880,1800,48],[3360,2100,37]]],["amd radeon pro 455 opengl engine","455",0,[[3360,2100,36]]],["amd radeon pro 460","460",0,[[2880,1800,50],[3360,2100,42]]],["amd radeon pro 460 opengl engine","460",0,[[5760,3240,15]]],["amd radeon pro 470","470",0,[[6016,3384,49]]],["amd radeon pro 480","480",0,[[1920,1080,60]]],["amd radeon pro 5300","5300",0,[[5120,2880,60]]],["amd radeon pro 5300m","5300",0,[[1920,1080,214],[3584,2240,130]]],["amd radeon pro 5500 xt","5500",0,[[5120,2880,51]]],["amd radeon pro 5500m","5500",0,[[3072,1920,60],[3584,2240,139]]],["amd radeon pro 555","555",0,[[2879,1800,54],[2880,1800,36],[3360,2100,40]]],["amd radeon pro 555x","555",0,[[2880,1800,42],[3360,2100,39]]],["amd radeon pro 560","560",0,[[2879,1800,56],[2880,1800,56],[3360,2100,42]]],["amd radeon pro 5600m","5600",0,[[3072,1920,60],[3584,2240,60]]],["amd radeon pro 560x","560",0,[[2879,1800,59],[2880,1800,71],[3360,2100,43]]],["amd radeon pro 570","570",0,[[5120,2880,48]]],["amd radeon pro 570 opengl engine","570",0,[[5120,2880,46]]],["amd radeon pro 5700","5700",0,[[5120,2880,60]]],["amd radeon pro 5700 xt","5700",0,[[5120,2880,60]]],["amd radeon pro 570x","570",0,[[5120,2880,50]]],["amd radeon pro 575","575",0,[[4096,2304,60],[5120,2880,50]]],["amd radeon pro 575 opengl engine","575",0,[[5120,2880,48]]],["amd radeon pro 575x","575",0,[[5120,2880,56]]],["amd radeon pro 580","580",0,[[5120,2880,54]]],["amd radeon pro 580 opengl engine","580",0,[[5120,2880,50]]],["amd radeon pro 580x","580",0,[[5120,2880,52]]],["amd radeon pro duo","pro",0,[[1920,1080,234],[1800,1350,59],[3840,2160,82],[4096,2160,60]]],["amd radeon pro rx 560","560",0,[[2560,1080,60]]],["amd radeon pro ssg","pro",0,[[3440,1440,125]]],["amd radeon pro v340","340",0,[[1920,1080,112]]],["amd radeon pro v520 mxgpu","520",0,[[1920,1080,271]]],["amd radeon pro v7350x2","7350",0,[[1920,1080,60]]],["amd radeon pro vega 16","16",0,[[2879,1800,60],[3360,2100,60]]],["amd radeon pro vega 20","20",0,[[2880,1800,120],[3360,2100,121],[3840,2160,30]]],["amd radeon pro vega 48","48",0,[[5120,2880,86]]],["amd radeon pro vega 56","56",0,[[1920,1080,60],[5120,2880,60]]],["amd radeon pro vega 56 opengl engine","56",0,[[5120,2880,60]]],["amd radeon pro vega 64","64",0,[[5120,2880,60]]],["amd radeon pro vega 64 opengl engine","64",0,[[5120,2880,60]]],["amd radeon pro vega 64x","64",0,[[2560,1440,206],[4096,2304,60],[5120,2880,60]]],["amd radeon pro vega ii","proii",0,[[3840,1600,60],[5120,2880,60]]],["amd radeon pro vega ii duo","proii",0,[[2560,1440,239],[5120,2880,60]]],["amd radeon pro w5500","5500",0,[[1920,1080,195],[3840,2160,59],[7680,3240,56]]],["amd radeon pro w5500m","5500",0,[[1920,1080,60]]],["amd radeon pro w5500x","5500",0,[[1920,1200,60]]],["amd radeon pro w5700","5700",0,[[1680,1050,253],[5120,1440,120],[3840,2160,60]]],["amd radeon pro w5700x","5700",0,[[3840,2160,60]]],["amd radeon pro w6600","6600",0,[[1920,1200,60],[3840,2160,166]]],["amd radeon pro w6600m","6600",0,[[1920,1080,60]]],["amd radeon pro w6800","6800",0,[[1920,1080,60],[3840,2160,237]]],["amd radeon pro w6800x","6800",0,[[6016,3384,60]]],["amd radeon pro w6800x duo","6800",0,[[3840,1600,60],[5120,2880,45]]],["amd radeon pro w6900x","6900",0,[[3840,2160,60]]],["amd radeon pro wx","pro",0,[[2560,1080,69]]],["amd radeon pro wx 2100","2100",0,[[1280,1024,145],[1920,1080,60]]],["amd radeon pro wx 3100","3100",0,[[1919,1080,58],[1920,1080,123],[2560,1440,82]]],["amd radeon pro wx 3200","3200",0,[[2560,1440,92]]],["amd radeon pro wx 4100","4100",0,[[1920,1080,60],[1920,1200,60],[3840,2160,30],[5120,2880,18]]],["amd radeon pro wx 4130","4130",0,[[1920,1080,60],[3840,2160,30]]],["amd radeon pro wx 4150","4150",0,[[1920,1080,56],[3840,2160,37],[4096,2160,34]]],["amd radeon pro wx 5100","5100",0,[[1920,1080,60],[2560,1440,91],[3840,2160,55]]],["amd radeon pro wx 5100 opengl engine","5100",0,[[2560,1440,60]]],["amd radeon pro wx 7100","7100",0,[[1920,1080,122],[2560,1080,58],[3840,2160,60],[5120,2880,60]]],["amd radeon pro wx 7100 mobile","7100",0,[[2560,1440,60]]],["amd radeon pro wx 7100 opengl engine","7100",0,[[3840,2160,60]]],["amd radeon pro wx 8200","8200",0,[[3440,1440,124]]],["amd radeon pro wx 9100","9100",0,[[1920,1080,60],[4096,2160,101]]],["amd radeon pro wx 9100 opengl engine","9100",0,[[1920,1080,60]]],["amd radeon pro wx vega m gl","prom",0,[[3840,2160,14]]],["amd radeon pro wx3200","3200",0,[[1920,1080,55]]],["amd radeon pro wx9100","9100",0,[[2560,1440,60]]],["amd radeon r2","2",0,[[1366,768,13],[1600,900,14]]],["amd radeon r2e","2",0,[[1366,768,16],[1920,1080,45],[3840,2160,4]]],["amd radeon r3","3",0,[[1366,768,17],[1920,1080,15]]],["amd radeon r4","4",0,[[1366,768,19],[1920,1080,13]]],["amd radeon r4e","4",0,[[3840,2160,6]]],["amd radeon r5","5",0,[[1024,768,38],[1360,768,25],[1366,768,21],[1280,1024,33],[1920,1080,14],[3200,1800,7]]],["amd radeon r5 220","5",0,[[1366,768,19],[1920,1080,12]]],["amd radeon r5 230","5",0,[[1920,1080,21]]],["amd radeon r5 235","5",0,[[1920,1080,17]]],["amd radeon r5 240","5",0,[[1280,1024,34],[1920,1080,24]]],["amd radeon r5 340","5",0,[[1920,1080,27]]],["amd radeon r5 340x","5",0,[[1920,1080,31]]],["amd radeon r5 430","5",0,[[1280,1024,31],[1680,1050,54],[1920,1080,54]]],["amd radeon r5 435","5",0,[[1920,1080,30]]],["amd radeon r5 m200","5",0,[[1600,900,45],[1920,1080,20]]],["amd radeon r5 m200 / hd 8500m","5",0,[[1366,768,31],[1920,1080,24]]],["amd radeon r5 m230","5",0,[[1366,768,37]]],["amd radeon r5 m240","5",0,[[1366,768,42],[1920,1080,23]]],["amd radeon r5 m255","5",0,[[1366,768,59],[1600,900,33]]],["amd radeon r5 m315","5",0,[[1366,768,45]]],["amd radeon r5 m320","5",0,[[1920,1080,19]]],["amd radeon r5 m330","5",0,[[1366,768,27],[1920,1080,26]]],["amd radeon r5 m335","5",0,[[1366,768,55],[1920,1080,19]]],["amd radeon r5 m420","5",0,[[1366,768,49]]],["amd radeon r5 m430","5",0,[[1366,768,36],[1920,1080,20]]],["amd radeon r5 m435","5",0,[[1920,1080,41],[2560,1440,67]]],["amd radeon r5 m445","5",0,[[1920,1080,32]]],["amd radeon r5e","5",0,[[1600,768,14],[1920,1080,16]]],["amd radeon r6","6",0,[[1366,768,30],[1280,1024,23],[1920,1080,12]]],["amd radeon r6 m255dx","6",0,[[1366,768,25]]],["amd radeon r6 m340dx","6",0,[[1366,768,31],[1920,1080,15]]],["amd radeon r6e","6",0,[[3840,2160,5]]],["amd radeon r7","7",0,[[1366,768,35],[1280,1024,31],[1680,1050,39],[1920,1080,12],[1920,1200,16],[2560,1080,15],[2560,1440,21],[3840,2160,8]]],["amd radeon r7 200","7",0,[[1280,1024,45],[1920,1080,120]]],["amd radeon r7 200 series","7",0,[[1920,1080,43]]],["amd radeon r7 240","7",0,[[1920,1080,29]]],["amd radeon r7 240 + hd 8570d dual","7",0,[[1920,1080,43]]],["amd radeon r7 250","7",0,[[1920,1080,49]]],["amd radeon r7 250e","7",0,[[1920,1080,60]]],["amd radeon r7 250x","7",0,[[1920,1080,60]]],["amd radeon r7 260x","7",0,[[1920,1080,56]]],["amd radeon r7 260x/360","7",0,[[1920,1200,102]]],["amd radeon r7 350","7",0,[[1024,768,60],[1280,1024,79],[1920,1080,59]]],["amd radeon r7 350x","7",0,[[1920,1080,50]]],["amd radeon r7 360","7",0,[[1920,1048,60],[1920,1080,102]]],["amd radeon r7 360 / r9 360","7",0,[[1920,1080,60]]],["amd radeon r7 370","7",0,[[1600,900,60],[1920,1080,75]]],["amd radeon r7 370 / r9 270","7",0,[[1920,1080,74]]],["amd radeon r7 370 / r9 270x/370","7",0,[[1600,900,115],[1920,1080,60]]],["amd radeon r7 370 / r9 270x/370x","7",0,[[1920,1080,115]]],["amd radeon r7 370 series","7",0,[[1920,1080,212],[3840,2160,60]]],["amd radeon r7 430","7",0,[[1920,1080,55],[3840,2160,10]]],["amd radeon r7 450","7",0,[[1920,1080,60]]],["amd radeon r7 a360","7",0,[[1920,1080,28]]],["amd radeon r7 graphics + hd 7700 dual","7",0,[[1600,1200,72]]],["amd radeon r7 graphics + r5 340 dual","7",0,[[1920,1080,47]]],["amd radeon r7 graphics + r7 200 dual","7",0,[[1920,1080,45],[1920,1200,47]]],["amd radeon r7 graphics + r7 350 dual","7",0,[[1919,1080,60]]],["amd radeon r7 m260","7",0,[[1600,900,44],[1920,1080,13]]],["amd radeon r7 m260dx","7",0,[[1366,768,46],[1920,1080,18]]],["amd radeon r7 m260x","7",0,[[1920,1080,29]]],["amd radeon r7 m265","7",0,[[1366,768,48],[1920,1080,27]]],["amd radeon r7 m270","7",0,[[1920,1080,31],[3840,2160,10]]],["amd radeon r7 m340","7",0,[[1366,768,60],[1920,1080,32]]],["amd radeon r7 m350","7",0,[[3840,2160,12]]],["amd radeon r7 m360","7",0,[[1366,768,40],[1920,1080,22]]],["amd radeon r7 m370","7",0,[[1920,1080,24]]],["amd radeon r7 m440","7",0,[[1920,1080,39]]],["amd radeon r7 m445","7",0,[[1920,1080,36]]],["amd radeon r7 m460","7",0,[[1919,1080,24],[1920,1080,29]]],["amd radeon r7 m520","7",0,[[1919,1080,17]]],["amd radeon r7 series / hd 9000","7",0,[[1920,1080,71],[2560,1080,59]]],["amd radeon r7e","7",0,[[1024,768,41]]],["amd radeon r8 m350dx","8",0,[[1366,768,30]]],["amd radeon r8 m365dx","8",0,[[1920,1080,28]]],["amd radeon r8 m435dx","8",0,[[1920,1080,22]]],["amd radeon r8 m445dx","8",0,[[1366,768,38],[1920,1080,27]]],["amd radeon r8 m535dx","8",0,[[1366,768,55]]],["amd radeon r9","9",0,[[1920,1080,60]]],["amd radeon r9 200","9",0,[[1920,1080,60]]],["amd radeon r9 200 / hd 7900","9",0,[[1920,1080,250]]],["amd radeon r9 255","9",0,[[1600,900,52],[1920,1080,51]]],["amd radeon r9 260","9",0,[[1920,1080,16]]],["amd radeon r9 270","9",0,[[1280,1024,60],[1920,1080,60]]],["amd radeon r9 270 1024sp","9",0,[[1920,1080,135]]],["amd radeon r9 270x","9",0,[[1920,1080,30]]],["amd radeon r9 280","9",0,[[1920,1080,75],[1920,1200,428],[2560,1440,60]]],["amd radeon r9 280,","9",0,[[5120,2880,39]]],["amd radeon r9 280x","9",0,[[1920,1080,137]]],["amd radeon r9 285","9",0,[[1920,1080,60],[1920,1200,129]]],["amd radeon r9 290","9",0,[[1920,1080,60]]],["amd radeon r9 290x","9",0,[[1920,1080,60],[2560,1440,60],[3840,2160,118]]],["amd radeon r9 300","9",0,[[1920,1080,59]]],["amd radeon r9 350","9",0,[[1920,1200,63]]],["amd radeon r9 360","9",0,[[1600,900,83],[1920,1080,60],[2560,1440,59]]],["amd radeon r9 370","9",0,[[1680,1050,205],[1920,1080,60],[3840,2160,49]]],["amd radeon r9 370x","9",0,[[1920,1080,60]]],["amd radeon r9 380","9",0,[[1920,1080,41],[2560,1440,75]]],["amd radeon r9 380x","9",0,[[2560,1600,60]]],["amd radeon r9 390","9",0,[[1920,1080,60],[2560,1440,60]]],["amd radeon r9 390x","9",0,[[2560,1440,60],[3840,2160,60]]],["amd radeon r9 a375","9",0,[[1920,1080,28]]],["amd radeon r9 fury","9",0,[[1920,1080,75],[3840,2160,133]]],["amd radeon r9 fury / nano","9",0,[[1920,1200,155]]],["amd radeon r9 m200x","9",0,[[1366,768,104],[1920,1080,60]]],["amd radeon r9 m265x","9",0,[[1920,1080,33]]],["amd radeon r9 m270x","9",0,[[1600,900,60],[1920,1080,68]]],["amd radeon r9 m275","9",0,[[1920,1080,29]]],["amd radeon r9 m275x","9",0,[[1920,1080,20]]],["amd radeon r9 m280x","9",0,[[1920,1080,60],[2560,1440,25]]],["amd radeon r9 m290","9",0,[[5120,2880,33]]],["amd radeon r9 m290x","9",0,[[1920,1080,60],[3840,2160,61],[5120,2880,33]]],["amd radeon r9 m295x","9",0,[[3840,2160,33],[5120,2880,36]]],["amd radeon r9 m295x mac","9",0,[[5120,2880,42]]],["amd radeon r9 m295x mac edition / r9 380x","9",0,[[1920,1080,128]]],["amd radeon r9 m360","9",0,[[1920,1080,60],[3840,2160,26]]],["amd radeon r9 m370x","9",0,[[2560,1440,30],[2880,1800,27]]],["amd radeon r9 m370x opengl engine","9",0,[[5120,2880,14]]],["amd radeon r9 m375","9",0,[[1920,1080,29]]],["amd radeon r9 m375x","9",0,[[1920,1080,60],[3840,2160,22]]],["amd radeon r9 m380","9",0,[[1920,1080,50],[3840,2160,8],[5120,2880,9]]],["amd radeon r9 m380 opengl engine","9",0,[[5120,2880,15]]],["amd radeon r9 m385","9",0,[[1920,1080,58]]],["amd radeon r9 m385x","9",0,[[1920,1080,60]]],["amd radeon r9 m390","9",0,[[5119,2879,29],[5120,2880,21],[5760,3240,32]]],["amd radeon r9 m390 opengl engine","9",0,[[5120,2880,27]]],["amd radeon r9 m390x","9",0,[[1920,1080,140]]],["amd radeon r9 m395","9",0,[[2560,1440,59],[5120,2880,19]]],["amd radeon r9 m395 opengl engine","9",0,[[5120,2880,38]]],["amd radeon r9 m395x","9",0,[[3840,2160,58],[5120,2880,36]]],["amd radeon r9 m395x opengl engine","9",0,[[5120,2880,35]]],["amd radeon r9 m470","9",0,[[3840,2160,29]]],["amd radeon r9 m470x","9",0,[[1920,1080,60]]],["amd radeon r9-290x","9",0,[[1920,1080,60]]],["amd radeon renoir graphics d1","1",0,[[1366,768,60]]],["amd radeon rro 580x","580",0,[[5120,2880,59]]],["amd radeon rx 460","460",0,[[1920,1080,55],[2560,1080,60],[3840,2160,31]]],["amd radeon rx 460 / pro 450/455/460/555/555x/560/560x","460",0,[[3440,1440,93]]],["amd radeon rx 460 / pro 450/455/460/560","460",0,[[1920,1080,72]]],["amd radeon rx 470","470",0,[[1280,1024,73],[1920,1080,58],[1920,1200,147],[3840,2160,51]]],["amd radeon rx 470 opengl engine","470",0,[[2560,1440,60]]],["amd radeon rx 475m","475",0,[[1920,1080,60]]],["amd radeon rx 480","480",0,[[1400,1050,267],[1920,1080,60],[2560,1080,71]]],["amd radeon rx 480 opengl engine","480",0,[[1920,1080,60]]],["amd radeon rx 5300m","5300",0,[[1920,1080,60],[3840,2160,60]]],["amd radeon rx 540","540",0,[[1919,1080,52],[1920,1080,36]]],["amd radeon rx 550","550",0,[[1280,1024,135],[1920,1080,60],[1920,1200,60],[6016,3384,15]]],["amd radeon rx 550 640sp / rx 560","550",0,[[1920,1080,60]]],["amd radeon rx 5500","5500",0,[[1920,1080,139]]],["amd radeon rx 5500 / pro 5500m","5500",0,[[1920,1080,60],[2560,1440,227]]],["amd radeon rx 5500 xt","5500",0,[[1920,1080,239]]],["amd radeon rx 5500m","5500",0,[[1920,1048,144],[1920,1080,144],[3840,2160,60]]],["amd radeon rx 550x","550",0,[[1920,1080,52]]],["amd radeon rx 560","560",0,[[1920,1080,60],[1920,1200,42],[2560,1440,60]]],["amd radeon rx 560 [baffin]","560",0,[[1920,1080,60]]],["amd radeon rx 5600 oem/5600 xt / 5700 xt","5600",0,[[1920,1080,360],[2560,1440,164]]],["amd radeon rx 5600 xt","5600",0,[[1920,1080,75]]],["amd radeon rx 5600m","5600",0,[[1920,1080,144]]],["amd radeon rx 560d","560",0,[[2560,1080,60]]],["amd radeon rx 560x","560",0,[[1920,1080,115],[3840,2160,35]]],["amd radeon rx 570","570",0,[[1920,1080,60],[3072,1728,60]]],["amd radeon rx 570 opengl engine","570",0,[[1920,1080,226]]],["amd radeon rx 5700","5700",0,[[1920,1080,144]]],["amd radeon rx 5700 / 5700 xt","5700",0,[[3840,2160,201]]],["amd radeon rx 5700 xt","5700",0,[[1920,1080,464],[3840,2160,60],[6016,3384,34]]],["amd radeon rx 5700 xt 50th anniversary","5700",0,[[2560,1440,144],[3840,1600,60],[3840,2160,222],[5120,2880,60]]],["amd radeon rx 5700xt","5700",0,[[1920,1080,369]]],["amd radeon rx 580","580",0,[[1920,1080,60],[1920,1200,97],[2560,1440,60],[3840,2160,60]]],["amd radeon rx 580 2048sp","580",0,[[1920,1080,60]]],["amd radeon rx 580 opengl engine","580",0,[[1920,1080,145]]],["amd radeon rx 580 special","580",0,[[2560,1440,60]]],["amd radeon rx 580x","580",0,[[1920,1200,60],[3840,2160,79]]],["amd radeon rx 590","590",0,[[1920,1080,75],[2560,1440,164],[3584,2240,60]]],["amd radeon rx 640","640",0,[[1920,1080,39]]],["amd radeon rx 6500 xt","6500",0,[[1920,1080,60]]],["amd radeon rx 6600","6600",0,[[1920,1080,433],[3840,2160,57]]],["amd radeon rx 6600 xt","6600",0,[[1920,1080,60]]],["amd radeon rx 6600 xt/6600m","6600",0,[[2560,1440,60]]],["amd radeon rx 6600m","6600",0,[[1920,1080,139]]],["amd radeon rx 6700 xt","6700",0,[[1920,1080,451]]],["amd radeon rx 6700 xt / 6800m","6700",0,[[2560,1440,144]]],["amd radeon rx 6700m","6700",0,[[1920,1080,240]]],["amd radeon rx 6800","6800",0,[[2560,1440,564],[3840,2160,60]]],["amd radeon rx 6800 xt","6800",0,[[2560,1440,446],[3440,1440,144],[3840,2160,60]]],["amd radeon rx 6800 xt / 6900 xt","6800",0,[[2560,1440,239]]],["amd radeon rx 6800 xt 16gb","6800",0,[[6400,2666,60]]],["amd radeon rx 6800m","6800",0,[[1920,1080,300]]],["amd radeon rx 6900 xt","6900",0,[[3840,2160,60]]],["amd radeon rx rx 560","560",0,[[1920,1080,60]]],["amd radeon rx vega","rx",0,[[1920,1080,39]]],["amd radeon rx vega 10","10",0,[[1920,1080,38]]],["amd radeon rx vega 11","11",0,[[1920,1080,35]]],["amd radeon rx vega 56","56",0,[[1920,1080,144],[3440,1440,60],[3840,2160,60]]],["amd radeon rx vega 56 8gb","56",0,[[2560,1600,60]]],["amd radeon rx vega 56 opengl engine","56",0,[[2560,1440,60]]],["amd radeon rx vega 64","64",0,[[2560,1440,518]]],["amd radeon rx vega 64 8gb","64",0,[[2560,1440,60]]],["amd radeon rx vega 64 opengl engine","64",0,[[3840,2160,119]]],["amd radeon rx vega 64.1","64",0,[[6016,3384,60]]],["amd radeon rx vega 8","8",0,[[1920,1080,53]]],["amd radeon rx vega m gh","rxm",0,[[1920,1080,60],[2560,1440,60],[3840,2160,51]]],["amd radeon rx vega m gl","rxm",0,[[2560,1440,567],[3840,2160,59]]],["amd radeon rx vega11","11",0,[[2496,1664,30]]],["amd radeon rx460","460",0,[[1920,1080,60]]],["amd radeon rx480","480",0,[[1920,1080,102],[2560,1080,71]]],["amd radeon rx540","540",0,[[2400,1800,37]]],["amd radeon rx550","550",0,[[1920,1080,60]]],["amd radeon rx560","560",0,[[1920,1080,93]]],["amd radeon rx5600","5600",0,[[3840,2160,129]]],["amd radeon rx570","570",0,[[5120,2880,59]]],["amd radeon rx5700","5700",0,[[1920,1080,60]]],["amd radeon rx580","580",0,[[1920,1080,60]]],["amd radeon rx590 gme","590",0,[[1920,1080,112]]],["amd radeon rx6600xt","6600",0,[[3840,2160,60]]],["amd radeon sky 500","500",0,[[4096,2160,34]]],["amd radeon vega","",0,[[5120,2880,32]]],["amd radeon vega 10","10",0,[[1920,1080,44]]],["amd radeon vega 10 mobile","10",0,[[1920,1080,30]]],["amd radeon vega 11","11",0,[[1280,1024,60],[1920,1080,60],[3840,2160,17]]],["amd radeon vega 2","2",0,[[1366,768,30]]],["amd radeon vega 3","3",0,[[1440,900,44],[1920,1080,29],[3840,2160,8]]],["amd radeon vega 3 mobile","3",0,[[1920,1080,30]]],["amd radeon vega 56","56",0,[[2560,1440,144]]],["amd radeon vega 6","6",0,[[1366,768,61],[1920,1080,23]]],["amd radeon vega 64","64",0,[[6016,3384,35]]],["amd radeon vega 64 lc","64",0,[[2560,1080,60]]],["amd radeon vega 8","8",0,[[1920,1080,35],[2560,1440,24],[4096,2160,15]]],["amd radeon vega 8 mobile","8",0,[[1920,1080,36]]],["amd radeon vega 9","9",0,[[2496,1663,32],[2496,1664,39]]],["amd radeon vega fe","fe",0,[[1920,1080,120],[2560,1440,60]]],["amd radeon vega frontier","",0,[[1920,1080,120],[3840,2160,60]]],["amd radeon vega frontier edition opengl engine","",0,[[3440,1440,60]]],["amd radeon vega series / radeon vega mobile","",0,[[1920,1080,67]]],["amd radeon vii","vii",0,[[1920,1080,468],[2560,1440,60],[3840,2160,60]]],["amd radeont 540x","540",0,[[1920,1080,74],[3840,2160,22]]],["amd radeont rx 5300","5300",0,[[1920,1080,60]]],["amd radeont rx 5500m","5500",0,[[1920,1080,303]]],["amd radeont rx 560x","560",0,[[1920,1080,60]]],["amd renoir","",0,[[1920,1080,60]]],["amd rx 480","480",0,[[1680,1050,119]]],["amd rx 560","560",0,[[5120,2880,37]]],["amd rx 5700xt","5700",0,[[3840,2160,60]]],["amd rx 580","580",0,[[1920,1200,60],[5120,2880,60]]],["amd rx 590","590",0,[[5120,2880,60]]],["amd rx vega 64","64",0,[[1920,1080,60]]],["amd rx xxx","xxx",0,[[1920,1080,60],[2560,1440,144]]],["amd saphire radeon rx 580","580",0,[[1920,1080,57]]],["amd sapphire hd 5770","5770",0,[[1440,900,60]]],["amd sapphire nitro+ rx 6800","6800",0,[[1920,1080,75]]],["amd sapphire radeon hd6870","6870",0,[[1680,1050,60]]],["amd sapphire radeon rx 560","560",0,[[1280,1024,60]]],["amd sapphire radeon rx vega 64 8gb","64",0,[[2560,1440,144]]],["amd tonga pro gl [firepro w7100]","7100",0,[[1920,1200,127]]],["amd video controller","",0,[[1919,1079,60],[1920,1080,291]]],["intel radeong 0.4 on amd bonaire","0",0,[[1920,1200,92]]],["intel radeong 0.4 on amd cape verde","0",0,[[1920,1200,73]]],["intel radeong 0.4 on amd polaris10","0",0,[[3840,2160,108]]],["intel radeong 0.4 on amd tonga","0",0,[[1920,1080,124]]],["radeong 0.4 on amd polaris10","0",0,[[3840,2160,109]]],["radeong 0.4 on amd tahiti","0",0,[[1920,1080,223]]]]')},732:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["apple a14","14",0,[[2704,1756,120]]],["apple m1","1",0,[[2880,1800,60]]],["apple m1 max","1",0,[[3456,2234,120]]],["apple m1 pro","1",0,[[3024,1964,120]]],["apple paravirtual device","",0,[[1024,768,30]]]]')},405:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["intel geforce gtx 960","960",0,[[1920,1080,26]]],["nvidia asus geforce gt 430","430",0,[[1366,768,35]]],["nvidia asus geforce gt 440","440",0,[[1920,1080,28]]],["nvidia asus geforce gt 520","520",0,[[1680,1050,12]]],["nvidia asus geforce gt 610","610",0,[[1920,1200,15]]],["nvidia asus geforce gt 630","630",0,[[1680,1050,41]]],["nvidia asus geforce gt 640","640",0,[[2560,1440,34]]],["nvidia asus geforce gt 710","710",0,[[1920,1080,31]]],["nvidia asus geforce gt 730","730",0,[[2560,1080,28],[3840,2160,12]]],["nvidia asus geforce gts 450","450",0,[[1920,1080,54]]],["nvidia asus geforce gtx 1060","1060",0,[[3840,2160,38]]],["nvidia asus geforce gtx 1080","1080",0,[[2560,1440,120]]],["nvidia asus geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia asus geforce gtx 480","480",0,[[1920,1080,59]]],["nvidia asus geforce gtx 550 ti","550",0,[[1920,1080,57]]],["nvidia asus geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia asus geforce gtx 560 se","560",0,[[1920,1080,59]]],["nvidia asus geforce gtx 560 ti","560",0,[[1680,1050,58]]],["nvidia asus geforce gtx 570","570",0,[[1280,1024,74]]],["nvidia asus geforce gtx 570 hd","570",0,[[1920,1080,60]]],["nvidia asus geforce gtx 580","580",0,[[1920,1200,59]]],["nvidia asus geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia asus geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia asus geforce gtx 750 ti","750",0,[[1360,768,59],[1920,1080,118]]],["nvidia asus geforce gtx 760","760",0,[[1920,1080,60],[1920,1200,60]]],["nvidia asus geforce gtx 770","770",0,[[1920,1080,60]]],["nvidia asus geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia asus geforce gtx 950","950",0,[[1920,1080,60]]],["nvidia asus geforce gtx 960","960",0,[[1920,1080,60],[2560,1600,117]]],["nvidia asus geforce gtx 970","970",0,[[2560,1600,60]]],["nvidia asus geforce gtx 980 ti","980",0,[[2560,1440,131]]],["nvidia colorful geforce gtx 960","960",0,[[2560,1440,60]]],["nvidia elitegroup geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia evga geforce gt 545","545",0,[[1920,1080,37]]],["nvidia evga geforce gt 640","640",0,[[1366,768,60]]],["nvidia evga geforce gt 710","710",0,[[1680,1050,36],[1920,1080,29]]],["nvidia evga geforce gt 730","730",0,[[1600,900,59]]],["nvidia evga geforce gt 740","740",0,[[1280,1024,45]]],["nvidia evga geforce gtx 1050 ti","1050",0,[[2560,1440,60],[4096,2304,58]]],["nvidia evga geforce gtx 1070","1070",0,[[5120,2880,60]]],["nvidia evga geforce gtx 1080 ti","1080",0,[[1920,1200,60]]],["nvidia evga geforce gtx 560 ti","560",0,[[1680,1050,59]]],["nvidia evga geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia evga geforce gtx 580","580",0,[[2560,1440,60]]],["nvidia evga geforce gtx 650","650",0,[[1920,1200,87],[2560,1600,43]]],["nvidia evga geforce gtx 650 ti","650",0,[[1680,1050,116],[2560,1440,55]]],["nvidia evga geforce gtx 650 ti boost","650",0,[[1920,1080,56]]],["nvidia evga geforce gtx 660 ti","660",0,[[1920,1200,60]]],["nvidia evga geforce gtx 680","680",0,[[1600,1200,60]]],["nvidia evga geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia evga geforce gtx 760","760",0,[[1920,1080,119],[1920,1200,60]]],["nvidia evga geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia evga geforce gtx 960","960",0,[[1920,1080,60],[2560,1440,115]]],["nvidia evga geforce gtx 970","970",0,[[1920,1080,120]]],["nvidia evga geforce gtx 980","980",0,[[3440,1440,60]]],["nvidia evga geforce gtx 980 ti","980",0,[[1920,1080,60]]],["nvidia gainward geforce gt 630","630",0,[[1920,1080,28]]],["nvidia gainward geforce gts 450","450",0,[[1920,1080,55]]],["nvidia gainward geforce gtx 460","460",0,[[1920,1080,58]]],["nvidia gainward geforce gtx 550 ti","550",0,[[1280,1024,67]]],["nvidia gainward geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia gainward geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia gainward geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia geforce 210","210",0,[[1920,1080,8]]],["nvidia geforce 410m","410",0,[[1366,768,25],[1600,900,19]]],["nvidia geforce 510","510",0,[[1280,960,20]]],["nvidia geforce 605","605",0,[[1768,992,17],[1920,1080,15]]],["nvidia geforce 610m","610",0,[[1366,768,26]]],["nvidia geforce 610m/710m/810m/820m / gt 620m/625m/630m/720m","610",0,[[1366,768,51]]],["nvidia geforce 615","615",0,[[1920,1080,21]]],["nvidia geforce 705m","705",0,[[1920,1080,18]]],["nvidia geforce 710a","710",0,[[1920,1080,32]]],["nvidia geforce 710m","710",0,[[1366,768,55]]],["nvidia geforce 730a","730",0,[[1920,1080,37]]],["nvidia geforce 800m","800",0,[[1920,1080,18]]],["nvidia geforce 810m","810",0,[[1366,768,44],[1920,1080,31]]],["nvidia geforce 820a","820",0,[[1920,1080,28]]],["nvidia geforce 820m","820",0,[[1366,768,57],[1920,1080,23]]],["nvidia geforce 830a","830",0,[[1920,1080,53]]],["nvidia geforce 830m","830",0,[[1366,768,60]]],["nvidia geforce 8400 gs","8400",0,[[1680,1050,4]]],["nvidia geforce 8400 gs rev. 3","8400",0,[[1920,1080,4]]],["nvidia geforce 840a","840",0,[[1920,1080,56]]],["nvidia geforce 840m","840",0,[[1920,1080,56]]],["nvidia geforce 845m","845",0,[[1920,1080,59]]],["nvidia geforce 8600 gt","8600",1,[[1920,1200,-1]]],["nvidia geforce 8600 gts","8600",1,[[1920,1080,-1]]],["nvidia geforce 910m","910",0,[[1366,768,58],[1600,900,45]]],["nvidia geforce 920m","920",0,[[1366,768,60]]],["nvidia geforce 920mx","920",0,[[1366,768,60],[1920,1080,60]]],["nvidia geforce 9300 / nforce 730i","9300",0,[[1920,1080,6]]],["nvidia geforce 930a","930",0,[[1920,1080,55]]],["nvidia geforce 930m","930",0,[[1366,768,60]]],["nvidia geforce 930mx","930",0,[[1366,768,89],[1920,1080,59]]],["nvidia geforce 9400 gt","9400",1,[[1366,768,-1]]],["nvidia geforce 940a","940",0,[[1920,1080,58]]],["nvidia geforce 940m","940",0,[[1920,1080,54]]],["nvidia geforce 940mx","940",0,[[1920,1080,60]]],["nvidia geforce 945m","945",0,[[1920,1080,59]]],["nvidia geforce 9600 gt","9600",0,[[1920,1200,2]]],["nvidia geforce 9600m gt","9600",1,[[1440,900,-1]]],["nvidia geforce 9800 gt","9800",0,[[1920,1200,52]]],["nvidia geforce 9800 gtx / 9800 gtx+","9800",0,[[1280,1024,59]]],["nvidia geforce gpu","gpu",0,[[3000,2000,36]]],["nvidia geforce gt 1010","1010",0,[[1920,1080,135]]],["nvidia geforce gt 1030","1030",0,[[1920,1080,60]]],["nvidia geforce gt 1030 opengl engine","1030",0,[[6720,3780,15]]],["nvidia geforce gt 120","120",1,[[1920,1080,-1]]],["nvidia geforce gt 240","240",0,[[1366,768,32]]],["nvidia geforce gt 320m","320",0,[[1366,768,26]]],["nvidia geforce gt 415m","415",0,[[1366,768,19]]],["nvidia geforce gt 420","420",0,[[1024,768,33],[1920,1080,20]]],["nvidia geforce gt 420m","420",0,[[1366,768,28]]],["nvidia geforce gt 425m","425",0,[[1366,768,55],[1600,900,28]]],["nvidia geforce gt 430","430",0,[[1600,1200,16],[1920,1080,28]]],["nvidia geforce gt 435m","435",0,[[1366,768,53],[1920,1080,22]]],["nvidia geforce gt 440","440",0,[[1280,1024,51],[1680,1050,38],[1920,1080,45]]],["nvidia geforce gt 445m","445",0,[[1600,900,53]]],["nvidia geforce gt 520","520",0,[[1440,900,19],[1920,1080,17]]],["nvidia geforce gt 520m","520",0,[[1366,768,29]]],["nvidia geforce gt 520mx","520",0,[[1366,768,35]]],["nvidia geforce gt 525m","525",0,[[1366,768,28],[1600,900,22]]],["nvidia geforce gt 530","530",0,[[1920,1080,26]]],["nvidia geforce gt 540m","540",0,[[1366,768,38]]],["nvidia geforce gt 545","545",0,[[1920,1080,54]]],["nvidia geforce gt 550m","550",0,[[1600,900,44],[1920,1080,29]]],["nvidia geforce gt 555m","555",0,[[1920,1080,42]]],["nvidia geforce gt 555m/635m","555",0,[[1920,1080,36]]],["nvidia geforce gt 610","610",0,[[1280,1024,22],[1920,1080,15]]],["nvidia geforce gt 620","620",0,[[1920,1080,19]]],["nvidia geforce gt 620 oem","620",0,[[1920,1080,20],[1920,1200,20]]],["nvidia geforce gt 620m","620",0,[[1366,768,55],[1920,1080,30]]],["nvidia geforce gt 620m/630m/635m/640m le","620",0,[[1368,768,38]]],["nvidia geforce gt 625","625",0,[[1920,1080,18]]],["nvidia geforce gt 625m","625",0,[[1366,768,38]]],["nvidia geforce gt 630","630",0,[[1680,1050,36],[1920,1080,36],[1920,1200,30]]],["nvidia geforce gt 630 oem","630",0,[[1600,900,33]]],["nvidia geforce gt 630 opengl engine","630",0,[[1920,1080,33]]],["nvidia geforce gt 630 rev. 2","630",0,[[1920,1080,26]]],["nvidia geforce gt 630m","630",0,[[1366,768,57]]],["nvidia geforce gt 635","635",0,[[1920,1080,27]]],["nvidia geforce gt 635m","635",0,[[1366,768,47]]],["nvidia geforce gt 640","640",0,[[1920,1080,47]]],["nvidia geforce gt 640 oem","640",0,[[1920,1080,46],[2560,1440,35]]],["nvidia geforce gt 640 opengl engine","640",0,[[1280,1024,43]]],["nvidia geforce gt 640 rev. 2","640",0,[[1280,1024,60],[1920,1080,55]]],["nvidia geforce gt 640m","640",0,[[1366,768,82],[1600,900,59],[1920,1080,34]]],["nvidia geforce gt 640m le","640",0,[[1920,1080,49]]],["nvidia geforce gt 640m mac","640",0,[[1366,768,56],[1920,1080,20]]],["nvidia geforce gt 640m opengl engine","640",0,[[1920,1080,45]]],["nvidia geforce gt 645m","645",0,[[1366,768,60]]],["nvidia geforce gt 650m","650",0,[[1360,768,59],[1920,1080,58],[2560,1440,59]]],["nvidia geforce gt 650m mac","650",0,[[1440,900,56],[1920,1080,15],[2560,1440,19],[2880,1800,31]]],["nvidia geforce gt 650m opengl engine","650",0,[[1920,1080,56],[3840,2160,27]]],["nvidia geforce gt 705","705",0,[[1920,1080,11]]],["nvidia geforce gt 710","710",0,[[1920,1080,28]]],["nvidia geforce gt 710b","710",0,[[1920,1080,26]]],["nvidia geforce gt 710m","710",0,[[1366,768,46]]],["nvidia geforce gt 720","720",0,[[1920,1080,19],[2560,1440,16],[5120,2880,5]]],["nvidia geforce gt 720 opengl engine","720",0,[[2560,1600,20]]],["nvidia geforce gt 720m","720",0,[[1366,768,42]]],["nvidia geforce gt 730","730",0,[[1920,1080,54]]],["nvidia geforce gt 730a","730",0,[[1920,1080,23]]],["nvidia geforce gt 730m","730",0,[[1920,1080,43]]],["nvidia geforce gt 735m","735",0,[[1920,1080,39]]],["nvidia geforce gt 740","740",0,[[1920,1080,55],[3440,1440,23]]],["nvidia geforce gt 740 opengl engine","740",0,[[1920,1200,51]]],["nvidia geforce gt 740m","740",0,[[1366,768,60]]],["nvidia geforce gt 745m","745",0,[[1920,1080,55]]],["nvidia geforce gt 750m","750",0,[[1920,1080,57]]],["nvidia geforce gt 750m mac","750",0,[[1920,1080,58],[2880,1800,28]]],["nvidia geforce gt 755m","755",0,[[1920,1080,57]]],["nvidia geforce gt 755m mac","755",0,[[2560,1440,41]]],["nvidia geforce gt 755m opengl engine","755",0,[[2560,1440,51]]],["nvidia geforce gt 820m","820",0,[[1600,900,47]]],["nvidia geforce gts 250","250",0,[[1680,1050,53]]],["nvidia geforce gts 450","450",0,[[1360,768,60],[1680,1050,57],[1920,1080,55]]],["nvidia geforce gts 450 rev. 2","450",0,[[1920,1080,56]]],["nvidia geforce gtx 1050","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 3gb","1050",0,[[1280,1024,60]]],["nvidia geforce gtx 1050 mobile","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 opengl engine","1050",0,[[1920,1080,116]]],["nvidia geforce gtx 1050 ti","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 ti mobile","1050",0,[[1920,1080,298]]],["nvidia geforce gtx 1050 ti opengl engine","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 ti with max-q design","1050",0,[[1920,1080,268],[2560,1440,102],[3840,2160,60]]],["nvidia geforce gtx 1050 with max-q design","1050",0,[[1920,1080,60],[3840,2160,24]]],["nvidia geforce gtx 1060","1060",0,[[1920,1080,60],[3840,2160,59]]],["nvidia geforce gtx 1060 3gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 3gb opengl engine","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 5gb","1060",0,[[1920,1080,55]]],["nvidia geforce gtx 1060 6gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 6gb opengl engine","1060",0,[[1920,1080,75]]],["nvidia geforce gtx 1060 mobile","1060",0,[[1920,1080,422]]],["nvidia geforce gtx 1060 mobile 6gb","1060",0,[[1920,1080,120]]],["nvidia geforce gtx 1060 with max-q design","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060se 3gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1070","1070",0,[[1920,1080,134]]],["nvidia geforce gtx 1070 a17","1070",0,[[1920,1080,60]]],["nvidia geforce gtx 1070 mobile","1070",0,[[1920,1080,467]]],["nvidia geforce gtx 1070 opengl engine","1070",0,[[1920,1080,143]]],["nvidia geforce gtx 1070 ti","1070",0,[[1920,1080,60],[6016,3384,59]]],["nvidia geforce gtx 1070 ti opengl engine","1070",0,[[1920,1080,75]]],["nvidia geforce gtx 1070 with max-q design","1070",0,[[1920,1080,448]]],["nvidia geforce gtx 1070 with maxq design","1070",0,[[1920,1080,60],[3840,2160,59]]],["nvidia geforce gtx 1080","1080",0,[[1920,1080,119],[2560,1440,326],[3840,2160,286]]],["nvidia geforce gtx 1080 mobile","1080",0,[[1920,1080,120]]],["nvidia geforce gtx 1080 opengl engine","1080",0,[[1920,1080,79]]],["nvidia geforce gtx 1080 ti","1080",0,[[1920,1080,120]]],["nvidia geforce gtx 1080 ti opengl engine","1080",0,[[1920,1080,127]]],["nvidia geforce gtx 1080 with max-q design","1080",0,[[1920,1080,144]]],["nvidia geforce gtx 1180","1180",0,[[3440,1440,60]]],["nvidia geforce gtx 1650","1650",0,[[1920,1080,380]]],["nvidia geforce gtx 1650 mobile / max-q","1650",0,[[1920,1080,292]]],["nvidia geforce gtx 1650 super","1650",0,[[1920,1080,433]]],["nvidia geforce gtx 1650 ti","1650",0,[[1920,1080,144],[3840,2400,59]]],["nvidia geforce gtx 1650 ti mobile","1650",0,[[1920,1080,144]]],["nvidia geforce gtx 1650 ti with max-q design","1650",0,[[1920,1080,60],[3839,2160,60]]],["nvidia geforce gtx 1650 with max-q design","1650",0,[[1920,1080,142],[3000,2000,60]]],["nvidia geforce gtx 1660","1660",0,[[1920,1080,144]]],["nvidia geforce gtx 1660 super","1660",0,[[1920,1080,60]]],["nvidia geforce gtx 1660 ti","1660",0,[[1920,1080,546],[3840,2160,60]]],["nvidia geforce gtx 1660 ti mobile","1660",0,[[1920,1080,451]]],["nvidia geforce gtx 1660 ti with max-q design","1660",0,[[1920,1080,144]]],["nvidia geforce gtx 280","280",0,[[1680,1050,56]]],["nvidia geforce gtx 295","295",0,[[1920,1080,56]]],["nvidia geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia geforce gtx 460 oem","460",0,[[1360,768,60],[1920,1080,60]]],["nvidia geforce gtx 460 opengl engine","460",0,[[1920,1080,59]]],["nvidia geforce gtx 460 se","460",0,[[1920,1080,56],[1920,1200,57]]],["nvidia geforce gtx 460 v2","460",0,[[1920,1080,60],[1920,1200,60],[2560,1600,55]]],["nvidia geforce gtx 460m","460",0,[[1920,1080,46]]],["nvidia geforce gtx 465","465",0,[[1920,1080,134],[1920,1200,59]]],["nvidia geforce gtx 470","470",0,[[1680,1050,60],[1920,1080,59]]],["nvidia geforce gtx 470m","470",0,[[1920,1200,55]]],["nvidia geforce gtx 480","480",0,[[1440,900,191],[1920,1080,115],[1920,1200,60]]],["nvidia geforce gtx 480 opengl engine","480",0,[[1600,1200,60]]],["nvidia geforce gtx 550 ti","550",0,[[1280,1024,58],[1920,1080,58]]],["nvidia geforce gtx 550 ti opengl engine","550",0,[[1920,1080,55]]],["nvidia geforce gtx 555","555",0,[[1920,1080,54]]],["nvidia geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia geforce gtx 560 se","560",0,[[1680,1050,52],[1920,1080,111]]],["nvidia geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia geforce gtx 560 ti 448 cores","560",0,[[1920,1080,60],[2560,1440,60]]],["nvidia geforce gtx 560 ti oem","560",0,[[1920,1080,176]]],["nvidia geforce gtx 560 ti opengl engine","560",0,[[1920,1080,48]]],["nvidia geforce gtx 560m","560",0,[[1920,1080,55]]],["nvidia geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia geforce gtx 570 opengl engine","570",0,[[1920,1080,60]]],["nvidia geforce gtx 570 rev. 2","570",0,[[1920,1080,60],[1920,1200,60]]],["nvidia geforce gtx 570m","570",0,[[1920,1080,125],[2560,1440,8]]],["nvidia geforce gtx 580","580",0,[[1920,1080,60]]],["nvidia geforce gtx 580 opengl engine","580",0,[[1680,1050,59]]],["nvidia geforce gtx 580m","580",0,[[1920,1080,60]]],["nvidia geforce gtx 590","590",0,[[1920,1080,59]]],["nvidia geforce gtx 645","645",0,[[1920,1080,57],[1920,1200,58]]],["nvidia geforce gtx 645 opengl engine","645",0,[[1920,1200,58]]],["nvidia geforce gtx 650","650",0,[[1920,1080,72]]],["nvidia geforce gtx 650 oem","650",0,[[1366,768,59]]],["nvidia geforce gtx 650 opengl engine","650",0,[[1920,1080,59]]],["nvidia geforce gtx 650 ti","650",0,[[1920,1080,60]]],["nvidia geforce gtx 650 ti boost","650",0,[[1280,1024,60],[1600,1200,187],[1920,1080,60]]],["nvidia geforce gtx 650 ti opengl engine","650",0,[[1920,1080,60]]],["nvidia geforce gtx 660","660",0,[[1920,1080,111]]],["nvidia geforce gtx 660 oem","660",0,[[1920,1080,59]]],["nvidia geforce gtx 660 ti","660",0,[[1920,1080,60]]],["nvidia geforce gtx 660 ti opengl engine","660",0,[[1280,1024,60]]],["nvidia geforce gtx 660m","660",0,[[1680,1050,36],[1920,1080,59]]],["nvidia geforce gtx 660m mac","660",0,[[2560,1440,2]]],["nvidia geforce gtx 660m opengl engine","660",0,[[2560,1440,36]]],["nvidia geforce gtx 670","670",0,[[1920,1080,100]]],["nvidia geforce gtx 670 opengl engine","670",0,[[1920,1080,60]]],["nvidia geforce gtx 670m","670",0,[[1920,1080,66]]],["nvidia geforce gtx 670mx","670",0,[[1920,1080,60]]],["nvidia geforce gtx 675m","675",0,[[1920,1080,60]]],["nvidia geforce gtx 675mx","675",0,[[1680,1050,60],[1920,1080,60],[2560,1440,55]]],["nvidia geforce gtx 675mx mac","675",0,[[2560,1440,36]]],["nvidia geforce gtx 675mx opengl engine","675",0,[[2560,1440,60]]],["nvidia geforce gtx 680","680",0,[[1920,1080,60]]],["nvidia geforce gtx 680 opengl engine","680",0,[[1920,1080,60]]],["nvidia geforce gtx 680m","680",0,[[1920,1080,39],[1920,1200,60]]],["nvidia geforce gtx 680m opengl engine","680",0,[[1920,1080,36]]],["nvidia geforce gtx 680mx","680",0,[[2560,1440,59]]],["nvidia geforce gtx 680mx opengl engine","680",0,[[2560,1440,59]]],["nvidia geforce gtx 690","690",0,[[1920,1080,60],[3840,2160,30]]],["nvidia geforce gtx 745","745",0,[[1920,1080,60],[2560,1600,29]]],["nvidia geforce gtx 750","750",0,[[1920,1080,60]]],["nvidia geforce gtx 750 opengl engine","750",0,[[1920,1200,58]]],["nvidia geforce gtx 750 ti","750",0,[[1920,1080,97]]],["nvidia geforce gtx 760","760",0,[[1920,1080,60],[1920,1200,116]]],["nvidia geforce gtx 760 oem","760",0,[[1920,1080,60]]],["nvidia geforce gtx 760 opengl engine","760",0,[[1920,1080,52]]],["nvidia geforce gtx 760 ti","760",0,[[1920,1080,60],[1920,1200,60]]],["nvidia geforce gtx 760 ti oem","760",0,[[1920,1200,60]]],["nvidia geforce gtx 760 ti opengl engine","760",0,[[1920,1080,60]]],["nvidia geforce gtx 760a","760",0,[[2560,1080,15]]],["nvidia geforce gtx 760m","760",0,[[1920,1080,60]]],["nvidia geforce gtx 765m","765",0,[[1920,1080,53],[2560,1440,57]]],["nvidia geforce gtx 765m by nick[d]vb","765",0,[[2560,1440,58]]],["nvidia geforce gtx 765m opengl engine","765",0,[[2560,1440,57]]],["nvidia geforce gtx 770","770",0,[[1920,1080,143],[2560,1440,203]]],["nvidia geforce gtx 770 opengl engine","770",0,[[1920,1080,60]]],["nvidia geforce gtx 770m","770",0,[[1920,1080,60],[2560,1440,59]]],["nvidia geforce gtx 770m by nick[d]vb","770",0,[[2560,1440,34]]],["nvidia geforce gtx 770m opengl engine","770",0,[[2560,1440,59]]],["nvidia geforce gtx 775m by idopt mac","775",0,[[2560,1440,56]]],["nvidia geforce gtx 775m mac","775",0,[[2560,1440,59]]],["nvidia geforce gtx 775m opengl engine","775",0,[[2560,1440,60]]],["nvidia geforce gtx 780","780",0,[[1920,1080,159]]],["nvidia geforce gtx 780 by st3phl3","780",0,[[3840,2160,30]]],["nvidia geforce gtx 780 mac","780",0,[[1680,1050,60],[1920,1080,60]]],["nvidia geforce gtx 780 rev. 2","780",0,[[1920,1080,144],[2560,1440,119],[3840,2160,58],[5120,2880,58]]],["nvidia geforce gtx 780 ti","780",0,[[1280,1024,120],[1920,1080,119]]],["nvidia geforce gtx 780 ti opengl engine","780",0,[[2560,1440,60]]],["nvidia geforce gtx 780m","780",0,[[1920,1080,60],[2560,1440,59]]],["nvidia geforce gtx 780m by nick[d]vb","780",0,[[1920,1080,59],[2560,1440,60]]],["nvidia geforce gtx 780m mac","780",0,[[2560,1440,60]]],["nvidia geforce gtx 780m opengl engine","780",0,[[2560,1440,60]]],["nvidia geforce gtx 850a","850",0,[[2560,1440,48]]],["nvidia geforce gtx 850m","850",0,[[1920,1080,60]]],["nvidia geforce gtx 860m","860",0,[[1920,1080,59]]],["nvidia geforce gtx 860m opengl engine","860",0,[[2560,1440,58]]],["nvidia geforce gtx 870m","870",0,[[1920,1080,60],[2560,1440,102]]],["nvidia geforce gtx 880m","880",0,[[1920,1080,60],[2560,1440,74]]],["nvidia geforce gtx 880m opengl engine","880",0,[[2560,1440,60]]],["nvidia geforce gtx 950","950",0,[[1920,1080,98]]],["nvidia geforce gtx 950 opengl engine","950",0,[[1920,1200,60]]],["nvidia geforce gtx 950a","950",0,[[1920,1080,60],[3840,2160,38]]],["nvidia geforce gtx 950m","950",0,[[1920,1080,114]]],["nvidia geforce gtx 960","960",0,[[1920,1080,60]]],["nvidia geforce gtx 960a","960",0,[[1920,1440,128]]],["nvidia geforce gtx 960m","960",0,[[1920,1080,119],[3840,2160,37]]],["nvidia geforce gtx 965m","965",0,[[1920,1080,195],[3000,2000,59],[3840,2160,41]]],["nvidia geforce gtx 965m opengl engine","965",0,[[2880,1620,55]]],["nvidia geforce gtx 970","970",0,[[1920,1080,143]]],["nvidia geforce gtx 970 opengl engine","970",0,[[2560,1600,60]]],["nvidia geforce gtx 970m","970",0,[[1920,1080,60]]],["nvidia geforce gtx 980","980",0,[[1920,1080,60],[3440,1440,294]]],["nvidia geforce gtx 980 ti","980",0,[[1920,1080,119],[2560,1440,456]]],["nvidia geforce gtx 980 ti opengl engine","980",0,[[1920,1080,60]]],["nvidia geforce gtx 980m","980",0,[[1920,1080,60],[3840,2160,104]]],["nvidia geforce gtx titan","gtx",0,[[1920,1080,119],[1920,1200,119],[2560,1440,60]]],["nvidia geforce gtx titan black","gtx",0,[[1680,1050,60],[1920,1080,60],[1920,1200,60],[2560,1440,60]]],["nvidia geforce gtx titan black opengl engine","gtx",0,[[3840,2160,60]]],["nvidia geforce gtx titan opengl engine","gtx",0,[[2560,1440,60]]],["nvidia geforce gtx titan x","gtxx",0,[[1920,1080,144],[2560,1440,120],[2560,1600,60]]],["nvidia geforce gtx titan xp","gtxxp",0,[[2560,1440,60],[3440,1440,60]]],["nvidia geforce gtx titan z","gtxz",0,[[1440,900,59],[1920,1080,39],[3840,2160,60]]],["nvidia geforce gtx780m by nikey22","780",0,[[2560,1440,60]]],["nvidia geforce gtx870m by nikey22","870",0,[[2560,1440,60]]],["nvidia geforce gtx880m","880",0,[[1920,1080,60]]],["nvidia geforce gtx880m by nikey22","880",0,[[2560,1440,59]]],["nvidia geforce gtx880m opengl engine","880",0,[[2560,1440,59]]],["nvidia geforce mx110","110",0,[[1366,768,61],[1920,1080,57]]],["nvidia geforce mx130","130",0,[[1920,1080,60]]],["nvidia geforce mx150","150",0,[[1920,1080,113]]],["nvidia geforce mx230","230",0,[[1920,1080,60]]],["nvidia geforce mx250","250",0,[[1920,1080,60]]],["nvidia geforce mx330","330",0,[[1920,1080,60],[3840,2160,51]]],["nvidia geforce mx350","350",0,[[1920,1080,60]]],["nvidia geforce mx450","450",0,[[1920,1080,60]]],["nvidia geforce pre-release graphics device","pre",0,[[2560,1440,60]]],["nvidia geforce pre-release tesla c2075 opengl engine","2075",0,[[1600,900,59]]],["nvidia geforce pre-release titan x opengl engine","prex",0,[[1920,1080,60]]],["nvidia geforce pre-release titan xp collectors edition opengl e","prexpe",0,[[1920,1080,59]]],["nvidia geforce pre-release titan xp opengl engine","prexp",0,[[2560,1440,60]]],["nvidia geforce rtx 2060","2060",0,[[1920,1080,512]]],["nvidia geforce rtx 2060 max-q","2060",0,[[2560,1440,301]]],["nvidia geforce rtx 2060 mobile","2060",0,[[1920,1080,518]]],["nvidia geforce rtx 2060 rev. a","2060",0,[[3840,2160,257]]],["nvidia geforce rtx 2060 super","2060",0,[[1920,1080,645],[2560,1440,143]]],["nvidia geforce rtx 2060 with max-q design","2060",0,[[1920,1080,292],[1920,1200,60]]],["nvidia geforce rtx 2070","2070",0,[[1920,1080,60],[3840,2160,60]]],["nvidia geforce rtx 2070 mobile","2070",0,[[1920,1080,477]]],["nvidia geforce rtx 2070 mobile / max-q","2070",0,[[1920,1080,526]]],["nvidia geforce rtx 2070 mobile / max-q refresh","2070",0,[[1920,1080,143]]],["nvidia geforce rtx 2070 rev. a","2070",0,[[2560,1440,144]]],["nvidia geforce rtx 2070 super","2070",0,[[1920,1080,510]]],["nvidia geforce rtx 2070 super with max-q design","2070",0,[[1920,1080,300]]],["nvidia geforce rtx 2070 with max-q design","2070",0,[[1920,1080,240]]],["nvidia geforce rtx 2080","2080",0,[[1920,1080,632],[2560,1440,165]]],["nvidia geforce rtx 2080 mobile","2080",0,[[1920,1080,144]]],["nvidia geforce rtx 2080 rev. a","2080",0,[[2560,1440,143]]],["nvidia geforce rtx 2080 super","2080",0,[[1920,1080,601]]],["nvidia geforce rtx 2080 super mobile / max-q","2080",0,[[3840,2160,59]]],["nvidia geforce rtx 2080 super with max-q design","2080",0,[[1920,1080,300]]],["nvidia geforce rtx 2080 ti","2080",0,[[1920,1080,83]]],["nvidia geforce rtx 2080 ti rev. a","2080",0,[[1920,1080,403]]],["nvidia geforce rtx 2080 with max-q design","2080",0,[[1920,1080,476]]],["nvidia geforce rtx 3050","3050",0,[[1920,1080,60]]],["nvidia geforce rtx 3050 laptop gpu","3050",0,[[1920,1080,144]]],["nvidia geforce rtx 3050 ti laptop gpu","3050",0,[[1920,1080,144]]],["nvidia geforce rtx 3060","3060",0,[[1920,1080,674]]],["nvidia geforce rtx 3060 laptop gpu","3060",0,[[1920,1080,300]]],["nvidia geforce rtx 3060 lite hash rate","3060",0,[[1920,1080,60]]],["nvidia geforce rtx 3060 mobile / max-q","3060",0,[[1920,1080,435]]],["nvidia geforce rtx 3060 ti","3060",0,[[1920,1080,779]]],["nvidia geforce rtx 3070","3070",0,[[1920,1080,723],[2560,1440,294]]],["nvidia geforce rtx 3070 laptop gpu","3070",0,[[1920,1080,357]]],["nvidia geforce rtx 3070 mobile / max-q","3070",0,[[2560,1440,386]]],["nvidia geforce rtx 3070 ti","3070",0,[[1920,1080,60]]],["nvidia geforce rtx 3080","3080",0,[[1920,1080,726],[2560,1440,60],[3840,2160,60]]],["nvidia geforce rtx 3080 laptop gpu","3080",0,[[1920,1080,294],[2560,1440,244]]],["nvidia geforce rtx 3080 mobile / max-q 8gb/16gb","3080",0,[[1920,1080,293]]],["nvidia geforce rtx 3080 ti","3080",0,[[1920,1080,239],[2560,1440,60]]],["nvidia geforce rtx 3090","3090",0,[[2560,1440,60],[3840,2160,474]]],["nvidia geforce rtx t10-16","10",0,[[2560,1600,3]]],["nvidia geforce rtx t10-8","10",0,[[2560,1600,3]]],["nvidia gigabyte geforce gt 440","440",0,[[1280,1024,34]]],["nvidia gigabyte geforce gt 610","610",0,[[1920,1080,17]]],["nvidia gigabyte geforce gt 630","630",0,[[1920,1080,34]]],["nvidia gigabyte geforce gt 730","730",0,[[1280,1024,38]]],["nvidia gigabyte geforce gts 450","450",0,[[1280,1024,37]]],["nvidia gigabyte geforce gtx 1050 ti","1050",0,[[1920,1080,30]]],["nvidia gigabyte geforce gtx 460","460",0,[[1680,1050,60]]],["nvidia gigabyte geforce gtx 550 ti","550",0,[[1920,1080,57]]],["nvidia gigabyte geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 570 hd","570",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 580","580",0,[[1920,1200,60]]],["nvidia gigabyte geforce gtx 650","650",0,[[1680,1050,55]]],["nvidia gigabyte geforce gtx 650 ti","650",0,[[2560,1440,40]]],["nvidia gigabyte geforce gtx 660","660",0,[[1920,1080,31]]],["nvidia gigabyte geforce gtx 660 ti","660",0,[[5120,2880,29]]],["nvidia gigabyte geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 750","750",0,[[1920,1080,59]]],["nvidia gigabyte geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 760","760",0,[[3440,1440,17]]],["nvidia gigabyte geforce gtx 770","770",0,[[2560,1440,59]]],["nvidia gigabyte geforce gtx 780 ti","780",0,[[1920,1080,240]]],["nvidia gigabyte geforce gtx 960","960",0,[[1920,1080,142],[1920,1200,120]]],["nvidia gigabyte geforce gtx 970","970",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 980","980",0,[[2560,1440,60]]],["nvidia gigabyte geforce gtx 980 ti","980",0,[[1920,1080,60]]],["nvidia hp geforce gt 730","730",0,[[1920,1080,55]]],["nvidia inno3d geforce gtx660","3",0,[[2560,1440,107]]],["nvidia msi geforce gt 610","610",0,[[1920,1080,16]]],["nvidia msi geforce gt 630","630",0,[[1440,900,12]]],["nvidia msi geforce gt 635","635",0,[[1920,1080,30]]],["nvidia msi geforce gt 710","710",0,[[1920,1080,27]]],["nvidia msi geforce gt 730","730",0,[[1920,1080,53]]],["nvidia msi geforce gtx 1050 ti","1050",0,[[1920,1080,59]]],["nvidia msi geforce gtx 1060","1060",0,[[1920,1080,120]]],["nvidia msi geforce gtx 1070","1070",0,[[1920,1200,45]]],["nvidia msi geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia msi geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia msi geforce gtx 570 hd","570",0,[[1920,1200,60]]],["nvidia msi geforce gtx 580","580",0,[[2560,1440,60]]],["nvidia msi geforce gtx 650","650",0,[[2560,1080,52]]],["nvidia msi geforce gtx 650 ti","650",0,[[1920,1080,60]]],["nvidia msi geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia msi geforce gtx 660 ti","660",0,[[1680,1050,49]]],["nvidia msi geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia msi geforce gtx 745","745",0,[[1920,1080,55]]],["nvidia msi geforce gtx 760","760",0,[[1280,1024,30],[1920,1080,58]]],["nvidia msi geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia msi geforce gtx 950","950",0,[[1920,1080,59]]],["nvidia msi geforce gtx 960","960",0,[[1680,1050,120],[2560,1440,59]]],["nvidia msi geforce gtx 970","970",0,[[1680,1050,60]]],["nvidia msi geforce gtx 980","980",0,[[1920,1080,120],[3840,2160,60]]],["nvidia msi geforce gtx 980 ti","980",0,[[5120,2880,56]]],["nvidia null geforce 920a","920",0,[[1920,1080,25]]],["nvidia palit geforce gtx 650","650",0,[[1920,1080,49]]],["nvidia palit geforce gtx 650 ti","650",0,[[1920,1080,59]]],["nvidia palit geforce gtx 660","660",0,[[1920,1080,26]]],["nvidia pegatron geforce gt 420","420",0,[[1400,1050,25]]],["nvidia pny geforce gt 610","610",0,[[1280,1024,19]]],["nvidia pny geforce gtx 1060","1060",0,[[1920,1080,60]]],["nvidia pny geforce gtx 460","460",0,[[1360,768,59]]],["nvidia pny geforce gtx 550 ti","550",0,[[1920,1080,55]]],["nvidia pny geforce gtx 570 hd","570",0,[[1280,1024,72]]],["nvidia pny geforce gtx 580","580",0,[[1920,1200,59]]],["nvidia pny geforce gtx 680","680",0,[[2560,1080,120]]],["nvidia pny geforce gtx 750","750",0,[[1280,1024,60]]],["nvidia pny geforce gtx 970","970",0,[[2560,1440,60]]],["nvidia pny geforce gtx 980","980",0,[[1920,1080,120]]],["nvidia point of view geforce gtx 470","470",0,[[1920,1080,59]]],["nvidia point of view geforce gtx 660 ti","660",0,[[1680,1050,59]]],["nvidia sony geforce 410m","410",0,[[1366,768,24]]],["nvidia toshiba geforce gt 525m","525",0,[[1366,768,33]]],["nvidia zotac geforce gt 430","430",0,[[1600,900,32]]],["nvidia zotac geforce gt 610","610",0,[[1920,1080,15]]],["nvidia zotac geforce gt 630","630",0,[[1360,768,46]]],["nvidia zotac geforce gt 740","740",0,[[1280,1024,118]]],["nvidia zotac geforce gtx 460","460",0,[[1920,1080,59]]],["nvidia zotac geforce gtx 550 ti","550",0,[[1920,1080,42]]],["nvidia zotac geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 580","580",0,[[1920,1080,48]]],["nvidia zotac geforce gtx 650","650",0,[[1920,1080,44]]],["nvidia zotac geforce gtx 650 ti","650",0,[[1920,1080,58]]],["nvidia zotac geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 680","680",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 750","750",0,[[1680,1050,114],[1920,1080,60]]],["nvidia zotac geforce gtx 760","760",0,[[1920,1080,101]]],["nvidia zotac geforce gtx 770","770",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 960","960",0,[[2048,1152,60]]]]')},178:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["intel","",0,[[4096,2304,12]]],["intel 0x496e74656c2048442047726170686963000732034343","0",0,[[1920,1080,22]]],["intel broxton-p hd","p",0,[[1920,1080,73]]],["intel cherryview hd","hd",0,[[1920,1080,16]]],["intel coffee lake uhd","uhd",0,[[1920,1080,49]]],["intel cometlake uhd graphics 630","630",0,[[2560,1440,40]]],["intel corporation 2nd gen core processor family integrated graphics controller","2",0,[[1366,768,25]]],["intel corporation 2nd generation core processor family integrated graphics controller","2",0,[[1600,900,28]]],["intel corporation 3rd gen core processor graphics controller","3",0,[[1366,768,20]]],["intel corporation 8th gen core processor gaussian mixture model","8",0,[[1366,768,17]]],["intel corporation atom processor z36xxx/z37xxx series graphics & display","36",0,[[1280,799,18],[1366,768,18]]],["intel corporation atom/celeron/pentium processor n4200 series integrated graphics controller","4200",0,[[1280,1024,28]]],["intel corporation atom/celeron/pentium processor x5-e8000 integrated graphics controller","5",0,[[1366,768,34]]],["intel corporation atom/celeron/pentium processor x5-e8000 series pci configuration registers","5",0,[[1920,1080,14]]],["intel corporation broadwell-u integrated","u",0,[[1920,1080,38]]],["intel corporation celeron n3350 n4200/atom e3900 series integrated graphics controller","3350",0,[[1680,1050,33]]],["intel corporation coffeelake-h gt2 [uhd graphics 630]","2",0,[[1920,1080,76]]],["intel corporation cometlake-h gt2 [uhd graphics]","2",0,[[3072,1728,29]]],["intel corporation cometlake-s gt2 [uhd graphics 630]","2",0,[[1920,1080,52]]],["intel corporation cometlake-u gt2 [uhd graphics]","2",0,[[1920,1080,39]]],["intel corporation device","",0,[[1920,1080,31]]],["intel corporation geminilake [uhd graphics 600]","600",0,[[1920,1080,15]]],["intel corporation haswell-ult integrated graphics controller","ult",0,[[1366,768,35]]],["intel corporation hd","hd",0,[[1920,1080,24]]],["intel corporation hd graphics 500","500",0,[[1366,768,19]]],["intel corporation hd graphics 510","510",0,[[1368,768,48]]],["intel corporation hd graphics 515","515",0,[[1920,1080,29]]],["intel corporation hd graphics 520","520",0,[[1366,768,59]]],["intel corporation hd graphics 530","530",0,[[1920,1080,58]]],["intel corporation hd graphics 5300","5300",0,[[1920,1080,35]]],["intel corporation hd graphics 5500","5500",0,[[1920,1080,36]]],["intel corporation hd graphics 610","610",0,[[1920,1080,28]]],["intel corporation hd graphics 620","620",0,[[1920,1080,56],[3200,1800,17]]],["intel corporation hd graphics 630","630",0,[[1920,1080,58]]],["intel corporation iris graphics 540","540",0,[[1920,1080,54]]],["intel corporation iris graphics 6100","6100",0,[[2560,1600,20]]],["intel corporation iris plus graphics 650","650",0,[[1440,900,60]]],["intel corporation iris plus graphics 655","655",0,[[1920,1080,119]]],["intel corporation iris plus graphics g1","1",0,[[1920,1080,57]]],["intel corporation iris plus graphics g7","7",0,[[1920,1080,112]]],["intel corporation iris pro graphics 580","580",0,[[1920,1080,60]]],["intel corporation iris pro graphics 6200","6200",0,[[2560,1080,41]]],["intel corporation iris xe","xe",0,[[1920,1200,60]]],["intel corporation sky lake integrated","sky",0,[[2560,1440,52]]],["intel corporation skylake gt2 [hd graphics 520]","2",0,[[1920,1080,52],[2560,1440,31]]],["intel corporation skylake integrated","",0,[[1920,1080,51]]],["intel corporation tigerlake gt2 [iris xe graphics]","2",0,[[1920,1080,60]]],["intel corporation tigerlake-lp gt2 [iris xe graphics]","2",0,[[1920,1080,60]]],["intel corporation uhd","uhd",0,[[1920,1080,65]]],["intel corporation uhd graphics 605","605",0,[[1920,1080,21]]],["intel corporation uhd graphics 615","615",0,[[1920,1080,30]]],["intel corporation uhd graphics 620","620",0,[[1920,1080,55]]],["intel corporation uhd graphics 630","630",0,[[1920,1080,57]]],["intel corporation whiskeylake-u gt2 [uhd graphics 620]","2",0,[[1920,1080,57]]],["intel corporation xeon e3-1200 v2 gen core processor graphics controller","3",0,[[1920,1080,15]]],["intel corporation xeon e3-1200 v3 gen core processor integrated graphics controller","3",0,[[1360,768,42],[1440,900,34],[1280,1024,23],[1920,1080,22]]],["intel corporation, series chipset iris plus graphics 655","655",0,[[1920,1080,42]]],["intel geforce gtx 960","960",0,[[1920,1080,26]]],["intel gen12 desktop graphics controller","12",0,[[3840,2160,20]]],["intel graphics gfx-driver-user-feature_dg1_poweron-27723 dch releaseinternal","1",0,[[3840,2160,11]]],["intel hd","hd",0,[[1280,800,18],[1366,768,26],[1600,900,12],[1920,1080,13],[1920,1200,16],[1920,1280,18],[3000,2002,6],[4096,2160,4]]],["intel hd 4000","4000",0,[[1366,768,37]]],["intel hd 530","530",0,[[1920,1200,54]]],["intel hd graphics 3000","3000",0,[[1920,1080,21]]],["intel hd graphics 4000","4000",0,[[1280,800,41],[1366,768,33],[1440,900,31],[1680,1050,50],[1920,1080,27],[2560,1600,13],[2880,1800,12]]],["intel hd graphics 4000,,,,,,,","4000",0,[[1920,1080,19]]],["intel hd graphics 4400","4400",0,[[1366,768,28],[1280,1024,48],[1920,1080,18],[2160,1440,20]]],["intel hd graphics 4600","4600",0,[[1366,768,14],[1280,960,65],[1280,1024,60],[1600,900,33],[1680,1050,31],[1600,1200,47],[1920,1080,19],[1920,1200,22],[2880,1620,14]]],["intel hd graphics 500","500",0,[[1920,1080,15]]],["intel hd graphics 5000","5000",0,[[1366,768,45],[1440,900,42],[1920,1032,25],[1920,1080,27],[2160,1439,19],[2160,1440,23],[2560,1440,15]]],["intel hd graphics 505","505",0,[[1366,768,28],[1920,1080,16]]],["intel hd graphics 510","510",0,[[1366,768,29],[1440,900,46],[1680,1050,12],[1920,1080,27]]],["intel hd graphics 515","515",0,[[1920,1080,45],[2720,768,22],[1920,1280,41],[2160,1440,28],[2560,1600,16],[2736,1824,19],[3200,1800,12],[3840,2160,10]]],["intel hd graphics 520","520",0,[[1366,768,90],[1920,1080,30],[2736,1824,26],[3000,2000,21]]],["intel hd graphics 530","530",0,[[1366,768,21],[1280,1024,65],[1920,1080,47],[1920,1200,39],[3840,2160,6]]],["intel hd graphics 5300","5300",0,[[1920,1080,21],[2304,1440,19],[2560,1600,13]]],["intel hd graphics 5500","5500",0,[[1366,768,37],[1920,1080,21]]],["intel hd graphics 5600","5600",0,[[1920,1080,26],[1920,1200,40],[2880,1620,21]]],["intel hd graphics 6000","6000",0,[[1366,768,43],[1440,900,40],[1920,1080,21]]],["intel hd graphics 610","610",0,[[1366,768,33],[1600,900,42],[1920,1080,27],[3840,2160,8]]],["intel hd graphics 615","615",0,[[1600,900,13],[1920,1080,18],[1800,1200,29],[1920,1200,34],[2560,1440,25],[2560,1600,21],[2736,1824,21]]],["intel hd graphics 620","620",0,[[1920,1080,37],[2736,1824,27],[3200,1800,25],[3840,2160,13]]],["intel hd graphics 630","630",0,[[1366,768,69],[1920,1080,40],[2560,1440,27],[2560,1600,23],[3360,2100,56],[3840,2160,12]]],["intel hd graphics 630 gt2","630",0,[[1920,1080,39],[1720,1440,120]]],["intel hd graphics cfl crb","hdcfl",0,[[2560,1440,38]]],["intel hd graphics family","hd",0,[[1366,768,44]]],["intel hd graphics icl rvp","hdicl",0,[[1920,1080,58]]],["intel hd graphics icl rvp bigsur","hdicl",0,[[1920,1080,57]]],["intel hd graphics kbl crb","hdkbl",0,[[1920,1080,57],[3840,2160,13]]],["intel hd graphics p4600","4600",0,[[1280,1024,57],[1920,1080,18],[2560,1600,60]]],["intel hd graphics p530","530",0,[[2560,1440,36],[3840,2160,12]]],["intel hd graphics p630","630",0,[[1440,900,35],[1920,1200,50]]],["intel hd graphics, gen10","10",0,[[3840,2160,4]]],["intel hd5500 broadwell pg7","5500",0,[[1366,768,31]]],["intel hd5500 graphics pg7","5500",0,[[1366,768,56]]],["intel iris","",0,[[1366,768,57],[1600,900,34],[1920,1080,34],[2560,1600,17],[2880,1800,14]]],["intel iris graphics 5100","5100",0,[[1920,1080,35],[2560,1600,18]]],["intel iris graphics 540","540",0,[[1920,1080,20],[2736,1824,28],[2880,1800,23],[3200,1800,17],[3840,2160,17]]],["intel iris graphics 550","550",0,[[1920,1080,81],[2160,1440,45],[2560,1600,28],[2880,1800,26],[3840,2160,24]]],["intel iris graphics 6100","6100",0,[[1920,1080,26],[2560,1600,19],[3840,2160,10]]],["intel iris graphics 6200","6200",0,[[4096,2304,13]]],["intel iris graphics 640","640",0,[[2256,1504,24],[3840,2160,9]]],["intel iris graphics 650","650",0,[[2560,1440,24]]],["intel iris graphics p580","580",0,[[3840,2160,12]]],["intel iris plus","",0,[[1920,1080,60],[2256,1504,95],[2496,1664,93],[2736,1824,60],[2880,1800,60],[3000,2000,56]]],["intel iris plus graphics 640","640",0,[[1920,1080,87],[2256,1504,46],[2560,1600,44],[2735,1823,28],[2736,1824,28],[2880,1800,26],[3072,1728,25],[3200,1800,37],[3840,2160,16]]],["intel iris plus graphics 645","645",0,[[2560,1599,32],[2560,1600,56],[2880,1800,47]]],["intel iris plus graphics 650","650",0,[[1920,1080,60],[2560,1600,49],[2880,1800,27],[3840,2160,16]]],["intel iris plus graphics 655","655",0,[[1920,1080,58],[2560,1440,85],[2880,1800,32],[3840,2160,24]]],["intel iris pro","pro",0,[[1920,1080,56]]],["intel iris pro graphics 5200","5200",0,[[1920,1080,53],[2879,1800,24],[2880,1800,21]]],["intel iris pro graphics 580","580",0,[[1920,1080,58],[2560,1080,91],[2560,1440,58],[3840,1600,27]]],["intel iris pro graphics 6200","6200",0,[[1366,696,38],[1920,1080,58],[1920,1200,60],[3840,2160,19],[4096,2304,14]]],["intel iris pro graphics p580","580",0,[[1024,768,42],[1920,1080,103],[3840,2160,27]]],["intel iris pro graphics p6300","6300",0,[[1366,768,102],[1440,900,128],[1920,1080,30]]],["intel iris xe","xe",0,[[1920,1080,88]]],["intel iris xe graphics releaseinternal","xe",0,[[3840,2160,38]]],["intel iris xe max","xe",0,[[1920,1080,60],[3840,2160,56]]],["intel kabylake hd graphics ult gt2","2",0,[[3840,2160,11]]],["intel kabylake hd graphics ulx gt2","2",0,[[1920,1080,28],[3840,2160,6]]],["intel kbl unknown","kbl",0,[[1920,1080,54]]],["intel mesa dri intel bay trail","dribay",0,[[1366,768,14]]],["intel mesa dri intel haswell mobile","dri",0,[[1920,1080,27]]],["intel mesa dri intel hd","drihd",0,[[1920,1080,10]]],["intel mesa dri intel hd graphics 400","400",0,[[1366,768,30]]],["intel mesa dri intel hd graphics 505","505",0,[[1920,1080,27]]],["intel mesa dri intel hd graphics 520","520",0,[[1920,1080,45],[2560,1440,24]]],["intel mesa dri intel hd graphics 530","530",0,[[3840,2160,12]]],["intel mesa dri intel hd graphics 5500","5500",0,[[1366,768,40]]],["intel mesa dri intel hd graphics 620","620",0,[[1920,1080,53]]],["intel mesa dri intel hd graphics 630","630",0,[[1477,831,58]]],["intel mesa dri intel hd graphics p4000","4000",0,[[1920,1080,36]]],["intel mesa dri intel iris graphics 540","540",0,[[1280,720,40]]],["intel mesa dri intel ivybridge desktop","dri",0,[[2560,1080,16]]],["intel mesa dri intel ivybridge mobile","dri",0,[[1920,1080,25]]],["intel mesa dri intel kabylake gt2","2",0,[[1920,1080,36]]],["intel mesa dri intel sandybridge desktop","dri",0,[[1280,1024,12]]],["intel mesa dri intel sandybridge mobile","dri",0,[[1366,768,33]]],["intel mesa dri intel uhd graphics 620","620",0,[[2736,1824,22]]],["intel mesa dri intel uhd graphics 630","630",0,[[1920,1080,42]]],["intel mesa intel hd graphics 520","520",0,[[1920,1080,47]]],["intel mesa intel hd graphics 530","530",0,[[1920,1080,55]]],["intel phdgd ivy 4","4",0,[[1366,768,45]]],["intel radeon pro vega 16","16",0,[[3360,1890,20]]],["intel radeong 0.4 on amd bonaire","0",0,[[1920,1200,92]]],["intel radeong 0.4 on amd cape verde","0",0,[[1920,1200,73]]],["intel radeong 0.4 on amd polaris10","0",0,[[3840,2160,108]]],["intel radeong 0.4 on amd tonga","0",0,[[1920,1080,124]]],["intel skl unknown","skl",0,[[1920,1080,43]]],["intel skylake gt2 [hd graphics 520]","2",0,[[1920,1080,39]]],["intel uhd","uhd",0,[[1920,1080,58],[2560,1600,22],[3440,1440,14],[2736,1824,32],[3840,2160,31]]],["intel uhd 630","630",0,[[2560,1440,38]]],["intel uhd graphics 600","600",0,[[1366,768,27],[1920,1080,13],[1920,1200,13],[2560,1440,11],[3840,2160,5]]],["intel uhd graphics 600 universal","600",0,[[1919,1031,15]]],["intel uhd graphics 605","605",0,[[1366,768,29],[1920,1080,37]]],["intel uhd graphics 610","610",0,[[1366,768,58],[1920,1080,32],[1920,1200,37],[2560,1440,17],[3840,2160,11]]],["intel uhd graphics 615","615",0,[[1920,1080,34],[1920,1280,29],[3840,2160,9]]],["intel uhd graphics 617","617",0,[[1920,1080,43],[2560,1599,24],[2560,1600,26],[2880,1800,24]]],["intel uhd graphics 620","620",0,[[1920,1080,50],[2736,1824,33],[3200,1800,16]]],["intel uhd graphics 630","630",0,[[1440,900,112],[1920,1080,44],[1920,1200,65],[2560,1080,68],[2560,1440,26],[3440,1440,25],[3584,2240,137],[3840,2160,12],[6016,3384,8]]],["intel uhd graphics 730","730",0,[[1920,1080,53]]],["intel uhd graphics 750","750",0,[[1920,1080,56],[3840,2160,36]]],["intel uhd graphics 770","770",0,[[3440,1440,78],[5120,1440,31]]],["intel uhd graphics gfx-driver-user-comp_core-23599","23599",0,[[3840,2160,18]]],["intel uhd graphics p630","630",0,[[1920,1080,54],[3840,2160,21]]],["intel uhd graphics releaseinternal","uhd",0,[[3199,1800,22],[3000,2000,47]]],["intel uhd graphics, gen11 lp","11",0,[[3840,2160,10]]],["intel uhd graphics, gen12 lp releaseinternal","12",0,[[3839,2159,4]]],["intel uhd graphics, lkf","uhdlkf",0,[[1927,1439,14]]],["intel unknown","",0,[[1920,1080,37]]],["intel xe","xe",0,[[1920,1080,268],[2560,1440,137]]],["intel xeon e3-1200 v3 gen core processor integrated graphics controller","3",0,[[1600,900,49]]]]')},217:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["nvidia %nvidia_dev.13d7.0580.1028%","13",0,[[1920,1018,60]]],["nvidia a100-pcie-40gb","100",0,[[1920,1080,449]]],["nvidia a40","40",0,[[1920,1080,504]]],["nvidia a40-8q","40",0,[[2560,1440,58]]],["nvidia ashley","",0,[[1920,1080,60]]],["nvidia asus geforce gt 430","430",0,[[1366,768,35]]],["nvidia asus geforce gt 440","440",0,[[1920,1080,28]]],["nvidia asus geforce gt 520","520",0,[[1680,1050,12]]],["nvidia asus geforce gt 610","610",0,[[1920,1200,15]]],["nvidia asus geforce gt 630","630",0,[[1680,1050,41]]],["nvidia asus geforce gt 640","640",0,[[2560,1440,34]]],["nvidia asus geforce gt 710","710",0,[[1920,1080,31]]],["nvidia asus geforce gt 730","730",0,[[2560,1080,28],[3840,2160,12]]],["nvidia asus geforce gts 450","450",0,[[1920,1080,54]]],["nvidia asus geforce gtx 1060","1060",0,[[3840,2160,38]]],["nvidia asus geforce gtx 1080","1080",0,[[2560,1440,120]]],["nvidia asus geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia asus geforce gtx 480","480",0,[[1920,1080,59]]],["nvidia asus geforce gtx 550 ti","550",0,[[1920,1080,57]]],["nvidia asus geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia asus geforce gtx 560 se","560",0,[[1920,1080,59]]],["nvidia asus geforce gtx 560 ti","560",0,[[1680,1050,58]]],["nvidia asus geforce gtx 570","570",0,[[1280,1024,74]]],["nvidia asus geforce gtx 570 hd","570",0,[[1920,1080,60]]],["nvidia asus geforce gtx 580","580",0,[[1920,1200,59]]],["nvidia asus geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia asus geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia asus geforce gtx 750 ti","750",0,[[1360,768,59],[1920,1080,118]]],["nvidia asus geforce gtx 760","760",0,[[1920,1080,60],[1920,1200,60]]],["nvidia asus geforce gtx 770","770",0,[[1920,1080,60]]],["nvidia asus geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia asus geforce gtx 950","950",0,[[1920,1080,60]]],["nvidia asus geforce gtx 960","960",0,[[1920,1080,60],[2560,1600,117]]],["nvidia asus geforce gtx 970","970",0,[[2560,1600,60]]],["nvidia asus geforce gtx 980 ti","980",0,[[2560,1440,131]]],["nvidia chip model","",0,[[1920,1080,60]]],["nvidia colorful geforce gtx 960","960",0,[[2560,1440,60]]],["nvidia dell nvs 5200m","5200",0,[[1920,1080,27]]],["nvidia dell quadro 2000m","2000",0,[[1920,1080,29]]],["nvidia device","",0,[[1920,1080,746]]],["nvidia elitegroup geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia evga geforce gt 545","545",0,[[1920,1080,37]]],["nvidia evga geforce gt 640","640",0,[[1366,768,60]]],["nvidia evga geforce gt 710","710",0,[[1680,1050,36],[1920,1080,29]]],["nvidia evga geforce gt 730","730",0,[[1600,900,59]]],["nvidia evga geforce gt 740","740",0,[[1280,1024,45]]],["nvidia evga geforce gtx 1050 ti","1050",0,[[2560,1440,60],[4096,2304,58]]],["nvidia evga geforce gtx 1070","1070",0,[[5120,2880,60]]],["nvidia evga geforce gtx 1080 ti","1080",0,[[1920,1200,60]]],["nvidia evga geforce gtx 560 ti","560",0,[[1680,1050,59]]],["nvidia evga geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia evga geforce gtx 580","580",0,[[2560,1440,60]]],["nvidia evga geforce gtx 650","650",0,[[1920,1200,87],[2560,1600,43]]],["nvidia evga geforce gtx 650 ti","650",0,[[1680,1050,116],[2560,1440,55]]],["nvidia evga geforce gtx 650 ti boost","650",0,[[1920,1080,56]]],["nvidia evga geforce gtx 660 ti","660",0,[[1920,1200,60]]],["nvidia evga geforce gtx 680","680",0,[[1600,1200,60]]],["nvidia evga geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia evga geforce gtx 760","760",0,[[1920,1080,119],[1920,1200,60]]],["nvidia evga geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia evga geforce gtx 960","960",0,[[1920,1080,60],[2560,1440,115]]],["nvidia evga geforce gtx 970","970",0,[[1920,1080,120]]],["nvidia evga geforce gtx 980","980",0,[[3440,1440,60]]],["nvidia evga geforce gtx 980 ti","980",0,[[1920,1080,60]]],["nvidia ga104gl [rtx a4000]","104",0,[[3840,2160,60]]],["nvidia gainward geforce gt 630","630",0,[[1920,1080,28]]],["nvidia gainward geforce gts 450","450",0,[[1920,1080,55]]],["nvidia gainward geforce gtx 460","460",0,[[1920,1080,58]]],["nvidia gainward geforce gtx 550 ti","550",0,[[1280,1024,67]]],["nvidia gainward geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia gainward geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia gainward geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia geforce 210","210",0,[[1920,1080,8]]],["nvidia geforce 410m","410",0,[[1366,768,25],[1600,900,19]]],["nvidia geforce 510","510",0,[[1280,960,20]]],["nvidia geforce 605","605",0,[[1768,992,17],[1920,1080,15]]],["nvidia geforce 610m","610",0,[[1366,768,26]]],["nvidia geforce 610m/710m/810m/820m / gt 620m/625m/630m/720m","610",0,[[1366,768,51]]],["nvidia geforce 615","615",0,[[1920,1080,21]]],["nvidia geforce 705m","705",0,[[1920,1080,18]]],["nvidia geforce 710a","710",0,[[1920,1080,32]]],["nvidia geforce 710m","710",0,[[1366,768,55]]],["nvidia geforce 730a","730",0,[[1920,1080,37]]],["nvidia geforce 800m","800",0,[[1920,1080,18]]],["nvidia geforce 810m","810",0,[[1366,768,44],[1920,1080,31]]],["nvidia geforce 820a","820",0,[[1920,1080,28]]],["nvidia geforce 820m","820",0,[[1366,768,57],[1920,1080,23]]],["nvidia geforce 830a","830",0,[[1920,1080,53]]],["nvidia geforce 830m","830",0,[[1366,768,60]]],["nvidia geforce 8400 gs","8400",0,[[1680,1050,4]]],["nvidia geforce 8400 gs rev. 3","8400",0,[[1920,1080,4]]],["nvidia geforce 840a","840",0,[[1920,1080,56]]],["nvidia geforce 840m","840",0,[[1920,1080,56]]],["nvidia geforce 845m","845",0,[[1920,1080,59]]],["nvidia geforce 8600 gt","8600",1,[[1920,1200,-1]]],["nvidia geforce 8600 gts","8600",1,[[1920,1080,-1]]],["nvidia geforce 910m","910",0,[[1366,768,58],[1600,900,45]]],["nvidia geforce 920m","920",0,[[1366,768,60]]],["nvidia geforce 920mx","920",0,[[1366,768,60],[1920,1080,60]]],["nvidia geforce 9300 / nforce 730i","9300",0,[[1920,1080,6]]],["nvidia geforce 930a","930",0,[[1920,1080,55]]],["nvidia geforce 930m","930",0,[[1366,768,60]]],["nvidia geforce 930mx","930",0,[[1366,768,89],[1920,1080,59]]],["nvidia geforce 9400 gt","9400",1,[[1366,768,-1]]],["nvidia geforce 940a","940",0,[[1920,1080,58]]],["nvidia geforce 940m","940",0,[[1920,1080,54]]],["nvidia geforce 940mx","940",0,[[1920,1080,60]]],["nvidia geforce 945m","945",0,[[1920,1080,59]]],["nvidia geforce 9600 gt","9600",0,[[1920,1200,2]]],["nvidia geforce 9600m gt","9600",1,[[1440,900,-1]]],["nvidia geforce 9800 gt","9800",0,[[1920,1200,52]]],["nvidia geforce 9800 gtx / 9800 gtx+","9800",0,[[1280,1024,59]]],["nvidia geforce gpu","gpu",0,[[3000,2000,36]]],["nvidia geforce gt 1010","1010",0,[[1920,1080,135]]],["nvidia geforce gt 1030","1030",0,[[1920,1080,60]]],["nvidia geforce gt 1030 opengl engine","1030",0,[[6720,3780,15]]],["nvidia geforce gt 120","120",1,[[1920,1080,-1]]],["nvidia geforce gt 240","240",0,[[1366,768,32]]],["nvidia geforce gt 320m","320",0,[[1366,768,26]]],["nvidia geforce gt 415m","415",0,[[1366,768,19]]],["nvidia geforce gt 420","420",0,[[1024,768,33],[1920,1080,20]]],["nvidia geforce gt 420m","420",0,[[1366,768,28]]],["nvidia geforce gt 425m","425",0,[[1366,768,55],[1600,900,28]]],["nvidia geforce gt 430","430",0,[[1600,1200,16],[1920,1080,28]]],["nvidia geforce gt 435m","435",0,[[1366,768,53],[1920,1080,22]]],["nvidia geforce gt 440","440",0,[[1280,1024,51],[1680,1050,38],[1920,1080,45]]],["nvidia geforce gt 445m","445",0,[[1600,900,53]]],["nvidia geforce gt 520","520",0,[[1440,900,19],[1920,1080,17]]],["nvidia geforce gt 520m","520",0,[[1366,768,29]]],["nvidia geforce gt 520mx","520",0,[[1366,768,35]]],["nvidia geforce gt 525m","525",0,[[1366,768,28],[1600,900,22]]],["nvidia geforce gt 530","530",0,[[1920,1080,26]]],["nvidia geforce gt 540m","540",0,[[1366,768,38]]],["nvidia geforce gt 545","545",0,[[1920,1080,54]]],["nvidia geforce gt 550m","550",0,[[1600,900,44],[1920,1080,29]]],["nvidia geforce gt 555m","555",0,[[1920,1080,42]]],["nvidia geforce gt 555m/635m","555",0,[[1920,1080,36]]],["nvidia geforce gt 610","610",0,[[1280,1024,22],[1920,1080,15]]],["nvidia geforce gt 620","620",0,[[1920,1080,19]]],["nvidia geforce gt 620 oem","620",0,[[1920,1080,20],[1920,1200,20]]],["nvidia geforce gt 620m","620",0,[[1366,768,55],[1920,1080,30]]],["nvidia geforce gt 620m/630m/635m/640m le","620",0,[[1368,768,38]]],["nvidia geforce gt 625","625",0,[[1920,1080,18]]],["nvidia geforce gt 625m","625",0,[[1366,768,38]]],["nvidia geforce gt 630","630",0,[[1680,1050,36],[1920,1080,36],[1920,1200,30]]],["nvidia geforce gt 630 oem","630",0,[[1600,900,33]]],["nvidia geforce gt 630 opengl engine","630",0,[[1920,1080,33]]],["nvidia geforce gt 630 rev. 2","630",0,[[1920,1080,26]]],["nvidia geforce gt 630m","630",0,[[1366,768,57]]],["nvidia geforce gt 635","635",0,[[1920,1080,27]]],["nvidia geforce gt 635m","635",0,[[1366,768,47]]],["nvidia geforce gt 640","640",0,[[1920,1080,47]]],["nvidia geforce gt 640 oem","640",0,[[1920,1080,46],[2560,1440,35]]],["nvidia geforce gt 640 opengl engine","640",0,[[1280,1024,43]]],["nvidia geforce gt 640 rev. 2","640",0,[[1280,1024,60],[1920,1080,55]]],["nvidia geforce gt 640m","640",0,[[1366,768,82],[1600,900,59],[1920,1080,34]]],["nvidia geforce gt 640m le","640",0,[[1920,1080,49]]],["nvidia geforce gt 640m mac","640",0,[[1366,768,56],[1920,1080,20]]],["nvidia geforce gt 640m opengl engine","640",0,[[1920,1080,45]]],["nvidia geforce gt 645m","645",0,[[1366,768,60]]],["nvidia geforce gt 650m","650",0,[[1360,768,59],[1920,1080,58],[2560,1440,59]]],["nvidia geforce gt 650m mac","650",0,[[1440,900,56],[1920,1080,15],[2560,1440,19],[2880,1800,31]]],["nvidia geforce gt 650m opengl engine","650",0,[[1920,1080,56],[3840,2160,27]]],["nvidia geforce gt 705","705",0,[[1920,1080,11]]],["nvidia geforce gt 710","710",0,[[1920,1080,28]]],["nvidia geforce gt 710b","710",0,[[1920,1080,26]]],["nvidia geforce gt 710m","710",0,[[1366,768,46]]],["nvidia geforce gt 720","720",0,[[1920,1080,19],[2560,1440,16],[5120,2880,5]]],["nvidia geforce gt 720 opengl engine","720",0,[[2560,1600,20]]],["nvidia geforce gt 720m","720",0,[[1366,768,42]]],["nvidia geforce gt 730","730",0,[[1920,1080,54]]],["nvidia geforce gt 730a","730",0,[[1920,1080,23]]],["nvidia geforce gt 730m","730",0,[[1920,1080,43]]],["nvidia geforce gt 735m","735",0,[[1920,1080,39]]],["nvidia geforce gt 740","740",0,[[1920,1080,55],[3440,1440,23]]],["nvidia geforce gt 740 opengl engine","740",0,[[1920,1200,51]]],["nvidia geforce gt 740m","740",0,[[1366,768,60]]],["nvidia geforce gt 745m","745",0,[[1920,1080,55]]],["nvidia geforce gt 750m","750",0,[[1920,1080,57]]],["nvidia geforce gt 750m mac","750",0,[[1920,1080,58],[2880,1800,28]]],["nvidia geforce gt 755m","755",0,[[1920,1080,57]]],["nvidia geforce gt 755m mac","755",0,[[2560,1440,41]]],["nvidia geforce gt 755m opengl engine","755",0,[[2560,1440,51]]],["nvidia geforce gt 820m","820",0,[[1600,900,47]]],["nvidia geforce gts 250","250",0,[[1680,1050,53]]],["nvidia geforce gts 450","450",0,[[1360,768,60],[1680,1050,57],[1920,1080,55]]],["nvidia geforce gts 450 rev. 2","450",0,[[1920,1080,56]]],["nvidia geforce gtx 1050","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 3gb","1050",0,[[1280,1024,60]]],["nvidia geforce gtx 1050 mobile","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 opengl engine","1050",0,[[1920,1080,116]]],["nvidia geforce gtx 1050 ti","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 ti mobile","1050",0,[[1920,1080,298]]],["nvidia geforce gtx 1050 ti opengl engine","1050",0,[[1920,1080,60]]],["nvidia geforce gtx 1050 ti with max-q design","1050",0,[[1920,1080,268],[2560,1440,102],[3840,2160,60]]],["nvidia geforce gtx 1050 with max-q design","1050",0,[[1920,1080,60],[3840,2160,24]]],["nvidia geforce gtx 1060","1060",0,[[1920,1080,60],[3840,2160,59]]],["nvidia geforce gtx 1060 3gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 3gb opengl engine","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 5gb","1060",0,[[1920,1080,55]]],["nvidia geforce gtx 1060 6gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060 6gb opengl engine","1060",0,[[1920,1080,75]]],["nvidia geforce gtx 1060 mobile","1060",0,[[1920,1080,422]]],["nvidia geforce gtx 1060 mobile 6gb","1060",0,[[1920,1080,120]]],["nvidia geforce gtx 1060 with max-q design","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1060se 3gb","1060",0,[[1920,1080,60]]],["nvidia geforce gtx 1070","1070",0,[[1920,1080,134]]],["nvidia geforce gtx 1070 a17","1070",0,[[1920,1080,60]]],["nvidia geforce gtx 1070 mobile","1070",0,[[1920,1080,467]]],["nvidia geforce gtx 1070 opengl engine","1070",0,[[1920,1080,143]]],["nvidia geforce gtx 1070 ti","1070",0,[[1920,1080,60],[6016,3384,59]]],["nvidia geforce gtx 1070 ti opengl engine","1070",0,[[1920,1080,75]]],["nvidia geforce gtx 1070 with max-q design","1070",0,[[1920,1080,448]]],["nvidia geforce gtx 1070 with maxq design","1070",0,[[1920,1080,60],[3840,2160,59]]],["nvidia geforce gtx 1080","1080",0,[[1920,1080,119],[2560,1440,326],[3840,2160,286]]],["nvidia geforce gtx 1080 mobile","1080",0,[[1920,1080,120]]],["nvidia geforce gtx 1080 opengl engine","1080",0,[[1920,1080,79]]],["nvidia geforce gtx 1080 ti","1080",0,[[1920,1080,120]]],["nvidia geforce gtx 1080 ti opengl engine","1080",0,[[1920,1080,127]]],["nvidia geforce gtx 1080 with max-q design","1080",0,[[1920,1080,144]]],["nvidia geforce gtx 1180","1180",0,[[3440,1440,60]]],["nvidia geforce gtx 1650","1650",0,[[1920,1080,380]]],["nvidia geforce gtx 1650 mobile / max-q","1650",0,[[1920,1080,292]]],["nvidia geforce gtx 1650 super","1650",0,[[1920,1080,433]]],["nvidia geforce gtx 1650 ti","1650",0,[[1920,1080,144],[3840,2400,59]]],["nvidia geforce gtx 1650 ti mobile","1650",0,[[1920,1080,144]]],["nvidia geforce gtx 1650 ti with max-q design","1650",0,[[1920,1080,60],[3839,2160,60]]],["nvidia geforce gtx 1650 with max-q design","1650",0,[[1920,1080,142],[3000,2000,60]]],["nvidia geforce gtx 1660","1660",0,[[1920,1080,144]]],["nvidia geforce gtx 1660 super","1660",0,[[1920,1080,60]]],["nvidia geforce gtx 1660 ti","1660",0,[[1920,1080,546],[3840,2160,60]]],["nvidia geforce gtx 1660 ti mobile","1660",0,[[1920,1080,451]]],["nvidia geforce gtx 1660 ti with max-q design","1660",0,[[1920,1080,144]]],["nvidia geforce gtx 280","280",0,[[1680,1050,56]]],["nvidia geforce gtx 295","295",0,[[1920,1080,56]]],["nvidia geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia geforce gtx 460 oem","460",0,[[1360,768,60],[1920,1080,60]]],["nvidia geforce gtx 460 opengl engine","460",0,[[1920,1080,59]]],["nvidia geforce gtx 460 se","460",0,[[1920,1080,56],[1920,1200,57]]],["nvidia geforce gtx 460 v2","460",0,[[1920,1080,60],[1920,1200,60],[2560,1600,55]]],["nvidia geforce gtx 460m","460",0,[[1920,1080,46]]],["nvidia geforce gtx 465","465",0,[[1920,1080,134],[1920,1200,59]]],["nvidia geforce gtx 470","470",0,[[1680,1050,60],[1920,1080,59]]],["nvidia geforce gtx 470m","470",0,[[1920,1200,55]]],["nvidia geforce gtx 480","480",0,[[1440,900,191],[1920,1080,115],[1920,1200,60]]],["nvidia geforce gtx 480 opengl engine","480",0,[[1600,1200,60]]],["nvidia geforce gtx 550 ti","550",0,[[1280,1024,58],[1920,1080,58]]],["nvidia geforce gtx 550 ti opengl engine","550",0,[[1920,1080,55]]],["nvidia geforce gtx 555","555",0,[[1920,1080,54]]],["nvidia geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia geforce gtx 560 se","560",0,[[1680,1050,52],[1920,1080,111]]],["nvidia geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia geforce gtx 560 ti 448 cores","560",0,[[1920,1080,60],[2560,1440,60]]],["nvidia geforce gtx 560 ti oem","560",0,[[1920,1080,176]]],["nvidia geforce gtx 560 ti opengl engine","560",0,[[1920,1080,48]]],["nvidia geforce gtx 560m","560",0,[[1920,1080,55]]],["nvidia geforce gtx 570","570",0,[[1920,1080,60]]],["nvidia geforce gtx 570 opengl engine","570",0,[[1920,1080,60]]],["nvidia geforce gtx 570 rev. 2","570",0,[[1920,1080,60],[1920,1200,60]]],["nvidia geforce gtx 570m","570",0,[[1920,1080,125],[2560,1440,8]]],["nvidia geforce gtx 580","580",0,[[1920,1080,60]]],["nvidia geforce gtx 580 opengl engine","580",0,[[1680,1050,59]]],["nvidia geforce gtx 580m","580",0,[[1920,1080,60]]],["nvidia geforce gtx 590","590",0,[[1920,1080,59]]],["nvidia geforce gtx 645","645",0,[[1920,1080,57],[1920,1200,58]]],["nvidia geforce gtx 645 opengl engine","645",0,[[1920,1200,58]]],["nvidia geforce gtx 650","650",0,[[1920,1080,72]]],["nvidia geforce gtx 650 oem","650",0,[[1366,768,59]]],["nvidia geforce gtx 650 opengl engine","650",0,[[1920,1080,59]]],["nvidia geforce gtx 650 ti","650",0,[[1920,1080,60]]],["nvidia geforce gtx 650 ti boost","650",0,[[1280,1024,60],[1600,1200,187],[1920,1080,60]]],["nvidia geforce gtx 650 ti opengl engine","650",0,[[1920,1080,60]]],["nvidia geforce gtx 660","660",0,[[1920,1080,111]]],["nvidia geforce gtx 660 oem","660",0,[[1920,1080,59]]],["nvidia geforce gtx 660 ti","660",0,[[1920,1080,60]]],["nvidia geforce gtx 660 ti opengl engine","660",0,[[1280,1024,60]]],["nvidia geforce gtx 660m","660",0,[[1680,1050,36],[1920,1080,59]]],["nvidia geforce gtx 660m mac","660",0,[[2560,1440,2]]],["nvidia geforce gtx 660m opengl engine","660",0,[[2560,1440,36]]],["nvidia geforce gtx 670","670",0,[[1920,1080,100]]],["nvidia geforce gtx 670 opengl engine","670",0,[[1920,1080,60]]],["nvidia geforce gtx 670m","670",0,[[1920,1080,66]]],["nvidia geforce gtx 670mx","670",0,[[1920,1080,60]]],["nvidia geforce gtx 675m","675",0,[[1920,1080,60]]],["nvidia geforce gtx 675mx","675",0,[[1680,1050,60],[1920,1080,60],[2560,1440,55]]],["nvidia geforce gtx 675mx mac","675",0,[[2560,1440,36]]],["nvidia geforce gtx 675mx opengl engine","675",0,[[2560,1440,60]]],["nvidia geforce gtx 680","680",0,[[1920,1080,60]]],["nvidia geforce gtx 680 opengl engine","680",0,[[1920,1080,60]]],["nvidia geforce gtx 680m","680",0,[[1920,1080,39],[1920,1200,60]]],["nvidia geforce gtx 680m opengl engine","680",0,[[1920,1080,36]]],["nvidia geforce gtx 680mx","680",0,[[2560,1440,59]]],["nvidia geforce gtx 680mx opengl engine","680",0,[[2560,1440,59]]],["nvidia geforce gtx 690","690",0,[[1920,1080,60],[3840,2160,30]]],["nvidia geforce gtx 745","745",0,[[1920,1080,60],[2560,1600,29]]],["nvidia geforce gtx 750","750",0,[[1920,1080,60]]],["nvidia geforce gtx 750 opengl engine","750",0,[[1920,1200,58]]],["nvidia geforce gtx 750 ti","750",0,[[1920,1080,97]]],["nvidia geforce gtx 760","760",0,[[1920,1080,60],[1920,1200,116]]],["nvidia geforce gtx 760 oem","760",0,[[1920,1080,60]]],["nvidia geforce gtx 760 opengl engine","760",0,[[1920,1080,52]]],["nvidia geforce gtx 760 ti","760",0,[[1920,1080,60],[1920,1200,60]]],["nvidia geforce gtx 760 ti oem","760",0,[[1920,1200,60]]],["nvidia geforce gtx 760 ti opengl engine","760",0,[[1920,1080,60]]],["nvidia geforce gtx 760a","760",0,[[2560,1080,15]]],["nvidia geforce gtx 760m","760",0,[[1920,1080,60]]],["nvidia geforce gtx 765m","765",0,[[1920,1080,53],[2560,1440,57]]],["nvidia geforce gtx 765m by nick[d]vb","765",0,[[2560,1440,58]]],["nvidia geforce gtx 765m opengl engine","765",0,[[2560,1440,57]]],["nvidia geforce gtx 770","770",0,[[1920,1080,143],[2560,1440,203]]],["nvidia geforce gtx 770 opengl engine","770",0,[[1920,1080,60]]],["nvidia geforce gtx 770m","770",0,[[1920,1080,60],[2560,1440,59]]],["nvidia geforce gtx 770m by nick[d]vb","770",0,[[2560,1440,34]]],["nvidia geforce gtx 770m opengl engine","770",0,[[2560,1440,59]]],["nvidia geforce gtx 775m by idopt mac","775",0,[[2560,1440,56]]],["nvidia geforce gtx 775m mac","775",0,[[2560,1440,59]]],["nvidia geforce gtx 775m opengl engine","775",0,[[2560,1440,60]]],["nvidia geforce gtx 780","780",0,[[1920,1080,159]]],["nvidia geforce gtx 780 by st3phl3","780",0,[[3840,2160,30]]],["nvidia geforce gtx 780 mac","780",0,[[1680,1050,60],[1920,1080,60]]],["nvidia geforce gtx 780 rev. 2","780",0,[[1920,1080,144],[2560,1440,119],[3840,2160,58],[5120,2880,58]]],["nvidia geforce gtx 780 ti","780",0,[[1280,1024,120],[1920,1080,119]]],["nvidia geforce gtx 780 ti opengl engine","780",0,[[2560,1440,60]]],["nvidia geforce gtx 780m","780",0,[[1920,1080,60],[2560,1440,59]]],["nvidia geforce gtx 780m by nick[d]vb","780",0,[[1920,1080,59],[2560,1440,60]]],["nvidia geforce gtx 780m mac","780",0,[[2560,1440,60]]],["nvidia geforce gtx 780m opengl engine","780",0,[[2560,1440,60]]],["nvidia geforce gtx 850a","850",0,[[2560,1440,48]]],["nvidia geforce gtx 850m","850",0,[[1920,1080,60]]],["nvidia geforce gtx 860m","860",0,[[1920,1080,59]]],["nvidia geforce gtx 860m opengl engine","860",0,[[2560,1440,58]]],["nvidia geforce gtx 870m","870",0,[[1920,1080,60],[2560,1440,102]]],["nvidia geforce gtx 880m","880",0,[[1920,1080,60],[2560,1440,74]]],["nvidia geforce gtx 880m opengl engine","880",0,[[2560,1440,60]]],["nvidia geforce gtx 950","950",0,[[1920,1080,98]]],["nvidia geforce gtx 950 opengl engine","950",0,[[1920,1200,60]]],["nvidia geforce gtx 950a","950",0,[[1920,1080,60],[3840,2160,38]]],["nvidia geforce gtx 950m","950",0,[[1920,1080,114]]],["nvidia geforce gtx 960","960",0,[[1920,1080,60]]],["nvidia geforce gtx 960a","960",0,[[1920,1440,128]]],["nvidia geforce gtx 960m","960",0,[[1920,1080,119],[3840,2160,37]]],["nvidia geforce gtx 965m","965",0,[[1920,1080,195],[3000,2000,59],[3840,2160,41]]],["nvidia geforce gtx 965m opengl engine","965",0,[[2880,1620,55]]],["nvidia geforce gtx 970","970",0,[[1920,1080,143]]],["nvidia geforce gtx 970 opengl engine","970",0,[[2560,1600,60]]],["nvidia geforce gtx 970m","970",0,[[1920,1080,60]]],["nvidia geforce gtx 980","980",0,[[1920,1080,60],[3440,1440,294]]],["nvidia geforce gtx 980 ti","980",0,[[1920,1080,119],[2560,1440,456]]],["nvidia geforce gtx 980 ti opengl engine","980",0,[[1920,1080,60]]],["nvidia geforce gtx 980m","980",0,[[1920,1080,60],[3840,2160,104]]],["nvidia geforce gtx titan","gtx",0,[[1920,1080,119],[1920,1200,119],[2560,1440,60]]],["nvidia geforce gtx titan black","gtx",0,[[1680,1050,60],[1920,1080,60],[1920,1200,60],[2560,1440,60]]],["nvidia geforce gtx titan black opengl engine","gtx",0,[[3840,2160,60]]],["nvidia geforce gtx titan opengl engine","gtx",0,[[2560,1440,60]]],["nvidia geforce gtx titan x","gtxx",0,[[1920,1080,144],[2560,1440,120],[2560,1600,60]]],["nvidia geforce gtx titan xp","gtxxp",0,[[2560,1440,60],[3440,1440,60]]],["nvidia geforce gtx titan z","gtxz",0,[[1440,900,59],[1920,1080,39],[3840,2160,60]]],["nvidia geforce gtx780m by nikey22","780",0,[[2560,1440,60]]],["nvidia geforce gtx870m by nikey22","870",0,[[2560,1440,60]]],["nvidia geforce gtx880m","880",0,[[1920,1080,60]]],["nvidia geforce gtx880m by nikey22","880",0,[[2560,1440,59]]],["nvidia geforce gtx880m opengl engine","880",0,[[2560,1440,59]]],["nvidia geforce mx110","110",0,[[1366,768,61],[1920,1080,57]]],["nvidia geforce mx130","130",0,[[1920,1080,60]]],["nvidia geforce mx150","150",0,[[1920,1080,113]]],["nvidia geforce mx230","230",0,[[1920,1080,60]]],["nvidia geforce mx250","250",0,[[1920,1080,60]]],["nvidia geforce mx330","330",0,[[1920,1080,60],[3840,2160,51]]],["nvidia geforce mx350","350",0,[[1920,1080,60]]],["nvidia geforce mx450","450",0,[[1920,1080,60]]],["nvidia geforce pre-release graphics device","pre",0,[[2560,1440,60]]],["nvidia geforce pre-release tesla c2075 opengl engine","2075",0,[[1600,900,59]]],["nvidia geforce pre-release titan x opengl engine","prex",0,[[1920,1080,60]]],["nvidia geforce pre-release titan xp collectors edition opengl e","prexpe",0,[[1920,1080,59]]],["nvidia geforce pre-release titan xp opengl engine","prexp",0,[[2560,1440,60]]],["nvidia geforce rtx 2060","2060",0,[[1920,1080,512]]],["nvidia geforce rtx 2060 max-q","2060",0,[[2560,1440,301]]],["nvidia geforce rtx 2060 mobile","2060",0,[[1920,1080,518]]],["nvidia geforce rtx 2060 rev. a","2060",0,[[3840,2160,257]]],["nvidia geforce rtx 2060 super","2060",0,[[1920,1080,645],[2560,1440,143]]],["nvidia geforce rtx 2060 with max-q design","2060",0,[[1920,1080,292],[1920,1200,60]]],["nvidia geforce rtx 2070","2070",0,[[1920,1080,60],[3840,2160,60]]],["nvidia geforce rtx 2070 mobile","2070",0,[[1920,1080,477]]],["nvidia geforce rtx 2070 mobile / max-q","2070",0,[[1920,1080,526]]],["nvidia geforce rtx 2070 mobile / max-q refresh","2070",0,[[1920,1080,143]]],["nvidia geforce rtx 2070 rev. a","2070",0,[[2560,1440,144]]],["nvidia geforce rtx 2070 super","2070",0,[[1920,1080,510]]],["nvidia geforce rtx 2070 super with max-q design","2070",0,[[1920,1080,300]]],["nvidia geforce rtx 2070 with max-q design","2070",0,[[1920,1080,240]]],["nvidia geforce rtx 2080","2080",0,[[1920,1080,632],[2560,1440,165]]],["nvidia geforce rtx 2080 mobile","2080",0,[[1920,1080,144]]],["nvidia geforce rtx 2080 rev. a","2080",0,[[2560,1440,143]]],["nvidia geforce rtx 2080 super","2080",0,[[1920,1080,601]]],["nvidia geforce rtx 2080 super mobile / max-q","2080",0,[[3840,2160,59]]],["nvidia geforce rtx 2080 super with max-q design","2080",0,[[1920,1080,300]]],["nvidia geforce rtx 2080 ti","2080",0,[[1920,1080,83]]],["nvidia geforce rtx 2080 ti rev. a","2080",0,[[1920,1080,403]]],["nvidia geforce rtx 2080 with max-q design","2080",0,[[1920,1080,476]]],["nvidia geforce rtx 3050","3050",0,[[1920,1080,60]]],["nvidia geforce rtx 3050 laptop gpu","3050",0,[[1920,1080,144]]],["nvidia geforce rtx 3050 ti laptop gpu","3050",0,[[1920,1080,144]]],["nvidia geforce rtx 3060","3060",0,[[1920,1080,674]]],["nvidia geforce rtx 3060 laptop gpu","3060",0,[[1920,1080,300]]],["nvidia geforce rtx 3060 lite hash rate","3060",0,[[1920,1080,60]]],["nvidia geforce rtx 3060 mobile / max-q","3060",0,[[1920,1080,435]]],["nvidia geforce rtx 3060 ti","3060",0,[[1920,1080,779]]],["nvidia geforce rtx 3070","3070",0,[[1920,1080,723],[2560,1440,294]]],["nvidia geforce rtx 3070 laptop gpu","3070",0,[[1920,1080,357]]],["nvidia geforce rtx 3070 mobile / max-q","3070",0,[[2560,1440,386]]],["nvidia geforce rtx 3070 ti","3070",0,[[1920,1080,60]]],["nvidia geforce rtx 3080","3080",0,[[1920,1080,726],[2560,1440,60],[3840,2160,60]]],["nvidia geforce rtx 3080 laptop gpu","3080",0,[[1920,1080,294],[2560,1440,244]]],["nvidia geforce rtx 3080 mobile / max-q 8gb/16gb","3080",0,[[1920,1080,293]]],["nvidia geforce rtx 3080 ti","3080",0,[[1920,1080,239],[2560,1440,60]]],["nvidia geforce rtx 3090","3090",0,[[2560,1440,60],[3840,2160,474]]],["nvidia geforce rtx t10-16","10",0,[[2560,1600,3]]],["nvidia geforce rtx t10-8","10",0,[[2560,1600,3]]],["nvidia gf100 board - 10220000","100",0,[[1920,1200,60]]],["nvidia gf117","117",0,[[1920,1080,32]]],["nvidia gigabyte geforce gt 440","440",0,[[1280,1024,34]]],["nvidia gigabyte geforce gt 610","610",0,[[1920,1080,17]]],["nvidia gigabyte geforce gt 630","630",0,[[1920,1080,34]]],["nvidia gigabyte geforce gt 730","730",0,[[1280,1024,38]]],["nvidia gigabyte geforce gts 450","450",0,[[1280,1024,37]]],["nvidia gigabyte geforce gtx 1050 ti","1050",0,[[1920,1080,30]]],["nvidia gigabyte geforce gtx 460","460",0,[[1680,1050,60]]],["nvidia gigabyte geforce gtx 550 ti","550",0,[[1920,1080,57]]],["nvidia gigabyte geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 570 hd","570",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 580","580",0,[[1920,1200,60]]],["nvidia gigabyte geforce gtx 650","650",0,[[1680,1050,55]]],["nvidia gigabyte geforce gtx 650 ti","650",0,[[2560,1440,40]]],["nvidia gigabyte geforce gtx 660","660",0,[[1920,1080,31]]],["nvidia gigabyte geforce gtx 660 ti","660",0,[[5120,2880,29]]],["nvidia gigabyte geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 750","750",0,[[1920,1080,59]]],["nvidia gigabyte geforce gtx 750 ti","750",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 760","760",0,[[3440,1440,17]]],["nvidia gigabyte geforce gtx 770","770",0,[[2560,1440,59]]],["nvidia gigabyte geforce gtx 780 ti","780",0,[[1920,1080,240]]],["nvidia gigabyte geforce gtx 960","960",0,[[1920,1080,142],[1920,1200,120]]],["nvidia gigabyte geforce gtx 970","970",0,[[1920,1080,60]]],["nvidia gigabyte geforce gtx 980","980",0,[[2560,1440,60]]],["nvidia gigabyte geforce gtx 980 ti","980",0,[[1920,1080,60]]],["nvidia gk104 board - 2051b502","104",0,[[2560,1440,60]]],["nvidia gk104 board - 20530501","104",0,[[2560,1440,60]]],["nvidia gk104gl [grid k2]","104",0,[[2560,1343,21]]],["nvidia gk104gl [grid k520]","104",0,[[1024,768,120]]],["nvidia gp102 [titan x]","102",0,[[3440,1440,462]]],["nvidia gp102 [titan xp]","102",0,[[1920,1080,126]]],["nvidia gp104","104",0,[[1920,1080,60]]],["nvidia gp104gl","104",0,[[2560,1343,36]]],["nvidia gp108","108",0,[[1920,1080,60]]],["nvidia graphics device","",0,[[1920,1080,60],[1920,1200,60],[3840,2160,60]]],["nvidia grid gtx p40-6","40",0,[[1440,900,153]]],["nvidia grid k1","1",0,[[1245,768,6],[1920,1080,35]]],["nvidia grid k140q vgpu","140",0,[[1920,1080,30]]],["nvidia grid k160q","160",0,[[1920,1080,34]]],["nvidia grid k180q","180",0,[[1920,1080,28]]],["nvidia grid k2","2",0,[[1245,768,6],[1920,1080,59]]],["nvidia grid k220q","220",0,[[1920,1200,34]]],["nvidia grid k240q","240",0,[[1920,1080,64]]],["nvidia grid k260q","260",0,[[2560,1440,31]]],["nvidia grid k280q","280",0,[[1920,1080,64]]],["nvidia grid k520","520",0,[[1280,720,60]]],["nvidia grid m10-1b","10",0,[[1024,768,49]]],["nvidia grid m10-2q","10",0,[[2560,1440,15]]],["nvidia grid m6-0b","6",0,[[1680,1050,33]]],["nvidia grid m60-1b","60",0,[[1680,1050,46],[1920,1080,46]]],["nvidia grid m60-1q","60",0,[[1536,864,60]]],["nvidia grid m60-2q","60",0,[[1920,1080,57]]],["nvidia grid m60-4q","60",0,[[1920,1080,59]]],["nvidia grid m60-8q","60",0,[[1920,1080,60]]],["nvidia grid p100-4q","100",0,[[2560,1440,16]]],["nvidia grid p4-4q","4",0,[[1892,932,247]]],["nvidia grid p40-4q","40",0,[[2741,1495,60]]],["nvidia grid p40-8q","40",0,[[1920,1080,60]]],["nvidia grid rtx6000-2q","6000",0,[[1024,768,60]]],["nvidia grid rtx6000p-6","6000",0,[[1280,1024,161]]],["nvidia grid t4-16q","4",0,[[1920,1080,61]]],["nvidia grid t4-1b","4",0,[[1920,1080,46]]],["nvidia grid t4-1q","4",0,[[1280,1024,48]]],["nvidia grid t4-2b4","4",0,[[1536,864,47]]],["nvidia grid t4-2q","4",0,[[1920,1080,65]]],["nvidia grid t4-8q","4",0,[[2560,1080,60]]],["nvidia grid v100-1q","100",0,[[1646,1154,59]]],["nvidia grid v100-2b","100",0,[[1440,900,45]]],["nvidia grid v100dx-16q","100",0,[[1280,1024,60]]],["nvidia grid v100dx-1q","100",0,[[1280,1024,60]]],["nvidia gtx 1060 hl","1060",0,[[3840,2160,60]]],["nvidia gtx 865m by imacgfx","865",0,[[2560,1440,60]]],["nvidia gtx 980m sli","980",0,[[1366,768,29]]],["nvidia gv-n660oc-2gd","660",0,[[1920,1200,60]]],["nvidia gv100","100",0,[[3840,2160,60]]],["nvidia gv100 [titan v]","100",0,[[2560,1440,60]]],["nvidia gv102","102",0,[[2560,1600,525]]],["nvidia hp geforce gt 730","730",0,[[1920,1080,55]]],["nvidia hp quadro 2000","2000",0,[[2560,1080,38]]],["nvidia hp quadro 4000","4000",0,[[2560,1080,52]]],["nvidia hp quadro 600","600",0,[[1360,768,41]]],["nvidia hp quadro k4000","4000",0,[[1920,1200,26]]],["nvidia hp quadro k620","620",0,[[1600,1200,94]]],["nvidia inno3d geforce gtx660","3",0,[[2560,1440,107]]],["nvidia microsoft virtual render driver","",0,[[1920,1080,59]]],["nvidia msi geforce gt 610","610",0,[[1920,1080,16]]],["nvidia msi geforce gt 630","630",0,[[1440,900,12]]],["nvidia msi geforce gt 635","635",0,[[1920,1080,30]]],["nvidia msi geforce gt 710","710",0,[[1920,1080,27]]],["nvidia msi geforce gt 730","730",0,[[1920,1080,53]]],["nvidia msi geforce gtx 1050 ti","1050",0,[[1920,1080,59]]],["nvidia msi geforce gtx 1060","1060",0,[[1920,1080,120]]],["nvidia msi geforce gtx 1070","1070",0,[[1920,1200,45]]],["nvidia msi geforce gtx 460","460",0,[[1920,1080,60]]],["nvidia msi geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia msi geforce gtx 570 hd","570",0,[[1920,1200,60]]],["nvidia msi geforce gtx 580","580",0,[[2560,1440,60]]],["nvidia msi geforce gtx 650","650",0,[[2560,1080,52]]],["nvidia msi geforce gtx 650 ti","650",0,[[1920,1080,60]]],["nvidia msi geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia msi geforce gtx 660 ti","660",0,[[1680,1050,49]]],["nvidia msi geforce gtx 670","670",0,[[1920,1080,60]]],["nvidia msi geforce gtx 745","745",0,[[1920,1080,55]]],["nvidia msi geforce gtx 760","760",0,[[1280,1024,30],[1920,1080,58]]],["nvidia msi geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia msi geforce gtx 950","950",0,[[1920,1080,59]]],["nvidia msi geforce gtx 960","960",0,[[1680,1050,120],[2560,1440,59]]],["nvidia msi geforce gtx 970","970",0,[[1680,1050,60]]],["nvidia msi geforce gtx 980","980",0,[[1920,1080,120],[3840,2160,60]]],["nvidia msi geforce gtx 980 ti","980",0,[[5120,2880,56]]],["nvidia n15e-gt","15",0,[[3840,2160,30]]],["nvidia null geforce 920a","920",0,[[1920,1080,25]]],["nvidia null graphics device","",0,[[1920,1080,24]]],["nvidia nvs 310","310",0,[[1280,1024,24],[1920,1080,15]]],["nvidia nvs 3100m","3100",0,[[1920,1080,10]]],["nvidia nvs 315","315",0,[[1280,1024,25],[1920,1080,15]]],["nvidia nvs 4200m","4200",0,[[1920,1080,11]]],["nvidia nvs 510","510",0,[[1920,1200,27],[2560,1080,24],[3440,1440,16]]],["nvidia nvs 5200m","5200",0,[[1366,768,55],[1600,900,33],[1920,1080,57]]],["nvidia nvs 5400m","5400",0,[[1600,900,46],[1920,1200,27]]],["nvidia p102-100","102",0,[[1600,1200,35]]],["nvidia p106-090","106",0,[[1920,1371,16]]],["nvidia p106-100","106",0,[[1920,1080,60],[3840,2160,30]]],["nvidia p106-100 custom","106",0,[[1680,1050,60]]],["nvidia palit geforce gtx 650","650",0,[[1920,1080,49]]],["nvidia palit geforce gtx 650 ti","650",0,[[1920,1080,59]]],["nvidia palit geforce gtx 660","660",0,[[1920,1080,26]]],["nvidia palit gtx 680 jetstream","680",0,[[1920,1080,60]]],["nvidia pegatron geforce gt 420","420",0,[[1400,1050,25]]],["nvidia pny geforce gt 610","610",0,[[1280,1024,19]]],["nvidia pny geforce gtx 1060","1060",0,[[1920,1080,60]]],["nvidia pny geforce gtx 460","460",0,[[1360,768,59]]],["nvidia pny geforce gtx 550 ti","550",0,[[1920,1080,55]]],["nvidia pny geforce gtx 570 hd","570",0,[[1280,1024,72]]],["nvidia pny geforce gtx 580","580",0,[[1920,1200,59]]],["nvidia pny geforce gtx 680","680",0,[[2560,1080,120]]],["nvidia pny geforce gtx 750","750",0,[[1280,1024,60]]],["nvidia pny geforce gtx 970","970",0,[[2560,1440,60]]],["nvidia pny geforce gtx 980","980",0,[[1920,1080,120]]],["nvidia point of view geforce gtx 470","470",0,[[1920,1080,59]]],["nvidia point of view geforce gtx 660 ti","660",0,[[1680,1050,59]]],["nvidia quadro 1000m","1000",0,[[1920,1080,28]]],["nvidia quadro 1000m,","1000",0,[[1920,1080,27]]],["nvidia quadro 2000","2000",0,[[1920,1080,51],[2560,1440,28]]],["nvidia quadro 2000d","2000",0,[[1280,1024,56]]],["nvidia quadro 2000m","2000",0,[[1920,1080,31]]],["nvidia quadro 3000m","3000",0,[[1920,1080,53],[2560,1440,6]]],["nvidia quadro 3000m opengl engine","3000",0,[[1920,1080,49]]],["nvidia quadro 4000","4000",0,[[1920,1080,56],[1920,1200,58]]],["nvidia quadro 4000m","4000",0,[[1920,1080,51]]],["nvidia quadro 410","410",0,[[1920,1080,23]]],["nvidia quadro 5000","5000",0,[[1920,1080,60],[2560,1080,55],[2560,1440,51]]],["nvidia quadro 5000 opengl engine","5000",0,[[1920,1200,59]]],["nvidia quadro 5000m","5000",0,[[1600,900,110]]],["nvidia quadro 600","600",0,[[1680,1050,28],[1920,1080,28],[1920,1200,26]]],["nvidia quadro 6000","6000",0,[[1920,1080,60],[1920,1200,60]]],["nvidia quadro 7000","7000",0,[[1920,1200,60]]],["nvidia quadro fx 1800m","1800",0,[[1600,900,15]]],["nvidia quadro fx 2800m","2800",0,[[1920,1200,36]]],["nvidia quadro fx grid k1","1",0,[[1920,1080,31]]],["nvidia quadro gp100","100",0,[[1920,1200,366]]],["nvidia quadro gv100","100",0,[[3840,2160,60],[4096,2160,60]]],["nvidia quadro k1000m","1000",0,[[1920,1080,28]]],["nvidia quadro k1000m by nick[d]vb","1000",0,[[1920,1080,36]]],["nvidia quadro k1100m","1100",0,[[1920,1080,56]]],["nvidia quadro k1100m by nick[d]vb","1100",0,[[1920,1080,66]]],["nvidia quadro k1100m opengl engine","1100",0,[[1920,1080,54]]],["nvidia quadro k1200","1200",0,[[1920,1080,60],[2560,1440,57],[3840,2160,28]]],["nvidia quadro k1200 opengl engine","1200",0,[[3840,2160,34]]],["nvidia quadro k2000","2000",0,[[1920,1080,55]]],["nvidia quadro k2000 opengl engine","2000",0,[[2560,1440,44]]],["nvidia quadro k2000d","2000",0,[[1280,1024,57],[1680,1050,57],[1920,1080,59]]],["nvidia quadro k2000m","2000",0,[[1920,1080,36]]],["nvidia quadro k2000m by nick[d]vb","2000",0,[[2560,1440,38]]],["nvidia quadro k2000m opengl engine","2000",0,[[1920,1080,43]]],["nvidia quadro k2100m","2100",0,[[1920,1080,58]]],["nvidia quadro k2100m by nick[d]vb","2100",0,[[2560,1440,54]]],["nvidia quadro k2100m opengl engine","2100",0,[[1920,1080,59]]],["nvidia quadro k2200","2200",0,[[1920,1080,60],[1920,1200,126],[5120,2880,25]]],["nvidia quadro k2200m","2200",0,[[1920,1080,60]]],["nvidia quadro k3000m","3000",0,[[1920,1080,59]]],["nvidia quadro k3000m by st3phl3","3000",0,[[2560,1440,50]]],["nvidia quadro k3100m","3100",0,[[1920,1080,60]]],["nvidia quadro k3100m by nikey22","3100",0,[[2560,1440,59]]],["nvidia quadro k3100m opengl engine","3100",0,[[2560,1440,58]]],["nvidia quadro k4000","4000",0,[[1920,1080,60],[1920,1200,59]]],["nvidia quadro k4000 opengl engine","4000",0,[[1920,1080,59]]],["nvidia quadro k4000m","4000",0,[[1920,1080,80]]],["nvidia quadro k4100m","4100",0,[[1920,1080,32]]],["nvidia quadro k4100m by nikey22","4100",0,[[2560,1440,60]]],["nvidia quadro k420","420",0,[[1366,768,57],[2560,1440,19],[3840,2160,10]]],["nvidia quadro k4200","4200",0,[[1920,1080,60],[2560,1440,59],[3840,2160,57]]],["nvidia quadro k5000","5000",0,[[1920,1080,60],[2560,1440,60]]],["nvidia quadro k5000 opengl engine","5000",0,[[2560,1600,59]]],["nvidia quadro k5000m","5000",0,[[1920,1080,60],[2560,1440,60]]],["nvidia quadro k5000m opengl engine","5000",0,[[2560,1440,60]]],["nvidia quadro k5100m","5100",0,[[1920,1080,60],[2560,1080,171]]],["nvidia quadro k5100m by nikey22","5100",0,[[2560,1440,60]]],["nvidia quadro k510m","510",0,[[1920,1080,33]]],["nvidia quadro k5200","5200",0,[[1920,1080,60],[1920,1200,60]]],["nvidia quadro k5200 opengl engine","5200",0,[[1920,1200,41]]],["nvidia quadro k600","600",0,[[1920,1080,28]]],["nvidia quadro k600 opengl engine","600",0,[[1920,1200,31]]],["nvidia quadro k6000","6000",0,[[1920,1080,60],[1920,1200,60],[2560,1440,60]]],["nvidia quadro k6000 opengl engine","6000",0,[[1920,1080,59]]],["nvidia quadro k610m","610",0,[[1920,1080,36]]],["nvidia quadro k610m by nick[d]vb","610",0,[[1920,1080,34]]],["nvidia quadro k620","620",0,[[1920,1080,87],[1920,1200,69],[2560,1440,44]]],["nvidia quadro k620 opengl engine","620",0,[[1920,1080,59]]],["nvidia quadro k620m","620",0,[[1920,1080,49],[2880,1620,15]]],["nvidia quadro m1000m","1000",0,[[1920,1080,60]]],["nvidia quadro m1200","1200",0,[[1920,1080,60],[3840,2160,43]]],["nvidia quadro m2000","2000",0,[[1920,1080,73],[2560,1440,59]]],["nvidia quadro m2000m","2000",0,[[1920,1080,60]]],["nvidia quadro m2000m special","2000",0,[[1920,1080,60]]],["nvidia quadro m2200","2200",0,[[1920,1080,60]]],["nvidia quadro m2200 mobile","2200",0,[[3840,2160,13]]],["nvidia quadro m3000m","3000",0,[[1920,1080,60]]],["nvidia quadro m4000","4000",0,[[1920,1080,120],[1920,1200,60],[2560,1440,60]]],["nvidia quadro m4000 opengl engine","4000",0,[[1920,1080,60]]],["nvidia quadro m4000m","4000",0,[[1920,1080,60],[3840,2160,69]]],["nvidia quadro m5000","5000",0,[[1920,1080,60],[1920,1200,60],[2560,1440,59]]],["nvidia quadro m5000m","5000",0,[[1920,1080,212],[3840,2160,60]]],["nvidia quadro m500m","500",0,[[1920,1080,58],[2880,1620,29]]],["nvidia quadro m520","520",0,[[1920,1080,59],[3840,2160,27]]],["nvidia quadro m5500","5500",0,[[3440,1440,60]]],["nvidia quadro m6000","6000",0,[[1920,1080,408],[2560,1440,60]]],["nvidia quadro m6000 24gb","6000",0,[[1680,1050,60],[1920,1200,60]]],["nvidia quadro m600m","600",0,[[1920,1080,59]]],["nvidia quadro m620","620",0,[[1920,1080,60]]],["nvidia quadro nvs 4200m","4200",0,[[1600,900,26],[1920,1080,19]]],["nvidia quadro p1000","1000",0,[[1920,1080,60],[1920,1200,60]]],["nvidia quadro p1000 mobile","1000",0,[[1920,1080,60]]],["nvidia quadro p2000","2000",0,[[1680,1050,60],[1920,1080,242],[2560,1440,60]]],["nvidia quadro p2000 mobile","2000",0,[[1920,1080,60]]],["nvidia quadro p2000 opengl engine","2000",0,[[1920,1080,59]]],["nvidia quadro p2000 with max-q design","2000",0,[[1920,1080,60],[3840,2160,67]]],["nvidia quadro p2200","2200",0,[[1920,1080,60],[3840,2160,340]]],["nvidia quadro p3000","3000",0,[[1920,1080,60]]],["nvidia quadro p3200","3200",0,[[1920,1080,60],[3840,2160,60]]],["nvidia quadro p3200 mobile","3200",0,[[3840,2160,60]]],["nvidia quadro p3200 with max-q design","3200",0,[[2560,1440,60]]],["nvidia quadro p400","400",0,[[1680,1050,46],[1920,1080,57],[1920,1200,54]]],["nvidia quadro p4000","4000",0,[[1920,1080,60],[3840,2160,167]]],["nvidia quadro p4200","4200",0,[[1920,1080,60],[3840,2160,60]]],["nvidia quadro p4200 with max-q design","4200",0,[[3839,2159,53]]],["nvidia quadro p500","500",0,[[1920,1080,60]]],["nvidia quadro p5000","5000",0,[[1920,1080,60]]],["nvidia quadro p5000 opengl engine","5000",0,[[3840,2160,58]]],["nvidia quadro p520","520",0,[[1920,1080,60]]],["nvidia quadro p5200","5200",0,[[3840,2160,100]]],["nvidia quadro p600","600",0,[[1920,1080,60]]],["nvidia quadro p6000","6000",0,[[1920,1080,60],[2560,1440,60],[2560,1600,411]]],["nvidia quadro p620","620",0,[[1920,1080,65]]],["nvidia quadro rtx 3000","3000",0,[[1920,1080,60]]],["nvidia quadro rtx 3000 mobile / max-q","3000",0,[[3840,2160,60]]],["nvidia quadro rtx 3000 with max-q design","3000",0,[[3240,2160,60]]],["nvidia quadro rtx 4000","4000",0,[[1920,1080,60]]],["nvidia quadro rtx 4000 mobile / max-q","4000",0,[[1920,1080,60]]],["nvidia quadro rtx 4000 with max-q design","4000",0,[[1920,1080,60],[3840,2160,60]]],["nvidia quadro rtx 5000","5000",0,[[1920,1080,443],[2560,1440,60]]],["nvidia quadro rtx 5000 mobile / max-q","5000",0,[[3840,2160,60]]],["nvidia quadro rtx 5000 with max-q design","5000",0,[[1920,1080,60],[3840,2160,60]]],["nvidia quadro rtx 6000","6000",0,[[1920,1080,438],[2560,1440,60]]],["nvidia quadro rtx 8000","8000",0,[[1920,1080,60],[1920,1200,60]]],["nvidia quadro t1000","1000",0,[[1920,1080,60],[2560,1440,41]]],["nvidia quadro t1000 mobile","1000",0,[[1920,1080,277]]],["nvidia quadro t1000 with max-q design","1000",0,[[1920,1080,60]]],["nvidia quadro t2000","2000",0,[[1920,1080,60]]],["nvidia quadro t2000 mobile / max-q","2000",0,[[1920,1080,302]]],["nvidia quadro t2000 with max-q design","2000",0,[[1920,1080,60],[1920,1200,60],[2560,1440,60]]],["nvidia rtx a1000 laptop gpu","1000",0,[[1920,1080,60]]],["nvidia rtx a2000","2000",0,[[3840,2160,60]]],["nvidia rtx a2000 laptop gpu","2000",0,[[2400,1600,120],[3840,2160,60]]],["nvidia rtx a3000 laptop gpu","3000",0,[[1920,1080,60],[3840,2160,60]]],["nvidia rtx a4000","4000",0,[[1920,1080,60],[3840,2160,60]]],["nvidia rtx a4000 laptop gpu","4000",0,[[1920,1080,60]]],["nvidia rtx a5000","5000",0,[[3840,2160,60]]],["nvidia rtx a5000 laptop gpu","5000",0,[[3840,2160,60]]],["nvidia rtx a6000","6000",0,[[1920,1200,60]]],["nvidia sony geforce 410m","410",0,[[1366,768,24]]],["nvidia t1000","1000",0,[[1920,1080,43],[3840,2160,60]]],["nvidia t1200 laptop gpu","1200",0,[[1920,1080,60]]],["nvidia t400","400",0,[[3840,2160,35]]],["nvidia t500","500",0,[[1920,1080,60],[3839,2159,52]]],["nvidia t600","600",0,[[1920,1080,60]]],["nvidia tesla c2050 / c2070","2050",0,[[1920,1080,105]]],["nvidia tesla c2070","2070",0,[[1920,1200,60]]],["nvidia tesla c2075","2075",0,[[1920,1080,60]]],["nvidia tesla k10","10",0,[[1920,1080,60]]],["nvidia tesla k10.g1.8gb","10",0,[[1440,900,59]]],["nvidia tesla k20m","20",0,[[1240,821,118]]],["nvidia tesla k20xm","20",0,[[3840,2400,17]]],["nvidia tesla k80","80",0,[[1664,896,66],[3840,2160,30]]],["nvidia tesla m10","10",0,[[1440,900,60],[1280,1024,60]]],["nvidia tesla m40","40",0,[[1600,1024,190]]],["nvidia tesla m6","6",0,[[1920,1080,59]]],["nvidia tesla m60","60",0,[[1366,768,60],[1920,962,61],[3840,2160,27]]],["nvidia tesla p100 pcie 16gb","100",0,[[1920,1080,60]]],["nvidia tesla p100-pcie-16gb","100",0,[[1920,1080,103]]],["nvidia tesla p4","4",0,[[1680,1050,60]]],["nvidia tesla p40","40",0,[[1546,877,62],[1920,1200,60]]],["nvidia tesla t4","4",0,[[1440,900,33],[1920,1080,60]]],["nvidia tesla v100-pcie-16gb","100",0,[[1920,997,57]]],["nvidia tesla v100-pcie-32gb","100",0,[[1920,1080,57]]],["nvidia tesla v100-sxm2-16gb","100",0,[[1920,1080,60]]],["nvidia tesla v100-sxm2-32gb","100",0,[[1920,1080,1],[2560,1440,60]]],["nvidia titan rtx","rtx",0,[[2560,1440,60],[3840,2160,680]]],["nvidia titan v","v",0,[[2560,1440,622],[3840,2160,60]]],["nvidia titan x","x",0,[[2560,1080,60],[3840,1600,75],[3840,2160,339]]],["nvidia titan xp","xp",0,[[1920,1200,60],[2560,1440,60],[3440,1440,105]]],["nvidia titan xp collectors","xp",0,[[1920,1080,60],[2560,1440,893],[5120,2880,60]]],["nvidia toshiba geforce gt 525m","525",0,[[1366,768,33]]],["nvidia tu102 [titan rtx]","102",0,[[3840,2160,60]]],["nvidia tu107","107",0,[[1920,1080,312]]],["nvidia tu117m","117",0,[[1920,1080,337]]],["nvidia unknown","",0,[[1920,1080,60]]],["nvidia zotac geforce gt 430","430",0,[[1600,900,32]]],["nvidia zotac geforce gt 610","610",0,[[1920,1080,15]]],["nvidia zotac geforce gt 630","630",0,[[1360,768,46]]],["nvidia zotac geforce gt 740","740",0,[[1280,1024,118]]],["nvidia zotac geforce gtx 460","460",0,[[1920,1080,59]]],["nvidia zotac geforce gtx 550 ti","550",0,[[1920,1080,42]]],["nvidia zotac geforce gtx 560","560",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 560 ti","560",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 580","580",0,[[1920,1080,48]]],["nvidia zotac geforce gtx 650","650",0,[[1920,1080,44]]],["nvidia zotac geforce gtx 650 ti","650",0,[[1920,1080,58]]],["nvidia zotac geforce gtx 660","660",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 680","680",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 750","750",0,[[1680,1050,114],[1920,1080,60]]],["nvidia zotac geforce gtx 760","760",0,[[1920,1080,101]]],["nvidia zotac geforce gtx 770","770",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 780","780",0,[[1920,1080,60]]],["nvidia zotac geforce gtx 960","960",0,[[2048,1152,60]]]]')},145:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["amd [amd/ati] fiji [radeon r9 fury / nano series]","9",0,[[1920,1200,162]]],["amd asus amd radeon r9-990x","9",0,[[1920,1080,60]]],["amd asus radeon r7 250","7",0,[[800,638,60]]],["amd asus radeon r7 260x","7",0,[[2560,1080,65]]],["amd asus radeon r9 270x","9",0,[[1024,768,85],[1920,1080,60]]],["amd asus radeon r9 280","9",0,[[1920,1080,60]]],["amd asus radeon rx 460","460",0,[[1360,768,104]]],["amd asus radeon rx 470","470",0,[[1920,1080,60]]],["amd asus radeon rx 480","480",0,[[1920,1080,124]]],["amd asus radeon rx 550","550",0,[[1440,900,60],[1920,1080,49]]],["amd asus radeon rx 5500 xt","5500",0,[[1920,1080,325]]],["amd asus radeon rx 560","560",0,[[1360,768,60],[1920,1080,85]]],["amd asus radeon rx 570","570",0,[[1600,900,202],[1920,1080,60]]],["amd asus radeon rx 5700","5700",0,[[1920,1080,327]]],["amd asus radeon rx 5700 xt","5700",0,[[1920,1080,224],[2560,1440,60]]],["amd asus radeon rx 580","580",0,[[1920,1080,177],[2560,1080,60]]],["amd asus radeon rx vega","rx",0,[[2560,1440,117]]],["amd ati mobility radeon hd 5870","5870",0,[[1920,1200,19]]],["amd baffin amd radeon rx 560","560",0,[[1920,1080,60]]],["amd ellesmere radeon rx 570","570",0,[[1920,1080,60]]],["amd embedded radeon e9171","9171",0,[[3840,2160,26]]],["amd embedded radeon e9173","9173",0,[[3840,2160,16]]],["amd gigabyte radeon rx 580","580",0,[[1920,1080,60]]],["amd madison [mobility radeon hd 5650 / 6530m/6550m]","5650",0,[[1366,768,43]]],["amd mobility radeon hd 4250","4250",0,[[963,722,26]]],["amd mobility radeon hd 5000","5000",0,[[1366,768,47]]],["amd mobility radeon hd 5400","5400",0,[[1366,768,24]]],["amd mobility radeon hd 5430","5430",0,[[1600,900,15],[1920,1080,60]]],["amd mobility radeon hd 5470","5470",0,[[1366,768,24]]],["amd mobility radeon hd 5570","5570",0,[[1920,1080,27]]],["amd mobility radeon hd 5730 / 6570m","5730",0,[[1366,768,58]]],["amd mobility radeon hd 5850","5850",0,[[1600,900,55]]],["amd mobility radeon hd 5870","5870",0,[[1600,900,64],[1920,1200,53]]],["amd park [mobility radeon hd 5430","5430",0,[[1280,720,11]]],["amd pitcairn pro radeon hd 7850","7850",0,[[1920,1080,60]]],["amd powercolor radeon r9 280","9",0,[[1920,1080,60]]],["amd radeon","",0,[[1920,1080,299],[3440,1440,60]]],["amd radeon 500","500",0,[[1920,1080,73]]],["amd radeon 520","520",0,[[1920,1080,35],[2560,1440,29]]],["amd radeon 530","530",0,[[1366,768,60],[1920,1080,30]]],["amd radeon 535","535",0,[[1920,1080,35]]],["amd radeon 535dx","535",0,[[1366,768,31],[1920,1080,37]]],["amd radeon 540","540",0,[[1920,1080,38]]],["amd radeon 540 / rx 540x/550/550x","540",0,[[2560,1440,88]]],["amd radeon 540x","540",0,[[1920,1080,59]]],["amd radeon 550","550",0,[[1920,1080,115]]],["amd radeon 550x","550",0,[[1920,1080,28]]],["amd radeon 610","610",0,[[1920,1080,29]]],["amd radeon 620","620",0,[[1920,1080,18]]],["amd radeon 625","625",0,[[1366,768,55],[1920,1080,47]]],["amd radeon 630","630",0,[[1920,1080,29]]],["amd radeon 6600m and 6700m","6600",0,[[1366,768,36],[1440,900,60]]],["amd radeon 6800","6800",0,[[3440,1440,100]]],["amd radeon 7500m/7600m","7500",0,[[1366,768,37]]],["amd radeon 7950 x2","7950",0,[[2560,1440,174]]],["amd radeon d700","700",0,[[2560,1440,120]]],["amd radeon e6460","6460",0,[[1600,1200,13]]],["amd radeon e6760","6760",0,[[1200,900,54],[1920,1080,42]]],["amd radeon e8860","8860",0,[[1920,1200,27],[2560,1374,88]]],["amd radeon e8870","8870",0,[[1920,1080,81]]],["amd radeon e8870mxm","8870",0,[[1920,1080,60]]],["amd radeon e9260","9260",0,[[1680,1050,60],[3840,2160,38]]],["amd radeon e9550","9550",0,[[1680,1050,60],[3840,2160,58]]],["amd radeon embedded e9560","9560",0,[[1920,1200,60]]],["amd radeon fury","",0,[[1920,1080,60]]],["amd radeon fury x","x",0,[[1920,1080,60],[2560,1440,144]]],["amd radeon hd - firepro d300","300",0,[[1920,1080,60]]],["amd radeon hd - firepro d300 opengl engine","300",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd - firepro d500 opengl engine","500",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd - firepro d700 opengl engine","700",0,[[3840,2160,52]]],["amd radeon hd 2600 xt","2600",1,[[2560,1600,-1]]],["amd radeon hd 5000","5000",0,[[1920,1080,8]]],["amd radeon hd 5400","5400",0,[[1920,1080,12]]],["amd radeon hd 5450","5450",0,[[1920,1080,13]]],["amd radeon hd 5470","5470",0,[[1280,1024,16]]],["amd radeon hd 5500","5500",0,[[1920,1080,27]]],["amd radeon hd 5570","5570",0,[[1920,1080,60],[2048,1152,31]]],["amd radeon hd 5600","5600",0,[[1920,1080,56]]],["amd radeon hd 5650","5650",0,[[1366,768,53]]],["amd radeon hd 5670","5670",1,[[1920,1080,-1],[2560,1440,-1]]],["amd radeon hd 5670 opengl engine","5670",1,[[2560,1440,-1]]],["amd radeon hd 5700","5700",0,[[1920,1080,59]]],["amd radeon hd 5730","5730",0,[[1366,768,46],[1680,1050,40]]],["amd radeon hd 5750","5750",1,[[1920,1080,-1],[1920,1200,-1],[2560,1440,-1]]],["amd radeon hd 5750 opengl engine","5750",1,[[2560,1440,-1]]],["amd radeon hd 5770","5770",0,[[1776,1000,43],[1920,1080,59]]],["amd radeon hd 5800","5800",0,[[1366,768,60],[1920,1200,102]]],["amd radeon hd 5850","5850",0,[[1920,1080,60]]],["amd radeon hd 5870","5870",0,[[1280,960,75],[1920,1080,60],[2048,1280,60]]],["amd radeon hd 5870m","5870",0,[[2560,1080,31]]],["amd radeon hd 5970","5970",0,[[1360,768,60],[1920,1080,60]]],["amd radeon hd 6230","6230",0,[[1366,768,13]]],["amd radeon hd 6250","6250",0,[[1280,800,8],[1366,768,8]]],["amd radeon hd 6290","6290",1,[[1366,768,-1]]],["amd radeon hd 6300m","6300",1,[[1366,768,-1]]],["amd radeon hd 6310","6310",1,[[1366,768,-1]]],["amd radeon hd 6320","6320",1,[[1366,768,-1]]],["amd radeon hd 6350","6350",0,[[1280,1024,18],[1920,1080,14]]],["amd radeon hd 6370d","6370",0,[[1920,1080,14]]],["amd radeon hd 6370m","6370",0,[[1366,768,25]]],["amd radeon hd 6380g","6380",0,[[1366,768,19]]],["amd radeon hd 6400","6400",0,[[1920,1080,13]]],["amd radeon hd 6400m","6400",0,[[1366,768,28]]],["amd radeon hd 6400m/7400m","6400",0,[[1366,768,28]]],["amd radeon hd 6410d","6410",0,[[1920,1080,11]]],["amd radeon hd 6450","6450",0,[[1920,1080,14]]],["amd radeon hd 6450 / r5 230","6450",0,[[1440,900,12]]],["amd radeon hd 6450 230","6450",0,[[1920,1080,15]]],["amd radeon hd 6470m","6470",0,[[1366,768,27],[1600,900,21]]],["amd radeon hd 6470m/7400m","6470",0,[[1366,768,44]]],["amd radeon hd 6480g","6480",0,[[1280,768,19],[1366,768,27],[1600,900,18]]],["amd radeon hd 6490m","6490",1,[[1366,768,-1],[1440,900,-1],[1680,1050,-1]]],["amd radeon hd 6500","6500",0,[[1920,1080,25]]],["amd radeon hd 6500m/5600","6500",0,[[1920,1080,27]]],["amd radeon hd 6510","6510",0,[[1600,900,32]]],["amd radeon hd 6520g","6520",0,[[1366,768,21],[1600,900,20]]],["amd radeon hd 6530d","6530",0,[[1366,768,31],[1440,900,36],[1920,1080,24]]],["amd radeon hd 6540","6540",0,[[1600,1200,13]]],["amd radeon hd 6550d","6550",0,[[1920,1080,28]]],["amd radeon hd 6570","6570",0,[[1920,1080,52],[2560,1440,17]]],["amd radeon hd 6620g","6620",0,[[1360,768,43],[1366,768,28]]],["amd radeon hd 6630m","6630",1,[[1366,768,-1],[1600,900,-1],[1920,1080,-1]]],["amd radeon hd 6630m/6650m/6750m/7670m/7690m","6630",1,[[1366,768,-1],[1920,1080,-1]]],["amd radeon hd 6650m","6650",0,[[1366,768,51],[1600,900,31]]],["amd radeon hd 6670","6670",0,[[1920,1080,55]]],["amd radeon hd 6700","6700",0,[[1920,1080,56]]],["amd radeon hd 6700 green","6700",0,[[1360,768,89]]],["amd radeon hd 6700m/7700m/7900m","6700",0,[[1366,768,59]]],["amd radeon hd 6730m/6770m","6730",0,[[1366,768,58],[1920,1080,46]]],["amd radeon hd 6730m/6770m/7690m xt","6730",0,[[1920,1080,48]]],["amd radeon hd 6750","6750",0,[[1440,900,72],[1920,1080,60]]],["amd radeon hd 6750m","6750",1,[[1440,900,-1],[1920,1080,-1],[1920,1200,-1]]],["amd radeon hd 6770","6770",0,[[1920,1080,60]]],["amd radeon hd 6770m","6770",1,[[1440,900,-1],[2560,1440,-1]]],["amd radeon hd 6770m opengl engine","6770",1,[[2560,1440,-1]]],["amd radeon hd 6790","6790",0,[[1920,1080,59]]],["amd radeon hd 6800","6800",0,[[1280,1024,89],[1920,1080,60]]],["amd radeon hd 6800m","6800",0,[[1600,900,18],[1920,1080,40]]],["amd radeon hd 6850","6850",0,[[1920,1080,59],[2560,1600,54]]],["amd radeon hd 6870","6870",0,[[1920,1080,60],[2560,1440,59]]],["amd radeon hd 6900","6900",0,[[1920,1080,60]]],["amd radeon hd 6900m","6900",0,[[1920,1080,60]]],["amd radeon hd 6950","6950",0,[[1680,1050,60],[1920,1080,41]]],["amd radeon hd 6970","6970",0,[[1920,1080,60]]],["amd radeon hd 6970m","6970",1,[[2560,1440,-1]]],["amd radeon hd 6970m opengl engine","6970",1,[[2560,1440,-1]]],["amd radeon hd 6990","6990",0,[[1920,1080,60]]],["amd radeon hd 7000","7000",0,[[1920,1080,24]]],["amd radeon hd 7290","7290",0,[[1366,768,9]]],["amd radeon hd 7310","7310",0,[[1366,768,14]]],["amd radeon hd 7340","7340",0,[[1366,768,17],[1920,1080,10]]],["amd radeon hd 7340g","7340",0,[[1366,768,15]]],["amd radeon hd 7340m","7340",0,[[1366,768,15]]],["amd radeon hd 7350","7350",0,[[1920,1080,13]]],["amd radeon hd 7400","7400",0,[[1920,1080,18]]],["amd radeon hd 7400g","7400",0,[[963,768,31]]],["amd radeon hd 7400m","7400",0,[[1366,768,44]]],["amd radeon hd 7420g","7420",0,[[1366,768,28],[1600,900,26]]],["amd radeon hd 7450","7450",0,[[1920,1080,15]]],["amd radeon hd 7450a","7450",0,[[1920,1080,15]]],["amd radeon hd 7450m","7450",0,[[1366,768,30]]],["amd radeon hd 7470","7470",0,[[1680,1050,22],[1920,1080,144]]],["amd radeon hd 7470m","7470",0,[[1366,768,31],[1600,900,23]]],["amd radeon hd 7480d","7480",0,[[1280,1024,25],[1920,1080,24],[1920,1200,18]]],["amd radeon hd 7500","7500",0,[[1366,696,49],[1366,768,49]]],["amd radeon hd 7500g","7500",0,[[1366,768,26]]],["amd radeon hd 7500m/7600m","7500",0,[[1366,768,46]]],["amd radeon hd 7520g","7520",0,[[1366,768,33]]],["amd radeon hd 7520g + hd 7400m dual","7520",0,[[1366,768,34]]],["amd radeon hd 7520g + hd 7600m dual","7520",0,[[1366,768,31],[1600,900,41]]],["amd radeon hd 7540d","7540",0,[[1024,768,55],[1280,1024,44],[1920,1080,22]]],["amd radeon hd 7540d + hd 6670 dual","7540",0,[[1280,1024,36]]],["amd radeon hd 7550m/7650m","7550",0,[[1366,768,57]]],["amd radeon hd 7560d","7560",0,[[1920,1080,34]]],["amd radeon hd 7560d + hd 6570 dual","7560",0,[[1680,1050,44]]],["amd radeon hd 7560d + hd 6670 dual","7560",0,[[800,638,60]]],["amd radeon hd 7570","7570",0,[[1024,768,72],[1920,1080,52]]],["amd radeon hd 7570m","7570",0,[[1366,768,35]]],["amd radeon hd 7570m/hd 7670m","7570",0,[[1366,768,50],[1600,900,29]]],["amd radeon hd 7600","7600",0,[[1920,1080,60]]],["amd radeon hd 7600a","7600",0,[[1920,1080,28]]],["amd radeon hd 7600g","7600",0,[[1366,768,29]]],["amd radeon hd 7600g + 7500m/7600m dual","7600",0,[[1366,768,19]]],["amd radeon hd 7600g + hd 8670m dual","7600",0,[[1366,768,29]]],["amd radeon hd 7600g + hd dual","7600",0,[[1366,768,20]]],["amd radeon hd 7600m","7600",0,[[1366,768,56]]],["amd radeon hd 7600m/7700m","7600",0,[[1366,768,31]]],["amd radeon hd 7610m","7610",0,[[1366,768,43]]],["amd radeon hd 7620g","7620",0,[[1366,768,22],[1920,1080,19]]],["amd radeon hd 7640g","7640",0,[[1366,768,38]]],["amd radeon hd 7640g + 7470m dual","7640",0,[[1366,768,32]]],["amd radeon hd 7640g + 7600m dual","7640",0,[[1366,768,23]]],["amd radeon hd 7640g + 7670m dual","7640",0,[[1600,900,15]]],["amd radeon hd 7640g + 8500m dual","7640",0,[[1366,768,35]]],["amd radeon hd 7640g + hd 7400m dual","7640",0,[[1366,768,37]]],["amd radeon hd 7640g + hd 7500 dual","7640",0,[[1366,768,35]]],["amd radeon hd 7640g + hd 7670m dual","7640",0,[[1366,768,34]]],["amd radeon hd 7640g + hd 8500m dual","7640",0,[[1366,768,40]]],["amd radeon hd 7640g + hd 8570m dual","7640",0,[[1366,768,31]]],["amd radeon hd 7650a","7650",0,[[1680,1050,43],[1920,1080,15]]],["amd radeon hd 7650m","7650",0,[[1366,768,41],[1600,900,45]]],["amd radeon hd 7660d","7660",0,[[1680,1050,40],[1920,1008,60],[1920,1080,38]]],["amd radeon hd 7660d + hd 6570 dual","7660",0,[[1200,900,32]]],["amd radeon hd 7660d + hd 6670 dual","7660",0,[[1360,768,57],[1920,1080,53]]],["amd radeon hd 7660g","7660",0,[[1366,768,44],[1600,900,41],[1920,1080,34],[1920,1200,27]]],["amd radeon hd 7660g + 7600m dual","7660",0,[[1366,768,53],[1600,900,45]]],["amd radeon hd 7660g + 7670m dual","7660",0,[[1366,768,52]]],["amd radeon hd 7660g + 8670m dual","7660",0,[[1600,900,46]]],["amd radeon hd 7660g + hd 7600m dual","7660",0,[[1366,768,50]]],["amd radeon hd 7660g + hd 7670m dual","7660",0,[[1366,768,35]]],["amd radeon hd 7660g + hd 8600m dual","7660",0,[[1600,900,29]]],["amd radeon hd 7670","7670",0,[[1920,1080,39]]],["amd radeon hd 7670m","7670",0,[[1366,768,49],[1920,1080,36]]],["amd radeon hd 7700","7700",0,[[1400,1050,45],[1920,1080,60]]],["amd radeon hd 7700m","7700",0,[[1920,1080,54]]],["amd radeon hd 7730m","7730",0,[[1920,1080,57]]],["amd radeon hd 7750","7750",0,[[1280,1024,60],[1600,900,60],[1400,1050,98],[1920,1080,60],[3840,2160,23]]],["amd radeon hd 7750 / r7 250e","7750",0,[[2560,1080,69]]],["amd radeon hd 7750m","7750",0,[[1680,1050,57]]],["amd radeon hd 7770","7770",0,[[1920,1080,60]]],["amd radeon hd 7770 / r7 250x","7770",0,[[1680,1050,78]]],["amd radeon hd 7770 ghz","7770",0,[[1920,1080,78]]],["amd radeon hd 7790","7790",0,[[1920,1080,16]]],["amd radeon hd 7790 / r7 360 / r9 260/360","7790",0,[[1280,1024,131]]],["amd radeon hd 7800","7800",0,[[1920,1080,60]]],["amd radeon hd 7800m","7800",0,[[1920,1080,57]]],["amd radeon hd 7850","7850",0,[[1920,1080,60]]],["amd radeon hd 7850 / r7 265 / r9 270 1024sp","7850",0,[[1280,1024,87]]],["amd radeon hd 7870","7870",0,[[1920,1080,120],[2560,1440,60],[2560,1600,114],[3840,2160,30]]],["amd radeon hd 7870 ghz","7870",0,[[1920,1080,75]]],["amd radeon hd 7870 xt","7870",0,[[1920,1080,57],[3840,2160,53]]],["amd radeon hd 7870m","7870",0,[[1920,1080,22],[2732,1536,40]]],["amd radeon hd 7900","7900",0,[[2560,1600,59]]],["amd radeon hd 7950","7950",0,[[1920,1080,50]]],["amd radeon hd 7950 / r9 280","7950",0,[[1920,1080,59]]],["amd radeon hd 7950 oem / r9 280","7950",0,[[1920,1080,60]]],["amd radeon hd 7970","7970",0,[[1920,1080,60]]],["amd radeon hd 7970 / r9 280x","7970",0,[[1920,1080,193]]],["amd radeon hd 7970m","7970",0,[[1366,768,60],[1920,1080,60]]],["amd radeon hd 7970x/8970 280x","7970",0,[[1920,1080,60]]],["amd radeon hd 7990","7990",0,[[1920,1080,60],[5120,2880,63]]],["amd radeon hd 7xxx","7",0,[[1920,1080,60]]],["amd radeon hd 8180","8180",0,[[1366,768,10]]],["amd radeon hd 8200 / r3","8200",0,[[1366,768,21],[1600,900,13],[1680,1050,13]]],["amd radeon hd 8210","8210",0,[[1366,768,18]]],["amd radeon hd 8240","8240",0,[[1600,900,17]]],["amd radeon hd 8240 / r3","8240",0,[[1366,768,14]]],["amd radeon hd 8250","8250",0,[[1366,768,14],[1920,1200,10]]],["amd radeon hd 8280","8280",0,[[1600,900,60]]],["amd radeon hd 8280 / r3","8280",0,[[1366,768,22]]],["amd radeon hd 8280e","8280",0,[[2880,1620,6]]],["amd radeon hd 8330","8330",0,[[1366,768,24]]],["amd radeon hd 8350","8350",0,[[1920,1080,57]]],["amd radeon hd 8350g","8350",0,[[1366,768,18]]],["amd radeon hd 8370d","8370",0,[[1366,768,60],[1280,1024,26],[1920,1080,22]]],["amd radeon hd 8400","8400",0,[[1366,768,30],[1920,1080,16]]],["amd radeon hd 8400 / r3","8400",0,[[1360,768,19],[1366,768,22],[1920,1080,12]]],["amd radeon hd 8400e","8400",0,[[1680,1050,17],[1920,1080,16],[1920,1200,14]]],["amd radeon hd 8410g","8410",0,[[1366,768,32]]],["amd radeon hd 8450g","8450",0,[[1366,768,23]]],["amd radeon hd 8450g + hd 8750m dual","8450",0,[[1366,768,21]]],["amd radeon hd 8470","8470",0,[[1920,1080,17]]],["amd radeon hd 8470 + 7660d dual","8470",0,[[1920,1080,60]]],["amd radeon hd 8470d","8470",0,[[1280,1024,44],[1920,1080,21]]],["amd radeon hd 8470d + hd 6450 dual","8470",0,[[1600,900,37]]],["amd radeon hd 8490","8490",0,[[1920,1080,18],[1920,1200,20]]],["amd radeon hd 8500m","8500",0,[[1366,768,41],[1920,1080,19]]],["amd radeon hd 8500m/8700m","8500",0,[[1920,1080,30]]],["amd radeon hd 8510g","8510",0,[[1366,768,29],[1920,1080,17]]],["amd radeon hd 8550","8550",0,[[1920,1080,25]]],["amd radeon hd 8550g","8550",0,[[1366,768,34],[1600,900,41],[1920,1080,34]]],["amd radeon hd 8550g + 8500m dual","8550",0,[[1366,768,42]]],["amd radeon hd 8550g + 8600 dual","8550",0,[[1920,1080,27]]],["amd radeon hd 8550g + hd 8570m dual","8550",0,[[1366,768,32]]],["amd radeon hd 8550g + hd 8600 dual","8550",0,[[1366,768,60]]],["amd radeon hd 8550g + hd 8750m dual","8550",0,[[1366,768,37]]],["amd radeon hd 8550g + r5 m230 dual","8550",0,[[1366,768,29]]],["amd radeon hd 8570","8570",0,[[1280,1024,60],[1680,1050,54],[1920,1080,50]]],["amd radeon hd 8570 / r5 430 / r7 240 / radeon 520","8570",0,[[1920,1080,25]]],["amd radeon hd 8570d","8570",0,[[1920,1080,16]]],["amd radeon hd 8570d + r7 240 dual","8570",0,[[1920,1080,45]]],["amd radeon hd 8570m","8570",0,[[1366,768,40]]],["amd radeon hd 8600","8600",0,[[1366,768,41]]],["amd radeon hd 8600m","8600",0,[[1366,768,42],[1920,1080,14]]],["amd radeon hd 8610g","8610",0,[[1366,768,31],[1920,1080,16]]],["amd radeon hd 8610g + 8600m dual","8610",0,[[1366,768,22]]],["amd radeon hd 8610g + hd 8600m dual","8610",0,[[1366,768,41]]],["amd radeon hd 8610g + hd 8670m dual","8610",0,[[1366,768,33]]],["amd radeon hd 8650g","8650",0,[[1360,768,44],[1366,768,44]]],["amd radeon hd 8650g + 8500m dual","8650",0,[[1366,768,35]]],["amd radeon hd 8650g + 8600 dual","8650",0,[[1920,1080,38]]],["amd radeon hd 8650g + 8600m dual","8650",0,[[1366,768,21]]],["amd radeon hd 8650g + 8670m dual","8650",0,[[1366,768,66]]],["amd radeon hd 8650g + 8750m dual","8650",0,[[1920,1080,28]]],["amd radeon hd 8650g + hd 7600m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + hd 8500m dual","8650",0,[[1366,768,23]]],["amd radeon hd 8650g + hd 8570m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + hd 8600m dual","8650",0,[[1366,768,46],[1600,900,29]]],["amd radeon hd 8650g + hd 8750m dual","8650",0,[[1366,768,36]]],["amd radeon hd 8650g + r5 m200 dual","8650",0,[[1366,768,35]]],["amd radeon hd 8670 / r7 250","8670",0,[[1024,768,1]]],["amd radeon hd 8670a/8670m/8690m","8670",0,[[1366,768,47]]],["amd radeon hd 8670a/8670m/8750m","8670",0,[[1366,768,60]]],["amd radeon hd 8670d","8670",0,[[1024,768,45],[1280,1024,69],[1920,1080,38]]],["amd radeon hd 8670d + 7700 dual","8670",0,[[1680,1050,58]]],["amd radeon hd 8670d + hd 6670 dual","8670",0,[[1680,1050,33]]],["amd radeon hd 8670d + r5 200 dual","8670",0,[[2560,1080,14]]],["amd radeon hd 8670d + r7 200 dual","8670",0,[[1920,1080,37]]],["amd radeon hd 8670m","8670",0,[[1366,768,41]]],["amd radeon hd 8690a","8690",0,[[1920,1080,31]]],["amd radeon hd 8690m","8690",0,[[1600,900,35]]],["amd radeon hd 8700m","8700",0,[[1366,768,60]]],["amd radeon hd 8730m","8730",0,[[1366,768,59]]],["amd radeon hd 8750m","8750",0,[[1366,768,60]]],["amd radeon hd 8770","8770",0,[[1920,1080,111]]],["amd radeon hd 8790m","8790",0,[[1600,900,78],[1920,1080,60]]],["amd radeon hd 8800m","8800",0,[[1920,1080,60],[2880,1800,45]]],["amd radeon hd 8830m","8830",0,[[1920,1080,82]]],["amd radeon hd 8850m","8850",0,[[1366,768,45]]],["amd radeon hd 8870m","8870",0,[[1280,1024,60],[1600,900,60]]],["amd radeon hd 8950","8950",0,[[1920,1080,60],[1920,1200,59]]],["amd radeon hd 8970","8970",0,[[2560,1600,60]]],["amd radeon hd 8970m","8970",0,[[1920,1080,146],[1920,1200,60]]],["amd radeon hd 8xxx","8",0,[[1920,1080,120],[2560,1440,58]]],["amd radeon hd5450","5450",0,[[1280,720,24]]],["amd radeon hd6870","6870",0,[[1920,1080,60]]],["amd radeon hd7970m","7970",0,[[2560,1440,116]]],["amd radeon hd8530m","8530",0,[[1366,768,40]]],["amd radeon hd8730","8730",0,[[1680,1050,42]]],["amd radeon hd8970m","8970",0,[[1920,1080,74]]],["amd radeon hybrid","",0,[[1366,768,27]]],["amd radeon infoshock rx 460","460",0,[[1360,768,102]]],["amd radeon instinct mi25","25",0,[[1920,1200,26]]],["amd radeon instinct mi25 mxgpu","25",0,[[1920,1080,20],[1920,1200,32]]],["amd radeon m535dx","535",0,[[1366,768,58]]],["amd radeon navi14","14",0,[[3840,2160,60]]],["amd radeon polaris","",0,[[3840,2160,60],[5120,2880,44]]],["amd radeon polaris 10","10",0,[[1920,1200,60]]],["amd radeon pro","pro",0,[[1920,1080,114]]],["amd radeon pro 270x","270",0,[[2560,1440,74]]],["amd radeon pro 450","450",0,[[1920,1080,30],[2880,1800,43],[3360,2100,36],[5120,2880,30]]],["amd radeon pro 450 opengl engine","450",0,[[1920,1200,60]]],["amd radeon pro 455","455",0,[[2879,1800,54],[2880,1800,48],[3360,2100,37]]],["amd radeon pro 455 opengl engine","455",0,[[3360,2100,36]]],["amd radeon pro 460","460",0,[[2880,1800,50],[3360,2100,42]]],["amd radeon pro 460 opengl engine","460",0,[[5760,3240,15]]],["amd radeon pro 470","470",0,[[6016,3384,49]]],["amd radeon pro 480","480",0,[[1920,1080,60]]],["amd radeon pro 5300","5300",0,[[5120,2880,60]]],["amd radeon pro 5300m","5300",0,[[1920,1080,214],[3584,2240,130]]],["amd radeon pro 5500 xt","5500",0,[[5120,2880,51]]],["amd radeon pro 5500m","5500",0,[[3072,1920,60],[3584,2240,139]]],["amd radeon pro 555","555",0,[[2879,1800,54],[2880,1800,36],[3360,2100,40]]],["amd radeon pro 555x","555",0,[[2880,1800,42],[3360,2100,39]]],["amd radeon pro 560","560",0,[[2879,1800,56],[2880,1800,56],[3360,2100,42]]],["amd radeon pro 5600m","5600",0,[[3072,1920,60],[3584,2240,60]]],["amd radeon pro 560x","560",0,[[2879,1800,59],[2880,1800,71],[3360,2100,43]]],["amd radeon pro 570","570",0,[[5120,2880,48]]],["amd radeon pro 570 opengl engine","570",0,[[5120,2880,46]]],["amd radeon pro 5700","5700",0,[[5120,2880,60]]],["amd radeon pro 5700 xt","5700",0,[[5120,2880,60]]],["amd radeon pro 570x","570",0,[[5120,2880,50]]],["amd radeon pro 575","575",0,[[4096,2304,60],[5120,2880,50]]],["amd radeon pro 575 opengl engine","575",0,[[5120,2880,48]]],["amd radeon pro 575x","575",0,[[5120,2880,56]]],["amd radeon pro 580","580",0,[[5120,2880,54]]],["amd radeon pro 580 opengl engine","580",0,[[5120,2880,50]]],["amd radeon pro 580x","580",0,[[5120,2880,52]]],["amd radeon pro duo","pro",0,[[1920,1080,234],[1800,1350,59],[3840,2160,82],[4096,2160,60]]],["amd radeon pro rx 560","560",0,[[2560,1080,60]]],["amd radeon pro ssg","pro",0,[[3440,1440,125]]],["amd radeon pro v340","340",0,[[1920,1080,112]]],["amd radeon pro v520 mxgpu","520",0,[[1920,1080,271]]],["amd radeon pro v7350x2","7350",0,[[1920,1080,60]]],["amd radeon pro vega 16","16",0,[[2879,1800,60],[3360,2100,60]]],["amd radeon pro vega 20","20",0,[[2880,1800,120],[3360,2100,121],[3840,2160,30]]],["amd radeon pro vega 48","48",0,[[5120,2880,86]]],["amd radeon pro vega 56","56",0,[[1920,1080,60],[5120,2880,60]]],["amd radeon pro vega 56 opengl engine","56",0,[[5120,2880,60]]],["amd radeon pro vega 64","64",0,[[5120,2880,60]]],["amd radeon pro vega 64 opengl engine","64",0,[[5120,2880,60]]],["amd radeon pro vega 64x","64",0,[[2560,1440,206],[4096,2304,60],[5120,2880,60]]],["amd radeon pro vega ii","proii",0,[[3840,1600,60],[5120,2880,60]]],["amd radeon pro vega ii duo","proii",0,[[2560,1440,239],[5120,2880,60]]],["amd radeon pro w5500","5500",0,[[1920,1080,195],[3840,2160,59],[7680,3240,56]]],["amd radeon pro w5500m","5500",0,[[1920,1080,60]]],["amd radeon pro w5500x","5500",0,[[1920,1200,60]]],["amd radeon pro w5700","5700",0,[[1680,1050,253],[5120,1440,120],[3840,2160,60]]],["amd radeon pro w5700x","5700",0,[[3840,2160,60]]],["amd radeon pro w6600","6600",0,[[1920,1200,60],[3840,2160,166]]],["amd radeon pro w6600m","6600",0,[[1920,1080,60]]],["amd radeon pro w6800","6800",0,[[1920,1080,60],[3840,2160,237]]],["amd radeon pro w6800x","6800",0,[[6016,3384,60]]],["amd radeon pro w6800x duo","6800",0,[[3840,1600,60],[5120,2880,45]]],["amd radeon pro w6900x","6900",0,[[3840,2160,60]]],["amd radeon pro wx","pro",0,[[2560,1080,69]]],["amd radeon pro wx 2100","2100",0,[[1280,1024,145],[1920,1080,60]]],["amd radeon pro wx 3100","3100",0,[[1919,1080,58],[1920,1080,123],[2560,1440,82]]],["amd radeon pro wx 3200","3200",0,[[2560,1440,92]]],["amd radeon pro wx 4100","4100",0,[[1920,1080,60],[1920,1200,60],[3840,2160,30],[5120,2880,18]]],["amd radeon pro wx 4130","4130",0,[[1920,1080,60],[3840,2160,30]]],["amd radeon pro wx 4150","4150",0,[[1920,1080,56],[3840,2160,37],[4096,2160,34]]],["amd radeon pro wx 5100","5100",0,[[1920,1080,60],[2560,1440,91],[3840,2160,55]]],["amd radeon pro wx 5100 opengl engine","5100",0,[[2560,1440,60]]],["amd radeon pro wx 7100","7100",0,[[1920,1080,122],[2560,1080,58],[3840,2160,60],[5120,2880,60]]],["amd radeon pro wx 7100 mobile","7100",0,[[2560,1440,60]]],["amd radeon pro wx 7100 opengl engine","7100",0,[[3840,2160,60]]],["amd radeon pro wx 8200","8200",0,[[3440,1440,124]]],["amd radeon pro wx 9100","9100",0,[[1920,1080,60],[4096,2160,101]]],["amd radeon pro wx 9100 opengl engine","9100",0,[[1920,1080,60]]],["amd radeon pro wx vega m gl","prom",0,[[3840,2160,14]]],["amd radeon pro wx3200","3200",0,[[1920,1080,55]]],["amd radeon pro wx9100","9100",0,[[2560,1440,60]]],["amd radeon r2","2",0,[[1366,768,13],[1600,900,14]]],["amd radeon r2e","2",0,[[1366,768,16],[1920,1080,45],[3840,2160,4]]],["amd radeon r3","3",0,[[1366,768,17],[1920,1080,15]]],["amd radeon r4","4",0,[[1366,768,19],[1920,1080,13]]],["amd radeon r4e","4",0,[[3840,2160,6]]],["amd radeon r5","5",0,[[1024,768,38],[1360,768,25],[1366,768,21],[1280,1024,33],[1920,1080,14],[3200,1800,7]]],["amd radeon r5 220","5",0,[[1366,768,19],[1920,1080,12]]],["amd radeon r5 230","5",0,[[1920,1080,21]]],["amd radeon r5 235","5",0,[[1920,1080,17]]],["amd radeon r5 240","5",0,[[1280,1024,34],[1920,1080,24]]],["amd radeon r5 340","5",0,[[1920,1080,27]]],["amd radeon r5 340x","5",0,[[1920,1080,31]]],["amd radeon r5 430","5",0,[[1280,1024,31],[1680,1050,54],[1920,1080,54]]],["amd radeon r5 435","5",0,[[1920,1080,30]]],["amd radeon r5 m200","5",0,[[1600,900,45],[1920,1080,20]]],["amd radeon r5 m200 / hd 8500m","5",0,[[1366,768,31],[1920,1080,24]]],["amd radeon r5 m230","5",0,[[1366,768,37]]],["amd radeon r5 m240","5",0,[[1366,768,42],[1920,1080,23]]],["amd radeon r5 m255","5",0,[[1366,768,59],[1600,900,33]]],["amd radeon r5 m315","5",0,[[1366,768,45]]],["amd radeon r5 m320","5",0,[[1920,1080,19]]],["amd radeon r5 m330","5",0,[[1366,768,27],[1920,1080,26]]],["amd radeon r5 m335","5",0,[[1366,768,55],[1920,1080,19]]],["amd radeon r5 m420","5",0,[[1366,768,49]]],["amd radeon r5 m430","5",0,[[1366,768,36],[1920,1080,20]]],["amd radeon r5 m435","5",0,[[1920,1080,41],[2560,1440,67]]],["amd radeon r5 m445","5",0,[[1920,1080,32]]],["amd radeon r5e","5",0,[[1600,768,14],[1920,1080,16]]],["amd radeon r6","6",0,[[1366,768,30],[1280,1024,23],[1920,1080,12]]],["amd radeon r6 m255dx","6",0,[[1366,768,25]]],["amd radeon r6 m340dx","6",0,[[1366,768,31],[1920,1080,15]]],["amd radeon r6e","6",0,[[3840,2160,5]]],["amd radeon r7","7",0,[[1366,768,35],[1280,1024,31],[1680,1050,39],[1920,1080,12],[1920,1200,16],[2560,1080,15],[2560,1440,21],[3840,2160,8]]],["amd radeon r7 200","7",0,[[1280,1024,45],[1920,1080,120]]],["amd radeon r7 200 series","7",0,[[1920,1080,43]]],["amd radeon r7 240","7",0,[[1920,1080,29]]],["amd radeon r7 240 + hd 8570d dual","7",0,[[1920,1080,43]]],["amd radeon r7 250","7",0,[[1920,1080,49]]],["amd radeon r7 250e","7",0,[[1920,1080,60]]],["amd radeon r7 250x","7",0,[[1920,1080,60]]],["amd radeon r7 260x","7",0,[[1920,1080,56]]],["amd radeon r7 260x/360","7",0,[[1920,1200,102]]],["amd radeon r7 350","7",0,[[1024,768,60],[1280,1024,79],[1920,1080,59]]],["amd radeon r7 350x","7",0,[[1920,1080,50]]],["amd radeon r7 360","7",0,[[1920,1048,60],[1920,1080,102]]],["amd radeon r7 360 / r9 360","7",0,[[1920,1080,60]]],["amd radeon r7 370","7",0,[[1600,900,60],[1920,1080,75]]],["amd radeon r7 370 / r9 270","7",0,[[1920,1080,74]]],["amd radeon r7 370 / r9 270x/370","7",0,[[1600,900,115],[1920,1080,60]]],["amd radeon r7 370 / r9 270x/370x","7",0,[[1920,1080,115]]],["amd radeon r7 370 series","7",0,[[1920,1080,212],[3840,2160,60]]],["amd radeon r7 430","7",0,[[1920,1080,55],[3840,2160,10]]],["amd radeon r7 450","7",0,[[1920,1080,60]]],["amd radeon r7 a360","7",0,[[1920,1080,28]]],["amd radeon r7 graphics + hd 7700 dual","7",0,[[1600,1200,72]]],["amd radeon r7 graphics + r5 340 dual","7",0,[[1920,1080,47]]],["amd radeon r7 graphics + r7 200 dual","7",0,[[1920,1080,45],[1920,1200,47]]],["amd radeon r7 graphics + r7 350 dual","7",0,[[1919,1080,60]]],["amd radeon r7 m260","7",0,[[1600,900,44],[1920,1080,13]]],["amd radeon r7 m260dx","7",0,[[1366,768,46],[1920,1080,18]]],["amd radeon r7 m260x","7",0,[[1920,1080,29]]],["amd radeon r7 m265","7",0,[[1366,768,48],[1920,1080,27]]],["amd radeon r7 m270","7",0,[[1920,1080,31],[3840,2160,10]]],["amd radeon r7 m340","7",0,[[1366,768,60],[1920,1080,32]]],["amd radeon r7 m350","7",0,[[3840,2160,12]]],["amd radeon r7 m360","7",0,[[1366,768,40],[1920,1080,22]]],["amd radeon r7 m370","7",0,[[1920,1080,24]]],["amd radeon r7 m440","7",0,[[1920,1080,39]]],["amd radeon r7 m445","7",0,[[1920,1080,36]]],["amd radeon r7 m460","7",0,[[1919,1080,24],[1920,1080,29]]],["amd radeon r7 m520","7",0,[[1919,1080,17]]],["amd radeon r7 series / hd 9000","7",0,[[1920,1080,71],[2560,1080,59]]],["amd radeon r7e","7",0,[[1024,768,41]]],["amd radeon r8 m350dx","8",0,[[1366,768,30]]],["amd radeon r8 m365dx","8",0,[[1920,1080,28]]],["amd radeon r8 m435dx","8",0,[[1920,1080,22]]],["amd radeon r8 m445dx","8",0,[[1366,768,38],[1920,1080,27]]],["amd radeon r8 m535dx","8",0,[[1366,768,55]]],["amd radeon r9","9",0,[[1920,1080,60]]],["amd radeon r9 200","9",0,[[1920,1080,60]]],["amd radeon r9 200 / hd 7900","9",0,[[1920,1080,250]]],["amd radeon r9 255","9",0,[[1600,900,52],[1920,1080,51]]],["amd radeon r9 260","9",0,[[1920,1080,16]]],["amd radeon r9 270","9",0,[[1280,1024,60],[1920,1080,60]]],["amd radeon r9 270 1024sp","9",0,[[1920,1080,135]]],["amd radeon r9 270x","9",0,[[1920,1080,30]]],["amd radeon r9 280","9",0,[[1920,1080,75],[1920,1200,428],[2560,1440,60]]],["amd radeon r9 280,","9",0,[[5120,2880,39]]],["amd radeon r9 280x","9",0,[[1920,1080,137]]],["amd radeon r9 285","9",0,[[1920,1080,60],[1920,1200,129]]],["amd radeon r9 290","9",0,[[1920,1080,60]]],["amd radeon r9 290x","9",0,[[1920,1080,60],[2560,1440,60],[3840,2160,118]]],["amd radeon r9 300","9",0,[[1920,1080,59]]],["amd radeon r9 350","9",0,[[1920,1200,63]]],["amd radeon r9 360","9",0,[[1600,900,83],[1920,1080,60],[2560,1440,59]]],["amd radeon r9 370","9",0,[[1680,1050,205],[1920,1080,60],[3840,2160,49]]],["amd radeon r9 370x","9",0,[[1920,1080,60]]],["amd radeon r9 380","9",0,[[1920,1080,41],[2560,1440,75]]],["amd radeon r9 380x","9",0,[[2560,1600,60]]],["amd radeon r9 390","9",0,[[1920,1080,60],[2560,1440,60]]],["amd radeon r9 390x","9",0,[[2560,1440,60],[3840,2160,60]]],["amd radeon r9 a375","9",0,[[1920,1080,28]]],["amd radeon r9 fury","9",0,[[1920,1080,75],[3840,2160,133]]],["amd radeon r9 fury / nano","9",0,[[1920,1200,155]]],["amd radeon r9 m200x","9",0,[[1366,768,104],[1920,1080,60]]],["amd radeon r9 m265x","9",0,[[1920,1080,33]]],["amd radeon r9 m270x","9",0,[[1600,900,60],[1920,1080,68]]],["amd radeon r9 m275","9",0,[[1920,1080,29]]],["amd radeon r9 m275x","9",0,[[1920,1080,20]]],["amd radeon r9 m280x","9",0,[[1920,1080,60],[2560,1440,25]]],["amd radeon r9 m290","9",0,[[5120,2880,33]]],["amd radeon r9 m290x","9",0,[[1920,1080,60],[3840,2160,61],[5120,2880,33]]],["amd radeon r9 m295x","9",0,[[3840,2160,33],[5120,2880,36]]],["amd radeon r9 m295x mac","9",0,[[5120,2880,42]]],["amd radeon r9 m295x mac edition / r9 380x","9",0,[[1920,1080,128]]],["amd radeon r9 m360","9",0,[[1920,1080,60],[3840,2160,26]]],["amd radeon r9 m370x","9",0,[[2560,1440,30],[2880,1800,27]]],["amd radeon r9 m370x opengl engine","9",0,[[5120,2880,14]]],["amd radeon r9 m375","9",0,[[1920,1080,29]]],["amd radeon r9 m375x","9",0,[[1920,1080,60],[3840,2160,22]]],["amd radeon r9 m380","9",0,[[1920,1080,50],[3840,2160,8],[5120,2880,9]]],["amd radeon r9 m380 opengl engine","9",0,[[5120,2880,15]]],["amd radeon r9 m385","9",0,[[1920,1080,58]]],["amd radeon r9 m385x","9",0,[[1920,1080,60]]],["amd radeon r9 m390","9",0,[[5119,2879,29],[5120,2880,21],[5760,3240,32]]],["amd radeon r9 m390 opengl engine","9",0,[[5120,2880,27]]],["amd radeon r9 m390x","9",0,[[1920,1080,140]]],["amd radeon r9 m395","9",0,[[2560,1440,59],[5120,2880,19]]],["amd radeon r9 m395 opengl engine","9",0,[[5120,2880,38]]],["amd radeon r9 m395x","9",0,[[3840,2160,58],[5120,2880,36]]],["amd radeon r9 m395x opengl engine","9",0,[[5120,2880,35]]],["amd radeon r9 m470","9",0,[[3840,2160,29]]],["amd radeon r9 m470x","9",0,[[1920,1080,60]]],["amd radeon r9-290x","9",0,[[1920,1080,60]]],["amd radeon renoir graphics d1","1",0,[[1366,768,60]]],["amd radeon rro 580x","580",0,[[5120,2880,59]]],["amd radeon rx 460","460",0,[[1920,1080,55],[2560,1080,60],[3840,2160,31]]],["amd radeon rx 460 / pro 450/455/460/555/555x/560/560x","460",0,[[3440,1440,93]]],["amd radeon rx 460 / pro 450/455/460/560","460",0,[[1920,1080,72]]],["amd radeon rx 470","470",0,[[1280,1024,73],[1920,1080,58],[1920,1200,147],[3840,2160,51]]],["amd radeon rx 470 opengl engine","470",0,[[2560,1440,60]]],["amd radeon rx 475m","475",0,[[1920,1080,60]]],["amd radeon rx 480","480",0,[[1400,1050,267],[1920,1080,60],[2560,1080,71]]],["amd radeon rx 480 opengl engine","480",0,[[1920,1080,60]]],["amd radeon rx 5300m","5300",0,[[1920,1080,60],[3840,2160,60]]],["amd radeon rx 540","540",0,[[1919,1080,52],[1920,1080,36]]],["amd radeon rx 550","550",0,[[1280,1024,135],[1920,1080,60],[1920,1200,60],[6016,3384,15]]],["amd radeon rx 550 640sp / rx 560","550",0,[[1920,1080,60]]],["amd radeon rx 5500","5500",0,[[1920,1080,139]]],["amd radeon rx 5500 / pro 5500m","5500",0,[[1920,1080,60],[2560,1440,227]]],["amd radeon rx 5500 xt","5500",0,[[1920,1080,239]]],["amd radeon rx 5500m","5500",0,[[1920,1048,144],[1920,1080,144],[3840,2160,60]]],["amd radeon rx 550x","550",0,[[1920,1080,52]]],["amd radeon rx 560","560",0,[[1920,1080,60],[1920,1200,42],[2560,1440,60]]],["amd radeon rx 560 [baffin]","560",0,[[1920,1080,60]]],["amd radeon rx 5600 oem/5600 xt / 5700 xt","5600",0,[[1920,1080,360],[2560,1440,164]]],["amd radeon rx 5600 xt","5600",0,[[1920,1080,75]]],["amd radeon rx 5600m","5600",0,[[1920,1080,144]]],["amd radeon rx 560d","560",0,[[2560,1080,60]]],["amd radeon rx 560x","560",0,[[1920,1080,115],[3840,2160,35]]],["amd radeon rx 570","570",0,[[1920,1080,60],[3072,1728,60]]],["amd radeon rx 570 opengl engine","570",0,[[1920,1080,226]]],["amd radeon rx 5700","5700",0,[[1920,1080,144]]],["amd radeon rx 5700 / 5700 xt","5700",0,[[3840,2160,201]]],["amd radeon rx 5700 xt","5700",0,[[1920,1080,464],[3840,2160,60],[6016,3384,34]]],["amd radeon rx 5700 xt 50th anniversary","5700",0,[[2560,1440,144],[3840,1600,60],[3840,2160,222],[5120,2880,60]]],["amd radeon rx 5700xt","5700",0,[[1920,1080,369]]],["amd radeon rx 580","580",0,[[1920,1080,60],[1920,1200,97],[2560,1440,60],[3840,2160,60]]],["amd radeon rx 580 2048sp","580",0,[[1920,1080,60]]],["amd radeon rx 580 opengl engine","580",0,[[1920,1080,145]]],["amd radeon rx 580 special","580",0,[[2560,1440,60]]],["amd radeon rx 580x","580",0,[[1920,1200,60],[3840,2160,79]]],["amd radeon rx 590","590",0,[[1920,1080,75],[2560,1440,164],[3584,2240,60]]],["amd radeon rx 640","640",0,[[1920,1080,39]]],["amd radeon rx 6500 xt","6500",0,[[1920,1080,60]]],["amd radeon rx 6600","6600",0,[[1920,1080,433],[3840,2160,57]]],["amd radeon rx 6600 xt","6600",0,[[1920,1080,60]]],["amd radeon rx 6600 xt/6600m","6600",0,[[2560,1440,60]]],["amd radeon rx 6600m","6600",0,[[1920,1080,139]]],["amd radeon rx 6700 xt","6700",0,[[1920,1080,451]]],["amd radeon rx 6700 xt / 6800m","6700",0,[[2560,1440,144]]],["amd radeon rx 6700m","6700",0,[[1920,1080,240]]],["amd radeon rx 6800","6800",0,[[2560,1440,564],[3840,2160,60]]],["amd radeon rx 6800 xt","6800",0,[[2560,1440,446],[3440,1440,144],[3840,2160,60]]],["amd radeon rx 6800 xt / 6900 xt","6800",0,[[2560,1440,239]]],["amd radeon rx 6800 xt 16gb","6800",0,[[6400,2666,60]]],["amd radeon rx 6800m","6800",0,[[1920,1080,300]]],["amd radeon rx 6900 xt","6900",0,[[3840,2160,60]]],["amd radeon rx rx 560","560",0,[[1920,1080,60]]],["amd radeon rx vega","rx",0,[[1920,1080,39]]],["amd radeon rx vega 10","10",0,[[1920,1080,38]]],["amd radeon rx vega 11","11",0,[[1920,1080,35]]],["amd radeon rx vega 56","56",0,[[1920,1080,144],[3440,1440,60],[3840,2160,60]]],["amd radeon rx vega 56 8gb","56",0,[[2560,1600,60]]],["amd radeon rx vega 56 opengl engine","56",0,[[2560,1440,60]]],["amd radeon rx vega 64","64",0,[[2560,1440,518]]],["amd radeon rx vega 64 8gb","64",0,[[2560,1440,60]]],["amd radeon rx vega 64 opengl engine","64",0,[[3840,2160,119]]],["amd radeon rx vega 64.1","64",0,[[6016,3384,60]]],["amd radeon rx vega 8","8",0,[[1920,1080,53]]],["amd radeon rx vega m gh","rxm",0,[[1920,1080,60],[2560,1440,60],[3840,2160,51]]],["amd radeon rx vega m gl","rxm",0,[[2560,1440,567],[3840,2160,59]]],["amd radeon rx vega11","11",0,[[2496,1664,30]]],["amd radeon rx460","460",0,[[1920,1080,60]]],["amd radeon rx480","480",0,[[1920,1080,102],[2560,1080,71]]],["amd radeon rx540","540",0,[[2400,1800,37]]],["amd radeon rx550","550",0,[[1920,1080,60]]],["amd radeon rx560","560",0,[[1920,1080,93]]],["amd radeon rx5600","5600",0,[[3840,2160,129]]],["amd radeon rx570","570",0,[[5120,2880,59]]],["amd radeon rx5700","5700",0,[[1920,1080,60]]],["amd radeon rx580","580",0,[[1920,1080,60]]],["amd radeon rx590 gme","590",0,[[1920,1080,112]]],["amd radeon rx6600xt","6600",0,[[3840,2160,60]]],["amd radeon sky 500","500",0,[[4096,2160,34]]],["amd radeon vega","",0,[[5120,2880,32]]],["amd radeon vega 10","10",0,[[1920,1080,44]]],["amd radeon vega 10 mobile","10",0,[[1920,1080,30]]],["amd radeon vega 11","11",0,[[1280,1024,60],[1920,1080,60],[3840,2160,17]]],["amd radeon vega 2","2",0,[[1366,768,30]]],["amd radeon vega 3","3",0,[[1440,900,44],[1920,1080,29],[3840,2160,8]]],["amd radeon vega 3 mobile","3",0,[[1920,1080,30]]],["amd radeon vega 56","56",0,[[2560,1440,144]]],["amd radeon vega 6","6",0,[[1366,768,61],[1920,1080,23]]],["amd radeon vega 64","64",0,[[6016,3384,35]]],["amd radeon vega 64 lc","64",0,[[2560,1080,60]]],["amd radeon vega 8","8",0,[[1920,1080,35],[2560,1440,24],[4096,2160,15]]],["amd radeon vega 8 mobile","8",0,[[1920,1080,36]]],["amd radeon vega 9","9",0,[[2496,1663,32],[2496,1664,39]]],["amd radeon vega fe","fe",0,[[1920,1080,120],[2560,1440,60]]],["amd radeon vega frontier","",0,[[1920,1080,120],[3840,2160,60]]],["amd radeon vega frontier edition opengl engine","",0,[[3440,1440,60]]],["amd radeon vega series / radeon vega mobile","",0,[[1920,1080,67]]],["amd radeon vii","vii",0,[[1920,1080,468],[2560,1440,60],[3840,2160,60]]],["amd radeont 540x","540",0,[[1920,1080,74],[3840,2160,22]]],["amd radeont rx 5300","5300",0,[[1920,1080,60]]],["amd radeont rx 5500m","5500",0,[[1920,1080,303]]],["amd radeont rx 560x","560",0,[[1920,1080,60]]],["amd saphire radeon rx 580","580",0,[[1920,1080,57]]],["amd sapphire radeon hd6870","6870",0,[[1680,1050,60]]],["amd sapphire radeon rx 560","560",0,[[1280,1024,60]]],["amd sapphire radeon rx vega 64 8gb","64",0,[[2560,1440,144]]],["intel radeon pro vega 16","16",0,[[3360,1890,20]]],["intel radeong 0.4 on amd bonaire","0",0,[[1920,1200,92]]],["intel radeong 0.4 on amd cape verde","0",0,[[1920,1200,73]]],["intel radeong 0.4 on amd polaris10","0",0,[[3840,2160,108]]],["intel radeong 0.4 on amd tonga","0",0,[[1920,1080,124]]],["radeon 500","500",0,[[1920,1080,58]]],["radeon 550","550",0,[[1920,1080,60]]],["radeon 550x","550",0,[[1920,1080,68]]],["radeon hd 7700","7700",0,[[1920,1080,60],[1920,1200,90]]],["radeon hd 7800","7800",0,[[1920,1080,60]]],["radeon hd 7900","7900",0,[[1920,1080,60],[1920,1200,60],[2560,1440,60]]],["radeon hd 8500","8500",0,[[1920,1080,42]]],["radeon hd 8790m","8790",0,[[1600,900,60]]],["radeon hd8800","8800",0,[[1920,1080,60]]],["radeon pro wx 5100 graphics (polaris10 / drm 3.27.0 / 4.19.4-1.el7.elrepo.x86_64, llvm 6.0","5100",0,[[1920,1080,60]]],["radeon pro wx3100","3100",0,[[2560,1440,1],[3840,2160,43]]],["radeon r5 340","5",0,[[1536,864,41]]],["radeon r5 m330","5",0,[[1366,768,38]]],["radeon r7 200","7",0,[[1280,1024,60],[2560,1440,52]]],["radeon r7 300","7",0,[[1920,1080,60]]],["radeon r7 m340","7",0,[[1920,1080,32]]],["radeon r7 m360","7",0,[[1920,1080,32]]],["radeon r9 200","9",0,[[1920,1080,60],[1920,1200,60],[2560,1440,1]]],["radeon r9 380","9",0,[[2560,1440,1]]],["radeon r9 390","9",0,[[1920,1080,60],[2560,1440,60]]],["radeon r9 fury","9",0,[[1920,1080,51],[1920,1920,60]]],["radeon rx","rx",0,[[1920,1200,60]]],["radeon rx 460","460",0,[[1920,1080,60],[1920,1200,60]]],["radeon rx 470","470",0,[[1280,768,60],[1680,1050,422],[1920,1080,60],[2560,1440,60]]],["radeon rx 480","480",0,[[1920,1080,60],[1920,1200,185],[2560,1440,1]]],["radeon rx 550","550",0,[[1600,900,60],[1680,1050,60],[1920,1080,1],[1920,1200,60],[2560,1080,60],[3840,2160,30]]],["radeon rx 5500 xt","5500",0,[[1920,1080,60],[1920,1200,60],[2560,1440,60],[3840,2160,19]]],["radeon rx 560","560",0,[[1600,900,60],[1920,1080,29],[1920,1200,47],[2688,1512,60],[3440,1440,60],[3840,2160,58]]],["radeon rx 5600 xt","5600",0,[[1920,1080,60]]],["radeon rx 570","570",0,[[1440,900,60],[1280,1024,60],[1920,1080,51],[1920,1200,60],[2560,1080,60],[2560,1440,37],[3440,1440,60]]],["radeon rx 5700 xt","5700",0,[[1707,960,60],[1920,1080,60],[2560,1440,55],[3840,2160,60]]],["radeon rx 580","580",0,[[1477,831,72],[1440,900,60],[1680,1050,60],[1920,1080,4],[1920,1200,60],[2560,1080,52],[2560,1440,60],[2560,1600,60],[3840,2160,1]]],["radeon rx 580 2048sp","580",0,[[1440,900,75]]],["radeon rx 590","590",0,[[1920,1080,60],[2560,1440,60],[3840,2160,30]]],["radeon rx vega","rx",0,[[1920,1080,60],[1920,1200,60],[2194,1234,60],[2560,1080,60],[2560,1440,60],[3440,1440,75],[3840,2160,60]]],["radeon rx vega 8","8",0,[[3840,2160,23]]],["radeon rx550","550",0,[[1680,1050,60],[1920,1080,60],[3440,1440,58]]],["radeon vega 8","8",0,[[1680,1050,60]]],["radeon vega frontier","",0,[[2560,1440,144]]],["radeon vii","vii",0,[[2560,1440,60],[3440,1440,60],[3840,2160,1]]],["radeong 0.4 on amd polaris10","0",0,[[3840,2160,109]]],["radeong 0.4 on amd tahiti","0",0,[[1920,1080,223]]],["ryzen embedded r1305g with radeon vega gfx","1305",0,[[3840,2160,14]]],["ryzen embedded v1605b with radeon vega gfx","1605",0,[[3840,2160,28]]]]')},921:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["adreno 506","506",0,[[1512,720,18,"motorola moto g(7) play"]]],["adreno 530","530",0,[[2560,1140,27,"samsung galaxy s7 (sm-930x)"],[2392,1440,28,"google pixel xl"]]],["adreno 615","615",0,[[2088,1080,20,"google pixel 3a"]]],["adreno 618","618",0,[[2210,1080,34,"xiaomi mi 9t"]]],["adreno 620","620",0,[[2340,1080,42,"google pixel 5"]]],["adreno 630","630",0,[[2280,1080,58,"oneplus a6003"]]],["adreno 640","640",0,[[2280,1080,60,"google pixel 4"]]],["qualcomm adreno 205","205",0,[[1280,720,11,"coolpad 8675-w00 (adreno 205)"]]],["qualcomm adreno 304","304",0,[[480,320,16,"zte z353vl cymbal t"],[480,480,6,"lg watch sport"],[758,480,8,"kyocera kyf33 torque x01 s-max"],[782,480,8,"vodafone vfd 510"],[791,480,8,"acer t012"],[792,480,6,"lg k4 2017 (m151, m160, m150 phoenix 3, m153 fortune, m154 risio 2, l58vl rebel 2)"],[800,480,7,"chainway c4050-q4"],[854,480,6,"zte q302c"],[897,540,6,"kyocera c6742 hydro view"],[960,540,6,"cat s40"],[1024,552,6,"tcl 9007 pixi 3 (7)"],[1184,720,4,"micromax q4251 canvas juice a1"],[1187,720,4,"lg phoenix 2 (k37x)"],[1193,720,4,"lg x power (k210, k450)"],[1196,720,4,"obi sj2.5"],[1217,720,4,"fibo la0920"],[1224,720,4,"umax visionbook p70 lte"],[1280,720,4,"k-touch beeline fast +"],[1280,736,4,"alcatel 9022x one touch pixi 3 8.0"],[1280,752,4,"lenovo tab 10 (x103f)"]]],["qualcomm adreno 305","305",0,[[432,320,18,"sonim xp6700"],[480,320,16,"lg t480s wine smart 3g"],[400,400,0,"huawei watch"],[734,480,7,"lg l fino (d290, d295)"],[737,480,7,"acer liquid z220"],[790,480,8,"htc desire 510 (adreno 305)"],[791,480,7,"sony xperia m (c19xx, c20xx)"],[800,480,5,"cherry mobile q510"],[854,480,6,"alcatel a564c one touch pop icon"],[886,540,7,"lg g2 mini (d610, d618, d620)"],[896,540,7,"htc desire 610"],[897,540,5,"motorola xt830c moto e"],[960,540,4,"huawei c8817l"],[1024,528,5,"aurora au701"],[1024,552,4,"asus zenfone go 6.9 (l001 zb690kg)"],[982,600,4,"huawei mediapad 7 youth 2"],[1024,600,7,"samsung galaxy tab 3 7.0 (sm-t215, sm-t217)"],[1024,720,4,"ereneben eben a2"],[1024,722,5,"prestigio pmt5287 multipad ranger 8.0 4g"],[1280,648,5,"tomtom bridge"],[1184,720,5,"htc desire 650 (d650)"],[1188,720,4,"lg aka (h778, h788, f520x)"],[1196,720,3,"zte z787"],[1200,720,4,"lg g vista (d631, vs880, gx2 f430)"],[1216,720,4,"vodafone smart 4 max"],[1217,720,4,"kyocera e6790 duraforce xd"],[1220,720,4,"huawei ascend mate 2 mt2-l03"],[1196,768,4,"infocus m2"],[1280,720,3,"zuum p47"],[1280,732,4,"lg g pad 7.0 (uk410, v410, vk410)"],[1280,736,4,"zte amazing p6"],[1280,737,4,"asus memo pad hd 7 (k00s me175kg)"],[1280,739,4,"lg g pad 8.0 (v480, v49x, p490, t01)"],[1280,740,4,"qualcomm msm8926 (adreno 305, development board)"],[1280,752,4,"asus padfone e (t008 a68m)"],[1216,800,3,"huawei mediapad t1 8.0 (adreno 305)"],[1280,800,3,"samsung tn10gedlte"],[1920,1080,2,"zte s2002 star 1"],[1920,1128,2,"lenovo b8080"]]],["qualcomm adreno 306","306",0,[[734,480,9,"lg f60 (d390, d392)"],[790,480,8,"htc desire 510 (adreno 306)"],[791,480,5,"lg l21g destiny"],[800,480,8,"covia fleaz cp-l42a pop"],[854,480,8,"freetel ft151a priori2 lte"],[897,540,7,"kyocera c6740 hydro wave"],[960,540,5,"blu studio mini lte 2"],[1024,552,6,"tcl 9006w"],[1024,600,5,"samsung sm-t116ir (adreno 306)"],[1024,720,5,"ereneben eben k8s"],[1024,768,5,"samsung sm-p350 galaxy tab a plus"],[1184,720,4,"lg x screen (k500, f650)"],[1188,720,4,"lg band play (f570s)"],[1196,720,4,"fly a5042"],[1199,720,4,"lg stylus 2 (f720, k520, k540, ls775 g stylo 2, l82vl)"],[1200,720,4,"lg g4 stylus (h63x, ms631, f560, ls770 g stylo)"],[1208,720,4,"vizio xr6m10 tablet remote"],[1217,720,4,"lenovo pb1-750x phab"],[1224,720,4,"c spire ft7"],[1280,720,3,"bgh joy smart axs ii"],[1280,736,4,"vodafone smart tab 4g"],[1280,752,4,"huawei mediapad t1 10 (t1-a21)"],[1216,800,4,"huawei mediapad t1 8.0 pro, lte (adreno 306)"],[1280,800,4,"samsung galaxy tab e 8.0 (adreno 306, sm-t377p)"],[1794,1080,2,"bluebird sf550"],[1815,1080,2,"vizio xr6"],[1920,1080,2,"longcheer cc01"]]],["qualcomm adreno 308","308",0,[[800,480,13,"samsung galaxy folder 2 (sm-g160x)"],[854,480,12,"coolpad 3632"],[960,540,10,"samsung sm-j250g"],[1184,720,5,"infocus 00ww"],[1187,720,6,"lg m200"],[1193,720,6,"lg k20 plus (mp260, k20 v vs501)"],[1195,720,6,"lg x charge (x power 2, m322, l63bl fiesta)"],[1199,720,6,"lg stylo 3 (l83bl)"],[1280,720,6,"hisense f23"],[1280,736,6,"lenovo tb-8504"],[1280,752,6,"lenovo tb-x304"],[1344,720,6,"wiko view"],[1223,800,6,"huawei mediapad t3 8.0 (kob-xxx)"],[1368,720,6,"casper via g1"],[1280,800,6,"samsung galaxy tab a2 s (sm-t380, sm-t385)"]]],["qualcomm adreno 320","320",0,[[1196,720,11,"pantech im-a850 vega r3"],[1196,768,10,"google nexus 4 (lg e960)"],[1280,720,8,"blackberry z30"],[1280,752,8,"asus memo pad 10 (k01e me103k)"],[1280,768,10,"lg optimus g (e97x, ls970, e987, f180, kddi lgl21)"],[1920,1008,5,"technicolor px36"],[1794,1080,5,"sony xperia z (c66xx, so-02e, l36x)"],[1848,1080,5,"pantech im-a860 vega n6"],[1920,1080,5,"zte nubia z5 (nx501, nx50x)"],[1920,1104,5,"google nexus 7 (2nd gen, razor)"],[1920,1114,4,"lg g pad 8.3 (vk810 4g)"],[1920,1128,5,"sony xperia tablet z (sgp3xx, so-03e)"]]],["qualcomm adreno 330","330",0,[[800,480,18,"samsung sm-w2014"],[1184,720,27,"sony so-04g xperia a4"],[1196,720,21,"sony xperia j1 compact (d5788)"],[1202,720,21,"lg g flex (d95x, ls995, lgl23, f340)"],[1280,720,20,"amazon fire phone (sd4930ur)"],[1280,768,21,"samsung sm-w2015 galaxy golden 2"],[1280,960,14,"lg f300 optimus vu 3"],[1600,1152,15,"hp pro slate 12"],[1440,1308,10,"blackberry passport"],[1776,1080,11,"google nexus 5"],[1788,1080,11,"lg g3 a f410"],[1794,1080,10,"fujitsu f-01f arrows nx luge (docomo)"],[1803,1080,11,"lg g pro 2 (d838, f350)"],[1836,1080,11,"sony xperia z ultra (c68xx, xl39h, sol24, sgp412)"],[1920,1080,9,"qualcomm quanta is7"],[1920,1104,12,"ntt docomo sh-06f sharp aquos pad"],[1920,1128,12,"sony xperia z2 tablet (sgp5xx, so-05f, sot21)"],[1920,1129,10,"lg g pad ii (v935, v940 prada 3.0, v930 g pad x 10.1, uk932)"],[1920,1200,9,"amazon kindle fire hdx 7 (3rd gen, kfthwa, kfthwi)"],[2048,1440,8,"hp red"],[2392,1440,8,"fujitsu f-02g arrows nx (docomo)"],[2400,1440,6,"iuni u3"],[2560,1440,7,"vivo x520l xplay 3s"],[2560,1504,7,"ntt docomo f-03g (fujitsu arrows tab)"],[2560,1600,5,"samsung sm-t525 galaxy tab pro 10.1"]]],["qualcomm adreno 405","405",0,[[1184,720,13,"lyf ls-5015 water 8"],[1196,720,10,"alcatel 6044 one touch pop up"],[1200,720,12,"oppo a53"],[1280,720,8,"hisense c1"],[1280,736,10,"asus zenpad 8 (adreno 405, p024 z380kl)"],[1776,1080,7,"lyf ls-5505"],[1794,1080,6,"medion life x5020"],[1798,1080,7,"lg h740 g vista 2"],[1800,1080,6,"oppo r7s plus"],[1803,1080,6,"oppo r7 plus (adreno 405)"],[1812,1080,6,"ramos mos1"],[1824,1080,6,"vargo ivargo v210101"],[1836,1080,6,"lenovo pb1-770m everypad3"],[1920,1080,2,"smartisan yq607 jianguo"],[1920,1104,5,"lg vk815 g pad x8.3, p815l g pad ii 8.3"],[1920,1111,6,"lg g pad x 8.0 (v52x)"],[1794,1200,5,"qisda f80"],[1920,1128,5,"huawei mediapad t2 10.0 pro (fdr-xxx)"],[1830,1200,6,"huawei mediapad x3 (ple-xxx)"],[1836,1200,6,"huawei mediapad t2 8.0 pro (jdn-xxx)"]]],["qualcomm adreno 418","418",0,[[1280,768,28,"samsung sm-g9198"],[1776,1080,17,"sharp sh-m03 aquos mini"],[1794,1080,15,"softbank 502sh (sharp aquos xx2)"],[1920,1080,11,"smartisan t2 (sm801)"],[2368,1440,10,"fujitsu f-02h arrows nx (docomo)"],[2392,1440,10,"lg k600"],[2413,1440,10,"motorola moto x style, pure (xt1570, xt1572, xt1575)"],[2560,1440,9,"qiku q terra (8692-a00)"],[2560,1504,9,"ntt docomo f-04h arrows tab"]]],["qualcomm adreno 420","420",0,[[1280,720,32,"odg r7-w"],[1920,1080,20,"samsung galaxy s5 (adreno 420, sm-g901)"],[2392,1440,13,"lg g3 (adreno 420, f460)"],[2560,1352,7,"qualcomm apq8084 (adreno 420, development board)"],[2413,1440,12,"motorola moto x pro"],[2560,1440,8,"qualcomm liquid (adreno 420, windows, development board)"],[2560,1532,12,"samsung galaxy note edge (adreno 420, sm-n915x, scl24, sc-01g)"],[2560,1600,11,"amazon kindle fire hdx 8.9 (4th gen, kfsawa, kfsawi)"]]],["qualcomm adreno 430","430",0,[[1184,720,53,"sony xperia z5 compact (e58xx, so-02h)"],[1280,720,18,"zebra technologies mtp8994"],[1776,1080,29,"sony xperia z5 (e66xx, so-01h, sov32, 501so)"],[1794,1080,19,"vertu signature touch (2015)"],[1920,1080,9,"nokia rm-1106"],[1920,1104,21,"ntt docomo sh-05g sharp aquos pad"],[2392,1440,11,"sony e6508 vzw xperia z4v"],[2413,1440,17,"sirin labs solarin"],[2560,1440,7,"microsoft rm-1105"],[2560,1504,16,"sony xperia z4 tablet (sgp7xx, so-05g, sot31)"]]],["qualcomm adreno 505","505",0,[[728,480,29,"zebra technologies tc25"],[1184,720,15,"ivvi i3-01"],[1196,720,15,"huawei honor 6c (dig-xxx)"],[1199,720,14,"lg stylus 2 plus (ms550, k550)"],[1280,720,14,"xiaomi land"],[1344,720,14,"wiko view prime"],[1368,720,13,"micromax hs3"],[1776,1080,7,"hisense a2"],[1787,1080,7,"lg qua phone px (lgv33)"],[1794,1080,7,"pantech im-100 vega"],[1798,1080,8,"lg stylo 3 plus (tp450, mp450, m470)"],[1802,1080,7,"lg k11 (k530, k535)"],[1812,1080,7,"sugar f11"],[1920,1080,6,"lg x venture (h700, m710)"],[1920,1111,6,"lg g pad x ii 8.0 plus (v530)"],[2004,1080,7,"lg q6 (m700, x600)"],[1920,1128,7,"vodafone vfd 1400"],[1920,1132,7,"huawei mediapad t3 lite 10 (bah-xxx)"],[1839,1200,7,"huawei mediapad m3 lite 8.0 (cpn-xxx)"]]],["qualcomm adreno 506","506",0,[[1184,720,20,"fujitsu f-04j docomo"],[1280,720,20,"samsung galaxy j7 2017 (adreno 506, sm-j727x)"],[1320,720,18,"xiaomi redmi 5"],[1356,720,18,"vivo v7 plus (1716)"],[1620,1080,11,"blackberry bbb100-x (keyone, mercury)"],[1776,1080,10,"condor plume h1"],[1788,1080,10,"huawei nova (caz-xxx)"],[1794,1080,10,"nuans neo reloaded"],[1920,1080,9,"blackberry bbd100"],[1920,1104,9,"nec lavietab pc-ts508fam"],[1980,1080,10,"xiaomi redmi 5 plus"],[1920,1128,9,"zte k92 primetime"],[1920,1132,9,"vestel v tab 1090 lte"],[1920,1200,9,"i.safe is910.1"]]],["qualcomm adreno 508","508",0,[[1776,1080,15,"sonim xp8812"],[1798,1080,15,"sharp fs8010"],[1920,1080,14,"htc u11 life"],[2009,1080,14,"vestel venus z20"]]],["qualcomm adreno 509","509",0,[[2159,1080,15,"asus zenfone 5"]]],["qualcomm adreno 510","510",0,[[1184,720,31,"zebra technologies tc51"],[1208,800,27,"askey turbonet tn800a1 turbotab e1"],[1366,720,29,"sony xperia touch (g1109)"],[1776,1080,13,"agm x2"],[1794,1080,14,"qualcomm msm8952 (adreno 510, development board)"],[1920,1080,14,"coolpad r116 cool1"],[2048,1440,11,"asus zenpad 3 8.0 (p008 z581kl)"],[2160,1440,10,"jide remix pro"],[2048,1536,11,"asus zenpad z10 (p00i zt500kl)"],[2368,1440,10,"vodafone vfd 900"],[2392,1440,10,"sharp aquos z3 (fs8009)"],[2413,1440,9,"infocus m820"],[2560,1440,9,"vivo pd1522a"],[2560,1504,9,"lenovo yoga tab3 plus (yt-x703)"]]],["qualcomm adreno 512","512",0,[[782,480,59,"honeywell cn80"],[1798,1080,23,"sharp fs8016"],[1920,1080,22,"vivo td1608"],[2016,1080,22,"oppo r11s"],[2034,1080,22,"vivo x20a"],[2151,1080,20,"xiaomi redmi note 7"]]],["qualcomm adreno 530","530",0,[[1600,900,56,"keecker keecker"],[1776,1080,43,"softbank 506sh (sharp aquos phone xx3)"],[1794,1080,49,"google pixel"],[1920,1024,47,"contextmedia p-wal-107-elc-03"],[1920,1080,26,"nokia 6071w"],[2048,1536,35,"samsung galaxy tab s3 (sm-t82x)"],[2368,1440,27,"motorola xt1650 (1.8 ghz)"],[2392,1440,21,"lg q8 (h970, x800l)"],[2416,1440,31,"alcatel 6076s"],[2560,1439,17,"hp elite x3"],[2560,1440,4,"hp falcon"],[2672,1440,30,"lg g6 (g600, us997, ls993, vs988, h87x)"],[2880,1440,26,"baofeng ke-01"],[3840,2076,15,"via vt6093"]]],["qualcomm adreno 540","540",0,[[1184,720,61,"sony xperia xz1 compact (g8441)"],[1776,1080,57,"sony xperia xz1 (g834x, sov36, so-01k, 701so)"],[1794,1080,57,"google pixel 2 (walleye)"],[1920,1080,56,"zte nx595j nubia"],[1980,1080,56,"xiaomi mi mix 2"],[2034,1080,55,"oneplus 5t (a5010)"],[2276,1312,43,"essential ph-1"],[2368,1440,39,"sharp aquos r (sh-03j, shv39, 605sh)"],[2392,1440,41,"qualcomm adreno 540 (development board)"],[2416,1440,40,"razer phone"],[2560,1440,36,"htc u11 (u-3x, 2pzc100, 2pzc5, htv33, 601ht)"],[2678,1440,35,"samsung galaxy s8 active (sm-g892)"],[2768,1440,33,"samsung galaxy s8+ (adreno 540, sm-g955x, sc-03j, scv35)"],[2960,1440,33,"samsung galaxy note 8 (adreno 540, sm-n950, sc-01k, scv37)"]]],["qualcomm adreno 615","615",0,[[2560,1492,18,"samsung galaxy tab s5e sm-t720"]]],["qualcomm adreno 616","616",0,[[2047,1080,30,"meizu x8"]]],["qualcomm adreno 618","618",0,[[2183,1080,38,"samsung galaxy a71 (sm-a715f)"],[2274,1080,37,"samsung galaxy a80 sm-a805f"]]],["qualcomm adreno 630","630",0,[[2792,1440,49,"samsung galaxy s9+ (adreno 630, sm-g965)"]]],["qualcomm adreno 640","640",0,[[2020,1080,60,"samsung galaxy s10e (adreno 640, sm-g970x)"],[2064,1080,60,"samsung galaxy note 10 (adreno 640, sm-n970x)"],[2181,1080,60,"samsung galaxy s10 lite"],[2198,1080,60,"samsung galaxy a90 5g"],[2210,1080,79,"xiaomi redmi k20 pro premium edition"],[2048,1410,59,"samsung galaxy fold 5g (adreno 640, sm-f900x)"],[2723,1440,55,"samsung galaxy s10 (adreno 640, sm-g973x)"],[2730,1440,56,"samsung galaxy s10+ (adreno 640, sm-g975x)"],[2759,1440,56,"samsung galaxy note 10+ (adreno 640, sm-n975x)"],[2901,1440,55,"samsung galaxy s10 5g (adreno 640, sm-g977x)"]]],["qualcomm adreno 650","650",0,[[2274,1080,90,"asus zenfone 7"],[3101,1387,50,"samsung galaxy s20 ultra 5g (sm-g988u1)"]]]]')},535:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["apple a10 gpu","10",0,[[2048,1536,41,"apple ipad (6th gen)"],[2160,1620,36,"apple ipad (10.2-inch) (7th generation)"]]],["apple a10x gpu","10",0,[[2048,1536,59,"apple ipad pro (10.5-inch)"],[2224,1668,69,"apple ipad pro (10.5-inch)"],[2732,2048,46,"apple ipad pro (12.9-inch, 2nd gen)"]]],["apple a12 gpu","12",0,[[2048,1536,60,"apple ipad mini (2019)"]]],["apple a12x gpu","12",0,[[2224,1668,116,"apple ipad pro (11-inch)"],[2388,1668,115,"apple ipad pro (11-inch)"],[2732,2048,60,"apple ipad pro (12.9-inch) (3rd generation)"]]],["apple a12z gpu","12",0,[[2388,1668,115,"apple ipad pro (11-inch) (2nd generation)"],[2732,2048,60,"apple ipad pro (12.9 inch) (4th generation)"]]],["apple a13 gpu","13",0,[[2160,1620,59,"apple ipad 9th gen"]]],["apple a14 gpu","14",0,[[2388,1668,52,"apple ipad air 4th gen (wi-fi only)"]]],["apple a15 gpu","15",0,[[2388,1668,60,"apple ipad mini (6th gen)"]]],["apple a7 gpu","7",0,[[2048,1536,10,"apple ipad mini 3"]]],["apple a8 gpu","8",0,[[2048,1536,16,"apple ipad mini 4"]]],["apple a8x gpu","8",0,[[2048,1536,30,"apple ipad air 2"]]],["apple a9 gpu","9",0,[[2048,1536,29,"apple ipad 9.7 (5th gen)"]]],["apple a9x gpu","9",0,[[2048,1536,40,"apple ipad pro 9.7"],[2732,2048,35,"apple ipad pro"]]],["apple m1 gpu","1",0,[[2732,2048,60,"apple ipad pro (12.9-inch) (5th generation)"]]]]')},438:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["apple a10 gpu","10",0,[[1334,750,104,"apple iphone 7"],[1920,1080,60,"apple iphone 7 plus"],[2001,1125,59,"apple iphone x"]]],["apple a11 gpu","11",0,[[1334,750,64,"apple iphone 8"],[1920,1080,78,"apple iphone 8 plus"]]],["apple a12 gpu","12",0,[[1792,828,60,"apple iphone xr"],[2436,1125,57,"apple iphone xs"],[2208,1242,60,"apple iphone xs max"]]],["apple a13 gpu","13",0,[[1334,750,60,"apple iphone se (2nd gen)"],[1792,828,61,"apple iphone 11"],[2436,1125,60,"apple iphone 11 pro"],[2688,1242,61,"apple iphone 11 pro max"]]],["apple a14 gpu","14",0,[[2338,1080,60,"apple iphone 12 mini"],[2436,1125,60,"apple iphone 12"],[2778,1284,60,"apple iphone 12 pro max"]]],["apple a15 gpu","15",0,[[2338,1080,60,"apple iphone 13 mini"],[2436,1125,60,"apple iphone 13 pro"],[2688,1242,60,"apple iphone 13 pro max"]]],["apple a7 gpu","7",0,[[1136,640,32,"apple iphone 5s"]]],["apple a8 gpu","8",0,[[1136,640,40,"apple ipod touch 6"],[1334,750,36,"apple iphone 6"],[1920,1080,21,"apple iphone 6 plus"]]],["apple a9 gpu","9",0,[[1136,640,90,"apple iphone se"],[1334,750,72,"apple iphone 6s"],[1920,1080,42,"apple iphone 6s plus"]]]]')},283:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["intel intel hd graphics for atom x5","5",0,[[1024,600,35,"amazon aeokn"],[1024,720,13,"arbor venus 8"],[1217,720,23,"gole gole1"],[1280,736,27,"medion p850x"],[1360,704,15,"chuwi hibox hero mini pc"],[1280,752,21,"tetratab casebook 3"],[1280,759,28,"lenovo yoga a12 (yb-q501f)"],[1366,720,19,"nextbook nx16a11264 ares 11 (x5-z8300)"],[1920,996,20,"teclast x16 pro"],[1920,1008,12,"teclast tbook 16 pro"],[1920,1016,13,"teclast x16 plus"],[1920,1104,13,"medion p851x"],[1920,1116,13,"teclast x80 pro (x5-z8350)"],[1920,1128,8,"cube technology i12-y"],[1920,1133,9,"cube technology i1-tfp (x5-z8350)"],[1920,1134,11,"microtech e-tab pro lte"],[1920,1136,14,"cube technology iwork 10 ultimate (i15-t)"],[1920,1214,10,"chuwi cw-hi10 plus (x5-z8350)"],[2048,1440,8,"teclast x98 plus"],[2160,1368,10,"chuwi hi12 (x5-z8350)"],[2048,1452,10,"teclast x98 plus ii"],[2048,1536,14,"xiaomi mi pad 2"],[2560,1356,7,"baofeng a1"],[2560,1504,6,"chuwi hibook pro (z8350)"],[2560,1518,11,"lenovo yt3-x90 yoga tablet 3 pro (x5-z8550)"]]],["intel intel hd graphics for baytrail","hdfor",0,[[1024,552,13,"multilaser intel 7qc"],[1024,696,17,"thundersoft dual os tablet"],[1024,720,15,"airis onepad 785i"],[1184,720,18,"trimble tdc500"],[1280,736,12,"acer a1-840"],[1280,752,9,"imuz mupad win 10.1 ii"],[1366,720,13,"nextbook nxa116qc164"],[1366,724,10,"cube technology i10 remix"],[1440,1008,12,"teclast x89 kindow"],[1920,1008,8,"minix neo z64"],[1920,1014,9,"cube technology i7 cx remix"],[1920,1032,11,"hp slate 17"],[1920,1104,5,"jltd d630"],[1920,1128,6,"intel(r) e1008"],[1920,1133,9,"pipo w3f"],[2048,1440,6,"kruger & matz eagle 975 (km0975)"],[2048,1448,6,"jide e-tab 3g"],[2048,1464,6,"reeder a10ix air"],[2560,1344,7,"lenovo yoga tablet 2 pro-1380"],[2560,1504,5,"teclast x10hd 3g"]]],["intel mesa dri intel bay trail","dribay",0,[[1366,768,15,"google chromebook pixel (2015, n2830)"]]],["intel mesa dri intel hd","drihd",0,[[688,412,39,"hp chromebook x360 11 g1 ee"],[960,568,36,"google chromebook pixel (2015, n3450)"],[1024,561,28,"aaeon up-cht01 up board"],[1024,736,33,"google chromebook reef (n3350)"]]],["intel mesa dri intel hd graphics 400","400",0,[[688,412,41,"asus c202sa chromebook"],[768,431,45,"hp chromebook 11 g5"],[960,568,25,"acer chromebook r11 (n3050)"],[1366,768,19,"samsung chromebook 3"],[1536,832,25,"google chromebook r11 (n3160)"],[1920,1080,17,"acer chromebook 14"]]],["intel mesa dri intel hd graphics 510","510",0,[[690,378,53,"hp chromebook chell"],[688,412,60,"acer chromebook 14 for work"]]],["intel mesa dri intel hd graphics 515","515",0,[[1033,617,56,"samsung chromebook pro (m7-6y75, caroline)"],[1536,1088,32,"google chromebook pixel (2015, m3-6y30)"],[1920,980,32,"asus c302 chromebook flip"],[2400,1504,22,"samsung chromebook pro (caroline)"],[3200,1640,12,"google chromebook pixel (2015, 4405y)"]]],["intel mesa dri intel hd graphics 520","520",0,[[700,412,60,"acer chromebook 14 for work (i3-6100u)"]]],["intel mesa dri intel hd graphics 5500","5500",0,[[1080,575,59,"google chromebook pixel (2015, i3-5005u)"],[1920,1000,30,"google chromebook pixel (2015, i5-5300u)"],[2560,1700,14,"google chromebook pixel (2015, i5-5200u)"]]],["intel mesa dri intel hd graphics 615","615",0,[[1034,618,55,"google soraka (4415y)"],[1200,720,34,"google poppy (4410y, kabylake)"],[2400,1504,21,"google chromebook eve (i5-7y54)"]]],["intel mesa dri intel kabylake gt2","2",0,[[960,568,38,"google chromebook pixel (2015, m3-7y30)"]]]]')},327:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["arm mali-t604 mp4","604",0,[[2560,1504,4,"google nexus 10"]]],["arm mali-t622","622",0,[[1024,564,12,"telechips tcc896x (quad core, development board)"],[1280,720,7,"leadcore l1860 (mali-t622, development board)"]]],["arm mali-t624","624",0,[[1794,1080,7,"huawei grace"],[1812,1080,6,"huawei abc-ul00"],[1830,1080,10,"huawei p8 max (dav-70x)"],[1920,1080,4,"sony amai vp9"],[1920,1104,9,"huawei dtab compact d-02h (docomo)"],[1920,1128,8,"huawei dtab d-01h (docomo)"],[1824,1200,9,"huawei mediapad m2 (m2-80xx)"],[1830,1200,9,"huawei mediapad x2 (gem-701l, gem-702l, gem-703l)"]]],["arm mali-t624 mp2","624",0,[[1280,720,5,"samsung sm-g910f (mali-t624)"]]],["arm mali-t624 mp4","624",0,[[1794,1080,9,"huawei z100"]]],["arm mali-t628","628",0,[[1024,600,30,"thinkware inavi davinci"],[2560,1536,8,"meizu mx4 pro"]]],["arm mali-t628 mp2","628",0,[[1280,720,8,"leadcore l1860 (development board)"]]],["arm mali-t628 mp6","628",0,[[800,480,35,"gen2wave rp1600"],[1280,672,14,"hardkernel odroid-xu3 (development board)"],[1280,720,26,"samsung galaxy alpha (mali-t628, sm-g850)"],[1920,1080,11,"samsung galaxy note iii (mali-t628, sm-n900, sm-n9000q)"],[2560,1600,3,"samsung sm-t520 galaxy tab 10.1"]]],["arm mali-t720","720",0,[[432,240,16,"unihertz jelly pro"],[782,480,8,"mobiistar lai zoro"],[784,480,8,"lg k3 (k100)"],[791,480,6,"i-mobile i-style 812 4g"],[800,480,4,"lava iris 550"],[854,480,3,"verykool sl5009 jet"],[897,540,5,"bluboo xfire"],[960,540,3,"siswoo a5 chocolate"],[1024,552,4,"bb-mobile tq763i techno 7.0 lte"],[1024,714,9,"bluedot bnt-791 (2g)"],[1024,720,3,"zte e8qp"],[1280,624,10,"panasonic p55 novo 4g"],[1280,648,4,"tcl 9025"],[1280,656,7,"acer a1-734 iconia talk s"],[1184,720,4,"lenovo xt1700, xt1706, k10a40"],[1187,720,7,"lg k8 (k350)"],[1189,720,5,"ark impulse p2"],[1193,720,7,"lg x power (k220, f750)"],[1196,720,2,"dtac phone m2"],[1198,720,5,"dtac phone t3"],[1205,720,7,"firefly aurii passion"],[1206,720,4,"archos 50 power"],[1208,720,3,"advan i7 plus"],[1217,720,7,"energy sistem energy phone max 2+"],[1238,720,9,"vnpt technology vivas lotus s3 lte"],[1280,720,2,"archos bush spira c2 5"],[1280,736,2,"digma cs1062ml citi 1903 4g"],[1280,737,3,"waywalkers t805g"],[1280,740,3,"casper via l8"],[1280,746,3,"philips tle821l e line 4g"],[1280,752,3,"4good light at200"],[1280,755,7,"leotec letab1020 supernova qi32"],[1356,720,8,"xiaolajiao la-v11"],[1360,720,7,"tecno in5"],[1368,720,7,"tinno p100"],[1280,800,4,"samsung galaxy tab e 8.0 (sm-t375x, sm-t377x)"],[1920,936,4,"panasonic eluga note"],[1920,996,4,"cube technology u83 iplay10"],[1776,1080,4,"fly fs522 cirrus 14"],[1787,1080,5,"lg x cam (k580, f690)"],[1920,1008,6,"alcatel one touch xess (p17aa)"],[1794,1080,3,"ramos mos 1 max"],[1800,1080,4,"archos sense 55 s"],[1815,1080,4,"archos diamond plus"],[1920,1032,5,"virgin media tellytablet"],[1920,1080,2,"infocus m640"],[1920,1104,4,"vestel v tab 7030"],[1920,1116,4,"jty q101"],[1920,1128,2,"archos 80 oxygen"],[2009,1080,4,"tcl 5099"],[1920,1136,4,"asus zenpad 10 (p028 z301m)"]]],["arm mali-t760","760",0,[[854,480,14,"aux t6200l"],[897,540,13,"sony xperia e4g (e20xx)"],[960,540,12,"gionee v381"],[960,568,24,"asus c100pa chromebook flip"],[1024,552,12,"archos 70 helium"],[1024,720,10,"wiz t-8168"],[1188,720,9,"lg h520 magna, h522 prime plus"],[1196,720,9,"acer s57 liquid jade z"],[1280,720,8,"dunetek vitamin a"],[1280,736,8,"archos 80b helium"],[1280,752,8,"frael m10g 4g"],[1280,768,8,"meizu m1"],[1794,1080,6,"sugar 2 ss136 l8560"],[1920,1032,9,"qbic bxp-300 box pc"],[1920,1080,4,"byxpress mphone xone"],[1920,1104,6,"cube technology t7"],[1920,1128,5,"nec lavietab pc-te510bal"],[2048,1440,3,"teclast p98 4g"],[2560,1440,10,"samsung galaxy note 4 (mali-t760, sm-n910x, sm-n916)"]]],["arm mali-t760 mp6","760",0,[[1920,1080,17,"samsung galaxy a8 (mali-t760, sm-a800x, scv32)"],[2048,1536,12,"samsung galaxy tab s 2 8.0 (sm-t710, sm-t715)"],[2560,1532,10,"samsung galaxy note edge (mali-t760, sm-n915x)"],[2560,1600,10,"samsung galaxy tab s 10.5 (mali-t760, sm-t805s)"]]],["arm mali-t760 mp8","760",0,[[1280,768,42,"samsung sm-w2016"],[1920,1080,25,"meizu niux"],[2160,1200,17,"idealens k2"],[2560,1440,12,"le xiang deepoon m2 vr"],[2560,1504,15,"bungbungame kalos 2"]]],["arm mali-t764","764",0,[[1024,600,19,"gpd q9"],[1280,720,15,"gpd xd"],[1280,752,13,"kruger & matz 1064.1g eagle"],[1280,800,13,"pipo p7"],[1920,1008,6,"rockchip mk809 4k tv stick"],[1920,1010,8,"pipo p7 hd"],[1920,1020,5,"rockchip mk903v mini tv"],[1920,1032,7,"acooo oneboard pro+"],[1872,1080,7,"contextmedia wallboard 32 tablet (p-wal-106-yit-01)"],[1920,1080,7,"rockchip cs4k tv box"],[1920,1128,7,"archos 101 oxygen"],[2048,1437,5,"haier pad 971"],[2048,1440,5,"hisense f5281 vidaa pad"],[2560,1504,4,"teclast p90hd"]]],["arm mali-t820","820",0,[[1344,720,5,"lenovo k320t"],[1776,1080,6,"leagoo t5c"],[1920,1008,7,"probox2 ava tv box"],[1920,1080,4,"skyworth coocaa 5s32 n2"]]],["arm mali-t830","830",0,[[1280,720,9,"samsung galaxy on7 (mali-t830, sm-g600x)"],[1280,800,9,"samsung sm-t536 (mali-t830)"],[1776,1080,9,"huawei p10 lite (was-xxx)"],[1794,1080,9,"huawei honor 6x (bln-xxx)"],[1920,1080,5,"samsung galaxy on7 prime 2018 (sm-g611)"],[2033,1080,8,"huawei p smart (fig-xxx)"],[2040,1080,9,"huawei maimang 6 (rne-xxx)"],[1920,1200,5,"samsung galaxy tab a 10.1 (sm-t580, sm-t585)"]]],["arm mali-t860","860",0,[[1184,720,8,"tcl a626"],[1196,720,8,"green orange go t2"],[1280,720,14,"htc one a9s"],[1920,1024,17,"hardkernel odroid-n1 (development board)"],[1920,1032,16,"contextmedia p-wal-108-elc-02"],[1920,1080,7,"htc u play (u-2u)"],[1920,1116,15,"imuz revolution a8"],[1920,1128,15,"rockchip rk3399 (development board)"],[2400,1440,10,"samsung chromebook plus (kevin)"]]],["arm mali-t860 mp2","860",0,[[598,480,25,"cipherlab 9700a"],[1184,720,11,"vernee m5"],[1193,720,11,"lg x power 2 (u+, x500, m-x320, m320)"],[1196,720,11,"lava z25"],[1199,720,11,"lg stylus 3 (m400)"],[1212,720,11,"meeg 306"],[1280,720,10,"oppo r66"],[1336,720,13,"asus pegasus 4s (x018d zb570tl)"],[1344,720,13,"allview x4 soul infinity n"],[1776,1080,7,"benq f55"],[1794,1080,6,"alcatel 7070"],[1798,1080,7,"energy sistem energy phone pro 3"],[1806,1080,8,"tecno phantom 6"],[1807,1080,7,"covia fleaz cp-j55a g07"],[1810,1080,8,"archos 55 diamond 2 plus"],[1920,1080,4,"advan vandroid i55c"],[2004,1080,7,"asus zenfone max plus m1 (x018d zb570tl)"],[1920,1128,7,"verizon qtaxia1"]]],["arm mali-t880","880",0,[[1184,720,22,"doogee mix"],[1280,720,20,"lenovo k8"],[1344,720,18,"casper via f2"],[1776,1080,11,"alcatel 6060 (mali-t880)"],[1794,1080,20,"huawei mate 8 (nxt-xxx)"],[1824,1080,11,"meiigoo m1"],[1920,1080,10,"letv leeco lex650"],[2016,1080,9,"vernee mix 2"],[2064,1080,10,"umi s2 pro"],[2392,1440,12,"huawei honor v8 (knt-al20)"],[2434,1440,11,"huawei honor note 8 premium edition (edi-al10)"],[2560,1440,24,"meizu pro 6 plus"],[2560,1480,10,"huawei dtab compact d-01j (docomo)"],[2560,1600,10,"huawei mediapad m3 (btv-xxx)"]]],["arm mali-t880 mp12","880",0,[[1920,1080,44,"samsung galaxy s7 (sm-g930f)"],[2560,1440,27,"samsung galaxy note 7 (mali-t880, sm-n930)"]]],["arm mali-t880 mp2","880",0,[[1184,720,19,"sony pikachu"],[1376,720,17,"umi s2"],[1776,1080,10,"coolpad a9s-9"],[1800,1080,11,"infinix x603"],[1920,1080,9,"innjoo pro2"]]],["arm mali-t880 mp4","880",0,[[1280,672,18,"mediatek x20 (development board)"],[1794,1080,13,"infocus tsp"],[1800,1080,16,"infinix x602 zero 4 plus"],[1806,1080,16,"tecno phantom a9"],[1810,1080,8,"mobiistar prime x pro"],[1815,1080,16,"tecno phantom 6 plus"],[1920,1080,7,"elephone r9"],[2048,1440,12,"brown tab 1"],[2392,1440,12,"vernee apollo"],[2416,1440,11,"freetel ftj162b kiwami2"],[2560,1440,10,"ivvi i5"]]],["mali-t830","830",0,[[1480,720,10,"samsung gm-j600fn"]]]]')},538:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["arm mali-g31","31",0,[[1920,1080,7,"mecool km9 pro"]]],["arm mali-g51","51",0,[[1920,636,10,"telechips tcc803x_lcn"],[1920,1080,5,"skyworth 8n10 g1a"]]],["arm mali-g52 mc1","52",0,[[1280,736,25,"amazon fire hd 8 (kfonwi, 2020)"]]],["arm mali-g52 mc2","52",0,[[2110,1080,23,"xiaomi redmi 10x 4g"],[2264,1080,20,"xiaomi redmi 9 m2004j19c"],[2400,1080,20,"huawei y9a frl-l22"]]],["arm mali-g57 mc3","57",0,[[2158,1080,48,"realme rmx2173"]]],["arm mali-g71","71",0,[[1280,720,14,"samsung sm-j337"],[1812,1080,53,"huawei mate 9 (mha-xxx)"],[1920,1080,12,"sony amai vp9 (mali-g71)"],[2009,1080,11,"tcl 6062"],[2016,1080,11,"gionee s11"],[2038,1080,10,"ulefone power 3"],[2076,1080,15,"samsung galaxy a8 2018 (sm-a530x)"],[2094,1080,15,"samsung sm-a730x"],[2160,1080,9,"oukitel k6"],[2368,1440,35,"huawei honor v9 (duk-xxx)"],[2560,1440,32,"huawei mate 9 pro (lon-xxx)"],[2678,1440,41,"samsung galaxy s8 (mali-g71, sm-g950x)"],[2960,1440,39,"samsung galaxy s8+ (mali-g71, sm-g955x)"]]],["arm mali-g72","72",0,[[2041,1080,55,"huawei mate 10 pro (bla-xxx)"],[2160,1080,56,"huawei honor view 10 (v10, bkl-xxx)"],[2560,1440,43,"huawei mate 10 (alp-xxx)"],[2768,1440,47,"samsung galaxy s9 (mali-g72, sm-g960)"],[2792,1440,47,"samsung galaxy s9+ (mali-g72, sm-g965)"]]],["arm mali-g76","76",0,[[2020,1080,60,"samsung galaxy s10e (mali-g76, sm-g970x)"],[2029,1080,31,"samsung galaxy s10 plus sm-g975n"],[2064,1080,60,"samsung galaxy note 10 5g (mali-g76, sm-n971x)"],[2159,1080,47,"samsung galaxy a51 5g"],[2232,1080,59,"huawei honor 20 pro yal-l41"],[2328,1128,60,"huawei mate 30 pro (lio-lx9, lio-xl00"],[2723,1440,57,"samsung galaxy s10 (mali-g76, sm-g973x)"],[2730,1440,56,"samsung galaxy s10+ (mali-g76, sm-g975x)"],[2733,1440,56,"samsung galaxy s10 5g (mali-g76, sm-g977x)"],[2759,1440,57,"samsung galaxy note 10+ (mali-g76, sm-n975x)"]]],["arm mali-g77","77",0,[[2178,1080,60,"samsung galaxy s20 5g (sm-g981b)"],[2200,1080,67,"samsung galaxy s20 ultra 5g (sm-g988b)"],[2304,1080,55,"oppo pdcm00"]]],["arm mali-g77 mc9","77",0,[[2293,1080,59,"oppo pdsm00"]]],["arm mali-g78","78",0,[[2646,1288,90,"huawei mate 40 pro 5g"]]],["arm mali-t604 mp4","604",0,[[2560,1504,4,"google nexus 10"]]],["arm mali-t622","622",0,[[1024,564,12,"telechips tcc896x (quad core, development board)"],[1280,720,7,"leadcore l1860 (mali-t622, development board)"]]],["arm mali-t624","624",0,[[1794,1080,7,"huawei grace"],[1812,1080,6,"huawei abc-ul00"],[1830,1080,10,"huawei p8 max (dav-70x)"],[1920,1080,4,"sony amai vp9"],[1920,1104,9,"huawei dtab compact d-02h (docomo)"],[1920,1128,8,"huawei dtab d-01h (docomo)"],[1824,1200,9,"huawei mediapad m2 (m2-80xx)"],[1830,1200,9,"huawei mediapad x2 (gem-701l, gem-702l, gem-703l)"]]],["arm mali-t624 mp2","624",0,[[1280,720,5,"samsung sm-g910f (mali-t624)"]]],["arm mali-t624 mp4","624",0,[[1794,1080,9,"huawei z100"]]],["arm mali-t628","628",0,[[1024,600,30,"thinkware inavi davinci"],[2560,1536,8,"meizu mx4 pro"]]],["arm mali-t628 mp2","628",0,[[1280,720,8,"leadcore l1860 (development board)"]]],["arm mali-t628 mp6","628",0,[[800,480,35,"gen2wave rp1600"],[1280,672,14,"hardkernel odroid-xu3 (development board)"],[1280,720,26,"samsung galaxy alpha (mali-t628, sm-g850)"],[1920,1080,11,"samsung galaxy note iii (mali-t628, sm-n900, sm-n9000q)"],[2560,1600,3,"samsung sm-t520 galaxy tab 10.1"]]],["arm mali-t720","720",0,[[432,240,16,"unihertz jelly pro"],[782,480,8,"mobiistar lai zoro"],[784,480,8,"lg k3 (k100)"],[791,480,6,"i-mobile i-style 812 4g"],[800,480,4,"lava iris 550"],[854,480,3,"verykool sl5009 jet"],[897,540,5,"bluboo xfire"],[960,540,3,"siswoo a5 chocolate"],[1024,552,4,"bb-mobile tq763i techno 7.0 lte"],[1024,714,9,"bluedot bnt-791 (2g)"],[1024,720,3,"zte e8qp"],[1280,624,10,"panasonic p55 novo 4g"],[1280,648,4,"tcl 9025"],[1280,656,7,"acer a1-734 iconia talk s"],[1184,720,4,"lenovo xt1700, xt1706, k10a40"],[1187,720,7,"lg k8 (k350)"],[1189,720,5,"ark impulse p2"],[1193,720,7,"lg x power (k220, f750)"],[1196,720,2,"dtac phone m2"],[1198,720,5,"dtac phone t3"],[1205,720,7,"firefly aurii passion"],[1206,720,4,"archos 50 power"],[1208,720,3,"advan i7 plus"],[1217,720,7,"energy sistem energy phone max 2+"],[1238,720,9,"vnpt technology vivas lotus s3 lte"],[1280,720,2,"archos bush spira c2 5"],[1280,736,2,"digma cs1062ml citi 1903 4g"],[1280,737,3,"waywalkers t805g"],[1280,740,3,"casper via l8"],[1280,746,3,"philips tle821l e line 4g"],[1280,752,3,"4good light at200"],[1280,755,7,"leotec letab1020 supernova qi32"],[1356,720,8,"xiaolajiao la-v11"],[1360,720,7,"tecno in5"],[1368,720,7,"tinno p100"],[1280,800,4,"samsung galaxy tab e 8.0 (sm-t375x, sm-t377x)"],[1920,936,4,"panasonic eluga note"],[1920,996,4,"cube technology u83 iplay10"],[1776,1080,4,"fly fs522 cirrus 14"],[1787,1080,5,"lg x cam (k580, f690)"],[1920,1008,6,"alcatel one touch xess (p17aa)"],[1794,1080,3,"ramos mos 1 max"],[1800,1080,4,"archos sense 55 s"],[1815,1080,4,"archos diamond plus"],[1920,1032,5,"virgin media tellytablet"],[1920,1080,2,"infocus m640"],[1920,1104,4,"vestel v tab 7030"],[1920,1116,4,"jty q101"],[1920,1128,2,"archos 80 oxygen"],[2009,1080,4,"tcl 5099"],[1920,1136,4,"asus zenpad 10 (p028 z301m)"]]],["arm mali-t760","760",0,[[854,480,14,"aux t6200l"],[897,540,13,"sony xperia e4g (e20xx)"],[960,540,12,"gionee v381"],[960,568,24,"asus c100pa chromebook flip"],[1024,552,12,"archos 70 helium"],[1024,720,10,"wiz t-8168"],[1188,720,9,"lg h520 magna, h522 prime plus"],[1196,720,9,"acer s57 liquid jade z"],[1280,720,8,"dunetek vitamin a"],[1280,736,8,"archos 80b helium"],[1280,752,8,"frael m10g 4g"],[1280,768,8,"meizu m1"],[1794,1080,6,"sugar 2 ss136 l8560"],[1920,1032,9,"qbic bxp-300 box pc"],[1920,1080,4,"byxpress mphone xone"],[1920,1104,6,"cube technology t7"],[1920,1128,5,"nec lavietab pc-te510bal"],[2048,1440,3,"teclast p98 4g"],[2560,1440,10,"samsung galaxy note 4 (mali-t760, sm-n910x, sm-n916)"]]],["arm mali-t760 mp6","760",0,[[1920,1080,17,"samsung galaxy a8 (mali-t760, sm-a800x, scv32)"],[2048,1536,12,"samsung galaxy tab s 2 8.0 (sm-t710, sm-t715)"],[2560,1532,10,"samsung galaxy note edge (mali-t760, sm-n915x)"],[2560,1600,10,"samsung galaxy tab s 10.5 (mali-t760, sm-t805s)"]]],["arm mali-t760 mp8","760",0,[[1280,768,42,"samsung sm-w2016"],[1920,1080,25,"meizu niux"],[2160,1200,17,"idealens k2"],[2560,1440,12,"le xiang deepoon m2 vr"],[2560,1504,15,"bungbungame kalos 2"]]],["arm mali-t764","764",0,[[1024,600,19,"gpd q9"],[1280,720,15,"gpd xd"],[1280,752,13,"kruger & matz 1064.1g eagle"],[1280,800,13,"pipo p7"],[1920,1008,6,"rockchip mk809 4k tv stick"],[1920,1010,8,"pipo p7 hd"],[1920,1020,5,"rockchip mk903v mini tv"],[1920,1032,7,"acooo oneboard pro+"],[1872,1080,7,"contextmedia wallboard 32 tablet (p-wal-106-yit-01)"],[1920,1080,7,"rockchip cs4k tv box"],[1920,1128,7,"archos 101 oxygen"],[2048,1437,5,"haier pad 971"],[2048,1440,5,"hisense f5281 vidaa pad"],[2560,1504,4,"teclast p90hd"]]],["arm mali-t820","820",0,[[1344,720,5,"lenovo k320t"],[1776,1080,6,"leagoo t5c"],[1920,1008,7,"probox2 ava tv box"],[1920,1080,4,"skyworth coocaa 5s32 n2"]]],["arm mali-t830","830",0,[[1280,720,9,"samsung galaxy on7 (mali-t830, sm-g600x)"],[1280,800,9,"samsung sm-t536 (mali-t830)"],[1776,1080,9,"huawei p10 lite (was-xxx)"],[1794,1080,9,"huawei honor 6x (bln-xxx)"],[1920,1080,5,"samsung galaxy on7 prime 2018 (sm-g611)"],[2033,1080,8,"huawei p smart (fig-xxx)"],[2040,1080,9,"huawei maimang 6 (rne-xxx)"],[1920,1200,5,"samsung galaxy tab a 10.1 (sm-t580, sm-t585)"]]],["arm mali-t860","860",0,[[1184,720,8,"tcl a626"],[1196,720,8,"green orange go t2"],[1280,720,14,"htc one a9s"],[1920,1024,17,"hardkernel odroid-n1 (development board)"],[1920,1032,16,"contextmedia p-wal-108-elc-02"],[1920,1080,7,"htc u play (u-2u)"],[1920,1116,15,"imuz revolution a8"],[1920,1128,15,"rockchip rk3399 (development board)"],[2400,1440,10,"samsung chromebook plus (kevin)"]]],["arm mali-t860 mp2","860",0,[[598,480,25,"cipherlab 9700a"],[1184,720,11,"vernee m5"],[1193,720,11,"lg x power 2 (u+, x500, m-x320, m320)"],[1196,720,11,"lava z25"],[1199,720,11,"lg stylus 3 (m400)"],[1212,720,11,"meeg 306"],[1280,720,10,"oppo r66"],[1336,720,13,"asus pegasus 4s (x018d zb570tl)"],[1344,720,13,"allview x4 soul infinity n"],[1776,1080,7,"benq f55"],[1794,1080,6,"alcatel 7070"],[1798,1080,7,"energy sistem energy phone pro 3"],[1806,1080,8,"tecno phantom 6"],[1807,1080,7,"covia fleaz cp-j55a g07"],[1810,1080,8,"archos 55 diamond 2 plus"],[1920,1080,4,"advan vandroid i55c"],[2004,1080,7,"asus zenfone max plus m1 (x018d zb570tl)"],[1920,1128,7,"verizon qtaxia1"]]],["arm mali-t880","880",0,[[1184,720,22,"doogee mix"],[1280,720,20,"lenovo k8"],[1344,720,18,"casper via f2"],[1776,1080,11,"alcatel 6060 (mali-t880)"],[1794,1080,20,"huawei mate 8 (nxt-xxx)"],[1824,1080,11,"meiigoo m1"],[1920,1080,10,"letv leeco lex650"],[2016,1080,9,"vernee mix 2"],[2064,1080,10,"umi s2 pro"],[2392,1440,12,"huawei honor v8 (knt-al20)"],[2434,1440,11,"huawei honor note 8 premium edition (edi-al10)"],[2560,1440,24,"meizu pro 6 plus"],[2560,1480,10,"huawei dtab compact d-01j (docomo)"],[2560,1600,10,"huawei mediapad m3 (btv-xxx)"]]],["arm mali-t880 mp12","880",0,[[1920,1080,44,"samsung galaxy s7 (sm-g930f)"],[2560,1440,27,"samsung galaxy note 7 (mali-t880, sm-n930)"]]],["arm mali-t880 mp2","880",0,[[1184,720,19,"sony pikachu"],[1376,720,17,"umi s2"],[1776,1080,10,"coolpad a9s-9"],[1800,1080,11,"infinix x603"],[1920,1080,9,"innjoo pro2"]]],["arm mali-t880 mp4","880",0,[[1280,672,18,"mediatek x20 (development board)"],[1794,1080,13,"infocus tsp"],[1800,1080,16,"infinix x602 zero 4 plus"],[1806,1080,16,"tecno phantom a9"],[1810,1080,8,"mobiistar prime x pro"],[1815,1080,16,"tecno phantom 6 plus"],[1920,1080,7,"elephone r9"],[2048,1440,12,"brown tab 1"],[2392,1440,12,"vernee apollo"],[2416,1440,11,"freetel ftj162b kiwami2"],[2560,1440,10,"ivvi i5"]]],["mali-g71","71",0,[[2220,1080,54,"samsung s8+ sm-g955f"]]],["mali-g72","72",0,[[2220,1080,56,"samsung s9+ sm-g965f"]]],["mali-t830","830",0,[[1480,720,10,"samsung gm-j600fn"]]]]')},884:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["nvidia tegra","",0,[[2048,1440,23,"google nexus 9"]]],["nvidia tegra k1","1",0,[[1920,1008,32,"nvidia jetson tk1 (pm375, development board)"],[1920,1032,12,"lenovo k1 hd (2014)"],[1920,1080,28,"nvidia tegra gk20a (ardbeg, development board)"],[1920,1104,29,"google project tango"],[2048,1536,21,"xiaomi mi pad"],[3840,2088,8,"lenovo thinkvision 28"]]],["nvidia tegra x1","1",0,[[1920,1080,60,"nvidia shield android tv"],[2560,1688,33,"google pixel c"]]]]')},214:e=>{"use strict";e.exports=JSON.parse('["4.0.8",["powervr rogue g6110","6110",0,[[1024,600,11,"dasaita mtcd px5 head unit"],[1280,752,8,"visual land prestige prime 10se"],[1366,720,7,"ditecma m1092r"],[1920,1008,6,"vensmile t051 tv box"],[1920,1016,5,"geekbuying geekbox tv box"],[1920,1032,4,"hannspree hsg1351"],[1920,1080,5,"10moons tv box (rogue g6110)"],[1920,1128,5,"teclast p10"]]],["powervr rogue g6200","6200",0,[[1280,720,15,"infocus m530"],[1280,736,12,"amazon kindle fire hd 8 (5th gen, kfmewi)"],[1280,752,12,"amazon kindle fire hd 10 (5th gen, kftbwi)"],[1280,800,9,"amazon kindle fire hd 7 (4th gen, kfaswi)"],[1794,1080,5,"ubik uno"],[1920,1080,6,"cherry mobile x220 cosmos one plus"],[1920,1152,8,"meizu mx4 (m460, m460a, m461)"],[2392,1440,6,"hasee hl9916004"],[2560,1440,6,"condor allure a100 pgn-607"]]],["powervr rogue g6230","6230",0,[[1920,1008,8,"rikomagic mk80 tv box (tronsmart draco aw80, fantasy a80)"],[1920,1016,7,"cubietech cubieboard 4 (cc-a80, hansen-a80, development board)"],[2048,1440,5,"teclast p98air"],[2048,1464,7,"actions gs900a (development board)"]]],["powervr rogue g6400","6400",0,[[1794,1080,8,"lg f490 liger (g6400)"],[1920,1032,8,"renesas lager"]]],["powervr rogue g6430","6430",0,[[1024,552,26,"asus fonepad 7 (k01f fe171mg)"],[1280,720,27,"asus zenfone 2 (z008 ze550ml)"],[1280,736,20,"asus fonepad 7 (k019 fe375cg)"],[1280,752,27,"asus zenpad 10 (p01t z300cl)"],[1788,1080,8,"lg f490 liger (g6430)"],[1920,1080,15,"asus zenfone zoom (intel z3560, z00xsb zx551ml)"],[1920,1104,11,"asus memo pad 8 ast21 (intel z3580, k015 me581cl)"],[2048,1440,11,"asus zenpad s 8.0 (p01m z580c)"],[2560,1504,9,"dell venue 10 7040"]]],["powervr rogue ge8100","8100",0,[[906,480,8,"tinno k600"],[1184,720,5,"mediatek mt6739 (development board, rogue ge8100)"],[1339,720,5,"vodafone vfd 720"],[1344,720,6,"gionee f205"]]],["powervr rogue ge8300","8300",0,[[1280,752,9,"acer b3-a40 iconia one 10"],[1208,800,8,"verizon qtaki1"],[1920,1128,5,"acer b3-a40 fhd iconia one 10"]]],["powervr rogue gx6250","6250",0,[[688,412,16,"lenovo n23 yoga / flex 11 chromebook"],[1280,672,25,"renesas salvator-x-r8a7796"],[1280,736,25,"mediatek mt8173 (development board)"],[1920,980,10,"google chromebook pixel (2015, rogue gx6250)"],[1920,1016,14,"peloton ruby"],[1920,1020,8,"acer chromebook r13"],[1920,1032,13,"renesas salvator-x-m3"],[1920,1080,12,"xiaomi mibox 3 pro tv box"],[1920,1128,10,"amazon kindle fire hd 10 (2017, kfsuwi)"],[2048,1536,7,"alps jdtab j01"],[2560,1504,7,"onda f109"]]],["powervr rogue gx6650","6650",0,[[1280,672,52,"renesas salvator-x"],[1920,1032,24,"renesas salvator-x (octa core)"]]],["powervr rogue han","han",0,[[1794,1080,6,"ireadygo w3d"],[1920,1080,6,"changhong x6"],[2392,1440,5,"alcatel one touch d820"],[2560,1440,4,"alcatel 6071y phantom"]]],["powervr rogue hood","",0,[[1280,736,16,"dell venue 7 3740"],[1920,1080,12,"lenovo p90"],[1920,1104,9,"dell venue 8 3840"]]],["powervr rogue lando","",0,[[1920,1080,13,"spreadtrum sp9861e (development board, rogue lando)"]]],["powervr rogue marlowe","",0,[[1920,1080,39,"meitu v6 mp1605"],[2560,1440,25,"meizu pro 7 plus"]]]]')},804:(e,a,n)=>{var r={"./d-adreno.json":622,"./d-amd.json":183,"./d-apple.json":732,"./d-geforce.json":405,"./d-intel.json":178,"./d-nvidia.json":217,"./d-radeon.json":145,"./m-adreno.json":921,"./m-apple-ipad.json":535,"./m-apple.json":438,"./m-intel.json":283,"./m-mali-t.json":327,"./m-mali.json":538,"./m-nvidia.json":884,"./m-powervr.json":214};function o(e){var a=d(e);return n(a)}function d(e){if(!n.o(r,e)){var a=new Error("Cannot find module '"+e+"'");throw a.code="MODULE_NOT_FOUND",a}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=d,e.exports=o,o.id=804},354:(e,a,n)=>{var r,o=function(){function e(e,a){if(!o[e]){o[e]={};for(var n=0;n<e.length;n++)o[e][e.charAt(n)]=n}return o[e][a]}var a=String.fromCharCode,n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",o={},d={compressToBase64:function(e){if(null==e)return"";var a=d._compress(e,6,(function(e){return n.charAt(e)}));switch(a.length%4){default:case 0:return a;case 1:return a+"===";case 2:return a+"==";case 3:return a+"="}},decompressFromBase64:function(a){return null==a?"":""==a?null:d._decompress(a.length,32,(function(r){return e(n,a.charAt(r))}))},compressToUTF16:function(e){return null==e?"":d._compress(e,15,(function(e){return a(e+32)}))+" "},decompressFromUTF16:function(e){return null==e?"":""==e?null:d._decompress(e.length,16384,(function(a){return e.charCodeAt(a)-32}))},compressToUint8Array:function(e){for(var a=d.compress(e),n=new Uint8Array(2*a.length),r=0,o=a.length;o>r;r++){var i=a.charCodeAt(r);n[2*r]=i>>>8,n[2*r+1]=i%256}return n},decompressFromUint8Array:function(e){if(null==e)return d.decompress(e);for(var n=new Array(e.length/2),r=0,o=n.length;o>r;r++)n[r]=256*e[2*r]+e[2*r+1];var i=[];return n.forEach((function(e){i.push(a(e))})),d.decompress(i.join(""))},compressToEncodedURIComponent:function(e){return null==e?"":d._compress(e,6,(function(e){return r.charAt(e)}))},decompressFromEncodedURIComponent:function(a){return null==a?"":""==a?null:(a=a.replace(/ /g,"+"),d._decompress(a.length,32,(function(n){return e(r,a.charAt(n))})))},compress:function(e){return d._compress(e,16,(function(e){return a(e)}))},_compress:function(e,a,n){if(null==e)return"";var r,o,d,i={},t={},g="",m="",c="",l=2,s=3,p=2,v=[],f=0,u=0;for(d=0;d<e.length;d+=1)if(g=e.charAt(d),Object.prototype.hasOwnProperty.call(i,g)||(i[g]=s++,t[g]=!0),m=c+g,Object.prototype.hasOwnProperty.call(i,m))c=m;else{if(Object.prototype.hasOwnProperty.call(t,c)){if(c.charCodeAt(0)<256){for(r=0;p>r;r++)f<<=1,u==a-1?(u=0,v.push(n(f)),f=0):u++;for(o=c.charCodeAt(0),r=0;8>r;r++)f=f<<1|1&o,u==a-1?(u=0,v.push(n(f)),f=0):u++,o>>=1}else{for(o=1,r=0;p>r;r++)f=f<<1|o,u==a-1?(u=0,v.push(n(f)),f=0):u++,o=0;for(o=c.charCodeAt(0),r=0;16>r;r++)f=f<<1|1&o,u==a-1?(u=0,v.push(n(f)),f=0):u++,o>>=1}0==--l&&(l=Math.pow(2,p),p++),delete t[c]}else for(o=i[c],r=0;p>r;r++)f=f<<1|1&o,u==a-1?(u=0,v.push(n(f)),f=0):u++,o>>=1;0==--l&&(l=Math.pow(2,p),p++),i[m]=s++,c=String(g)}if(""!==c){if(Object.prototype.hasOwnProperty.call(t,c)){if(c.charCodeAt(0)<256){for(r=0;p>r;r++)f<<=1,u==a-1?(u=0,v.push(n(f)),f=0):u++;for(o=c.charCodeAt(0),r=0;8>r;r++)f=f<<1|1&o,u==a-1?(u=0,v.push(n(f)),f=0):u++,o>>=1}else{for(o=1,r=0;p>r;r++)f=f<<1|o,u==a-1?(u=0,v.push(n(f)),f=0):u++,o=0;for(o=c.charCodeAt(0),r=0;16>r;r++)f=f<<1|1&o,u==a-1?(u=0,v.push(n(f)),f=0):u++,o>>=1}0==--l&&(l=Math.pow(2,p),p++),delete t[c]}else for(o=i[c],r=0;p>r;r++)f=f<<1|1&o,u==a-1?(u=0,v.push(n(f)),f=0):u++,o>>=1;0==--l&&(l=Math.pow(2,p),p++)}for(o=2,r=0;p>r;r++)f=f<<1|1&o,u==a-1?(u=0,v.push(n(f)),f=0):u++,o>>=1;for(;;){if(f<<=1,u==a-1){v.push(n(f));break}u++}return v.join("")},decompress:function(e){return null==e?"":""==e?null:d._decompress(e.length,32768,(function(a){return e.charCodeAt(a)}))},_decompress:function(e,n,r){var o,d,i,t,g,m,c,l=[],s=4,p=4,v=3,f="",u=[],x={val:r(0),position:n,index:1};for(o=0;3>o;o+=1)l[o]=o;for(i=0,g=Math.pow(2,2),m=1;m!=g;)t=x.val&x.position,x.position>>=1,0==x.position&&(x.position=n,x.val=r(x.index++)),i|=(t>0?1:0)*m,m<<=1;switch(i){case 0:for(i=0,g=Math.pow(2,8),m=1;m!=g;)t=x.val&x.position,x.position>>=1,0==x.position&&(x.position=n,x.val=r(x.index++)),i|=(t>0?1:0)*m,m<<=1;c=a(i);break;case 1:for(i=0,g=Math.pow(2,16),m=1;m!=g;)t=x.val&x.position,x.position>>=1,0==x.position&&(x.position=n,x.val=r(x.index++)),i|=(t>0?1:0)*m,m<<=1;c=a(i);break;case 2:return""}for(l[3]=c,d=c,u.push(c);;){if(x.index>e)return"";for(i=0,g=Math.pow(2,v),m=1;m!=g;)t=x.val&x.position,x.position>>=1,0==x.position&&(x.position=n,x.val=r(x.index++)),i|=(t>0?1:0)*m,m<<=1;switch(c=i){case 0:for(i=0,g=Math.pow(2,8),m=1;m!=g;)t=x.val&x.position,x.position>>=1,0==x.position&&(x.position=n,x.val=r(x.index++)),i|=(t>0?1:0)*m,m<<=1;l[p++]=a(i),c=p-1,s--;break;case 1:for(i=0,g=Math.pow(2,16),m=1;m!=g;)t=x.val&x.position,x.position>>=1,0==x.position&&(x.position=n,x.val=r(x.index++)),i|=(t>0?1:0)*m,m<<=1;l[p++]=a(i),c=p-1,s--;break;case 2:return u.join("")}if(0==s&&(s=Math.pow(2,v),v++),l[c])f=l[c];else{if(c!==p)return null;f=d+d.charAt(0)}u.push(f),l[p++]=d+f.charAt(0),d=f,0==--s&&(s=Math.pow(2,v),v++)}}};return d}();void 0===(r=function(){return o}.call(a,n,a,e))||(e.exports=r)}},a={};function n(r){if(a[r])return a[r].exports;var o=a[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}return n.o=(e,a)=>Object.prototype.hasOwnProperty.call(e,a),n(607)})().default}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/async-es/asyncify.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/async-es/asyncify.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ asyncify)
/* harmony export */ });
/* harmony import */ var _internal_initialParams_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/initialParams.js */ "../../lib-jitsi-meet/node_modules/async-es/internal/initialParams.js");
/* harmony import */ var _internal_setImmediate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/setImmediate.js */ "../../lib-jitsi-meet/node_modules/async-es/internal/setImmediate.js");
/* harmony import */ var _internal_wrapAsync_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/wrapAsync.js */ "../../lib-jitsi-meet/node_modules/async-es/internal/wrapAsync.js");




/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    if ((0,_internal_wrapAsync_js__WEBPACK_IMPORTED_MODULE_0__.isAsync)(func)) {
        return function (...args/*, callback*/) {
            const callback = args.pop()
            const promise = func.apply(this, args)
            return handlePromise(promise, callback)
        }
    }

    return (0,_internal_initialParams_js__WEBPACK_IMPORTED_MODULE_1__["default"])(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (result && typeof result.then === 'function') {
            return handlePromise(result, callback)
        } else {
            callback(null, result);
        }
    });
}

function handlePromise(promise, callback) {
    return promise.then(value => {
        invokeCallback(callback, null, value);
    }, err => {
        invokeCallback(callback, err && err.message ? err : new Error(err));
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (err) {
        (0,_internal_setImmediate_js__WEBPACK_IMPORTED_MODULE_2__["default"])(e => { throw e }, err);
    }
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/async-es/internal/DoublyLinkedList.js":
/*!*******************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/async-es/internal/DoublyLinkedList.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DLL)
/* harmony export */ });
// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
// used for queues. This implementation assumes that the node provided by the user can be modified
// to adjust the next and last properties. We implement only the minimal functionality
// for queue support.
class DLL {
    constructor() {
        this.head = this.tail = null;
        this.length = 0;
    }

    removeLink(node) {
        if (node.prev) node.prev.next = node.next;
        else this.head = node.next
        if (node.next) node.next.prev = node.prev;
        else this.tail = node.prev;

        node.prev = node.next = null;
        this.length -= 1;
        return node;
    }

    empty () {
        while(this.head) this.shift();
        return this;
    }

    insertAfter(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next) node.next.prev = newNode;
        else this.tail = newNode;
        node.next = newNode;
        this.length += 1;
    }

    insertBefore(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev) node.prev.next = newNode;
        else this.head = newNode;
        node.prev = newNode;
        this.length += 1;
    }

    unshift(node) {
        if (this.head) this.insertBefore(this.head, node);
        else setInitial(this, node);
    }

    push(node) {
        if (this.tail) this.insertAfter(this.tail, node);
        else setInitial(this, node);
    }

    shift() {
        return this.head && this.removeLink(this.head);
    }

    pop() {
        return this.tail && this.removeLink(this.tail);
    }

    toArray() {
        return [...this]
    }

    *[Symbol.iterator] () {
        var cur = this.head
        while (cur) {
            yield cur.data
            cur = cur.next
        }
    }

    remove (testFn) {
        var curr = this.head;
        while(curr) {
            var {next} = curr;
            if (testFn(curr)) {
                this.removeLink(curr);
            }
            curr = next;
        }
        return this;
    }
}

function setInitial(dll, node) {
    dll.length = 1;
    dll.head = dll.tail = node;
}



/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/async-es/internal/initialParams.js":
/*!****************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/async-es/internal/initialParams.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(fn) {
    return function (...args/*, callback*/) {
        var callback = args.pop();
        return fn.call(this, args, callback);
    };
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/async-es/internal/onlyOnce.js":
/*!***********************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/async-es/internal/onlyOnce.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ onlyOnce)
/* harmony export */ });
function onlyOnce(fn) {
    return function (...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    };
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/async-es/internal/queue.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/async-es/internal/queue.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ queue)
/* harmony export */ });
/* harmony import */ var _onlyOnce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./onlyOnce.js */ "../../lib-jitsi-meet/node_modules/async-es/internal/onlyOnce.js");
/* harmony import */ var _setImmediate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setImmediate.js */ "../../lib-jitsi-meet/node_modules/async-es/internal/setImmediate.js");
/* harmony import */ var _DoublyLinkedList_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DoublyLinkedList.js */ "../../lib-jitsi-meet/node_modules/async-es/internal/DoublyLinkedList.js");
/* harmony import */ var _wrapAsync_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrapAsync.js */ "../../lib-jitsi-meet/node_modules/async-es/internal/wrapAsync.js");





function queue(worker, concurrency, payload) {
    if (concurrency == null) {
        concurrency = 1;
    }
    else if(concurrency === 0) {
        throw new RangeError('Concurrency must not be zero');
    }

    var _worker = (0,_wrapAsync_js__WEBPACK_IMPORTED_MODULE_0__["default"])(worker);
    var numRunning = 0;
    var workersList = [];
    const events = {
        error: [],
        drain: [],
        saturated: [],
        unsaturated: [],
        empty: []
    }

    function on (event, handler) {
        events[event].push(handler)
    }

    function once (event, handler) {
        const handleAndRemove = (...args) => {
            off(event, handleAndRemove)
            handler(...args)
        }
        events[event].push(handleAndRemove)
    }

    function off (event, handler) {
        if (!event) return Object.keys(events).forEach(ev => events[ev] = [])
        if (!handler) return events[event] = []
        events[event] = events[event].filter(ev => ev !== handler)
    }

    function trigger (event, ...args) {
        events[event].forEach(handler => handler(...args))
    }

    var processingScheduled = false;
    function _insert(data, insertAtFront, rejectOnError, callback) {
        if (callback != null && typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;

        var res, rej;
        function promiseCallback (err, ...args) {
            // we don't care about the error, let the global error handler
            // deal with it
            if (err) return rejectOnError ? rej(err) : res()
            if (args.length <= 1) return res(args[0])
            res(args)
        }

        var item = q._createTaskItem(
            data,
            rejectOnError ? promiseCallback :
                (callback || promiseCallback)
        );

        if (insertAtFront) {
            q._tasks.unshift(item);
        } else {
            q._tasks.push(item);
        }

        if (!processingScheduled) {
            processingScheduled = true;
            (0,_setImmediate_js__WEBPACK_IMPORTED_MODULE_1__["default"])(() => {
                processingScheduled = false;
                q.process();
            });
        }

        if (rejectOnError || !callback) {
            return new Promise((resolve, reject) => {
                res = resolve
                rej = reject
            })
        }
    }

    function _createCB(tasks) {
        return function (err, ...args) {
            numRunning -= 1;

            for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];

                var index = workersList.indexOf(task);
                if (index === 0) {
                    workersList.shift();
                } else if (index > 0) {
                    workersList.splice(index, 1);
                }

                task.callback(err, ...args);

                if (err != null) {
                    trigger('error', err, task.data);
                }
            }

            if (numRunning <= (q.concurrency - q.buffer) ) {
                trigger('unsaturated')
            }

            if (q.idle()) {
                trigger('drain')
            }
            q.process();
        };
    }

    function _maybeDrain(data) {
        if (data.length === 0 && q.idle()) {
            // call drain immediately if there are no tasks
            (0,_setImmediate_js__WEBPACK_IMPORTED_MODULE_1__["default"])(() => trigger('drain'));
            return true
        }
        return false
    }

    const eventMethod = (name) => (handler) => {
        if (!handler) {
            return new Promise((resolve, reject) => {
                once(name, (err, data) => {
                    if (err) return reject(err)
                    resolve(data)
                })
            })
        }
        off(name)
        on(name, handler)

    }

    var isProcessing = false;
    var q = {
        _tasks: new _DoublyLinkedList_js__WEBPACK_IMPORTED_MODULE_2__["default"](),
        _createTaskItem (data, callback) {
            return {
                data,
                callback
            };
        },
        *[Symbol.iterator] () {
            yield* q._tasks[Symbol.iterator]()
        },
        concurrency,
        payload,
        buffer: concurrency / 4,
        started: false,
        paused: false,
        push (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, false, false, callback))
            }
            return _insert(data, false, false, callback);
        },
        pushAsync (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, false, true, callback))
            }
            return _insert(data, false, true, callback);
        },
        kill () {
            off()
            q._tasks.empty();
        },
        unshift (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, true, false, callback))
            }
            return _insert(data, true, false, callback);
        },
        unshiftAsync (data, callback) {
            if (Array.isArray(data)) {
                if (_maybeDrain(data)) return
                return data.map(datum => _insert(datum, true, true, callback))
            }
            return _insert(data, true, true, callback);
        },
        remove (testFn) {
            q._tasks.remove(testFn);
        },
        process () {
            // Avoid trying to start too many processing operations. This can occur
            // when callbacks resolve synchronously (#1267).
            if (isProcessing) {
                return;
            }
            isProcessing = true;
            while(!q.paused && numRunning < q.concurrency && q._tasks.length){
                var tasks = [], data = [];
                var l = q._tasks.length;
                if (q.payload) l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) {
                    var node = q._tasks.shift();
                    tasks.push(node);
                    workersList.push(node);
                    data.push(node.data);
                }

                numRunning += 1;

                if (q._tasks.length === 0) {
                    trigger('empty');
                }

                if (numRunning === q.concurrency) {
                    trigger('saturated');
                }

                var cb = (0,_onlyOnce_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_createCB(tasks));
                _worker(data, cb);
            }
            isProcessing = false;
        },
        length () {
            return q._tasks.length;
        },
        running () {
            return numRunning;
        },
        workersList () {
            return workersList;
        },
        idle() {
            return q._tasks.length + numRunning === 0;
        },
        pause () {
            q.paused = true;
        },
        resume () {
            if (q.paused === false) { return; }
            q.paused = false;
            (0,_setImmediate_js__WEBPACK_IMPORTED_MODULE_1__["default"])(q.process);
        }
    };
    // define these as fixed properties, so people get useful errors when updating
    Object.defineProperties(q, {
        saturated: {
            writable: false,
            value: eventMethod('saturated')
        },
        unsaturated: {
            writable: false,
            value: eventMethod('unsaturated')
        },
        empty: {
            writable: false,
            value: eventMethod('empty')
        },
        drain: {
            writable: false,
            value: eventMethod('drain')
        },
        error: {
            writable: false,
            value: eventMethod('error')
        },
    })
    return q;
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/async-es/internal/setImmediate.js":
/*!***************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/async-es/internal/setImmediate.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fallback: () => (/* binding */ fallback),
/* harmony export */   hasNextTick: () => (/* binding */ hasNextTick),
/* harmony export */   hasQueueMicrotask: () => (/* binding */ hasQueueMicrotask),
/* harmony export */   hasSetImmediate: () => (/* binding */ hasSetImmediate),
/* harmony export */   wrap: () => (/* binding */ wrap)
/* harmony export */ });
/* istanbul ignore file */

var hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;
var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return (fn, ...args) => defer(() => fn(...args));
}

var _defer;

if (hasQueueMicrotask) {
    _defer = queueMicrotask;
} else if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (wrap(_defer));


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/async-es/internal/wrapAsync.js":
/*!************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/async-es/internal/wrapAsync.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   isAsync: () => (/* binding */ isAsync),
/* harmony export */   isAsyncGenerator: () => (/* binding */ isAsyncGenerator),
/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable)
/* harmony export */ });
/* harmony import */ var _asyncify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asyncify.js */ "../../lib-jitsi-meet/node_modules/async-es/asyncify.js");


function isAsync(fn) {
    return fn[Symbol.toStringTag] === 'AsyncFunction';
}

function isAsyncGenerator(fn) {
    return fn[Symbol.toStringTag] === 'AsyncGenerator';
}

function isAsyncIterable(obj) {
    return typeof obj[Symbol.asyncIterator] === 'function';
}

function wrapAsync(asyncFn) {
    if (typeof asyncFn !== 'function') throw new Error('expected a function')
    return isAsync(asyncFn) ? (0,_asyncify_js__WEBPACK_IMPORTED_MODULE_0__["default"])(asyncFn) : asyncFn;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (wrapAsync);




/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/async-es/queue.js":
/*!***********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/async-es/queue.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _internal_queue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/queue.js */ "../../lib-jitsi-meet/node_modules/async-es/internal/queue.js");
/* harmony import */ var _internal_wrapAsync_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/wrapAsync.js */ "../../lib-jitsi-meet/node_modules/async-es/internal/wrapAsync.js");



/**
 * A queue of tasks for the worker function to complete.
 * @typedef {Iterable} QueueObject
 * @memberOf module:ControlFlow
 * @property {Function} length - a function returning the number of items
 * waiting to be processed. Invoke with `queue.length()`.
 * @property {boolean} started - a boolean indicating whether or not any
 * items have been pushed and processed by the queue.
 * @property {Function} running - a function returning the number of items
 * currently being processed. Invoke with `queue.running()`.
 * @property {Function} workersList - a function returning the array of items
 * currently being processed. Invoke with `queue.workersList()`.
 * @property {Function} idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
 * @property {number} concurrency - an integer for determining how many `worker`
 * functions should be run in parallel. This property can be changed after a
 * `queue` is created to alter the concurrency on-the-fly.
 * @property {number} payload - an integer that specifies how many items are
 * passed to the worker function at a time. only applies if this is a
 * [cargo]{@link module:ControlFlow.cargo} object
 * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`
 * once the `worker` has finished processing the task. Instead of a single task,
 * a `tasks` array can be submitted. The respective callback is used for every
 * task in the list. Invoke with `queue.push(task, [callback])`,
 * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.
 * Invoke with `queue.unshift(task, [callback])`.
 * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns
 * a promise that rejects if an error occurs.
 * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns
 * a promise that rejects if an error occurs.
 * @property {Function} remove - remove items from the queue that match a test
 * function.  The test function will be passed an object with a `data` property,
 * and a `priority` property, if this is a
 * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
 * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
 * `function ({data, priority}) {}` and returns a Boolean.
 * @property {Function} saturated - a function that sets a callback that is
 * called when the number of running workers hits the `concurrency` limit, and
 * further tasks will be queued.  If the callback is omitted, `q.saturated()`
 * returns a promise for the next occurrence.
 * @property {Function} unsaturated - a function that sets a callback that is
 * called when the number of running workers is less than the `concurrency` &
 * `buffer` limits, and further tasks will not be queued. If the callback is
 * omitted, `q.unsaturated()` returns a promise for the next occurrence.
 * @property {number} buffer - A minimum threshold buffer in order to say that
 * the `queue` is `unsaturated`.
 * @property {Function} empty - a function that sets a callback that is called
 * when the last item from the `queue` is given to a `worker`. If the callback
 * is omitted, `q.empty()` returns a promise for the next occurrence.
 * @property {Function} drain - a function that sets a callback that is called
 * when the last item from the `queue` has returned from the `worker`. If the
 * callback is omitted, `q.drain()` returns a promise for the next occurrence.
 * @property {Function} error - a function that sets a callback that is called
 * when a task errors. Has the signature `function(error, task)`. If the
 * callback is omitted, `error()` returns a promise that rejects on the next
 * error.
 * @property {boolean} paused - a boolean for determining whether the queue is
 * in a paused state.
 * @property {Function} pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke with `queue.pause()`.
 * @property {Function} resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
 * @property {Function} kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. No more tasks
 * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
 *
 * @example
 * const q = async.queue(worker, 2)
 * q.push(item1)
 * q.push(item2)
 * q.push(item3)
 * // queues are iterable, spread into an array to inspect
 * const items = [...q] // [item1, item2, item3]
 * // or use for of
 * for (let item of q) {
 *     console.log(item)
 * }
 *
 * q.drain(() => {
 *     console.log('all done')
 * })
 * // or
 * await q.drain()
 */

/**
 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
 * `queue` are processed in parallel (up to the `concurrency` limit). If all
 * `worker`s are in progress, the task is queued until one becomes available.
 * Once a `worker` completes a `task`, that `task`'s callback is called.
 *
 * @name queue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`. Invoked with (task, callback).
 * @param {number} [concurrency=1] - An `integer` for determining how many
 * `worker` functions should be run in parallel.  If omitted, the concurrency
 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be
 * attached as certain properties to listen for specific events during the
 * lifecycle of the queue.
 * @example
 *
 * // create a queue object with concurrency 2
 * var q = async.queue(function(task, callback) {
 *     console.log('hello ' + task.name);
 *     callback();
 * }, 2);
 *
 * // assign a callback
 * q.drain(function() {
 *     console.log('all items have been processed');
 * });
 * // or await the end
 * await q.drain()
 *
 * // assign an error callback
 * q.error(function(err, task) {
 *     console.error('task experienced an error');
 * });
 *
 * // add some items to the queue
 * q.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * // callback is optional
 * q.push({name: 'bar'});
 *
 * // add some items to the queue (batch-wise)
 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
 *     console.log('finished processing item');
 * });
 *
 * // add some items to the front of the queue
 * q.unshift({name: 'bar'}, function (err) {
 *     console.log('finished processing bar');
 * });
 */
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(worker, concurrency) {
    var _worker = (0,_internal_wrapAsync_js__WEBPACK_IMPORTED_MODULE_0__["default"])(worker);
    return (0,_internal_queue_js__WEBPACK_IMPORTED_MODULE_1__["default"])((items, cb) => {
        _worker(items[0], cb);
    }, concurrency, 1);
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/base64-js/index.js":
/*!************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/base64-js/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/bowser/es5.js":
/*!*******************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/bowser/es5.js ***!
  \*******************************************************/
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(function(){return function(e){var t={};function r(i){if(t[i])return t[i].exports;var n=t[i]={i:i,l:!1,exports:{}};return e[i].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=e,r.c=t,r.d=function(e,t,i){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)r.d(i,n,function(t){return e[t]}.bind(null,n));return i},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=90)}({17:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i=r(18),n=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||""},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||""},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case"NT":return"NT";case"XP":return"XP";case"NT 5.0":return"2000";case"NT 5.1":return"XP";case"NT 5.2":return"2003";case"NT 6.0":return"Vista";case"NT 6.1":return"7";case"NT 6.2":return"8";case"NT 6.3":return"8.1";case"NT 10.0":return"10";default:return}},e.getMacOSVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return"Leopard";case 6:return"Snow Leopard";case 7:return"Lion";case 8:return"Mountain Lion";case 9:return"Mavericks";case 10:return"Yosemite";case 11:return"El Capitan";case 12:return"Sierra";case 13:return"High Sierra";case 14:return"Mojave";case 15:return"Catalina";default:return}},e.getAndroidVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?"Cupcake":1===t[0]&&t[1]>=6?"Donut":2===t[0]&&t[1]<2?"Eclair":2===t[0]&&2===t[1]?"Froyo":2===t[0]&&t[1]>2?"Gingerbread":3===t[0]?"Honeycomb":4===t[0]&&t[1]<1?"Ice Cream Sandwich":4===t[0]&&t[1]<4?"Jelly Bean":4===t[0]&&t[1]>=4?"KitKat":5===t[0]?"Lollipop":6===t[0]?"Marshmallow":7===t[0]?"Nougat":8===t[0]?"Oreo":9===t[0]?"Pie":void 0},e.getVersionPrecision=function(e){return e.split(".").length},e.compareVersions=function(t,r,i){void 0===i&&(i=!1);var n=e.getVersionPrecision(t),s=e.getVersionPrecision(r),o=Math.max(n,s),a=0,u=e.map([t,r],(function(t){var r=o-e.getVersionPrecision(t),i=t+new Array(r+1).join(".0");return e.map(i.split("."),(function(e){return new Array(20-e.length).join("0")+e})).reverse()}));for(i&&(a=o-Math.min(n,s)),o-=1;o>=a;){if(u[0][o]>u[1][o])return 1;if(u[0][o]===u[1][o]){if(o===a)return 0;o-=1}else if(u[0][o]<u[1][o])return-1}},e.map=function(e,t){var r,i=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)i.push(t(e[r]));return i},e.getBrowserAlias=function(e){return i.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return i.BROWSER_MAP[e]||""},e}();t.default=n,e.exports=t.default},18:function(e,t,r){"use strict";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"};t.BROWSER_MAP={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"};t.PLATFORMS_MAP={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv"};t.OS_MAP={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"};t.ENGINE_MAP={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"}},90:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(91))&&i.__esModule?i:{default:i},s=r(18);function o(e,t){for(var r=0;r<t.length;r++){var i=t[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var a=function(){function e(){}var t,r,i;return e.getParser=function(e,t){if(void 0===t&&(t=!1),"string"!=typeof e)throw new Error("UserAgent should be a string");return new n.default(e,t)},e.parse=function(e){return new n.default(e).getResult()},t=e,i=[{key:"BROWSER_MAP",get:function(){return s.BROWSER_MAP}},{key:"ENGINE_MAP",get:function(){return s.ENGINE_MAP}},{key:"OS_MAP",get:function(){return s.OS_MAP}},{key:"PLATFORMS_MAP",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&o(t.prototype,r),i&&o(t,i),e}();t.default=a,e.exports=t.default},91:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i=u(r(92)),n=u(r(93)),s=u(r(94)),o=u(r(95)),a=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||""===e)throw new Error("UserAgent parameter can't be empty");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=i.default.find((function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||"":this.getBrowser().name||""},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=n.default.find((function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||"":t||""},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||"":t||""},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=s.default.find((function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||"":this.getEngine().name||""},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find((function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return Object.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},i=0,n={},s=0;if(Object.keys(e).forEach((function(t){var o=e[t];"string"==typeof o?(n[t]=o,s+=1):"object"==typeof o&&(r[t]=o,i+=1)})),i>0){var o=Object.keys(r),a=o.find((function(e){return t.isOS(e)}));if(a){var u=this.satisfies(r[a]);if(void 0!==u)return u}var d=o.find((function(e){return t.isPlatform(e)}));if(d){var c=this.satisfies(r[d]);if(void 0!==c)return c}}if(s>0){var f=Object.keys(n).find((function(e){return t.isBrowser(e,!0)}));if(void 0!==f)return this.compareVersion(n[f])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),i=e.toLowerCase(),n=a.default.getBrowserTypeByAlias(i);return t&&n&&(i=n.toLowerCase()),i===r},t.compareVersion=function(e){var t=[0],r=e,i=!1,n=this.getBrowserVersion();if("string"==typeof n)return">"===e[0]||"<"===e[0]?(r=e.substr(1),"="===e[1]?(i=!0,r=e.substr(2)):t=[],">"===e[0]?t.push(1):t.push(-1)):"="===e[0]?r=e.substr(1):"~"===e[0]&&(i=!0,r=e.substr(1)),t.indexOf(a.default.compareVersions(n,r,i))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e){return this.isBrowser(e)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i};var s=/version\/(\d+(\.?_?\d+)+)/i,o=[{test:[/googlebot/i],describe:function(e){var t={name:"Googlebot"},r=n.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:"Opera"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\/|opios/i],describe:function(e){var t={name:"Opera"},r=n.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:"Samsung Internet for Android"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:"NAVER Whale Browser"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:"MZ Browser"},r=n.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:"Focus"},r=n.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:"Swing"},r=n.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:"Opera Coast"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:"Yandex Browser"},r=n.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:"UC Browser"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:"Maxthon"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:"Epiphany"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:"Puffin"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:"Sleipnir"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:"K-Meleon"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:"WeChat"},r=n.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?"QQ Browser Lite":"QQ Browser"},r=n.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:"Internet Explorer"},r=n.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\sedg\//i],describe:function(e){var t={name:"Microsoft Edge"},r=n.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:"Microsoft Edge"},r=n.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:"Vivaldi"},r=n.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:"SeaMonkey"},r=n.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:"Sailfish"},r=n.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:"Amazon Silk"},r=n.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:"PhantomJS"},r=n.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:"SlimerJS"},r=n.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t={name:"BlackBerry"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:"WebOS Browser"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:"Bada"},r=n.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:"Tizen"},r=n.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:"QupZilla"},r=n.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:"Firefox"},r=n.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:"Chromium"},r=n.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:"Chrome"},r=n.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:"Google Search"},r=n.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:"Android Browser"},r=n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:"PlayStation 4"},r=n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:"Safari"},r=n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search("\\(")?/^(.*)\/(.*)[ \t]\((.*)/:/^(.*)\/(.*) /;return{name:n.default.getFirstMatch(t,e),version:n.default.getSecondMatch(t,e)}}}];t.default=o,e.exports=t.default},93:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i},s=r(18);var o=[{test:[/Roku\/DVP/],describe:function(e){var t=n.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=n.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows/i],describe:function(e){var t=n.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,e),r=n.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/macintosh/i],describe:function(e){var t=n.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,e).replace(/[_\s]/g,"."),r=n.default.getMacOSVersionName(t),i={name:s.OS_MAP.MacOS,version:t};return r&&(i.versionName=r),i}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=n.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,e).replace(/[_\s]/g,".");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=n.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,e),r=n.default.getAndroidVersionName(t),i={name:s.OS_MAP.Android,version:t};return r&&(i.versionName=r),i}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=n.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t=n.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,e)||n.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,e)||n.default.getFirstMatch(/\bbb(\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=n.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=n.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=n.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=o,e.exports=t.default},94:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i},s=r(18);var o=[{test:[/googlebot/i],describe:function(){return{type:"bot",vendor:"Google"}}},{test:[/huawei/i],describe:function(e){var t=n.default.getFirstMatch(/(can-l01)/i,e)&&"Nova",r={type:s.PLATFORMS_MAP.mobile,vendor:"Huawei"};return t&&(r.model=t),r}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Nexus"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=n.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:"Apple",model:t}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Nexus"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"blackberry"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"BlackBerry"}}},{test:function(e){return"bada"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"windows phone"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Microsoft"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(".")[0]);return"android"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return"android"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"macos"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:"Apple"}}},{test:function(e){return"windows"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"linux"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"playstation 4"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return"roku"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=o,e.exports=t.default},95:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i},s=r(18);var o=[{test:function(e){return"microsoft edge"===e.getBrowserName(!0)},describe:function(e){if(/\sedg\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=n.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=n.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=n.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=n.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\/537\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=n.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=o,e.exports=t.default}})}));

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/current-executing-script/dist/currentExecutingScript.js":
/*!*************************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/current-executing-script/dist/currentExecutingScript.js ***!
  \*************************************************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * currentExecutingScript
 * Get the currently executing script, regardless of its source/trigger/synchronicity. Similar to HTML5's `document.currentScript` but arguably much more useful!
 * Copyright (c) 2015 James M. Greene
 * Licensed MIT
 * https://github.com/JamesMGreene/currentExecutingScript
 * v0.1.3
 */
(function(root, factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(
  // Current context/scope
  this || window,

  // Factory function to return the export
  function() {

var scriptReadyRegex = /^(interactive|loaded|complete)$/;

// This page's URL (minus query string and fragment identifer hash, if any)
var fullPageUrl = !!window.location ? window.location.href : null;
var pageUrl = fullPageUrl ? fullPageUrl.replace(/#.*$/, "").replace(/\?.*$/, "") || null : null;

// Live NodeList collection
var scripts = document.getElementsByTagName("script");

// Check if the browser supports the `readyState` property on `script` elements
var supportsScriptReadyState = "readyState" in (scripts[0] || document.createElement("script"));

// Lousy browser detection for [not] Opera
var isNotOpera = !window.opera || window.opera.toString() !== "[object Opera]";

// Detect if `document.currentScript` is supported
var hasNativeCurrentScriptAccessor = "currentScript" in document;

var originalStackDepthConfig;
// Detect if the V8 Error Stack Trace API is supported
if ("stackTraceLimit" in Error && Error.stackTraceLimit !== Infinity) {
  originalStackDepthConfig = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;
}


// In some browsers (e.g. Chrome), you can get the current stack from an Error
// object instance without needing to throw it. Avoiding an unnecessary
// use of `throw` saves time and performance.
var hasStackBeforeThrowing = false,
    hasStackAfterThrowing = false;
(function() {
  try {
    var err = new Error();
    hasStackBeforeThrowing = typeof err.stack === "string" && !!err.stack;
    throw err;
  }
  catch (thrownErr) {
    hasStackAfterThrowing = typeof thrownErr.stack === "string" && !!thrownErr.stack;
  }
})();


// Normalize whitespace within a string
function normalizeWhitespace(str) {
  return str ? str.replace(/^\s+$|\s+$/g, "").replace(/\s\s+/g, " ") : "";
}

// Get script object based on the `src` URL
function getScriptFromUrl(url, eligibleScripts) {
  var i,
      script = null;

  eligibleScripts = eligibleScripts || scripts;

  if (typeof url === "string" && url) {
    for (i = eligibleScripts.length; i--; ) {
      if (eligibleScripts[i].src === url) {
        // NOTE: Could check if the same script URL is used by more than one `script` element
        // here... but let's not. That would yield less useful results in "loose" detection. ;)
        script = eligibleScripts[i];
        break;
      }
    }
  }
  return script;
}

// Get script object based on the caller function's source code body (text)
function getInlineScriptFromCallerSource(callerFnSource, eligibleScripts) {
  var i, inlineScriptText,
      script = null,
      callerSourceText = normalizeWhitespace(callerFnSource);

  eligibleScripts = eligibleScripts || scripts;

  if (callerFnSource && callerSourceText) {
    for (i = eligibleScripts.length; i--; ) {
      // Only look at inline scripts
      if (!eligibleScripts[i].hasAttribute("src")) {
        inlineScriptText = normalizeWhitespace(eligibleScripts[i].text);
        if (inlineScriptText.indexOf(callerSourceText) !== -1) {
          // If more than one match is found, don't return any
          if (script) {
            script = null;
            break;
          }
          script = eligibleScripts[i];
        }
      }
    }
  }

  return script;
}

// If there is only a single inline script on the page, return it; otherwise `null`
function getSoleInlineScript(eligibleScripts) {
  var i, len,
      script = null;
  eligibleScripts = eligibleScripts || scripts;
  for (i = 0, len = eligibleScripts.length; i < len; i++) {
    if (!eligibleScripts[i].hasAttribute("src")) {
      if (script) {
        script = null;
        break;
      }
      script = eligibleScripts[i];
    }
  }
  return script;
}

// Get the currently executing script URL from an Error stack trace
function getScriptUrlFromStack(stack, skipStackDepth) {
  var matches, remainingStack,
      url = null,
      ignoreMessage = typeof skipStackDepth === "number";
  skipStackDepth = ignoreMessage ? Math.round(skipStackDepth) : 0;
  if (typeof stack === "string" && stack) {
    if (ignoreMessage) {
      matches = stack.match(/(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
    }
    else {
      matches = stack.match(/^(?:|[^:@]*@|.+\)@(?=data:text\/javascript|blob|http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);

      if (!(matches && matches[1])) {
        matches = stack.match(/\)@(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
      }
    }

    if (matches && matches[1]) {
      if (skipStackDepth > 0) {
        remainingStack = stack.slice(stack.indexOf(matches[0]) + matches[0].length);
        url = getScriptUrlFromStack(remainingStack, (skipStackDepth - 1));
      }
      else {
        url = matches[1];
      }
    }

    // TODO: Handle more edge cases!
    // Fixes #1
    // See https://github.com/JamesMGreene/currentExecutingScript/issues/1

    // ???

  }
  return url;
}


// Get the farthest currently executing (i.e. yes, EXECUTING) `script` DOM
// element for the caller function, regardless of whether it is that `script`
// DOM element is currently being evaluated for the first time. The farthest
// currently executing `script` DOM element would typically be considered the
// originator of the current execution stack.
function _farthestExecutingScript() {
  /*jshint noarg:false */

  // TODO: Implement!
  // Fixes #3
  // See https://github.com/JamesMGreene/currentExecutingScript/issues/3
  return null;

/*
  // Yes, this IS possible, i.e. if a script removes other scripts (or itself)
  if (scripts.length === 0) {
    return null;
  }

  // Guaranteed accurate in IE 6-10.
  // Not accurate/supported in any other browsers.
  if (isNotOpera && supportsScriptReadyState) {
    for (var i = scripts.length; i--; ) {
      if (scripts[i].readyState === "interactive") {
        return scripts[i];
      }
    }
  }

  var stack,
      e = new Error();
  if (hasStackBeforeThrowing) {
    stack = e.stack;
  }
  if (!stack && hasStackAfterThrowing) {
    try {
      throw e;
    }
    catch (err) {
      // NOTE: Cannot use `err.sourceURL` or `err.fileName` as they will always be THIS script
      stack = err.stack;
    }
  }
  if (stack) {
    var url = getScriptUrlFromStack(stack, skipStackDepth);
    var script = getScriptFromUrl(url, scripts );
    if (!script && pageUrl && url === pageUrl) {
      // Try to find the correct inline script by searching through
      // inline scripts' text content for the caller function's source
      // code to be present. If the caller function's source code is
      // not available, see if there is only one inline script element
      // in the DOM and return that (even though it may be wrong)

      // TODO: Implement!
      // Fixes #4 in part
      // See https://github.com/JamesMGreene/currentExecutingScript/issues/4

      var callerFn = _farthestExecutingScript.caller || null,
          callerFnStack = [],
          callerFnSource = null;

      while (callerFn) {
        callerFnStack.push(callerFn);
        callerFn = callerFn.caller || null;
      }
      callerFn = callerFnStack.slice(-1)[0];
      callerFnSource = callerFn ? ("" + callerFn) : null;


      if (callerFnSource) {
        script = getInlineScriptFromCallerSource(callerFnSource);
      }
      else {
        // NOTE: This is a loose assumption that could be inaccurate!
        //
        // Inaccuracies:
        //  - If the inline script that initiated the call was also removed from the DOM.
        //  - If the call was initiated by an element's inline event handler,
        //    e.g. `<a onclick="(function() { alert(currentExecutingScript()); }()">click</a>`
        script = getSoleInlineScript();
      }
    }
    return script;
  }

  // NOTE: This is a loose assumption that could be inaccurate!
  //
  // Inaccuracies:
  //  - If a script is created dynamically and appended to some position
  //    other than the very end of the document.
  //  - If multiple scripts are created dynamically and all appended to the
  //    same position within the document (and do not have their `async` attributes
  //    set to `false`, at least in browsers that support async script evaluation.
  //    other than the very end of the document.
  //  - If any scripts are added with the `async` attribute set to `true` in a browser
  //    that supports it.
  //  - May get confused by `script` elements within `svg` elements
  return scripts[scripts.length - 1] || null;
*/
}


// Get the originating currently executing (i.e. yes, EXECUTING) `script` DOM
// element or attribute node (e.g. `onclick`) for the caller function,
// regardless of whether it is that `script` DOM element is currently being
// evaluated for the first time. The originating currently executing `script`
// DOM element [or attribute node] is the originator of the current execution stack.
function _originatingExecutingScript() {
  // TODO: Implement!
  // Fixes #2
  // See https://github.com/JamesMGreene/currentExecutingScript/issues/2
  return null;
}

// Get the nearest currently executing (i.e. yes, EXECUTING) `script` DOM
// element for the caller function, regardless of whether it is that `script`
// DOM element is currently being evaluated for the first time.
function _nearestExecutingScript() {
  /*jshint noarg:false */

  // Yes, this IS possible, i.e. if a script removes other scripts (or itself)
  if (scripts.length === 0) {
    return null;
  }

  var i, e, stack, url, script,
      eligibleScripts = [],
      skipStackDepth = _nearestExecutingScript.skipStackDepth || 1,

      // TODO: Implement!
      // Fixes #4 in part
      // See https://github.com/JamesMGreene/currentExecutingScript/issues/4
      callerFnSource = null;  //("" + (_nearestExecutingScript.caller || "")) || null;

  // This part will only help in IE 6-10.
  for (i = 0; i < scripts.length; i++) {
    if (isNotOpera && supportsScriptReadyState) {
      if (scriptReadyRegex.test(scripts[i].readyState)) {
        eligibleScripts.push(scripts[i]);
      }
    }
    else {
      eligibleScripts.push(scripts[i]);
    }
  }

  e = new Error();
  if (hasStackBeforeThrowing) {
    stack = e.stack;
  }
  if (!stack && hasStackAfterThrowing) {
    try {
      throw e;
    }
    catch (err) {
      // NOTE: Cannot use `err.sourceURL` or `err.fileName` as they will always be THIS script
      stack = err.stack;
    }
  }

  if (stack) {
    url = getScriptUrlFromStack(stack, skipStackDepth);
    script = getScriptFromUrl(url, eligibleScripts);

    if (!script && pageUrl && url === pageUrl) {
      // Try to find the correct inline script by searching through
      // inline scripts' text content for the caller function's source
      // code to be present.
      if (callerFnSource) {
        script = getInlineScriptFromCallerSource(callerFnSource, eligibleScripts);
      }
      // If the caller function's source code is not available, see if
      // there is only one inline script element in the DOM and return
      // that (even though it may be wrong)...
      else {
        // NOTE: This is a loose assumption that could be inaccurate!
        //
        // Inaccuracies:
        //  - If the inline script that initiated the call was also removed from the DOM.
        //  - If the call was initiated by an element's inline event handler,
        //    e.g. `<a onclick="(function() { alert(currentExecutingScript()); }()">click</a>`
        script = getSoleInlineScript(eligibleScripts);
      }
    }
  }

  //
  // Welcome to the Island of Inaccurate Assumptions!
  // NOTE: ALL of the following are loose assumptions that could be inaccurate!
  //

  if (!script) {
    // Inaccuracies:
    //  - If the inline script that initiated the call was also removed from the DOM.
    //  - If the call was initiated by an element's inline event handler,
    //    e.g. `<a onclick="(function() { alert(currentExecutingScript()); }()">click</a>`
    if (eligibleScripts.length === 1) {
      script = eligibleScripts[0];
    }
  }

  if (!script) {
    // Inaccuracies:
    //  - If script currently being synchronously evaluated by the parser is the
    //    originator of this call stack but NOT the source script of the caller/invocation
    //    e.g.
    //    ```html
    //    <script id="a">
    //    function getCurrentScriptCallerFn() {
    //      return currentExecutingScript.near();
    //    }
    //    </script>
    //    <script id="b">
    //    // Should get `script[id="a"]` but will get `script[id="b"]` instead
    //    getCurrentScriptCallerFn();
    //    </script>
    if (hasNativeCurrentScriptAccessor) {
      script = document.currentScript;
    }
  }

  if (!script) {
    // Inaccuracies:
    //  - If script currently being synchronously evaluated by the parser is the
    //    originator of this call stack but NOT the source script of the caller/invocation
    //    e.g.
    //    ```html
    //    <script id="a">
    //    function getCurrentScriptCallerFn() {
    //      return currentExecutingScript.near();
    //    }
    //    </script>
    //    <script id="b">
    //    // Should get `script[id="a"]` but will get `script[id="b"]` instead
    //    getCurrentScriptCallerFn();
    //    </script>
    if (isNotOpera && supportsScriptReadyState) {
      for (i = eligibleScripts.length; i--; ) {
        if (eligibleScripts[i].readyState === "interactive") {
          script = eligibleScripts[i];
          break;
        }
      }
    }
  }

  if (!script) {
    // Inaccuracies:
    //  - If a script is created dynamically and appended to some position
    //    other than the very end of the document.
    //  - If multiple scripts are created dynamically and all appended to the
    //    same position within the document (and do not have their `async` attributes
    //    set to `false`, at least in browsers that support async script evaluation.
    //    other than the very end of the document.
    //  - If any scripts are added with the `async` attribute set to `true` in a browser
    //    that supports it.
    //  - May get confused by `script` elements within `svg` elements
    //  - If script currently being synchronously evaluated by the parser is the
    //    originator of this call stack but NOT the source script of the caller/invocation
    //    e.g.
    //    ```html
    //    <script id="a">
    //    function getCurrentScriptCallerFn() {
    //      return currentExecutingScript.near();
    //    }
    //    </script>
    //    <script id="b">
    //    // Should get `script[id="a"]` but will get `script[id="b"]` instead
    //    getCurrentScriptCallerFn();
    //    </script>
    //    ```
    script = eligibleScripts[eligibleScripts.length - 1] || null;
  }

  return script;
}

// Default stack depth to skip over when analyzing call stack frames
_nearestExecutingScript.skipStackDepth = 1;



    //
    // Export the API
    //
    var currentExecutingScript    = _nearestExecutingScript;      // default
    currentExecutingScript.near   = _nearestExecutingScript;
    currentExecutingScript.far    = _farthestExecutingScript;
    currentExecutingScript.origin = _originatingExecutingScript;


    // Just return a value to define the module export.
    // This example returns an object, but the module
    // can return a function as the exported value.
    return currentExecutingScript;
  })
);


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/events/events.js":
/*!**********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/events/events.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js":
/*!***************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/jquery/dist/jquery.js ***!
  \***************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.6.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2022-08-26T17:52Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.6.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.6
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2021-02-16
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem && elem.namespaceURI,
		docElem = elem && ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						// Support: Chrome 86+
						// In Chrome, if an element having a focusout handler is blurred by
						// clicking outside of it, it invokes the handler synchronously. If
						// that handler calls `.remove()` on the element, the data is cleared,
						// leaving `result` undefined. We need to guard against this.
						return result && result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );

var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is display: block
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		// trim whitespace for custom property (issue gh-4926)
		if ( isCustomProp ) {

			// rtrim treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" );
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/js-md5/src/md5.js":
/*!***********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/js-md5/src/md5.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * [js-md5]{@link https://github.com/emn178/js-md5}
 *
 * @namespace md5
 * @version 0.7.3
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
(function () {
  'use strict';

  var ERROR = 'input is invalid type';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_MD5_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = __webpack_require__.g;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && "object" === 'object' && module.exports;
  var AMD =  true && __webpack_require__.amdO;
  var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [128, 32768, 8388608, -2147483648];
  var SHIFT = [0, 8, 16, 24];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer', 'base64'];
  var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  var blocks = [], buffer8;
  if (ARRAY_BUFFER) {
    var buffer = new ArrayBuffer(68);
    buffer8 = new Uint8Array(buffer);
    blocks = new Uint32Array(buffer);
  }

  if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  /**
   * @method hex
   * @memberof md5
   * @description Output hash as hex string
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {String} Hex string
   * @example
   * md5.hex('The quick brown fox jumps over the lazy dog');
   * // equal to
   * md5('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method digest
   * @memberof md5
   * @description Output hash as bytes array
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Array} Bytes array
   * @example
   * md5.digest('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method array
   * @memberof md5
   * @description Output hash as bytes array
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Array} Bytes array
   * @example
   * md5.array('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method arrayBuffer
   * @memberof md5
   * @description Output hash as ArrayBuffer
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {ArrayBuffer} ArrayBuffer
   * @example
   * md5.arrayBuffer('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method buffer
   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
   * @memberof md5
   * @description Output hash as ArrayBuffer
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {ArrayBuffer} ArrayBuffer
   * @example
   * md5.buffer('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method base64
   * @memberof md5
   * @description Output hash as base64 string
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {String} base64 string
   * @example
   * md5.base64('The quick brown fox jumps over the lazy dog');
   */
  var createOutputMethod = function (outputType) {
    return function (message) {
      return new Md5(true).update(message)[outputType]();
    };
  };

  /**
   * @method create
   * @memberof md5
   * @description Create Md5 object
   * @returns {Md5} Md5 object.
   * @example
   * var hash = md5.create();
   */
  /**
   * @method update
   * @memberof md5
   * @description Create and update Md5 object
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Md5} Md5 object.
   * @example
   * var hash = md5.update('The quick brown fox jumps over the lazy dog');
   * // equal to
   * var hash = md5.create();
   * hash.update('The quick brown fox jumps over the lazy dog');
   */
  var createMethod = function () {
    var method = createOutputMethod('hex');
    if (NODE_JS) {
      method = nodeWrap(method);
    }
    method.create = function () {
      return new Md5();
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type);
    }
    return method;
  };

  var nodeWrap = function (method) {
    var crypto = eval("require('crypto')");
    var Buffer = eval("require('buffer').Buffer");
    var nodeMethod = function (message) {
      if (typeof message === 'string') {
        return crypto.createHash('md5').update(message, 'utf8').digest('hex');
      } else {
        if (message === null || message === undefined) {
          throw ERROR;
        } else if (message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
      }
      if (Array.isArray(message) || ArrayBuffer.isView(message) ||
        message.constructor === Buffer) {
        return crypto.createHash('md5').update(new Buffer(message)).digest('hex');
      } else {
        return method(message);
      }
    };
    return nodeMethod;
  };

  /**
   * Md5 class
   * @class Md5
   * @description This is internal class.
   * @see {@link md5.create}
   */
  function Md5(sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
      blocks[4] = blocks[5] = blocks[6] = blocks[7] =
      blocks[8] = blocks[9] = blocks[10] = blocks[11] =
      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
      this.buffer8 = buffer8;
    } else {
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        this.buffer8 = new Uint8Array(buffer);
        this.blocks = new Uint32Array(buffer);
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
    }
    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }

  /**
   * @method update
   * @memberof Md5
   * @instance
   * @description Update hash
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Md5} Md5 object.
   * @see {@link md5.update}
   */
  Md5.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }

    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw ERROR;
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw ERROR;
          }
        }
      } else {
        throw ERROR;
      }
      notString = true;
    }
    var code, index = 0, i, length = message.length, blocks = this.blocks;
    var buffer8 = this.buffer8;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = blocks[16];
        blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      if (notString) {
        if (ARRAY_BUFFER) {
          for (i = this.start; index < length && i < 64; ++index) {
            buffer8[i++] = message[index];
          }
        } else {
          for (i = this.start; index < length && i < 64; ++index) {
            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        }
      } else {
        if (ARRAY_BUFFER) {
          for (i = this.start; index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 0x80) {
              buffer8[i++] = code;
            } else if (code < 0x800) {
              buffer8[i++] = 0xc0 | (code >> 6);
              buffer8[i++] = 0x80 | (code & 0x3f);
            } else if (code < 0xd800 || code >= 0xe000) {
              buffer8[i++] = 0xe0 | (code >> 12);
              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);
              buffer8[i++] = 0x80 | (code & 0x3f);
            } else {
              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
              buffer8[i++] = 0xf0 | (code >> 18);
              buffer8[i++] = 0x80 | ((code >> 12) & 0x3f);
              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);
              buffer8[i++] = 0x80 | (code & 0x3f);
            }
          }
        } else {
          for (i = this.start; index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 0x80) {
              blocks[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 0x800) {
              blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            } else if (code < 0xd800 || code >= 0xe000) {
              blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            } else {
              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
              blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            }
          }
        }
      }
      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Md5.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[i >> 2] |= EXTRA[i & 3];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = blocks[16];
      blocks[16] = blocks[1] = blocks[2] = blocks[3] =
      blocks[4] = blocks[5] = blocks[6] = blocks[7] =
      blocks[8] = blocks[9] = blocks[10] = blocks[11] =
      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.bytes << 3;
    blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
    this.hash();
  };

  Md5.prototype.hash = function () {
    var a, b, c, d, bc, da, blocks = this.blocks;

    if (this.first) {
      a = blocks[0] - 680876937;
      a = (a << 7 | a >>> 25) - 271733879 << 0;
      d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
      d = (d << 12 | d >>> 20) + a << 0;
      c = (-271733879 ^ (d & (a ^ -271733879))) + blocks[2] - 1126478375;
      c = (c << 17 | c >>> 15) + d << 0;
      b = (a ^ (c & (d ^ a))) + blocks[3] - 1316259209;
      b = (b << 22 | b >>> 10) + c << 0;
    } else {
      a = this.h0;
      b = this.h1;
      c = this.h2;
      d = this.h3;
      a += (d ^ (b & (c ^ d))) + blocks[0] - 680876936;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ (a & (b ^ c))) + blocks[1] - 389564586;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ (d & (a ^ b))) + blocks[2] + 606105819;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ (c & (d ^ a))) + blocks[3] - 1044525330;
      b = (b << 22 | b >>> 10) + c << 0;
    }

    a += (d ^ (b & (c ^ d))) + blocks[4] - 176418897;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ (a & (b ^ c))) + blocks[5] + 1200080426;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ (d & (a ^ b))) + blocks[6] - 1473231341;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ (c & (d ^ a))) + blocks[7] - 45705983;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ (b & (c ^ d))) + blocks[8] + 1770035416;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ (a & (b ^ c))) + blocks[9] - 1958414417;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ (d & (a ^ b))) + blocks[10] - 42063;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ (c & (d ^ a))) + blocks[11] - 1990404162;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ (b & (c ^ d))) + blocks[12] + 1804603682;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ (a & (b ^ c))) + blocks[13] - 40341101;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ (d & (a ^ b))) + blocks[14] - 1502002290;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ (c & (d ^ a))) + blocks[15] + 1236535329;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[1] - 165796510;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[6] - 1069501632;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[11] + 643717713;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[0] - 373897302;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[5] - 701558691;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[10] + 38016083;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[15] - 660478335;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[4] - 405537848;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[9] + 568446438;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[14] - 1019803690;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[3] - 187363961;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[8] + 1163531501;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[13] - 1444681467;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[2] - 51403784;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[7] + 1735328473;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[12] - 1926607734;
    b = (b << 20 | b >>> 12) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[5] - 378558;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[8] - 2022574463;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[11] + 1839030562;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[14] - 35309556;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[1] - 1530992060;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[4] + 1272893353;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[7] - 155497632;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[10] - 1094730640;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[13] + 681279174;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[0] - 358537222;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[3] - 722521979;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[6] + 76029189;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[9] - 640364487;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[12] - 421815835;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[15] + 530742520;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[2] - 995338651;
    b = (b << 23 | b >>> 9) + c << 0;
    a += (c ^ (b | ~d)) + blocks[0] - 198630844;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[5] - 57434055;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[10] - 1051523;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[15] - 30611744;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[4] - 145523070;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[2] + 718787259;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[9] - 343485551;
    b = (b << 21 | b >>> 11) + c << 0;

    if (this.first) {
      this.h0 = a + 1732584193 << 0;
      this.h1 = b - 271733879 << 0;
      this.h2 = c - 1732584194 << 0;
      this.h3 = d + 271733878 << 0;
      this.first = false;
    } else {
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b << 0;
      this.h2 = this.h2 + c << 0;
      this.h3 = this.h3 + d << 0;
    }
  };

  /**
   * @method hex
   * @memberof Md5
   * @instance
   * @description Output hash as hex string
   * @returns {String} Hex string
   * @see {@link md5.hex}
   * @example
   * hash.hex();
   */
  Md5.prototype.hex = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;

    return HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
      HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F];
  };

  /**
   * @method toString
   * @memberof Md5
   * @instance
   * @description Output hash as hex string
   * @returns {String} Hex string
   * @see {@link md5.hex}
   * @example
   * hash.toString();
   */
  Md5.prototype.toString = Md5.prototype.hex;

  /**
   * @method digest
   * @memberof Md5
   * @instance
   * @description Output hash as bytes array
   * @returns {Array} Bytes array
   * @see {@link md5.digest}
   * @example
   * hash.digest();
   */
  Md5.prototype.digest = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
    return [
      h0 & 0xFF, (h0 >> 8) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 24) & 0xFF,
      h1 & 0xFF, (h1 >> 8) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 24) & 0xFF,
      h2 & 0xFF, (h2 >> 8) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 24) & 0xFF,
      h3 & 0xFF, (h3 >> 8) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 24) & 0xFF
    ];
  };

  /**
   * @method array
   * @memberof Md5
   * @instance
   * @description Output hash as bytes array
   * @returns {Array} Bytes array
   * @see {@link md5.array}
   * @example
   * hash.array();
   */
  Md5.prototype.array = Md5.prototype.digest;

  /**
   * @method arrayBuffer
   * @memberof Md5
   * @instance
   * @description Output hash as ArrayBuffer
   * @returns {ArrayBuffer} ArrayBuffer
   * @see {@link md5.arrayBuffer}
   * @example
   * hash.arrayBuffer();
   */
  Md5.prototype.arrayBuffer = function () {
    this.finalize();

    var buffer = new ArrayBuffer(16);
    var blocks = new Uint32Array(buffer);
    blocks[0] = this.h0;
    blocks[1] = this.h1;
    blocks[2] = this.h2;
    blocks[3] = this.h3;
    return buffer;
  };

  /**
   * @method buffer
   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
   * @memberof Md5
   * @instance
   * @description Output hash as ArrayBuffer
   * @returns {ArrayBuffer} ArrayBuffer
   * @see {@link md5.buffer}
   * @example
   * hash.buffer();
   */
  Md5.prototype.buffer = Md5.prototype.arrayBuffer;

  /**
   * @method base64
   * @memberof Md5
   * @instance
   * @description Output hash as base64 string
   * @returns {String} base64 string
   * @see {@link md5.base64}
   * @example
   * hash.base64();
   */
  Md5.prototype.base64 = function () {
    var v1, v2, v3, base64Str = '', bytes = this.array();
    for (var i = 0; i < 15;) {
      v1 = bytes[i++];
      v2 = bytes[i++];
      v3 = bytes[i++];
      base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +
        BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] +
        BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] +
        BASE64_ENCODE_CHAR[v3 & 63];
    }
    v1 = bytes[i];
    base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +
      BASE64_ENCODE_CHAR[(v1 << 4) & 63] +
      '==';
    return base64Str;
  };

  var exports = createMethod();

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    /**
     * @method md5
     * @description Md5 hash function, export to global in browsers.
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {String} md5 hashes
     * @example
     * md5(''); // d41d8cd98f00b204e9800998ecf8427e
     * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6
     * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0
     *
     * // It also supports UTF-8 encoding
     * md5('中文'); // a7bac2239fcdcb3a067903d8077c4a07
     *
     * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`
     * md5([]); // d41d8cd98f00b204e9800998ecf8427e
     * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e
     */
    root.md5 = exports;
    if (AMD) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return exports;
      }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/lodash.clonedeep/index.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/lodash.clonedeep/index.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, true, true);
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = cloneDeep;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/lodash.debounce/index.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/lodash.debounce/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/lodash.isequal/index.js":
/*!*****************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/lodash.isequal/index.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = isEqual;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/grammar.js":
/*!**********************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/sdp-transform/lib/grammar.js ***!
  \**********************************************************************/
/***/ ((module) => {

var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{ //o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  //k: [{}], // outdated thing ignored
  t: [{ //t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{ //c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{ //b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [
    { //a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding) ?
          'rtpmap:%d %s/%s/%s':
          o.rate ?
          'rtpmap:%d %s/%s':
          'rtpmap:%d %s';
      }
    },
    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      //a=fmtp:111 minptime=10; useinbandfec=1
      push: 'fmtp',
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ['payload', 'config'],
      format: 'fmtp:%d %s'
    },
    { //a=control:streamid=0
      name: 'control',
      reg: /^control:(.*)/,
      format: 'control:%s'
    },
    { //a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null) ?
          'rtcp:%d %s IP%d %s':
          'rtcp:%d';
      }
    },
    { //a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: 'rtcp-fb:%d trr-int %d'
    },
    { //a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null) ?
          'rtcp-fb:%s %s %s':
          'rtcp-fb:%s %s';
      }
    },
    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      //a=extmap:1/recvonly URI-gps-string
      push: 'ext',
      reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
      names: ['value', 'direction', 'uri', 'config'],
      format: function (o) {
        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');
      }
    },
    { //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null) ?
          'crypto:%d %s %s %s':
          'crypto:%d %s %s';
      }
    },
    { //a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: 'setup:%s'
    },
    { //a=mid:1
      name: 'mid',
      reg: /^mid:([^\s]*)/,
      format: 'mid:%s'
    },
    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: 'msid',
      reg: /^msid:(.*)/,
      format: 'msid:%s'
    },
    { //a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*)/,
      format: 'ptime:%d'
    },
    { //a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*)/,
      format: 'maxptime:%d'
    },
    { //a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    { //a=ice-lite
      name: 'icelite',
      reg: /^(ice-lite)/
    },
    { //a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: 'ice-ufrag:%s'
    },
    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: 'ice-pwd:%s'
    },
    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: 'fingerprint:%s %s'
    },
    { //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
      format: function (o) {
        var str = 'candidate:%s %d %s %d %s %d typ %s';

        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

        // NB: candidate has three optional chunks, so %void middles one if it's missing
        str += (o.tcptype != null) ? ' tcptype %s' : '%v';

        if (o.generation != null) {
          str += ' generation %d';
        }

        str += (o['network-id'] != null) ? ' network-id %d' : '%v';
        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
        return str;
      }
    },
    { //a=end-of-candidates (keep after the candidates line for readability)
      name: 'endOfCandidates',
      reg: /^(end-of-candidates)/
    },
    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: 'remote-candidates:%s'
    },
    { //a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: 'ice-options:%s'
    },
    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: 'ssrcs',
      reg: /^ssrc:(\d*) ([\w_]*)(?::(.*))?/,
      names: ['id', 'attribute', 'value'],
      format: function (o) {
        var str = 'ssrc:%d';
        if (o.attribute != null) {
          str += ' %s';
          if (o.value != null) {
            str += ':%s';
          }
        }
        return str;
      }
    },
    { //a=ssrc-group:FEC 1 2
      //a=ssrc-group:FEC-FR 3004364195 1080772241
      push: 'ssrcGroups',
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ['semantics', 'ssrcs'],
      format: 'ssrc-group:%s %s'
    },
    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: 'msidSemantic',
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: 'msid-semantic: %s %s' // space after ':' is not accidental
    },
    { //a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: 'group:%s %s'
    },
    { //a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    { //a=rtcp-rsize
      name: 'rtcpRsize',
      reg: /^(rtcp-rsize)/
    },
    { //a=sctpmap:5000 webrtc-datachannel 1024
      name: 'sctpmap',
      reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
      names: ['sctpmapNumber', 'app', 'maxMessageSize'],
      format: function (o) {
        return (o.maxMessageSize != null) ?
          'sctpmap:%s %s %s' :
          'sctpmap:%s %s';
      }
    },
    { //a=x-google-flag:conference
      name: 'xGoogleFlag',
      reg: /^x-google-flag:([^\s]*)/,
      format: 'x-google-flag:%s'
    },
    { //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: 'rids',
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ['id', 'direction', 'params'],
      format: function (o) {
        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
      }
    },
    { //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      //a=imageattr:* send [x=800,y=640] recv *
      //a=imageattr:100 recv [x=320,y=240]
      push: 'imageattrs',
      reg: new RegExp(
        //a=imageattr:97
        '^imageattr:(\\d+|\\*)' +
        //send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
        '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
        //recv [x=330,y=250]
        '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
      ),
      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
      format: function (o) {
        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    { //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      //a=simulcast:recv 1;4,5 send 6;7
      name: 'simulcast',
      reg: new RegExp(
        //a=simulcast:
        '^simulcast:' +
        //send 1,2,3;~4,~5
        '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
        //space + recv 6;~7,~8
        '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
        //end
        '$'
      ),
      names: ['dir1', 'list1', 'dir2', 'list2'],
      format: function (o) {
        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    { //Old simulcast draft 03 (implemented by Firefox)
      //  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      //a=simulcast: recv pt=97;98 send pt=97
      //a=simulcast: send rid=5;6;7 paused=6,7
      name: 'simulcast_03',
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ['value'],
      format: 'simulcast: %s'
    },
    {
      //a=framerate:25
      //a=framerate:29.97
      name: 'framerate',
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: 'framerate:%s'
    },
    { // any a= that we don't understand is kepts verbatim on media.invalid
      push: 'invalid',
      names: ['value']
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/index.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/sdp-transform/lib/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var parser = __webpack_require__(/*! ./parser */ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/parser.js");
var writer = __webpack_require__(/*! ./writer */ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/writer.js");

exports.write = writer;
exports.parse = parser.parse;
exports.parseFmtpConfig = parser.parseFmtpConfig;
exports.parseParams = parser.parseParams;
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/parser.js":
/*!*********************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/sdp-transform/lib/parser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = __webpack_require__(/*! ./grammar */ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/grammar.js");
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var paramReducer = function (acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  }
  return acc;
};

exports.parseParams = function (str) {
  return str.split(/\;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;

exports.parsePayloads = function (str) {
  return str.split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
  });
};

exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid, paused = false;

      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }

      return {
        scid: scid,
        paused: paused
      };
    });
  });
};


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/writer.js":
/*!*********************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/sdp-transform/lib/writer.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var grammar = __webpack_require__(/*! ./grammar */ "../../lib-jitsi-meet/node_modules/sdp-transform/lib/grammar.js");

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
    case '%%':
      return '%';
    case '%s':
      return String(arg);
    case '%d':
      return Number(arg);
    case '%v':
      return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/sdp/sdp.js":
/*!****************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/sdp/sdp.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
/* eslint-env node */


// SDP helpers.
const SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(line => line.trim());
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  const parts = blob.split('\nm=');
  return parts.map((part, index) => (index > 0 ?
    'm=' + part : part).trim() + '\r\n');
};

// Returns the session description.
SDPUtils.getDescription = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// Returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  const sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
// Input can be prefixed with a=.
SDPUtils.parseCandidate = function(line) {
  let parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  const candidate = {
    foundation: parts[0],
    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7],
  };

  for (let i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compatibility.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag. Don't overwrite.
        if (candidate[parts[i]] === undefined) {
          candidate[parts[i]] = parts[i + 1];
        }
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
// This does not include the a= prefix!
SDPUtils.writeCandidate = function(candidate) {
  const sdp = [];
  sdp.push(candidate.foundation);

  const component = candidate.component;
  if (component === 'rtp') {
    sdp.push(1);
  } else if (component === 'rtcp') {
    sdp.push(2);
  } else {
    sdp.push(component);
  }
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  const type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// Sample input:
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
};

// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  let parts = line.substr(9).split(' ');
  const parsed = {
    payloadType: parseInt(parts.shift(), 10), // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generates a rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  const channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses a extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  const parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1],
  };
};

// Generates an extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
        ? '/' + headerExtension.direction
        : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses a fmtp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  const parsed = {};
  let kv;
  const parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (let j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  let line = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    const params = [];
    Object.keys(codec.parameters).forEach(param => {
      if (codec.parameters[param] !== undefined) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  const parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' '),
  };
};

// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  let lines = '';
  let pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(fb => {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses a RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  const sp = line.indexOf(' ');
  const parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10),
  };
  const colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Parse a ssrc-group line (see RFC 5576). Sample input:
// a=ssrc-group:semantics 12 34
SDPUtils.parseSsrcGroup = function(line) {
  const parts = line.substr(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),
  };
};

// Extracts the MID (RFC 5888) from a media section.
// Returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
};

// Parses a fingerprint line for DTLS-SRTP.
SDPUtils.parseFingerprint = function(line) {
  const parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint),
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  let sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(fp => {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};

// Parses a=crypto lines into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
SDPUtils.parseCryptoLine = function(line) {
  const parts = line.substr(9).split(' ');
  return {
    tag: parseInt(parts[0], 10),
    cryptoSuite: parts[1],
    keyParams: parts[2],
    sessionParams: parts.slice(3),
  };
};

SDPUtils.writeCryptoLine = function(parameters) {
  return 'a=crypto:' + parameters.tag + ' ' +
    parameters.cryptoSuite + ' ' +
    (typeof parameters.keyParams === 'object'
      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
      : parameters.keyParams) +
    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
    '\r\n';
};

// Parses the crypto key parameters into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
SDPUtils.parseCryptoKeyParams = function(keyParams) {
  if (keyParams.indexOf('inline:') !== 0) {
    return null;
  }
  const parts = keyParams.substr(7).split('|');
  return {
    keyMethod: 'inline',
    keySalt: parts[0],
    lifeTime: parts[1],
    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
  };
};

SDPUtils.writeCryptoKeyParams = function(keyParams) {
  return keyParams.keyMethod + ':'
    + keyParams.keySalt +
    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
    (keyParams.mkiValue && keyParams.mkiLength
      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
      : '');
};

// Extracts all SDES parameters.
SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=crypto:');
  return lines.map(SDPUtils.parseCryptoLine);
};

// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-ufrag:')[0];
  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-pwd:')[0];
  if (!(ufrag && pwd)) {
    return null;
  }
  return {
    usernameFragment: ufrag.substr(12),
    password: pwd.substr(10),
  };
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
  if (params.iceLite) {
    sdp += 'a=ice-lite\r\n';
  }
  return sdp;
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  const description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: [],
  };
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    const pt = mline[i];
    const rtpmapline = SDPUtils.matchPrefix(
      mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      const codec = SDPUtils.parseRtpMap(rtpmapline);
      const fmtps = SDPUtils.matchPrefix(
        mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
        mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  let sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(codec => {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(codec => {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  let maxptime = 0;
  caps.codecs.forEach(codec => {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(extension => {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  const encodingParameters = [];
  const description = SDPUtils.parseRtpParameters(mediaSection);
  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(parts => parts.attribute === 'cname');
  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  let secondarySsrc;

  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(line => {
      const parts = line.substr(17).split(' ');
      return parts.map(part => parseInt(part, 10));
    });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(codec => {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      let encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc,
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(params => {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  const rtcpParameters = {};

  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(obj => obj.attribute === 'cname')[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrіbute.
  // Note that Edge does not support unmuxed RTCP.
  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

SDPUtils.writeRtcpParameters = function(rtcpParameters) {
  let sdp = '';
  if (rtcpParameters.reducedSize) {
    sdp += 'a=rtcp-rsize\r\n';
  }
  if (rtcpParameters.mux) {
    sdp += 'a=rtcp-mux\r\n';
  }
  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {
    sdp += 'a=ssrc:' + rtcpParameters.ssrc +
      ' cname:' + rtcpParameters.cname + '\r\n';
  }
  return sdp;
};


// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  let parts;
  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(line => SDPUtils.parseSsrcMedia(line))
    .filter(msidParts => msidParts.attribute === 'msid');
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// SCTP
// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
// to draft-ietf-mmusic-sctp-sdp-05
SDPUtils.parseSctpDescription = function(mediaSection) {
  const mline = SDPUtils.parseMLine(mediaSection);
  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
  let maxMessageSize;
  if (maxSizeLine.length > 0) {
    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
  }
  if (isNaN(maxMessageSize)) {
    maxMessageSize = 65536;
  }
  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
  if (sctpPort.length > 0) {
    return {
      port: parseInt(sctpPort[0].substr(12), 10),
      protocol: mline.fmt,
      maxMessageSize,
    };
  }
  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
  if (sctpMapLines.length > 0) {
    const parts = sctpMapLines[0]
      .substr(10)
      .split(' ');
    return {
      port: parseInt(parts[0], 10),
      protocol: parts[1],
      maxMessageSize,
    };
  }
};

// SCTP
// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
// support by now receiving in this format, unless we originally parsed
// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
// protocol of DTLS/SCTP -- without UDP/ or TCP/)
SDPUtils.writeSctpDescription = function(media, sctp) {
  let output = [];
  if (media.protocol !== 'DTLS/SCTP') {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctp-port:' + sctp.port + '\r\n',
    ];
  } else {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n',
    ];
  }
  if (sctp.maxMessageSize !== undefined) {
    output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
  }
  return output.join('');
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boiler plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  let sessionId;
  const version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  const user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  const lines = SDPUtils.splitLines(mediaSection);
  for (let i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  const lines = SDPUtils.splitLines(mediaSection);
  const parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' '),
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  const parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5],
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  const lines = SDPUtils.splitLines(blob);
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (true) {
  module.exports = SDPUtils;
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js":
/*!************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

(function (global, factory) {
             true ? factory(exports) :
            0;
})(this, (function (exports) { 'use strict';

            var global$1 = typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

            /*
             * This module provides uniform
             * Shims APIs and globals that are not present in all JS environments,
             * the most common example for Strophe being browser APIs like WebSocket
             * and DOM that don't exist under nodejs.
             *
             * Usually these will be supplied in nodejs by conditionally requiring a
             * NPM module that provides a compatible implementation.
             */

            /* global global */

            /**
             * WHATWG WebSockets API
             * https://www.w3.org/TR/websockets/
             *
             * Interface to use the web socket protocol
             *
             * Used implementations:
             * - supported browsers: built-in in WebSocket global
             *   https://developer.mozilla.org/en-US/docs/Web/API/WebSocket#Browser_compatibility
             * - nodejs: use standard-compliant 'ws' module
             *   https://www.npmjs.com/package/ws
             */
            function getWebSocketImplementation() {
              let WebSocketImplementation = global$1.WebSocket;

              if (typeof WebSocketImplementation === 'undefined') {
                try {
                  WebSocketImplementation = __webpack_require__(/*! ws */ "../../lib-jitsi-meet/node_modules/ws/index.js");
                } catch (err) {
                  throw new Error('You must install the "ws" package to use Strophe in nodejs.');
                }
              }

              return WebSocketImplementation;
            }

            const WebSocket = getWebSocketImplementation();
            /**
             * DOMParser
             * https://w3c.github.io/DOM-Parsing/#the-domparser-interface
             *
             * Interface to parse XML strings into Document objects
             *
             * Used implementations:
             * - supported browsers: built-in in DOMParser global
             *   https://developer.mozilla.org/en-US/docs/Web/API/DOMParser#Browser_compatibility
             * - nodejs: use '@xmldom/xmldom' module
             *   https://www.npmjs.com/package/@xmldom/xmldom
             */

            function getDOMParserImplementation() {
              let DOMParserImplementation = global$1.DOMParser;

              if (typeof DOMParserImplementation === 'undefined') {
                try {
                  DOMParserImplementation = (__webpack_require__(/*! @xmldom/xmldom */ "?9d57").DOMParser);
                } catch (err) {
                  throw new Error('You must install the "@xmldom/xmldom" package to use Strophe in nodejs.');
                }
              }

              return DOMParserImplementation;
            }

            const DOMParser = getDOMParserImplementation();
            /**
             *  Gets IE xml doc object. Used by getDummyXMLDocument shim.
             *
             *  Returns:
             *    A Microsoft XML DOM Object
             *  See Also:
             *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx
             */

            function _getIEXmlDom() {
              const docStrings = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"];

              for (let d = 0; d < docStrings.length; d++) {
                try {
                  // eslint-disable-next-line no-undef
                  const doc = new ActiveXObject(docStrings[d]);
                  return doc;
                } catch (e) {// Try next one
                }
              }
            }
            /**
             * Creates a dummy XML DOM document to serve as an element and text node generator.
             *
             * Used implementations:
             *  - IE < 10: avoid using createDocument() due to a memory leak, use ie-specific
             *    workaround
             *  - other supported browsers: use document's createDocument
             *  - nodejs: use '@xmldom/xmldom'
             */


            function getDummyXMLDOMDocument() {
              // nodejs
              if (typeof document === 'undefined') {
                try {
                  const DOMImplementation = (__webpack_require__(/*! @xmldom/xmldom */ "?9d57").DOMImplementation);

                  return new DOMImplementation().createDocument('jabber:client', 'strophe', null);
                } catch (err) {
                  throw new Error('You must install the "@xmldom/xmldom" package to use Strophe in nodejs.');
                }
              } // IE < 10


              if (document.implementation.createDocument === undefined || document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
                const doc = _getIEXmlDom();

                doc.appendChild(doc.createElement('strophe'));
                return doc;
              } // All other supported browsers


              return document.implementation.createDocument('jabber:client', 'strophe', null);
            }

            /*
             * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
             * Digest Algorithm, as defined in RFC 1321.
             * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
             * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
             * Distributed under the BSD License
             * See http://pajhome.org.uk/crypt/md5 for more info.
             */

            /*
             * Everything that isn't used by Strophe has been stripped here!
             */

            /*
             * Add integers, wrapping at 2^32. This uses 16-bit operations internally
             * to work around bugs in some JS interpreters.
             */
            const safe_add$1 = function (x, y) {
              const lsw = (x & 0xFFFF) + (y & 0xFFFF);
              const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
              return msw << 16 | lsw & 0xFFFF;
            };
            /*
             * Bitwise rotate a 32-bit number to the left.
             */


            const bit_rol = function (num, cnt) {
              return num << cnt | num >>> 32 - cnt;
            };
            /*
             * Convert a string to an array of little-endian words
             */


            const str2binl = function (str) {
              if (typeof str !== "string") {
                throw new Error("str2binl was passed a non-string");
              }

              const bin = [];

              for (let i = 0; i < str.length * 8; i += 8) {
                bin[i >> 5] |= (str.charCodeAt(i / 8) & 255) << i % 32;
              }

              return bin;
            };
            /*
             * Convert an array of little-endian words to a string
             */


            const binl2str = function (bin) {
              let str = "";

              for (let i = 0; i < bin.length * 32; i += 8) {
                str += String.fromCharCode(bin[i >> 5] >>> i % 32 & 255);
              }

              return str;
            };
            /*
             * Convert an array of little-endian words to a hex string.
             */


            const binl2hex = function (binarray) {
              const hex_tab = "0123456789abcdef";
              let str = "";

              for (let i = 0; i < binarray.length * 4; i++) {
                str += hex_tab.charAt(binarray[i >> 2] >> i % 4 * 8 + 4 & 0xF) + hex_tab.charAt(binarray[i >> 2] >> i % 4 * 8 & 0xF);
              }

              return str;
            };
            /*
             * These functions implement the four basic operations the algorithm uses.
             */


            const md5_cmn = function (q, a, b, x, s, t) {
              return safe_add$1(bit_rol(safe_add$1(safe_add$1(a, q), safe_add$1(x, t)), s), b);
            };

            const md5_ff = function (a, b, c, d, x, s, t) {
              return md5_cmn(b & c | ~b & d, a, b, x, s, t);
            };

            const md5_gg = function (a, b, c, d, x, s, t) {
              return md5_cmn(b & d | c & ~d, a, b, x, s, t);
            };

            const md5_hh = function (a, b, c, d, x, s, t) {
              return md5_cmn(b ^ c ^ d, a, b, x, s, t);
            };

            const md5_ii = function (a, b, c, d, x, s, t) {
              return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
            };
            /*
             * Calculate the MD5 of an array of little-endian words, and a bit length
             */


            const core_md5 = function (x, len) {
              /* append padding */
              x[len >> 5] |= 0x80 << len % 32;
              x[(len + 64 >>> 9 << 4) + 14] = len;
              let a = 1732584193;
              let b = -271733879;
              let c = -1732584194;
              let d = 271733878;
              let olda, oldb, oldc, oldd;

              for (let i = 0; i < x.length; i += 16) {
                olda = a;
                oldb = b;
                oldc = c;
                oldd = d;
                a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
                d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
                c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
                b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
                a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
                d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
                c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
                b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
                a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
                d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
                c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
                b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
                a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
                d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
                c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
                b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
                a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
                d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
                c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
                b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
                a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
                d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
                c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
                b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
                a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
                d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
                c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
                b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
                a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
                d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
                c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
                b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
                a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
                d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
                c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
                b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
                a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
                d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
                c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
                b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
                a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
                d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
                c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
                b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
                a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
                d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
                c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
                b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
                a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
                d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
                c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
                b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
                a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
                d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
                c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
                b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
                a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
                d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
                c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
                b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
                a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
                d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
                c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
                b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
                a = safe_add$1(a, olda);
                b = safe_add$1(b, oldb);
                c = safe_add$1(c, oldc);
                d = safe_add$1(d, oldd);
              }

              return [a, b, c, d];
            };
            /*
             * These are the functions you'll usually want to call.
             * They take string arguments and return either hex or base-64 encoded
             * strings.
             */


            const MD5 = {
              hexdigest: function (s) {
                return binl2hex(core_md5(str2binl(s), s.length * 8));
              },
              hash: function (s) {
                return binl2str(core_md5(str2binl(s), s.length * 8));
              }
            };

            /** Class: Strophe.SASLMechanism
             *
             *  Encapsulates an SASL authentication mechanism.
             *
             *  User code may override the priority for each mechanism or disable it completely.
             *  See <priority> for information about changing priority and <test> for informatian on
             *  how to disable a mechanism.
             *
             *  By default, all mechanisms are enabled and the priorities are
             *
             *      SCRAM-SHA-1 - 60
             *      PLAIN       - 50
             *      OAUTHBEARER - 40
             *      X-OAUTH2    - 30
             *      ANONYMOUS   - 20
             *      EXTERNAL    - 10
             *
             *  See: Strophe.Connection.addSupportedSASLMechanisms
             */
            class SASLMechanism {
              /**
               * PrivateConstructor: Strophe.SASLMechanism
               * SASL auth mechanism abstraction.
               *
               *  Parameters:
               *    (String) name - SASL Mechanism name.
               *    (Boolean) isClientFirst - If client should send response first without challenge.
               *    (Number) priority - Priority.
               *
               *  Returns:
               *    A new Strophe.SASLMechanism object.
               */
              constructor(name, isClientFirst, priority) {
                /** PrivateVariable: mechname
                 *  Mechanism name.
                 */
                this.mechname = name;
                /** PrivateVariable: isClientFirst
                 *  If client sends response without initial server challenge.
                 */

                this.isClientFirst = isClientFirst;
                /** Variable: priority
                 *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).
                 *  Users may override this to prioritize mechanisms differently.
                 *
                 *  Example: (This will cause Strophe to choose the mechanism that the server sent first)
                 *
                 *  > Strophe.SASLPlain.priority = Strophe.SASLSHA1.priority;
                 *
                 *  See <SASL mechanisms> for a list of available mechanisms.
                 *
                 */

                this.priority = priority;
              }
              /**
               *  Function: test
               *  Checks if mechanism able to run.
               *  To disable a mechanism, make this return false;
               *
               *  To disable plain authentication run
               *  > Strophe.SASLPlain.test = function() {
               *  >   return false;
               *  > }
               *
               *  See <SASL mechanisms> for a list of available mechanisms.
               *
               *  Parameters:
               *    (Strophe.Connection) connection - Target Connection.
               *
               *  Returns:
               *    (Boolean) If mechanism was able to run.
               */


              test() {
                // eslint-disable-line class-methods-use-this
                return true;
              }
              /** PrivateFunction: onStart
               *  Called before starting mechanism on some connection.
               *
               *  Parameters:
               *    (Strophe.Connection) connection - Target Connection.
               */


              onStart(connection) {
                this._connection = connection;
              }
              /** PrivateFunction: onChallenge
               *  Called by protocol implementation on incoming challenge.
               *
               *  By deafult, if the client is expected to send data first (isClientFirst === true),
               *  this method is called with `challenge` as null on the first call,
               *  unless `clientChallenge` is overridden in the relevant subclass.
               *
               *  Parameters:
               *    (Strophe.Connection) connection - Target Connection.
               *    (String) challenge - current challenge to handle.
               *
               *  Returns:
               *    (String) Mechanism response.
               */


              onChallenge(connection, challenge) {
                // eslint-disable-line
                throw new Error("You should implement challenge handling!");
              }
              /** PrivateFunction: clientChallenge
               *  Called by the protocol implementation if the client is expected to send
               *  data first in the authentication exchange (i.e. isClientFirst === true).
               *
               *  Parameters:
               *    (Strophe.Connection) connection - Target Connection.
               *
               *  Returns:
               *    (String) Mechanism response.
               */


              clientChallenge(connection) {
                if (!this.isClientFirst) {
                  throw new Error("clientChallenge should not be called if isClientFirst is false!");
                }

                return this.onChallenge(connection);
              }
              /** PrivateFunction: onFailure
               *  Protocol informs mechanism implementation about SASL failure.
               */


              onFailure() {
                this._connection = null;
              }
              /** PrivateFunction: onSuccess
               *  Protocol informs mechanism implementation about SASL success.
               */


              onSuccess() {
                this._connection = null;
              }

            }

            class SASLAnonymous extends SASLMechanism {
              /** PrivateConstructor: SASLAnonymous
               *  SASL ANONYMOUS authentication.
               */
              constructor() {
                let mechname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ANONYMOUS';
                let isClientFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 20;
                super(mechname, isClientFirst, priority);
              }

              test(connection) {
                // eslint-disable-line class-methods-use-this
                return connection.authcid === null;
              }

            }

            class SASLExternal extends SASLMechanism {
              /** PrivateConstructor: SASLExternal
               *  SASL EXTERNAL authentication.
               *
               *  The EXTERNAL mechanism allows a client to request the server to use
               *  credentials established by means external to the mechanism to
               *  authenticate the client. The external means may be, for instance,
               *  TLS services.
               */
              constructor() {
                let mechname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'EXTERNAL';
                let isClientFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
                super(mechname, isClientFirst, priority);
              }

              onChallenge(connection) {
                // eslint-disable-line class-methods-use-this

                /** According to XEP-178, an authzid SHOULD NOT be presented when the
                 * authcid contained or implied in the client certificate is the JID (i.e.
                 * authzid) with which the user wants to log in as.
                 *
                 * To NOT send the authzid, the user should therefore set the authcid equal
                 * to the JID when instantiating a new Strophe.Connection object.
                 */
                return connection.authcid === connection.authzid ? '' : connection.authzid;
              }

            }

            const utils = {
              utf16to8: function (str) {
                var i, c;
                var out = "";
                var len = str.length;

                for (i = 0; i < len; i++) {
                  c = str.charCodeAt(i);

                  if (c >= 0x0000 && c <= 0x007F) {
                    out += str.charAt(i);
                  } else if (c > 0x07FF) {
                    out += String.fromCharCode(0xE0 | c >> 12 & 0x0F);
                    out += String.fromCharCode(0x80 | c >> 6 & 0x3F);
                    out += String.fromCharCode(0x80 | c >> 0 & 0x3F);
                  } else {
                    out += String.fromCharCode(0xC0 | c >> 6 & 0x1F);
                    out += String.fromCharCode(0x80 | c >> 0 & 0x3F);
                  }
                }

                return out;
              },
              addCookies: function (cookies) {
                /* Parameters:
                 *  (Object) cookies - either a map of cookie names
                 *    to string values or to maps of cookie values.
                 *
                 * For example:
                 * { "myCookie": "1234" }
                 *
                 * or:
                 * { "myCookie": {
                 *      "value": "1234",
                 *      "domain": ".example.org",
                 *      "path": "/",
                 *      "expires": expirationDate
                 *      }
                 *  }
                 *
                 *  These values get passed to Strophe.Connection via
                 *   options.cookies
                 */
                cookies = cookies || {};

                for (const cookieName in cookies) {
                  if (Object.prototype.hasOwnProperty.call(cookies, cookieName)) {
                    let expires = '';
                    let domain = '';
                    let path = '';
                    const cookieObj = cookies[cookieName];
                    const isObj = typeof cookieObj === "object";
                    const cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));

                    if (isObj) {
                      expires = cookieObj.expires ? ";expires=" + cookieObj.expires : '';
                      domain = cookieObj.domain ? ";domain=" + cookieObj.domain : '';
                      path = cookieObj.path ? ";path=" + cookieObj.path : '';
                    }

                    document.cookie = cookieName + '=' + cookieValue + expires + domain + path;
                  }
                }
              }
            };

            class SASLOAuthBearer extends SASLMechanism {
              /** PrivateConstructor: SASLOAuthBearer
               *  SASL OAuth Bearer authentication.
               */
              constructor() {
                let mechname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'OAUTHBEARER';
                let isClientFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 40;
                super(mechname, isClientFirst, priority);
              }

              test(connection) {
                // eslint-disable-line class-methods-use-this
                return connection.pass !== null;
              }

              onChallenge(connection) {
                // eslint-disable-line class-methods-use-this
                let auth_str = 'n,';

                if (connection.authcid !== null) {
                  auth_str = auth_str + 'a=' + connection.authzid;
                }

                auth_str = auth_str + ',';
                auth_str = auth_str + "\u0001";
                auth_str = auth_str + 'auth=Bearer ';
                auth_str = auth_str + connection.pass;
                auth_str = auth_str + "\u0001";
                auth_str = auth_str + "\u0001";
                return utils.utf16to8(auth_str);
              }

            }

            class SASLPlain extends SASLMechanism {
              /** PrivateConstructor: SASLPlain
               *  SASL PLAIN authentication.
               */
              constructor() {
                let mechname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'PLAIN';
                let isClientFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;
                super(mechname, isClientFirst, priority);
              }

              test(connection) {
                // eslint-disable-line class-methods-use-this
                return connection.authcid !== null;
              }

              onChallenge(connection) {
                // eslint-disable-line class-methods-use-this
                const {
                  authcid,
                  authzid,
                  domain,
                  pass
                } = connection;

                if (!domain) {
                  throw new Error("SASLPlain onChallenge: domain is not defined!");
                } // Only include authzid if it differs from authcid.
                // See: https://tools.ietf.org/html/rfc6120#section-6.3.8


                let auth_str = authzid !== `${authcid}@${domain}` ? authzid : '';
                auth_str = auth_str + "\u0000";
                auth_str = auth_str + authcid;
                auth_str = auth_str + "\u0000";
                auth_str = auth_str + pass;
                return utils.utf16to8(auth_str);
              }

            }

            /*
             * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
             * in FIPS PUB 180-1
             * Version 2.1a Copyright Paul Johnston 2000 - 2002.
             * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
             * Distributed under the BSD License
             * See http://pajhome.org.uk/crypt/md5 for details.
             */

            /* global define */

            /* Some functions and variables have been stripped for use with Strophe */

            /*
             * Calculate the SHA-1 of an array of big-endian words, and a bit length
             */
            function core_sha1(x, len) {
              /* append padding */
              x[len >> 5] |= 0x80 << 24 - len % 32;
              x[(len + 64 >> 9 << 4) + 15] = len;
              var w = new Array(80);
              var a = 1732584193;
              var b = -271733879;
              var c = -1732584194;
              var d = 271733878;
              var e = -1009589776;
              var i, j, t, olda, oldb, oldc, oldd, olde;

              for (i = 0; i < x.length; i += 16) {
                olda = a;
                oldb = b;
                oldc = c;
                oldd = d;
                olde = e;

                for (j = 0; j < 80; j++) {
                  if (j < 16) {
                    w[j] = x[i + j];
                  } else {
                    w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                  }

                  t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
                  e = d;
                  d = c;
                  c = rol(b, 30);
                  b = a;
                  a = t;
                }

                a = safe_add(a, olda);
                b = safe_add(b, oldb);
                c = safe_add(c, oldc);
                d = safe_add(d, oldd);
                e = safe_add(e, olde);
              }

              return [a, b, c, d, e];
            }
            /*
             * Perform the appropriate triplet combination function for the current
             * iteration
             */


            function sha1_ft(t, b, c, d) {
              if (t < 20) {
                return b & c | ~b & d;
              }

              if (t < 40) {
                return b ^ c ^ d;
              }

              if (t < 60) {
                return b & c | b & d | c & d;
              }

              return b ^ c ^ d;
            }
            /*
             * Determine the appropriate additive constant for the current iteration
             */


            function sha1_kt(t) {
              return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
            }
            /*
             * Calculate the HMAC-SHA1 of a key and some data
             */


            function core_hmac_sha1(key, data) {
              var bkey = str2binb(key);

              if (bkey.length > 16) {
                bkey = core_sha1(bkey, key.length * 8);
              }

              var ipad = new Array(16),
                  opad = new Array(16);

              for (var i = 0; i < 16; i++) {
                ipad[i] = bkey[i] ^ 0x36363636;
                opad[i] = bkey[i] ^ 0x5C5C5C5C;
              }

              var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
              return core_sha1(opad.concat(hash), 512 + 160);
            }
            /*
             * Add integers, wrapping at 2^32. This uses 16-bit operations internally
             * to work around bugs in some JS interpreters.
             */


            function safe_add(x, y) {
              var lsw = (x & 0xFFFF) + (y & 0xFFFF);
              var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
              return msw << 16 | lsw & 0xFFFF;
            }
            /*
             * Bitwise rotate a 32-bit number to the left.
             */


            function rol(num, cnt) {
              return num << cnt | num >>> 32 - cnt;
            }
            /*
             * Convert an 8-bit or 16-bit string to an array of big-endian words
             * In 8-bit function, characters >255 have their hi-byte silently ignored.
             */


            function str2binb(str) {
              var bin = [];
              var mask = 255;

              for (var i = 0; i < str.length * 8; i += 8) {
                bin[i >> 5] |= (str.charCodeAt(i / 8) & mask) << 24 - i % 32;
              }

              return bin;
            }
            /*
             * Convert an array of big-endian words to a base-64 string
             */


            function binb2b64(binarray) {
              var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
              var str = "";
              var triplet, j;

              for (var i = 0; i < binarray.length * 4; i += 3) {
                triplet = (binarray[i >> 2] >> 8 * (3 - i % 4) & 0xFF) << 16 | (binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4) & 0xFF) << 8 | binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4) & 0xFF;

                for (j = 0; j < 4; j++) {
                  if (i * 8 + j * 6 > binarray.length * 32) {
                    str += "=";
                  } else {
                    str += tab.charAt(triplet >> 6 * (3 - j) & 0x3F);
                  }
                }
              }

              return str;
            }
            /*
             * Convert an array of big-endian words to a string
             */


            function binb2str(bin) {
              var str = "";
              var mask = 255;

              for (var i = 0; i < bin.length * 32; i += 8) {
                str += String.fromCharCode(bin[i >> 5] >>> 24 - i % 32 & mask);
              }

              return str;
            }
            /*
             * These are the functions you'll usually want to call
             * They take string arguments and return either hex or base-64 encoded strings
             */


            const SHA1 = {
              b64_hmac_sha1: function (key, data) {
                return binb2b64(core_hmac_sha1(key, data));
              },
              b64_sha1: function (s) {
                return binb2b64(core_sha1(str2binb(s), s.length * 8));
              },
              binb2str: binb2str,
              core_hmac_sha1: core_hmac_sha1,
              str_hmac_sha1: function (key, data) {
                return binb2str(core_hmac_sha1(key, data));
              },
              str_sha1: function (s) {
                return binb2str(core_sha1(str2binb(s), s.length * 8));
              }
            };

            class SASLSHA1 extends SASLMechanism {
              /** PrivateConstructor: SASLSHA1
               *  SASL SCRAM SHA 1 authentication.
               */
              constructor() {
                let mechname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'SCRAM-SHA-1';
                let isClientFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;
                super(mechname, isClientFirst, priority);
              }

              test(connection) {
                // eslint-disable-line class-methods-use-this
                return connection.authcid !== null;
              }

              onChallenge(connection, challenge) {
                // eslint-disable-line class-methods-use-this
                let nonce, salt, iter, Hi, U, U_old, i, k;
                let responseText = "c=biws,";
                let authMessage = `${connection._sasl_data["client-first-message-bare"]},${challenge},`;
                const cnonce = connection._sasl_data.cnonce;
                const attribMatch = /([a-z]+)=([^,]+)(,|$)/;

                while (challenge.match(attribMatch)) {
                  const matches = challenge.match(attribMatch);
                  challenge = challenge.replace(matches[0], "");

                  switch (matches[1]) {
                    case "r":
                      nonce = matches[2];
                      break;

                    case "s":
                      salt = matches[2];
                      break;

                    case "i":
                      iter = matches[2];
                      break;
                  }
                }

                if (nonce.slice(0, cnonce.length) !== cnonce) {
                  connection._sasl_data = {};
                  return connection._sasl_failure_cb();
                }

                responseText += "r=" + nonce;
                authMessage += responseText;
                salt = atob(salt);
                salt += "\x00\x00\x00\x01";
                const pass = utils.utf16to8(connection.pass);
                Hi = U_old = SHA1.core_hmac_sha1(pass, salt);

                for (i = 1; i < iter; i++) {
                  U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));

                  for (k = 0; k < 5; k++) {
                    Hi[k] ^= U[k];
                  }

                  U_old = U;
                }

                Hi = SHA1.binb2str(Hi);
                const clientKey = SHA1.core_hmac_sha1(Hi, "Client Key");
                const serverKey = SHA1.str_hmac_sha1(Hi, "Server Key");
                const clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);
                connection._sasl_data["server-signature"] = SHA1.b64_hmac_sha1(serverKey, authMessage);

                for (k = 0; k < 5; k++) {
                  clientKey[k] ^= clientSignature[k];
                }

                responseText += ",p=" + btoa(SHA1.binb2str(clientKey));
                return responseText;
              }

              clientChallenge(connection, test_cnonce) {
                // eslint-disable-line class-methods-use-this
                const cnonce = test_cnonce || MD5.hexdigest("" + Math.random() * 1234567890);
                let auth_str = "n=" + utils.utf16to8(connection.authcid);
                auth_str += ",r=";
                auth_str += cnonce;
                connection._sasl_data.cnonce = cnonce;
                connection._sasl_data["client-first-message-bare"] = auth_str;
                auth_str = "n,," + auth_str;
                return auth_str;
              }

            }

            class SASLXOAuth2 extends SASLMechanism {
              /** PrivateConstructor: SASLXOAuth2
               *  SASL X-OAuth2 authentication.
               */
              constructor() {
                let mechname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'X-OAUTH2';
                let isClientFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 30;
                super(mechname, isClientFirst, priority);
              }

              test(connection) {
                // eslint-disable-line class-methods-use-this
                return connection.pass !== null;
              }

              onChallenge(connection) {
                // eslint-disable-line class-methods-use-this
                let auth_str = '\u0000';

                if (connection.authcid !== null) {
                  auth_str = auth_str + connection.authzid;
                }

                auth_str = auth_str + "\u0000";
                auth_str = auth_str + connection.pass;
                return utils.utf16to8(auth_str);
              }

            }

            /**
             * Implementation of atob() according to the HTML and Infra specs, except that
             * instead of throwing INVALID_CHARACTER_ERR we return null.
             */

            function atob$2(data) {
              if (arguments.length === 0) {
                throw new TypeError("1 argument required, but only 0 present.");
              } // Web IDL requires DOMStrings to just be converted using ECMAScript
              // ToString, which in our case amounts to using a template literal.


              data = `${data}`; // "Remove all ASCII whitespace from data."

              data = data.replace(/[ \t\n\f\r]/g, ""); // "If data's length divides by 4 leaving no remainder, then: if data ends
              // with one or two U+003D (=) code points, then remove them from data."

              if (data.length % 4 === 0) {
                data = data.replace(/==?$/, "");
              } // "If data's length divides by 4 leaving a remainder of 1, then return
              // failure."
              //
              // "If data contains a code point that is not one of
              //
              // U+002B (+)
              // U+002F (/)
              // ASCII alphanumeric
              //
              // then return failure."


              if (data.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(data)) {
                return null;
              } // "Let output be an empty byte sequence."


              let output = ""; // "Let buffer be an empty buffer that can have bits appended to it."
              //
              // We append bits via left-shift and or.  accumulatedBits is used to track
              // when we've gotten to 24 bits.

              let buffer = 0;
              let accumulatedBits = 0; // "Let position be a position variable for data, initially pointing at the
              // start of data."
              //
              // "While position does not point past the end of data:"

              for (let i = 0; i < data.length; i++) {
                // "Find the code point pointed to by position in the second column of
                // Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in
                // the first cell of the same row.
                //
                // "Append to buffer the six bits corresponding to n, most significant bit
                // first."
                //
                // atobLookup() implements the table from RFC 4648.
                buffer <<= 6;
                buffer |= atobLookup(data[i]);
                accumulatedBits += 6; // "If buffer has accumulated 24 bits, interpret them as three 8-bit
                // big-endian numbers. Append three bytes with values equal to those
                // numbers to output, in the same order, and then empty buffer."

                if (accumulatedBits === 24) {
                  output += String.fromCharCode((buffer & 0xff0000) >> 16);
                  output += String.fromCharCode((buffer & 0xff00) >> 8);
                  output += String.fromCharCode(buffer & 0xff);
                  buffer = accumulatedBits = 0;
                } // "Advance position by 1."

              } // "If buffer is not empty, it contains either 12 or 18 bits. If it contains
              // 12 bits, then discard the last four and interpret the remaining eight as
              // an 8-bit big-endian number. If it contains 18 bits, then discard the last
              // two and interpret the remaining 16 as two 8-bit big-endian numbers. Append
              // the one or two bytes with values equal to those one or two numbers to
              // output, in the same order."


              if (accumulatedBits === 12) {
                buffer >>= 4;
                output += String.fromCharCode(buffer);
              } else if (accumulatedBits === 18) {
                buffer >>= 2;
                output += String.fromCharCode((buffer & 0xff00) >> 8);
                output += String.fromCharCode(buffer & 0xff);
              } // "Return output."


              return output;
            }
            /**
             * A lookup table for atob(), which converts an ASCII character to the
             * corresponding six-bit number.
             */


            const keystr$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

            function atobLookup(chr) {
              const index = keystr$1.indexOf(chr); // Throw exception if character is not in the lookup string; should not be hit in tests

              return index < 0 ? undefined : index;
            }

            var atob_1 = atob$2;

            /**
             * btoa() as defined by the HTML and Infra specs, which mostly just references
             * RFC 4648.
             */

            function btoa$2(s) {
              if (arguments.length === 0) {
                throw new TypeError("1 argument required, but only 0 present.");
              }

              let i; // String conversion as required by Web IDL.

              s = `${s}`; // "The btoa() method must throw an "InvalidCharacterError" DOMException if
              // data contains any character whose code point is greater than U+00FF."

              for (i = 0; i < s.length; i++) {
                if (s.charCodeAt(i) > 255) {
                  return null;
                }
              }

              let out = "";

              for (i = 0; i < s.length; i += 3) {
                const groupsOfSix = [undefined, undefined, undefined, undefined];
                groupsOfSix[0] = s.charCodeAt(i) >> 2;
                groupsOfSix[1] = (s.charCodeAt(i) & 0x03) << 4;

                if (s.length > i + 1) {
                  groupsOfSix[1] |= s.charCodeAt(i + 1) >> 4;
                  groupsOfSix[2] = (s.charCodeAt(i + 1) & 0x0f) << 2;
                }

                if (s.length > i + 2) {
                  groupsOfSix[2] |= s.charCodeAt(i + 2) >> 6;
                  groupsOfSix[3] = s.charCodeAt(i + 2) & 0x3f;
                }

                for (let j = 0; j < groupsOfSix.length; j++) {
                  if (typeof groupsOfSix[j] === "undefined") {
                    out += "=";
                  } else {
                    out += btoaLookup(groupsOfSix[j]);
                  }
                }
              }

              return out;
            }
            /**
             * Lookup table for btoa(), which converts a six-bit number into the
             * corresponding ASCII character.
             */


            const keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

            function btoaLookup(index) {
              if (index >= 0 && index < 64) {
                return keystr[index];
              } // Throw INVALID_CHARACTER_ERR exception here -- won't be hit in the tests.


              return undefined;
            }

            var btoa_1 = btoa$2;

            const atob$1 = atob_1;

            const btoa$1 = btoa_1;

            var abab = {
              atob: atob$1,
              btoa: btoa$1
            };

            /*
                This program is distributed under the terms of the MIT license.
                Please see the LICENSE file for details.

                Copyright 2006-2018, OGG, LLC
            */
            /** Function: $build
             *  Create a Strophe.Builder.
             *  This is an alias for 'new Strophe.Builder(name, attrs)'.
             *
             *  Parameters:
             *    (String) name - The root element name.
             *    (Object) attrs - The attributes for the root element in object notation.
             *
             *  Returns:
             *    A new Strophe.Builder object.
             */

            function $build(name, attrs) {
              return new Strophe.Builder(name, attrs);
            }
            /** Function: $msg
             *  Create a Strophe.Builder with a <message/> element as the root.
             *
             *  Parameters:
             *    (Object) attrs - The <message/> element attributes in object notation.
             *
             *  Returns:
             *    A new Strophe.Builder object.
             */

            function $msg(attrs) {
              return new Strophe.Builder("message", attrs);
            }
            /** Function: $iq
             *  Create a Strophe.Builder with an <iq/> element as the root.
             *
             *  Parameters:
             *    (Object) attrs - The <iq/> element attributes in object notation.
             *
             *  Returns:
             *    A new Strophe.Builder object.
             */

            function $iq(attrs) {
              return new Strophe.Builder("iq", attrs);
            }
            /** Function: $pres
             *  Create a Strophe.Builder with a <presence/> element as the root.
             *
             *  Parameters:
             *    (Object) attrs - The <presence/> element attributes in object notation.
             *
             *  Returns:
             *    A new Strophe.Builder object.
             */

            function $pres(attrs) {
              return new Strophe.Builder("presence", attrs);
            }
            /** Class: Strophe
             *  An object container for all Strophe library functions.
             *
             *  This class is just a container for all the objects and constants
             *  used in the library.  It is not meant to be instantiated, but to
             *  provide a namespace for library objects, constants, and functions.
             */

            const Strophe = {
              /** Constant: VERSION */
              VERSION: "1.5.0",

              /** Constants: XMPP Namespace Constants
               *  Common namespace constants from the XMPP RFCs and XEPs.
               *
               *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.
               *  NS.BOSH - BOSH namespace from XEP 206.
               *  NS.CLIENT - Main XMPP client namespace.
               *  NS.AUTH - Legacy authentication namespace.
               *  NS.ROSTER - Roster operations namespace.
               *  NS.PROFILE - Profile namespace.
               *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.
               *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.
               *  NS.MUC - Multi-User Chat namespace from XEP 45.
               *  NS.SASL - XMPP SASL namespace from RFC 3920.
               *  NS.STREAM - XMPP Streams namespace from RFC 3920.
               *  NS.BIND - XMPP Binding namespace from RFC 3920 and RFC 6120.
               *  NS.SESSION - XMPP Session namespace from RFC 3920.
               *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.
               *  NS.XHTML - XHTML body namespace from XEP 71.
               */
              NS: {
                HTTPBIND: "http://jabber.org/protocol/httpbind",
                BOSH: "urn:xmpp:xbosh",
                CLIENT: "jabber:client",
                AUTH: "jabber:iq:auth",
                ROSTER: "jabber:iq:roster",
                PROFILE: "jabber:iq:profile",
                DISCO_INFO: "http://jabber.org/protocol/disco#info",
                DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                MUC: "http://jabber.org/protocol/muc",
                SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                STREAM: "http://etherx.jabber.org/streams",
                FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                VERSION: "jabber:iq:version",
                STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                XHTML: "http://www.w3.org/1999/xhtml"
              },

              /** Constants: XHTML_IM Namespace
               *  contains allowed tags, tag attributes, and css properties.
               *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.
               *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended
               *  allowed tags and their attributes.
               */
              XHTML: {
                tags: ['a', 'blockquote', 'br', 'cite', 'em', 'img', 'li', 'ol', 'p', 'span', 'strong', 'ul', 'body'],
                attributes: {
                  'a': ['href'],
                  'blockquote': ['style'],
                  'br': [],
                  'cite': ['style'],
                  'em': [],
                  'img': ['src', 'alt', 'style', 'height', 'width'],
                  'li': ['style'],
                  'ol': ['style'],
                  'p': ['style'],
                  'span': ['style'],
                  'strong': [],
                  'ul': ['style'],
                  'body': []
                },
                css: ['background-color', 'color', 'font-family', 'font-size', 'font-style', 'font-weight', 'margin-left', 'margin-right', 'text-align', 'text-decoration'],

                /** Function: XHTML.validTag
                 *
                 * Utility method to determine whether a tag is allowed
                 * in the XHTML_IM namespace.
                 *
                 * XHTML tag names are case sensitive and must be lower case.
                 */
                validTag(tag) {
                  for (let i = 0; i < Strophe.XHTML.tags.length; i++) {
                    if (tag === Strophe.XHTML.tags[i]) {
                      return true;
                    }
                  }

                  return false;
                },

                /** Function: XHTML.validAttribute
                 *
                 * Utility method to determine whether an attribute is allowed
                 * as recommended per XEP-0071
                 *
                 * XHTML attribute names are case sensitive and must be lower case.
                 */
                validAttribute(tag, attribute) {
                  if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {
                    for (let i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                      if (attribute === Strophe.XHTML.attributes[tag][i]) {
                        return true;
                      }
                    }
                  }

                  return false;
                },

                validCSS(style) {
                  for (let i = 0; i < Strophe.XHTML.css.length; i++) {
                    if (style === Strophe.XHTML.css[i]) {
                      return true;
                    }
                  }

                  return false;
                }

              },

              /** Constants: Connection Status Constants
               *  Connection status constants for use by the connection handler
               *  callback.
               *
               *  Status.ERROR - An error has occurred
               *  Status.CONNECTING - The connection is currently being made
               *  Status.CONNFAIL - The connection attempt failed
               *  Status.AUTHENTICATING - The connection is authenticating
               *  Status.AUTHFAIL - The authentication attempt failed
               *  Status.CONNECTED - The connection has succeeded
               *  Status.DISCONNECTED - The connection has been terminated
               *  Status.DISCONNECTING - The connection is currently being terminated
               *  Status.ATTACHED - The connection has been attached
               *  Status.REDIRECT - The connection has been redirected
               *  Status.CONNTIMEOUT - The connection has timed out
               */
              Status: {
                ERROR: 0,
                CONNECTING: 1,
                CONNFAIL: 2,
                AUTHENTICATING: 3,
                AUTHFAIL: 4,
                CONNECTED: 5,
                DISCONNECTED: 6,
                DISCONNECTING: 7,
                ATTACHED: 8,
                REDIRECT: 9,
                CONNTIMEOUT: 10,
                BINDREQUIRED: 11,
                ATTACHFAIL: 12
              },
              ErrorCondition: {
                BAD_FORMAT: "bad-format",
                CONFLICT: "conflict",
                MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
                NO_AUTH_MECH: "no-auth-mech",
                UNKNOWN_REASON: "unknown"
              },

              /** Constants: Log Level Constants
               *  Logging level indicators.
               *
               *  LogLevel.DEBUG - Debug output
               *  LogLevel.INFO - Informational output
               *  LogLevel.WARN - Warnings
               *  LogLevel.ERROR - Errors
               *  LogLevel.FATAL - Fatal errors
               */
              LogLevel: {
                DEBUG: 0,
                INFO: 1,
                WARN: 2,
                ERROR: 3,
                FATAL: 4
              },

              /** PrivateConstants: DOM Element Type Constants
               *  DOM element types.
               *
               *  ElementType.NORMAL - Normal element.
               *  ElementType.TEXT - Text data element.
               *  ElementType.FRAGMENT - XHTML fragment element.
               */
              ElementType: {
                NORMAL: 1,
                TEXT: 3,
                CDATA: 4,
                FRAGMENT: 11
              },

              /** PrivateConstants: Timeout Values
               *  Timeout values for error states.  These values are in seconds.
               *  These should not be changed unless you know exactly what you are
               *  doing.
               *
               *  TIMEOUT - Timeout multiplier. A waiting request will be considered
               *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.
               *      This defaults to 1.1, and with default wait, 66 seconds.
               *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where
               *      Strophe can detect early failure, it will consider the request
               *      failed if it doesn't return after
               *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.
               *      This defaults to 0.1, and with default wait, 6 seconds.
               */
              TIMEOUT: 1.1,
              SECONDARY_TIMEOUT: 0.1,

              /** Function: addNamespace
               *  This function is used to extend the current namespaces in
               *  Strophe.NS.  It takes a key and a value with the key being the
               *  name of the new namespace, with its actual value.
               *  For example:
               *  Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
               *
               *  Parameters:
               *    (String) name - The name under which the namespace will be
               *      referenced under Strophe.NS
               *    (String) value - The actual namespace.
               */
              addNamespace(name, value) {
                Strophe.NS[name] = value;
              },

              /** Function: forEachChild
               *  Map a function over some or all child elements of a given element.
               *
               *  This is a small convenience function for mapping a function over
               *  some or all of the children of an element.  If elemName is null, all
               *  children will be passed to the function, otherwise only children
               *  whose tag names match elemName will be passed.
               *
               *  Parameters:
               *    (XMLElement) elem - The element to operate on.
               *    (String) elemName - The child element tag name filter.
               *    (Function) func - The function to apply to each child.  This
               *      function should take a single argument, a DOM element.
               */
              forEachChild(elem, elemName, func) {
                for (let i = 0; i < elem.childNodes.length; i++) {
                  const childNode = elem.childNodes[i];

                  if (childNode.nodeType === Strophe.ElementType.NORMAL && (!elemName || this.isTagEqual(childNode, elemName))) {
                    func(childNode);
                  }
                }
              },

              /** Function: isTagEqual
               *  Compare an element's tag name with a string.
               *
               *  This function is case sensitive.
               *
               *  Parameters:
               *    (XMLElement) el - A DOM element.
               *    (String) name - The element name.
               *
               *  Returns:
               *    true if the element's tag name matches _el_, and false
               *    otherwise.
               */
              isTagEqual(el, name) {
                return el.tagName === name;
              },

              /** PrivateVariable: _xmlGenerator
               *  _Private_ variable that caches a DOM document to
               *  generate elements.
               */
              _xmlGenerator: null,

              /** Function: xmlGenerator
               *  Get the DOM document to generate elements.
               *
               *  Returns:
               *    The currently used DOM document.
               */
              xmlGenerator() {
                if (!Strophe._xmlGenerator) {
                  Strophe._xmlGenerator = getDummyXMLDOMDocument();
                }

                return Strophe._xmlGenerator;
              },

              /** Function: xmlElement
               *  Create an XML DOM element.
               *
               *  This function creates an XML DOM element correctly across all
               *  implementations. Note that these are not HTML DOM elements, which
               *  aren't appropriate for XMPP stanzas.
               *
               *  Parameters:
               *    (String) name - The name for the element.
               *    (Array|Object) attrs - An optional array or object containing
               *      key/value pairs to use as element attributes. The object should
               *      be in the format {'key': 'value'} or {key: 'value'}. The array
               *      should have the format [['key1', 'value1'], ['key2', 'value2']].
               *    (String) text - The text child data for the element.
               *
               *  Returns:
               *    A new XML DOM element.
               */
              xmlElement(name) {
                if (!name) {
                  return null;
                }

                const node = Strophe.xmlGenerator().createElement(name); // FIXME: this should throw errors if args are the wrong type or
                // there are more than two optional args

                for (let a = 1; a < arguments.length; a++) {
                  const arg = arguments[a];

                  if (!arg) {
                    continue;
                  }

                  if (typeof arg === "string" || typeof arg === "number") {
                    node.appendChild(Strophe.xmlTextNode(arg));
                  } else if (typeof arg === "object" && typeof arg.sort === "function") {
                    for (let i = 0; i < arg.length; i++) {
                      const attr = arg[i];

                      if (typeof attr === "object" && typeof attr.sort === "function" && attr[1] !== undefined && attr[1] !== null) {
                        node.setAttribute(attr[0], attr[1]);
                      }
                    }
                  } else if (typeof arg === "object") {
                    for (const k in arg) {
                      if (Object.prototype.hasOwnProperty.call(arg, k) && arg[k] !== undefined && arg[k] !== null) {
                        node.setAttribute(k, arg[k]);
                      }
                    }
                  }
                }

                return node;
              },

              /*  Function: xmlescape
               *  Excapes invalid xml characters.
               *
               *  Parameters:
               *     (String) text - text to escape.
               *
               *  Returns:
               *      Escaped text.
               */
              xmlescape(text) {
                text = text.replace(/\&/g, "&amp;");
                text = text.replace(/</g, "&lt;");
                text = text.replace(/>/g, "&gt;");
                text = text.replace(/'/g, "&apos;");
                text = text.replace(/"/g, "&quot;");
                return text;
              },

              /*  Function: xmlunescape
              *  Unexcapes invalid xml characters.
              *
              *  Parameters:
              *     (String) text - text to unescape.
              *
              *  Returns:
              *      Unescaped text.
              */
              xmlunescape(text) {
                text = text.replace(/\&amp;/g, "&");
                text = text.replace(/&lt;/g, "<");
                text = text.replace(/&gt;/g, ">");
                text = text.replace(/&apos;/g, "'");
                text = text.replace(/&quot;/g, "\"");
                return text;
              },

              /** Function: xmlTextNode
               *  Creates an XML DOM text node.
               *
               *  Provides a cross implementation version of document.createTextNode.
               *
               *  Parameters:
               *    (String) text - The content of the text node.
               *
               *  Returns:
               *    A new XML DOM text node.
               */
              xmlTextNode(text) {
                return Strophe.xmlGenerator().createTextNode(text);
              },

              /** Function: xmlHtmlNode
               *  Creates an XML DOM html node.
               *
               *  Parameters:
               *    (String) html - The content of the html node.
               *
               *  Returns:
               *    A new XML DOM text node.
               */
              xmlHtmlNode(html) {
                let node; //ensure text is escaped

                if (DOMParser) {
                  const parser = new DOMParser();
                  node = parser.parseFromString(html, "text/xml");
                } else {
                  node = new ActiveXObject("Microsoft.XMLDOM");
                  node.async = "false";
                  node.loadXML(html);
                }

                return node;
              },

              /** Function: getText
               *  Get the concatenation of all text children of an element.
               *
               *  Parameters:
               *    (XMLElement) elem - A DOM element.
               *
               *  Returns:
               *    A String with the concatenated text of all text element children.
               */
              getText(elem) {
                if (!elem) {
                  return null;
                }

                let str = "";

                if (elem.childNodes.length === 0 && elem.nodeType === Strophe.ElementType.TEXT) {
                  str += elem.nodeValue;
                }

                for (let i = 0; i < elem.childNodes.length; i++) {
                  if (elem.childNodes[i].nodeType === Strophe.ElementType.TEXT) {
                    str += elem.childNodes[i].nodeValue;
                  }
                }

                return Strophe.xmlescape(str);
              },

              /** Function: copyElement
               *  Copy an XML DOM element.
               *
               *  This function copies a DOM element and all its descendants and returns
               *  the new copy.
               *
               *  Parameters:
               *    (XMLElement) elem - A DOM element.
               *
               *  Returns:
               *    A new, copied DOM element tree.
               */
              copyElement(elem) {
                let el;

                if (elem.nodeType === Strophe.ElementType.NORMAL) {
                  el = Strophe.xmlElement(elem.tagName);

                  for (let i = 0; i < elem.attributes.length; i++) {
                    el.setAttribute(elem.attributes[i].nodeName, elem.attributes[i].value);
                  }

                  for (let i = 0; i < elem.childNodes.length; i++) {
                    el.appendChild(Strophe.copyElement(elem.childNodes[i]));
                  }
                } else if (elem.nodeType === Strophe.ElementType.TEXT) {
                  el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);
                }

                return el;
              },

              /** Function: createHtml
               *  Copy an HTML DOM element into an XML DOM.
               *
               *  This function copies a DOM element and all its descendants and returns
               *  the new copy.
               *
               *  Parameters:
               *    (HTMLElement) elem - A DOM element.
               *
               *  Returns:
               *    A new, copied DOM element tree.
               */
              createHtml(elem) {
                let el;

                if (elem.nodeType === Strophe.ElementType.NORMAL) {
                  const tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.

                  if (Strophe.XHTML.validTag(tag)) {
                    try {
                      el = Strophe.xmlElement(tag);

                      for (let i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                        const attribute = Strophe.XHTML.attributes[tag][i];
                        let value = elem.getAttribute(attribute);

                        if (typeof value === 'undefined' || value === null || value === '' || value === false || value === 0) {
                          continue;
                        }

                        if (attribute === 'style' && typeof value === 'object' && typeof value.cssText !== 'undefined') {
                          value = value.cssText; // we're dealing with IE, need to get CSS out
                        } // filter out invalid css styles


                        if (attribute === 'style') {
                          const css = [];
                          const cssAttrs = value.split(';');

                          for (let j = 0; j < cssAttrs.length; j++) {
                            const attr = cssAttrs[j].split(':');
                            const cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();

                            if (Strophe.XHTML.validCSS(cssName)) {
                              const cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                              css.push(cssName + ': ' + cssValue);
                            }
                          }

                          if (css.length > 0) {
                            value = css.join('; ');
                            el.setAttribute(attribute, value);
                          }
                        } else {
                          el.setAttribute(attribute, value);
                        }
                      }

                      for (let i = 0; i < elem.childNodes.length; i++) {
                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                      }
                    } catch (e) {
                      // invalid elements
                      el = Strophe.xmlTextNode('');
                    }
                  } else {
                    el = Strophe.xmlGenerator().createDocumentFragment();

                    for (let i = 0; i < elem.childNodes.length; i++) {
                      el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                    }
                  }
                } else if (elem.nodeType === Strophe.ElementType.FRAGMENT) {
                  el = Strophe.xmlGenerator().createDocumentFragment();

                  for (let i = 0; i < elem.childNodes.length; i++) {
                    el.appendChild(Strophe.createHtml(elem.childNodes[i]));
                  }
                } else if (elem.nodeType === Strophe.ElementType.TEXT) {
                  el = Strophe.xmlTextNode(elem.nodeValue);
                }

                return el;
              },

              /** Function: escapeNode
               *  Escape the node part (also called local part) of a JID.
               *
               *  Parameters:
               *    (String) node - A node (or local part).
               *
               *  Returns:
               *    An escaped node (or local part).
               */
              escapeNode(node) {
                if (typeof node !== "string") {
                  return node;
                }

                return node.replace(/^\s+|\s+$/g, '').replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40");
              },

              /** Function: unescapeNode
               *  Unescape a node part (also called local part) of a JID.
               *
               *  Parameters:
               *    (String) node - A node (or local part).
               *
               *  Returns:
               *    An unescaped node (or local part).
               */
              unescapeNode(node) {
                if (typeof node !== "string") {
                  return node;
                }

                return node.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\");
              },

              /** Function: getNodeFromJid
               *  Get the node portion of a JID String.
               *
               *  Parameters:
               *    (String) jid - A JID.
               *
               *  Returns:
               *    A String containing the node.
               */
              getNodeFromJid(jid) {
                if (jid.indexOf("@") < 0) {
                  return null;
                }

                return jid.split("@")[0];
              },

              /** Function: getDomainFromJid
               *  Get the domain portion of a JID String.
               *
               *  Parameters:
               *    (String) jid - A JID.
               *
               *  Returns:
               *    A String containing the domain.
               */
              getDomainFromJid(jid) {
                const bare = Strophe.getBareJidFromJid(jid);

                if (bare.indexOf("@") < 0) {
                  return bare;
                } else {
                  const parts = bare.split("@");
                  parts.splice(0, 1);
                  return parts.join('@');
                }
              },

              /** Function: getResourceFromJid
               *  Get the resource portion of a JID String.
               *
               *  Parameters:
               *    (String) jid - A JID.
               *
               *  Returns:
               *    A String containing the resource.
               */
              getResourceFromJid(jid) {
                if (!jid) {
                  return null;
                }

                const s = jid.split("/");

                if (s.length < 2) {
                  return null;
                }

                s.splice(0, 1);
                return s.join('/');
              },

              /** Function: getBareJidFromJid
               *  Get the bare JID from a JID String.
               *
               *  Parameters:
               *    (String) jid - A JID.
               *
               *  Returns:
               *    A String containing the bare JID.
               */
              getBareJidFromJid(jid) {
                return jid ? jid.split("/")[0] : null;
              },

              /** PrivateFunction: _handleError
               *  _Private_ function that properly logs an error to the console
               */
              _handleError(e) {
                if (typeof e.stack !== "undefined") {
                  Strophe.fatal(e.stack);
                }

                if (e.sourceURL) {
                  Strophe.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message);
                } else if (e.fileName) {
                  Strophe.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message);
                } else {
                  Strophe.fatal("error: " + e.message);
                }
              },

              /** Function: log
               *  User overrideable logging function.
               *
               *  This function is called whenever the Strophe library calls any
               *  of the logging functions.  The default implementation of this
               *  function logs only fatal errors.  If client code wishes to handle the logging
               *  messages, it should override this with
               *  > Strophe.log = function (level, msg) {
               *  >   (user code here)
               *  > };
               *
               *  Please note that data sent and received over the wire is logged
               *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
               *
               *  The different levels and their meanings are
               *
               *    DEBUG - Messages useful for debugging purposes.
               *    INFO - Informational messages.  This is mostly information like
               *      'disconnect was called' or 'SASL auth succeeded'.
               *    WARN - Warnings about potential problems.  This is mostly used
               *      to report transient connection errors like request timeouts.
               *    ERROR - Some error occurred.
               *    FATAL - A non-recoverable fatal error occurred.
               *
               *  Parameters:
               *    (Integer) level - The log level of the log message.  This will
               *      be one of the values in Strophe.LogLevel.
               *    (String) msg - The log message.
               */
              log(level, msg) {
                if (level === this.LogLevel.FATAL) {
                  var _console;

                  (_console = console) === null || _console === void 0 ? void 0 : _console.error(msg);
                }
              },

              /** Function: debug
               *  Log a message at the Strophe.LogLevel.DEBUG level.
               *
               *  Parameters:
               *    (String) msg - The log message.
               */
              debug(msg) {
                this.log(this.LogLevel.DEBUG, msg);
              },

              /** Function: info
               *  Log a message at the Strophe.LogLevel.INFO level.
               *
               *  Parameters:
               *    (String) msg - The log message.
               */
              info(msg) {
                this.log(this.LogLevel.INFO, msg);
              },

              /** Function: warn
               *  Log a message at the Strophe.LogLevel.WARN level.
               *
               *  Parameters:
               *    (String) msg - The log message.
               */
              warn(msg) {
                this.log(this.LogLevel.WARN, msg);
              },

              /** Function: error
               *  Log a message at the Strophe.LogLevel.ERROR level.
               *
               *  Parameters:
               *    (String) msg - The log message.
               */
              error(msg) {
                this.log(this.LogLevel.ERROR, msg);
              },

              /** Function: fatal
               *  Log a message at the Strophe.LogLevel.FATAL level.
               *
               *  Parameters:
               *    (String) msg - The log message.
               */
              fatal(msg) {
                this.log(this.LogLevel.FATAL, msg);
              },

              /** Function: serialize
               *  Render a DOM element and all descendants to a String.
               *
               *  Parameters:
               *    (XMLElement) elem - A DOM element.
               *
               *  Returns:
               *    The serialized element tree as a String.
               */
              serialize(elem) {
                if (!elem) {
                  return null;
                }

                if (typeof elem.tree === "function") {
                  elem = elem.tree();
                }

                const names = [...Array(elem.attributes.length).keys()].map(i => elem.attributes[i].nodeName);
                names.sort();
                let result = names.reduce((a, n) => `${a} ${n}="${Strophe.xmlescape(elem.attributes.getNamedItem(n).value)}"`, `<${elem.nodeName}`);

                if (elem.childNodes.length > 0) {
                  result += ">";

                  for (let i = 0; i < elem.childNodes.length; i++) {
                    const child = elem.childNodes[i];

                    switch (child.nodeType) {
                      case Strophe.ElementType.NORMAL:
                        // normal element, so recurse
                        result += Strophe.serialize(child);
                        break;

                      case Strophe.ElementType.TEXT:
                        // text element to escape values
                        result += Strophe.xmlescape(child.nodeValue);
                        break;

                      case Strophe.ElementType.CDATA:
                        // cdata section so don't escape values
                        result += "<![CDATA[" + child.nodeValue + "]]>";
                    }
                  }

                  result += "</" + elem.nodeName + ">";
                } else {
                  result += "/>";
                }

                return result;
              },

              /** PrivateVariable: _requestId
               *  _Private_ variable that keeps track of the request ids for
               *  connections.
               */
              _requestId: 0,

              /** PrivateVariable: Strophe.connectionPlugins
               *  _Private_ variable Used to store plugin names that need
               *  initialization on Strophe.Connection construction.
               */
              _connectionPlugins: {},

              /** Function: addConnectionPlugin
               *  Extends the Strophe.Connection object with the given plugin.
               *
               *  Parameters:
               *    (String) name - The name of the extension.
               *    (Object) ptype - The plugin's prototype.
               */
              addConnectionPlugin(name, ptype) {
                Strophe._connectionPlugins[name] = ptype;
              }

            };
            /** Class: Strophe.Builder
             *  XML DOM builder.
             *
             *  This object provides an interface similar to JQuery but for building
             *  DOM elements easily and rapidly.  All the functions except for toString()
             *  and tree() return the object, so calls can be chained.  Here's an
             *  example using the $iq() builder helper.
             *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})
             *  >     .c('query', {xmlns: 'strophe:example'})
             *  >     .c('example')
             *  >     .toString()
             *
             *  The above generates this XML fragment
             *  > <iq to='you' from='me' type='get' id='1'>
             *  >   <query xmlns='strophe:example'>
             *  >     <example/>
             *  >   </query>
             *  > </iq>
             *  The corresponding DOM manipulations to get a similar fragment would be
             *  a lot more tedious and probably involve several helper variables.
             *
             *  Since adding children makes new operations operate on the child, up()
             *  is provided to traverse up the tree.  To add two children, do
             *  > builder.c('child1', ...).up().c('child2', ...)
             *  The next operation on the Builder will be relative to the second child.
             */

            /** Constructor: Strophe.Builder
             *  Create a Strophe.Builder object.
             *
             *  The attributes should be passed in object notation.  For example
             *  > let b = new Builder('message', {to: 'you', from: 'me'});
             *  or
             *  > let b = new Builder('messsage', {'xml:lang': 'en'});
             *
             *  Parameters:
             *    (String) name - The name of the root element.
             *    (Object) attrs - The attributes for the root element in object notation.
             *
             *  Returns:
             *    A new Strophe.Builder.
             */

            Strophe.Builder = class Builder {
              constructor(name, attrs) {
                // Set correct namespace for jabber:client elements
                if (name === "presence" || name === "message" || name === "iq") {
                  if (attrs && !attrs.xmlns) {
                    attrs.xmlns = Strophe.NS.CLIENT;
                  } else if (!attrs) {
                    attrs = {
                      xmlns: Strophe.NS.CLIENT
                    };
                  }
                } // Holds the tree being built.


                this.nodeTree = Strophe.xmlElement(name, attrs); // Points to the current operation node.

                this.node = this.nodeTree;
              }
              /** Function: tree
               *  Return the DOM tree.
               *
               *  This function returns the current DOM tree as an element object.  This
               *  is suitable for passing to functions like Strophe.Connection.send().
               *
               *  Returns:
               *    The DOM tree as a element object.
               */


              tree() {
                return this.nodeTree;
              }
              /** Function: toString
               *  Serialize the DOM tree to a String.
               *
               *  This function returns a string serialization of the current DOM
               *  tree.  It is often used internally to pass data to a
               *  Strophe.Request object.
               *
               *  Returns:
               *    The serialized DOM tree in a String.
               */


              toString() {
                return Strophe.serialize(this.nodeTree);
              }
              /** Function: up
               *  Make the current parent element the new current element.
               *
               *  This function is often used after c() to traverse back up the tree.
               *  For example, to add two children to the same element
               *  > builder.c('child1', {}).up().c('child2', {});
               *
               *  Returns:
               *    The Stophe.Builder object.
               */


              up() {
                this.node = this.node.parentNode;
                return this;
              }
              /** Function: root
               *  Make the root element the new current element.
               *
               *  When at a deeply nested element in the tree, this function can be used
               *  to jump back to the root of the tree, instead of having to repeatedly
               *  call up().
               *
               *  Returns:
               *    The Stophe.Builder object.
               */


              root() {
                this.node = this.nodeTree;
                return this;
              }
              /** Function: attrs
               *  Add or modify attributes of the current element.
               *
               *  The attributes should be passed in object notation.  This function
               *  does not move the current element pointer.
               *
               *  Parameters:
               *    (Object) moreattrs - The attributes to add/modify in object notation.
               *
               *  Returns:
               *    The Strophe.Builder object.
               */


              attrs(moreattrs) {
                for (const k in moreattrs) {
                  if (Object.prototype.hasOwnProperty.call(moreattrs, k)) {
                    if (moreattrs[k] === undefined) {
                      this.node.removeAttribute(k);
                    } else {
                      this.node.setAttribute(k, moreattrs[k]);
                    }
                  }
                }

                return this;
              }
              /** Function: c
               *  Add a child to the current element and make it the new current
               *  element.
               *
               *  This function moves the current element pointer to the child,
               *  unless text is provided.  If you need to add another child, it
               *  is necessary to use up() to go back to the parent in the tree.
               *
               *  Parameters:
               *    (String) name - The name of the child.
               *    (Object) attrs - The attributes of the child in object notation.
               *    (String) text - The text to add to the child.
               *
               *  Returns:
               *    The Strophe.Builder object.
               */


              c(name, attrs, text) {
                const child = Strophe.xmlElement(name, attrs, text);
                this.node.appendChild(child);

                if (typeof text !== "string" && typeof text !== "number") {
                  this.node = child;
                }

                return this;
              }
              /** Function: cnode
               *  Add a child to the current element and make it the new current
               *  element.
               *
               *  This function is the same as c() except that instead of using a
               *  name and an attributes object to create the child it uses an
               *  existing DOM element object.
               *
               *  Parameters:
               *    (XMLElement) elem - A DOM element.
               *
               *  Returns:
               *    The Strophe.Builder object.
               */


              cnode(elem) {
                let impNode;
                const xmlGen = Strophe.xmlGenerator();

                try {
                  impNode = xmlGen.importNode !== undefined;
                } catch (e) {
                  impNode = false;
                }

                const newElem = impNode ? xmlGen.importNode(elem, true) : Strophe.copyElement(elem);
                this.node.appendChild(newElem);
                this.node = newElem;
                return this;
              }
              /** Function: t
               *  Add a child text element.
               *
               *  This *does not* make the child the new current element since there
               *  are no children of text elements.
               *
               *  Parameters:
               *    (String) text - The text data to append to the current element.
               *
               *  Returns:
               *    The Strophe.Builder object.
               */


              t(text) {
                const child = Strophe.xmlTextNode(text);
                this.node.appendChild(child);
                return this;
              }
              /** Function: h
               *  Replace current element contents with the HTML passed in.
               *
               *  This *does not* make the child the new current element
               *
               *  Parameters:
               *    (String) html - The html to insert as contents of current element.
               *
               *  Returns:
               *    The Strophe.Builder object.
               */


              h(html) {
                const fragment = Strophe.xmlGenerator().createElement('body'); // force the browser to try and fix any invalid HTML tags

                fragment.innerHTML = html; // copy cleaned html into an xml dom

                const xhtml = Strophe.createHtml(fragment);

                while (xhtml.childNodes.length > 0) {
                  this.node.appendChild(xhtml.childNodes[0]);
                }

                return this;
              }

            };
            /** PrivateClass: Strophe.Handler
             *  _Private_ helper class for managing stanza handlers.
             *
             *  A Strophe.Handler encapsulates a user provided callback function to be
             *  executed when matching stanzas are received by the connection.
             *  Handlers can be either one-off or persistant depending on their
             *  return value. Returning true will cause a Handler to remain active, and
             *  returning false will remove the Handler.
             *
             *  Users will not use Strophe.Handler objects directly, but instead they
             *  will use Strophe.Connection.addHandler() and
             *  Strophe.Connection.deleteHandler().
             */

            /** PrivateConstructor: Strophe.Handler
             *  Create and initialize a new Strophe.Handler.
             *
             *  Parameters:
             *    (Function) handler - A function to be executed when the handler is run.
             *    (String) ns - The namespace to match.
             *    (String) name - The element name to match.
             *    (String) type - The element type to match.
             *    (String) id - The element id attribute to match.
             *    (String) from - The element from attribute to match.
             *    (Object) options - Handler options
             *
             *  Returns:
             *    A new Strophe.Handler object.
             */

            Strophe.Handler = function (handler, ns, name, type, id, from, options) {
              this.handler = handler;
              this.ns = ns;
              this.name = name;
              this.type = type;
              this.id = id;
              this.options = options || {
                'matchBareFromJid': false,
                'ignoreNamespaceFragment': false
              }; // BBB: Maintain backward compatibility with old `matchBare` option

              if (this.options.matchBare) {
                Strophe.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.');
                this.options.matchBareFromJid = this.options.matchBare;
                delete this.options.matchBare;
              }

              if (this.options.matchBareFromJid) {
                this.from = from ? Strophe.getBareJidFromJid(from) : null;
              } else {
                this.from = from;
              } // whether the handler is a user handler or a system handler


              this.user = true;
            };

            Strophe.Handler.prototype = {
              /** PrivateFunction: getNamespace
               *  Returns the XML namespace attribute on an element.
               *  If `ignoreNamespaceFragment` was passed in for this handler, then the
               *  URL fragment will be stripped.
               *
               *  Parameters:
               *    (XMLElement) elem - The XML element with the namespace.
               *
               *  Returns:
               *    The namespace, with optionally the fragment stripped.
               */
              getNamespace(elem) {
                let elNamespace = elem.getAttribute("xmlns");

                if (elNamespace && this.options.ignoreNamespaceFragment) {
                  elNamespace = elNamespace.split('#')[0];
                }

                return elNamespace;
              },

              /** PrivateFunction: namespaceMatch
               *  Tests if a stanza matches the namespace set for this Strophe.Handler.
               *
               *  Parameters:
               *    (XMLElement) elem - The XML element to test.
               *
               *  Returns:
               *    true if the stanza matches and false otherwise.
               */
              namespaceMatch(elem) {
                let nsMatch = false;

                if (!this.ns) {
                  return true;
                } else {
                  Strophe.forEachChild(elem, null, elem => {
                    if (this.getNamespace(elem) === this.ns) {
                      nsMatch = true;
                    }
                  });
                  return nsMatch || this.getNamespace(elem) === this.ns;
                }
              },

              /** PrivateFunction: isMatch
               *  Tests if a stanza matches the Strophe.Handler.
               *
               *  Parameters:
               *    (XMLElement) elem - The XML element to test.
               *
               *  Returns:
               *    true if the stanza matches and false otherwise.
               */
              isMatch(elem) {
                let from = elem.getAttribute('from');

                if (this.options.matchBareFromJid) {
                  from = Strophe.getBareJidFromJid(from);
                }

                const elem_type = elem.getAttribute("type");

                if (this.namespaceMatch(elem) && (!this.name || Strophe.isTagEqual(elem, this.name)) && (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) !== -1 : elem_type === this.type)) && (!this.id || elem.getAttribute("id") === this.id) && (!this.from || from === this.from)) {
                  return true;
                }

                return false;
              },

              /** PrivateFunction: run
               *  Run the callback on a matching stanza.
               *
               *  Parameters:
               *    (XMLElement) elem - The DOM element that triggered the
               *      Strophe.Handler.
               *
               *  Returns:
               *    A boolean indicating if the handler should remain active.
               */
              run(elem) {
                let result = null;

                try {
                  result = this.handler(elem);
                } catch (e) {
                  Strophe._handleError(e);

                  throw e;
                }

                return result;
              },

              /** PrivateFunction: toString
               *  Get a String representation of the Strophe.Handler object.
               *
               *  Returns:
               *    A String.
               */
              toString() {
                return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}";
              }

            };
            /** PrivateClass: Strophe.TimedHandler
             *  _Private_ helper class for managing timed handlers.
             *
             *  A Strophe.TimedHandler encapsulates a user provided callback that
             *  should be called after a certain period of time or at regular
             *  intervals.  The return value of the callback determines whether the
             *  Strophe.TimedHandler will continue to fire.
             *
             *  Users will not use Strophe.TimedHandler objects directly, but instead
             *  they will use Strophe.Connection.addTimedHandler() and
             *  Strophe.Connection.deleteTimedHandler().
             */

            Strophe.TimedHandler = class TimedHandler {
              /** PrivateConstructor: Strophe.TimedHandler
               *  Create and initialize a new Strophe.TimedHandler object.
               *
               *  Parameters:
               *    (Integer) period - The number of milliseconds to wait before the
               *      handler is called.
               *    (Function) handler - The callback to run when the handler fires.  This
               *      function should take no arguments.
               *
               *  Returns:
               *    A new Strophe.TimedHandler object.
               */
              constructor(period, handler) {
                this.period = period;
                this.handler = handler;
                this.lastCalled = new Date().getTime();
                this.user = true;
              }
              /** PrivateFunction: run
               *  Run the callback for the Strophe.TimedHandler.
               *
               *  Returns:
               *    true if the Strophe.TimedHandler should be called again, and false
               *      otherwise.
               */


              run() {
                this.lastCalled = new Date().getTime();
                return this.handler();
              }
              /** PrivateFunction: reset
               *  Reset the last called time for the Strophe.TimedHandler.
               */


              reset() {
                this.lastCalled = new Date().getTime();
              }
              /** PrivateFunction: toString
               *  Get a string representation of the Strophe.TimedHandler object.
               *
               *  Returns:
               *    The string representation.
               */


              toString() {
                return "{TimedHandler: " + this.handler + "(" + this.period + ")}";
              }

            };
            /** Class: Strophe.Connection
             *  XMPP Connection manager.
             *
             *  This class is the main part of Strophe.  It manages a BOSH or websocket
             *  connection to an XMPP server and dispatches events to the user callbacks
             *  as data arrives. It supports SASL PLAIN, SASL SCRAM-SHA-1
             *  and legacy authentication.
             *
             *  After creating a Strophe.Connection object, the user will typically
             *  call connect() with a user supplied callback to handle connection level
             *  events like authentication failure, disconnection, or connection
             *  complete.
             *
             *  The user will also have several event handlers defined by using
             *  addHandler() and addTimedHandler().  These will allow the user code to
             *  respond to interesting stanzas or do something periodically with the
             *  connection. These handlers will be active once authentication is
             *  finished.
             *
             *  To send data to the connection, use send().
             */

            /** Constructor: Strophe.Connection
             *  Create and initialize a Strophe.Connection object.
             *
             *  The transport-protocol for this connection will be chosen automatically
             *  based on the given service parameter. URLs starting with "ws://" or
             *  "wss://" will use WebSockets, URLs starting with "http://", "https://"
             *  or without a protocol will use BOSH.
             *
             *  To make Strophe connect to the current host you can leave out the protocol
             *  and host part and just pass the path, e.g.
             *
             *  > let conn = new Strophe.Connection("/http-bind/");
             *
             *  Options common to both Websocket and BOSH:
             *  ------------------------------------------
             *
             *  cookies:
             *
             *  The *cookies* option allows you to pass in cookies to be added to the
             *  document. These cookies will then be included in the BOSH XMLHttpRequest
             *  or in the websocket connection.
             *
             *  The passed in value must be a map of cookie names and string values.
             *
             *  > { "myCookie": {
             *  >     "value": "1234",
             *  >     "domain": ".example.org",
             *  >     "path": "/",
             *  >     "expires": expirationDate
             *  >     }
             *  > }
             *
             *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).
             *  Those cookies need to be set under those domains, for example they can be
             *  set server-side by making a XHR call to that domain to ask it to set any
             *  necessary cookies.
             *
             *  mechanisms:
             *
             *  The *mechanisms* option allows you to specify the SASL mechanisms that this
             *  instance of Strophe.Connection (and therefore your XMPP client) will
             *  support.
             *
             *  The value must be an array of objects with Strophe.SASLMechanism
             *  prototypes.
             *
             *  If nothing is specified, then the following mechanisms (and their
             *  priorities) are registered:
             *
             *      SCRAM-SHA-1 - 60
             *      PLAIN       - 50
             *      OAUTHBEARER - 40
             *      X-OAUTH2    - 30
             *      ANONYMOUS   - 20
             *      EXTERNAL    - 10
             *
             *  explicitResourceBinding:
             *
             *  If `explicitResourceBinding` is set to a truthy value, then the XMPP client
             *  needs to explicitly call `Strophe.Connection.prototype.bind` once the XMPP
             *  server has advertised the "urn:ietf:params:xml:ns:xmpp-bind" feature.
             *
             *  Making this step explicit allows client authors to first finish other
             *  stream related tasks, such as setting up an XEP-0198 Stream Management
             *  session, before binding the JID resource for this session.
             *
             *  WebSocket options:
             *  ------------------
             *
             *  protocol:
             *
             *  If you want to connect to the current host with a WebSocket connection you
             *  can tell Strophe to use WebSockets through a "protocol" attribute in the
             *  optional options parameter. Valid values are "ws" for WebSocket and "wss"
             *  for Secure WebSocket.
             *  So to connect to "wss://CURRENT_HOSTNAME/xmpp-websocket" you would call
             *
             *  > let conn = new Strophe.Connection("/xmpp-websocket/", {protocol: "wss"});
             *
             *  Note that relative URLs _NOT_ starting with a "/" will also include the path
             *  of the current site.
             *
             *  Also because downgrading security is not permitted by browsers, when using
             *  relative URLs both BOSH and WebSocket connections will use their secure
             *  variants if the current connection to the site is also secure (https).
             *
             *  worker:
             *
             *  Set this option to URL from where the shared worker script should be loaded.
             *
             *  To run the websocket connection inside a shared worker.
             *  This allows you to share a single websocket-based connection between
             *  multiple Strophe.Connection instances, for example one per browser tab.
             *
             *  The script to use is the one in `src/shared-connection-worker.js`.
             *
             *  BOSH options:
             *  -------------
             *
             *  By adding "sync" to the options, you can control if requests will
             *  be made synchronously or not. The default behaviour is asynchronous.
             *  If you want to make requests synchronous, make "sync" evaluate to true.
             *  > let conn = new Strophe.Connection("/http-bind/", {sync: true});
             *
             *  You can also toggle this on an already established connection.
             *  > conn.options.sync = true;
             *
             *  The *customHeaders* option can be used to provide custom HTTP headers to be
             *  included in the XMLHttpRequests made.
             *
             *  The *keepalive* option can be used to instruct Strophe to maintain the
             *  current BOSH session across interruptions such as webpage reloads.
             *
             *  It will do this by caching the sessions tokens in sessionStorage, and when
             *  "restore" is called it will check whether there are cached tokens with
             *  which it can resume an existing session.
             *
             *  The *withCredentials* option should receive a Boolean value and is used to
             *  indicate wether cookies should be included in ajax requests (by default
             *  they're not).
             *  Set this value to true if you are connecting to a BOSH service
             *  and for some reason need to send cookies to it.
             *  In order for this to work cross-domain, the server must also enable
             *  credentials by setting the Access-Control-Allow-Credentials response header
             *  to "true". For most usecases however this setting should be false (which
             *  is the default).
             *  Additionally, when using Access-Control-Allow-Credentials, the
             *  Access-Control-Allow-Origin header can't be set to the wildcard "*", but
             *  instead must be restricted to actual domains.
             *
             *  The *contentType* option can be set to change the default Content-Type
             *  of "text/xml; charset=utf-8", which can be useful to reduce the amount of
             *  CORS preflight requests that are sent to the server.
             *
             *  Parameters:
             *    (String) service - The BOSH or WebSocket service URL.
             *    (Object) options - A hash of configuration options
             *
             *  Returns:
             *    A new Strophe.Connection object.
             */

            Strophe.Connection = class Connection {
              constructor(service, options) {
                // The service URL
                this.service = service; // Configuration options

                this.options = options || {};
                this.setProtocol();
                /* The connected JID. */

                this.jid = "";
                /* the JIDs domain */

                this.domain = null;
                /* stream:features */

                this.features = null; // SASL

                this._sasl_data = {};
                this.do_bind = false;
                this.do_session = false;
                this.mechanisms = {}; // handler lists

                this.timedHandlers = [];
                this.handlers = [];
                this.removeTimeds = [];
                this.removeHandlers = [];
                this.addTimeds = [];
                this.addHandlers = [];
                this.protocolErrorHandlers = {
                  'HTTP': {},
                  'websocket': {}
                };
                this._idleTimeout = null;
                this._disconnectTimeout = null;
                this.authenticated = false;
                this.connected = false;
                this.disconnecting = false;
                this.do_authentication = true;
                this.paused = false;
                this.restored = false;
                this._data = [];
                this._uniqueId = 0;
                this._sasl_success_handler = null;
                this._sasl_failure_handler = null;
                this._sasl_challenge_handler = null; // Max retries before disconnecting

                this.maxRetries = 5; // Call onIdle callback every 1/10th of a second

                this._idleTimeout = setTimeout(() => this._onIdle(), 100);
                utils.addCookies(this.options.cookies);
                this.registerSASLMechanisms(this.options.mechanisms); // A client must always respond to incoming IQ "set" and "get" stanzas.
                // See https://datatracker.ietf.org/doc/html/rfc6120#section-8.2.3
                //
                // This is a fallback handler which gets called when no other handler
                // was called for a received IQ "set" or "get".

                this.iqFallbackHandler = new Strophe.Handler(iq => this.send($iq({
                  type: 'error',
                  id: iq.getAttribute('id')
                }).c('error', {
                  'type': 'cancel'
                }).c('service-unavailable', {
                  'xmlns': Strophe.NS.STANZAS
                })), null, 'iq', ['get', 'set']); // initialize plugins

                for (const k in Strophe._connectionPlugins) {
                  if (Object.prototype.hasOwnProperty.call(Strophe._connectionPlugins, k)) {
                    const F = function () {};

                    F.prototype = Strophe._connectionPlugins[k];
                    this[k] = new F();
                    this[k].init(this);
                  }
                }
              }
              /** Function: setProtocol
               *  Select protocal based on this.options or this.service
               */


              setProtocol() {
                const proto = this.options.protocol || "";

                if (this.options.worker) {
                  this._proto = new Strophe.WorkerWebsocket(this);
                } else if (this.service.indexOf("ws:") === 0 || this.service.indexOf("wss:") === 0 || proto.indexOf("ws") === 0) {
                  this._proto = new Strophe.Websocket(this);
                } else {
                  this._proto = new Strophe.Bosh(this);
                }
              }
              /** Function: reset
               *  Reset the connection.
               *
               *  This function should be called after a connection is disconnected
               *  before that connection is reused.
               */


              reset() {
                this._proto._reset(); // SASL


                this.do_session = false;
                this.do_bind = false; // handler lists

                this.timedHandlers = [];
                this.handlers = [];
                this.removeTimeds = [];
                this.removeHandlers = [];
                this.addTimeds = [];
                this.addHandlers = [];
                this.authenticated = false;
                this.connected = false;
                this.disconnecting = false;
                this.restored = false;
                this._data = [];
                this._requests = [];
                this._uniqueId = 0;
              }
              /** Function: pause
               *  Pause the request manager.
               *
               *  This will prevent Strophe from sending any more requests to the
               *  server.  This is very useful for temporarily pausing
               *  BOSH-Connections while a lot of send() calls are happening quickly.
               *  This causes Strophe to send the data in a single request, saving
               *  many request trips.
               */


              pause() {
                this.paused = true;
              }
              /** Function: resume
               *  Resume the request manager.
               *
               *  This resumes after pause() has been called.
               */


              resume() {
                this.paused = false;
              }
              /** Function: getUniqueId
               *  Generate a unique ID for use in <iq/> elements.
               *
               *  All <iq/> stanzas are required to have unique id attributes.  This
               *  function makes creating these easy.  Each connection instance has
               *  a counter which starts from zero, and the value of this counter
               *  plus a colon followed by the suffix becomes the unique id. If no
               *  suffix is supplied, the counter is used as the unique id.
               *
               *  Suffixes are used to make debugging easier when reading the stream
               *  data, and their use is recommended.  The counter resets to 0 for
               *  every new connection for the same reason.  For connections to the
               *  same server that authenticate the same way, all the ids should be
               *  the same, which makes it easy to see changes.  This is useful for
               *  automated testing as well.
               *
               *  Parameters:
               *    (String) suffix - A optional suffix to append to the id.
               *
               *  Returns:
               *    A unique string to be used for the id attribute.
               */


              getUniqueId(suffix) {
                // eslint-disable-line class-methods-use-this
                const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                  const r = Math.random() * 16 | 0,
                        v = c === 'x' ? r : r & 0x3 | 0x8;
                  return v.toString(16);
                });

                if (typeof suffix === "string" || typeof suffix === "number") {
                  return uuid + ":" + suffix;
                } else {
                  return uuid + "";
                }
              }
              /** Function: addProtocolErrorHandler
               *  Register a handler function for when a protocol (websocker or HTTP)
               *  error occurs.
               *
               *  NOTE: Currently only HTTP errors for BOSH requests are handled.
               *  Patches that handle websocket errors would be very welcome.
               *
               *  Parameters:
               *    (String) protocol - 'HTTP' or 'websocket'
               *    (Integer) status_code - Error status code (e.g 500, 400 or 404)
               *    (Function) callback - Function that will fire on Http error
               *
               *  Example:
               *  function onError(err_code){
               *    //do stuff
               *  }
               *
               *  let conn = Strophe.connect('http://example.com/http-bind');
               *  conn.addProtocolErrorHandler('HTTP', 500, onError);
               *  // Triggers HTTP 500 error and onError handler will be called
               *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);
               */


              addProtocolErrorHandler(protocol, status_code, callback) {
                this.protocolErrorHandlers[protocol][status_code] = callback;
              }
              /** Function: connect
               *  Starts the connection process.
               *
               *  As the connection process proceeds, the user supplied callback will
               *  be triggered multiple times with status updates.  The callback
               *  should take two arguments - the status code and the error condition.
               *
               *  The status code will be one of the values in the Strophe.Status
               *  constants.  The error condition will be one of the conditions
               *  defined in RFC 3920 or the condition 'strophe-parsererror'.
               *
               *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant
               *  for BOSH connections. Please see XEP 124 for a more detailed explanation
               *  of the optional parameters.
               *
               *  Parameters:
               *    (String) jid - The user's JID.  This may be a bare JID,
               *      or a full JID.  If a node is not supplied, SASL OAUTHBEARER or
               *      SASL ANONYMOUS authentication will be attempted (OAUTHBEARER will
               *      process the provided password value as an access token).
               *    (String) pass - The user's password.
               *    (Function) callback - The connect callback function.
               *    (Integer) wait - The optional HTTPBIND wait value.  This is the
               *      time the server will wait before returning an empty result for
               *      a request.  The default setting of 60 seconds is recommended.
               *    (Integer) hold - The optional HTTPBIND hold value.  This is the
               *      number of connections the server will hold at one time.  This
               *      should almost always be set to 1 (the default).
               *    (String) route - The optional route value.
               *    (String) authcid - The optional alternative authentication identity
               *      (username) if intending to impersonate another user.
               *      When using the SASL-EXTERNAL authentication mechanism, for example
               *      with client certificates, then the authcid value is used to
               *      determine whether an authorization JID (authzid) should be sent to
               *      the server. The authzid should NOT be sent to the server if the
               *      authzid and authcid are the same. So to prevent it from being sent
               *      (for example when the JID is already contained in the client
               *      certificate), set authcid to that same JID. See XEP-178 for more
               *      details.
               *     (Integer) disconnection_timeout - The optional disconnection timeout
               *      in milliseconds before _doDisconnect will be called.
               */


              connect(jid, pass, callback, wait, hold, route, authcid) {
                let disconnection_timeout = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 3000;
                this.jid = jid;
                /** Variable: authzid
                 *  Authorization identity.
                 */

                this.authzid = Strophe.getBareJidFromJid(this.jid);
                /** Variable: authcid
                 *  Authentication identity (User name).
                 */

                this.authcid = authcid || Strophe.getNodeFromJid(this.jid);
                /** Variable: pass
                 *  Authentication identity (User password).
                 */

                this.pass = pass;
                this.connect_callback = callback;
                this.disconnecting = false;
                this.connected = false;
                this.authenticated = false;
                this.restored = false;
                this.disconnection_timeout = disconnection_timeout; // parse jid for domain

                this.domain = Strophe.getDomainFromJid(this.jid);

                this._changeConnectStatus(Strophe.Status.CONNECTING, null);

                this._proto._connect(wait, hold, route);
              }
              /** Function: attach
               *  Attach to an already created and authenticated BOSH session.
               *
               *  This function is provided to allow Strophe to attach to BOSH
               *  sessions which have been created externally, perhaps by a Web
               *  application.  This is often used to support auto-login type features
               *  without putting user credentials into the page.
               *
               *  Parameters:
               *    (String) jid - The full JID that is bound by the session.
               *    (String) sid - The SID of the BOSH session.
               *    (String) rid - The current RID of the BOSH session.  This RID
               *      will be used by the next request.
               *    (Function) callback The connect callback function.
               *    (Integer) wait - The optional HTTPBIND wait value.  This is the
               *      time the server will wait before returning an empty result for
               *      a request.  The default setting of 60 seconds is recommended.
               *      Other settings will require tweaks to the Strophe.TIMEOUT value.
               *    (Integer) hold - The optional HTTPBIND hold value.  This is the
               *      number of connections the server will hold at one time.  This
               *      should almost always be set to 1 (the default).
               *    (Integer) wind - The optional HTTBIND window value.  This is the
               *      allowed range of request ids that are valid.  The default is 5.
               */


              attach(jid, sid, rid, callback, wait, hold, wind) {
                if (this._proto._attach) {
                  return this._proto._attach(jid, sid, rid, callback, wait, hold, wind);
                } else {
                  const error = new Error('The "attach" method is not available for your connection protocol');
                  error.name = 'StropheSessionError';
                  throw error;
                }
              }
              /** Function: restore
               *  Attempt to restore a cached BOSH session.
               *
               *  This function is only useful in conjunction with providing the
               *  "keepalive":true option when instantiating a new Strophe.Connection.
               *
               *  When "keepalive" is set to true, Strophe will cache the BOSH tokens
               *  RID (Request ID) and SID (Session ID) and then when this function is
               *  called, it will attempt to restore the session from those cached
               *  tokens.
               *
               *  This function must therefore be called instead of connect or attach.
               *
               *  For an example on how to use it, please see examples/restore.js
               *
               *  Parameters:
               *    (String) jid - The user's JID.  This may be a bare JID or a full JID.
               *    (Function) callback - The connect callback function.
               *    (Integer) wait - The optional HTTPBIND wait value.  This is the
               *      time the server will wait before returning an empty result for
               *      a request.  The default setting of 60 seconds is recommended.
               *    (Integer) hold - The optional HTTPBIND hold value.  This is the
               *      number of connections the server will hold at one time.  This
               *      should almost always be set to 1 (the default).
               *    (Integer) wind - The optional HTTBIND window value.  This is the
               *      allowed range of request ids that are valid.  The default is 5.
               */


              restore(jid, callback, wait, hold, wind) {
                if (this._sessionCachingSupported()) {
                  this._proto._restore(jid, callback, wait, hold, wind);
                } else {
                  const error = new Error('The "restore" method can only be used with a BOSH connection.');
                  error.name = 'StropheSessionError';
                  throw error;
                }
              }
              /** PrivateFunction: _sessionCachingSupported
               * Checks whether sessionStorage and JSON are supported and whether we're
               * using BOSH.
               */


              _sessionCachingSupported() {
                if (this._proto instanceof Strophe.Bosh) {
                  if (!JSON) {
                    return false;
                  }

                  try {
                    sessionStorage.setItem('_strophe_', '_strophe_');
                    sessionStorage.removeItem('_strophe_');
                  } catch (e) {
                    return false;
                  }

                  return true;
                }

                return false;
              }
              /** Function: xmlInput
               *  User overrideable function that receives XML data coming into the
               *  connection.
               *
               *  The default function does nothing.  User code can override this with
               *  > Strophe.Connection.xmlInput = function (elem) {
               *  >   (user code)
               *  > };
               *
               *  Due to limitations of current Browsers' XML-Parsers the opening and closing
               *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
               *
               *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
               *  <Strophe.Bosh.strip> if you want to strip this tag.
               *
               *  Parameters:
               *    (XMLElement) elem - The XML data received by the connection.
               */


              xmlInput(elem) {
                // eslint-disable-line
                return;
              }
              /** Function: xmlOutput
               *  User overrideable function that receives XML data sent to the
               *  connection.
               *
               *  The default function does nothing.  User code can override this with
               *  > Strophe.Connection.xmlOutput = function (elem) {
               *  >   (user code)
               *  > };
               *
               *  Due to limitations of current Browsers' XML-Parsers the opening and closing
               *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.
               *
               *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See
               *  <Strophe.Bosh.strip> if you want to strip this tag.
               *
               *  Parameters:
               *    (XMLElement) elem - The XMLdata sent by the connection.
               */


              xmlOutput(elem) {
                // eslint-disable-line
                return;
              }
              /** Function: rawInput
               *  User overrideable function that receives raw data coming into the
               *  connection.
               *
               *  The default function does nothing.  User code can override this with
               *  > Strophe.Connection.rawInput = function (data) {
               *  >   (user code)
               *  > };
               *
               *  Parameters:
               *    (String) data - The data received by the connection.
               */


              rawInput(data) {
                // eslint-disable-line
                return;
              }
              /** Function: rawOutput
               *  User overrideable function that receives raw data sent to the
               *  connection.
               *
               *  The default function does nothing.  User code can override this with
               *  > Strophe.Connection.rawOutput = function (data) {
               *  >   (user code)
               *  > };
               *
               *  Parameters:
               *    (String) data - The data sent by the connection.
               */


              rawOutput(data) {
                // eslint-disable-line
                return;
              }
              /** Function: nextValidRid
               *  User overrideable function that receives the new valid rid.
               *
               *  The default function does nothing. User code can override this with
               *  > Strophe.Connection.nextValidRid = function (rid) {
               *  >    (user code)
               *  > };
               *
               *  Parameters:
               *    (Number) rid - The next valid rid
               */


              nextValidRid(rid) {
                // eslint-disable-line
                return;
              }
              /** Function: send
               *  Send a stanza.
               *
               *  This function is called to push data onto the send queue to
               *  go out over the wire.  Whenever a request is sent to the BOSH
               *  server, all pending data is sent and the queue is flushed.
               *
               *  Parameters:
               *    (XMLElement |
               *     [XMLElement] |
               *     Strophe.Builder) elem - The stanza to send.
               */


              send(elem) {
                if (elem === null) {
                  return;
                }

                if (typeof elem.sort === "function") {
                  for (let i = 0; i < elem.length; i++) {
                    this._queueData(elem[i]);
                  }
                } else if (typeof elem.tree === "function") {
                  this._queueData(elem.tree());
                } else {
                  this._queueData(elem);
                }

                this._proto._send();
              }
              /** Function: flush
               *  Immediately send any pending outgoing data.
               *
               *  Normally send() queues outgoing data until the next idle period
               *  (100ms), which optimizes network use in the common cases when
               *  several send()s are called in succession. flush() can be used to
               *  immediately send all pending data.
               */


              flush() {
                // cancel the pending idle period and run the idle function
                // immediately
                clearTimeout(this._idleTimeout);

                this._onIdle();
              }
              /** Function: sendPresence
               *  Helper function to send presence stanzas. The main benefit is for
               *  sending presence stanzas for which you expect a responding presence
               *  stanza with the same id (for example when leaving a chat room).
               *
               *  Parameters:
               *    (XMLElement) elem - The stanza to send.
               *    (Function) callback - The callback function for a successful request.
               *    (Function) errback - The callback function for a failed or timed
               *      out request.  On timeout, the stanza will be null.
               *    (Integer) timeout - The time specified in milliseconds for a
               *      timeout to occur.
               *
               *  Returns:
               *    The id used to send the presence.
               */


              sendPresence(elem, callback, errback, timeout) {
                let timeoutHandler = null;

                if (typeof elem.tree === "function") {
                  elem = elem.tree();
                }

                let id = elem.getAttribute('id');

                if (!id) {
                  // inject id if not found
                  id = this.getUniqueId("sendPresence");
                  elem.setAttribute("id", id);
                }

                if (typeof callback === "function" || typeof errback === "function") {
                  const handler = this.addHandler(stanza => {
                    // remove timeout handler if there is one
                    if (timeoutHandler) {
                      this.deleteTimedHandler(timeoutHandler);
                    }

                    if (stanza.getAttribute('type') === 'error') {
                      if (errback) {
                        errback(stanza);
                      }
                    } else if (callback) {
                      callback(stanza);
                    }
                  }, null, 'presence', null, id); // if timeout specified, set up a timeout handler.

                  if (timeout) {
                    timeoutHandler = this.addTimedHandler(timeout, () => {
                      // get rid of normal handler
                      this.deleteHandler(handler); // call errback on timeout with null stanza

                      if (errback) {
                        errback(null);
                      }

                      return false;
                    });
                  }
                }

                this.send(elem);
                return id;
              }
              /** Function: sendIQ
               *  Helper function to send IQ stanzas.
               *
               *  Parameters:
               *    (XMLElement) elem - The stanza to send.
               *    (Function) callback - The callback function for a successful request.
               *    (Function) errback - The callback function for a failed or timed
               *      out request.  On timeout, the stanza will be null.
               *    (Integer) timeout - The time specified in milliseconds for a
               *      timeout to occur.
               *
               *  Returns:
               *    The id used to send the IQ.
              */


              sendIQ(elem, callback, errback, timeout) {
                let timeoutHandler = null;

                if (typeof elem.tree === "function") {
                  elem = elem.tree();
                }

                let id = elem.getAttribute('id');

                if (!id) {
                  // inject id if not found
                  id = this.getUniqueId("sendIQ");
                  elem.setAttribute("id", id);
                }

                if (typeof callback === "function" || typeof errback === "function") {
                  const handler = this.addHandler(stanza => {
                    // remove timeout handler if there is one
                    if (timeoutHandler) {
                      this.deleteTimedHandler(timeoutHandler);
                    }

                    const iqtype = stanza.getAttribute('type');

                    if (iqtype === 'result') {
                      if (callback) {
                        callback(stanza);
                      }
                    } else if (iqtype === 'error') {
                      if (errback) {
                        errback(stanza);
                      }
                    } else {
                      const error = new Error(`Got bad IQ type of ${iqtype}`);
                      error.name = "StropheError";
                      throw error;
                    }
                  }, null, 'iq', ['error', 'result'], id); // if timeout specified, set up a timeout handler.

                  if (timeout) {
                    timeoutHandler = this.addTimedHandler(timeout, () => {
                      // get rid of normal handler
                      this.deleteHandler(handler); // call errback on timeout with null stanza

                      if (errback) {
                        errback(null);
                      }

                      return false;
                    });
                  }
                }

                this.send(elem);
                return id;
              }
              /** PrivateFunction: _queueData
               *  Queue outgoing data for later sending.  Also ensures that the data
               *  is a DOMElement.
               */


              _queueData(element) {
                if (element === null || !element.tagName || !element.childNodes) {
                  const error = new Error("Cannot queue non-DOMElement.");
                  error.name = "StropheError";
                  throw error;
                }

                this._data.push(element);
              }
              /** PrivateFunction: _sendRestart
               *  Send an xmpp:restart stanza.
               */


              _sendRestart() {
                this._data.push("restart");

                this._proto._sendRestart();

                this._idleTimeout = setTimeout(() => this._onIdle(), 100);
              }
              /** Function: addTimedHandler
               *  Add a timed handler to the connection.
               *
               *  This function adds a timed handler.  The provided handler will
               *  be called every period milliseconds until it returns false,
               *  the connection is terminated, or the handler is removed.  Handlers
               *  that wish to continue being invoked should return true.
               *
               *  Because of method binding it is necessary to save the result of
               *  this function if you wish to remove a handler with
               *  deleteTimedHandler().
               *
               *  Note that user handlers are not active until authentication is
               *  successful.
               *
               *  Parameters:
               *    (Integer) period - The period of the handler.
               *    (Function) handler - The callback function.
               *
               *  Returns:
               *    A reference to the handler that can be used to remove it.
               */


              addTimedHandler(period, handler) {
                const thand = new Strophe.TimedHandler(period, handler);
                this.addTimeds.push(thand);
                return thand;
              }
              /** Function: deleteTimedHandler
               *  Delete a timed handler for a connection.
               *
               *  This function removes a timed handler from the connection.  The
               *  handRef parameter is *not* the function passed to addTimedHandler(),
               *  but is the reference returned from addTimedHandler().
               *
               *  Parameters:
               *    (Strophe.TimedHandler) handRef - The handler reference.
               */


              deleteTimedHandler(handRef) {
                // this must be done in the Idle loop so that we don't change
                // the handlers during iteration
                this.removeTimeds.push(handRef);
              }
              /** Function: addHandler
               *  Add a stanza handler for the connection.
               *
               *  This function adds a stanza handler to the connection.  The
               *  handler callback will be called for any stanza that matches
               *  the parameters.  Note that if multiple parameters are supplied,
               *  they must all match for the handler to be invoked.
               *
               *  The handler will receive the stanza that triggered it as its argument.
               *  *The handler should return true if it is to be invoked again;
               *  returning false will remove the handler after it returns.*
               *
               *  As a convenience, the ns parameters applies to the top level element
               *  and also any of its immediate children.  This is primarily to make
               *  matching /iq/query elements easy.
               *
               *  Options
               *  ~~~~~~~
               *  With the options argument, you can specify boolean flags that affect how
               *  matches are being done.
               *
               *  Currently two flags exist:
               *
               *  - matchBareFromJid:
               *      When set to true, the from parameter and the
               *      from attribute on the stanza will be matched as bare JIDs instead
               *      of full JIDs. To use this, pass {matchBareFromJid: true} as the
               *      value of options. The default value for matchBareFromJid is false.
               *
               *  - ignoreNamespaceFragment:
               *      When set to true, a fragment specified on the stanza's namespace
               *      URL will be ignored when it's matched with the one configured for
               *      the handler.
               *
               *      This means that if you register like this:
               *      >   connection.addHandler(
               *      >       handler,
               *      >       'http://jabber.org/protocol/muc',
               *      >       null, null, null, null,
               *      >       {'ignoreNamespaceFragment': true}
               *      >   );
               *
               *      Then a stanza with XML namespace of
               *      'http://jabber.org/protocol/muc#user' will also be matched. If
               *      'ignoreNamespaceFragment' is false, then only stanzas with
               *      'http://jabber.org/protocol/muc' will be matched.
               *
               *  Deleting the handler
               *  ~~~~~~~~~~~~~~~~~~~~
               *  The return value should be saved if you wish to remove the handler
               *  with deleteHandler().
               *
               *  Parameters:
               *    (Function) handler - The user callback.
               *    (String) ns - The namespace to match.
               *    (String) name - The stanza name to match.
               *    (String|Array) type - The stanza type (or types if an array) to match.
               *    (String) id - The stanza id attribute to match.
               *    (String) from - The stanza from attribute to match.
               *    (String) options - The handler options
               *
               *  Returns:
               *    A reference to the handler that can be used to remove it.
               */


              addHandler(handler, ns, name, type, id, from, options) {
                const hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
                this.addHandlers.push(hand);
                return hand;
              }
              /** Function: deleteHandler
               *  Delete a stanza handler for a connection.
               *
               *  This function removes a stanza handler from the connection.  The
               *  handRef parameter is *not* the function passed to addHandler(),
               *  but is the reference returned from addHandler().
               *
               *  Parameters:
               *    (Strophe.Handler) handRef - The handler reference.
               */


              deleteHandler(handRef) {
                // this must be done in the Idle loop so that we don't change
                // the handlers during iteration
                this.removeHandlers.push(handRef); // If a handler is being deleted while it is being added,
                // prevent it from getting added

                const i = this.addHandlers.indexOf(handRef);

                if (i >= 0) {
                  this.addHandlers.splice(i, 1);
                }
              }
              /** Function: registerSASLMechanisms
               *
               * Register the SASL mechanisms which will be supported by this instance of
               * Strophe.Connection (i.e. which this XMPP client will support).
               *
               *  Parameters:
               *    (Array) mechanisms - Array of objects with Strophe.SASLMechanism prototypes
               *
               */


              registerSASLMechanisms(mechanisms) {
                this.mechanisms = {};
                mechanisms = mechanisms || [Strophe.SASLAnonymous, Strophe.SASLExternal, Strophe.SASLOAuthBearer, Strophe.SASLXOAuth2, Strophe.SASLPlain, Strophe.SASLSHA1];
                mechanisms.forEach(m => this.registerSASLMechanism(m));
              }
              /** Function: registerSASLMechanism
               *
               * Register a single SASL mechanism, to be supported by this client.
               *
               *  Parameters:
               *    (Object) mechanism - Object with a Strophe.SASLMechanism prototype
               *
               */


              registerSASLMechanism(Mechanism) {
                const mechanism = new Mechanism();
                this.mechanisms[mechanism.mechname] = mechanism;
              }
              /** Function: disconnect
               *  Start the graceful disconnection process.
               *
               *  This function starts the disconnection process.  This process starts
               *  by sending unavailable presence and sending BOSH body of type
               *  terminate.  A timeout handler makes sure that disconnection happens
               *  even if the BOSH server does not respond.
               *  If the Connection object isn't connected, at least tries to abort all pending requests
               *  so the connection object won't generate successful requests (which were already opened).
               *
               *  The user supplied connection callback will be notified of the
               *  progress as this process happens.
               *
               *  Parameters:
               *    (String) reason - The reason the disconnect is occuring.
               */


              disconnect(reason) {
                this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);

                if (reason) {
                  Strophe.warn("Disconnect was called because: " + reason);
                } else {
                  Strophe.info("Disconnect was called");
                }

                if (this.connected) {
                  let pres = false;
                  this.disconnecting = true;

                  if (this.authenticated) {
                    pres = $pres({
                      'xmlns': Strophe.NS.CLIENT,
                      'type': 'unavailable'
                    });
                  } // setup timeout handler


                  this._disconnectTimeout = this._addSysTimedHandler(this.disconnection_timeout, this._onDisconnectTimeout.bind(this));

                  this._proto._disconnect(pres);
                } else {
                  Strophe.warn("Disconnect was called before Strophe connected to the server");

                  this._proto._abortAllRequests();

                  this._doDisconnect();
                }
              }
              /** PrivateFunction: _changeConnectStatus
               *  _Private_ helper function that makes sure plugins and the user's
               *  callback are notified of connection status changes.
               *
               *  Parameters:
               *    (Integer) status - the new connection status, one of the values
               *      in Strophe.Status
               *    (String) condition - the error condition or null
               *    (XMLElement) elem - The triggering stanza.
               */


              _changeConnectStatus(status, condition, elem) {
                // notify all plugins listening for status changes
                for (const k in Strophe._connectionPlugins) {
                  if (Object.prototype.hasOwnProperty.call(Strophe._connectionPlugins, k)) {
                    const plugin = this[k];

                    if (plugin.statusChanged) {
                      try {
                        plugin.statusChanged(status, condition);
                      } catch (err) {
                        Strophe.error(`${k} plugin caused an exception changing status: ${err}`);
                      }
                    }
                  }
                } // notify the user's callback


                if (this.connect_callback) {
                  try {
                    this.connect_callback(status, condition, elem);
                  } catch (e) {
                    Strophe._handleError(e);

                    Strophe.error(`User connection callback caused an exception: ${e}`);
                  }
                }
              }
              /** PrivateFunction: _doDisconnect
               *  _Private_ function to disconnect.
               *
               *  This is the last piece of the disconnection logic.  This resets the
               *  connection and alerts the user's connection callback.
               */


              _doDisconnect(condition) {
                if (typeof this._idleTimeout === "number") {
                  clearTimeout(this._idleTimeout);
                } // Cancel Disconnect Timeout


                if (this._disconnectTimeout !== null) {
                  this.deleteTimedHandler(this._disconnectTimeout);
                  this._disconnectTimeout = null;
                }

                Strophe.debug("_doDisconnect was called");

                this._proto._doDisconnect();

                this.authenticated = false;
                this.disconnecting = false;
                this.restored = false; // delete handlers

                this.handlers = [];
                this.timedHandlers = [];
                this.removeTimeds = [];
                this.removeHandlers = [];
                this.addTimeds = [];
                this.addHandlers = []; // tell the parent we disconnected

                this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);

                this.connected = false;
              }
              /** PrivateFunction: _dataRecv
               *  _Private_ handler to processes incoming data from the the connection.
               *
               *  Except for _connect_cb handling the initial connection request,
               *  this function handles the incoming data for all requests.  This
               *  function also fires stanza handlers that match each incoming
               *  stanza.
               *
               *  Parameters:
               *    (Strophe.Request) req - The request that has data ready.
               *    (string) req - The stanza a raw string (optiona).
               */


              _dataRecv(req, raw) {
                const elem = this._proto._reqToData(req);

                if (elem === null) {
                  return;
                }

                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                  if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
                    this.xmlInput(elem.childNodes[0]);
                  } else {
                    this.xmlInput(elem);
                  }
                }

                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                  if (raw) {
                    this.rawInput(raw);
                  } else {
                    this.rawInput(Strophe.serialize(elem));
                  }
                } // remove handlers scheduled for deletion


                while (this.removeHandlers.length > 0) {
                  const hand = this.removeHandlers.pop();
                  const i = this.handlers.indexOf(hand);

                  if (i >= 0) {
                    this.handlers.splice(i, 1);
                  }
                } // add handlers scheduled for addition


                while (this.addHandlers.length > 0) {
                  this.handlers.push(this.addHandlers.pop());
                } // handle graceful disconnect


                if (this.disconnecting && this._proto._emptyQueue()) {
                  this._doDisconnect();

                  return;
                }

                const type = elem.getAttribute("type");

                if (type !== null && type === "terminate") {
                  // Don't process stanzas that come in after disconnect
                  if (this.disconnecting) {
                    return;
                  } // an error occurred


                  let cond = elem.getAttribute("condition");
                  const conflict = elem.getElementsByTagName("conflict");

                  if (cond !== null) {
                    if (cond === "remote-stream-error" && conflict.length > 0) {
                      cond = "conflict";
                    }

                    this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
                  } else {
                    this._changeConnectStatus(Strophe.Status.CONNFAIL, Strophe.ErrorCondition.UNKOWN_REASON);
                  }

                  this._doDisconnect(cond);

                  return;
                } // send each incoming stanza through the handler chain


                Strophe.forEachChild(elem, null, child => {
                  const matches = [];
                  this.handlers = this.handlers.reduce((handlers, handler) => {
                    try {
                      if (handler.isMatch(child) && (this.authenticated || !handler.user)) {
                        if (handler.run(child)) {
                          handlers.push(handler);
                        }

                        matches.push(handler);
                      } else {
                        handlers.push(handler);
                      }
                    } catch (e) {
                      // if the handler throws an exception, we consider it as false
                      Strophe.warn('Removing Strophe handlers due to uncaught exception: ' + e.message);
                    }

                    return handlers;
                  }, []); // If no handler was fired for an incoming IQ with type="set",
                  // then we return an IQ error stanza with service-unavailable.

                  if (!matches.length && this.iqFallbackHandler.isMatch(child)) {
                    this.iqFallbackHandler.run(child);
                  }
                });
              }
              /** PrivateFunction: _connect_cb
               *  _Private_ handler for initial connection request.
               *
               *  This handler is used to process the initial connection request
               *  response from the BOSH server. It is used to set up authentication
               *  handlers and start the authentication process.
               *
               *  SASL authentication will be attempted if available, otherwise
               *  the code will fall back to legacy authentication.
               *
               *  Parameters:
               *    (Strophe.Request) req - The current request.
               *    (Function) _callback - low level (xmpp) connect callback function.
               *      Useful for plugins with their own xmpp connect callback (when they
               *      want to do something special).
               */


              _connect_cb(req, _callback, raw) {
                Strophe.debug("_connect_cb was called");
                this.connected = true;
                let bodyWrap;

                try {
                  bodyWrap = this._proto._reqToData(req);
                } catch (e) {
                  if (e.name !== Strophe.ErrorCondition.BAD_FORMAT) {
                    throw e;
                  }

                  this._changeConnectStatus(Strophe.Status.CONNFAIL, Strophe.ErrorCondition.BAD_FORMAT);

                  this._doDisconnect(Strophe.ErrorCondition.BAD_FORMAT);
                }

                if (!bodyWrap) {
                  return;
                }

                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
                  if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
                    this.xmlInput(bodyWrap.childNodes[0]);
                  } else {
                    this.xmlInput(bodyWrap);
                  }
                }

                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
                  if (raw) {
                    this.rawInput(raw);
                  } else {
                    this.rawInput(Strophe.serialize(bodyWrap));
                  }
                }

                const conncheck = this._proto._connect_cb(bodyWrap);

                if (conncheck === Strophe.Status.CONNFAIL) {
                  return;
                } // Check for the stream:features tag


                let hasFeatures;

                if (bodyWrap.getElementsByTagNameNS) {
                  hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "features").length > 0;
                } else {
                  hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 || bodyWrap.getElementsByTagName("features").length > 0;
                }

                if (!hasFeatures) {
                  this._proto._no_auth_received(_callback);

                  return;
                }

                const matched = Array.from(bodyWrap.getElementsByTagName("mechanism")).map(m => this.mechanisms[m.textContent]).filter(m => m);

                if (matched.length === 0) {
                  if (bodyWrap.getElementsByTagName("auth").length === 0) {
                    // There are no matching SASL mechanisms and also no legacy
                    // auth available.
                    this._proto._no_auth_received(_callback);

                    return;
                  }
                }

                if (this.do_authentication !== false) {
                  this.authenticate(matched);
                }
              }
              /** Function: sortMechanismsByPriority
               *
               *  Sorts an array of objects with prototype SASLMechanism according to
               *  their priorities.
               *
               *  Parameters:
               *    (Array) mechanisms - Array of SASL mechanisms.
               *
               */


              sortMechanismsByPriority(mechanisms) {
                // eslint-disable-line class-methods-use-this
                // Sorting mechanisms according to priority.
                for (let i = 0; i < mechanisms.length - 1; ++i) {
                  let higher = i;

                  for (let j = i + 1; j < mechanisms.length; ++j) {
                    if (mechanisms[j].priority > mechanisms[higher].priority) {
                      higher = j;
                    }
                  }

                  if (higher !== i) {
                    const swap = mechanisms[i];
                    mechanisms[i] = mechanisms[higher];
                    mechanisms[higher] = swap;
                  }
                }

                return mechanisms;
              }
              /** Function: authenticate
               * Set up authentication
               *
               *  Continues the initial connection request by setting up authentication
               *  handlers and starting the authentication process.
               *
               *  SASL authentication will be attempted if available, otherwise
               *  the code will fall back to legacy authentication.
               *
               *  Parameters:
               *    (Array) matched - Array of SASL mechanisms supported.
               *
               */


              authenticate(matched) {
                if (!this._attemptSASLAuth(matched)) {
                  this._attemptLegacyAuth();
                }
              }
              /** PrivateFunction: _attemptSASLAuth
               *
               *  Iterate through an array of SASL mechanisms and attempt authentication
               *  with the highest priority (enabled) mechanism.
               *
               *  Parameters:
               *    (Array) mechanisms - Array of SASL mechanisms.
               *
               *  Returns:
               *    (Boolean) mechanism_found - true or false, depending on whether a
               *          valid SASL mechanism was found with which authentication could be
               *          started.
               */


              _attemptSASLAuth(mechanisms) {
                mechanisms = this.sortMechanismsByPriority(mechanisms || []);
                let mechanism_found = false;

                for (let i = 0; i < mechanisms.length; ++i) {
                  if (!mechanisms[i].test(this)) {
                    continue;
                  }

                  this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null);
                  this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null);
                  this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null);
                  this._sasl_mechanism = mechanisms[i];

                  this._sasl_mechanism.onStart(this);

                  const request_auth_exchange = $build("auth", {
                    'xmlns': Strophe.NS.SASL,
                    'mechanism': this._sasl_mechanism.mechname
                  });

                  if (this._sasl_mechanism.isClientFirst) {
                    const response = this._sasl_mechanism.clientChallenge(this);

                    request_auth_exchange.t(abab.btoa(response));
                  }

                  this.send(request_auth_exchange.tree());
                  mechanism_found = true;
                  break;
                }

                return mechanism_found;
              }
              /** PrivateFunction: _sasl_challenge_cb
               *  _Private_ handler for the SASL challenge
               *
               */


              _sasl_challenge_cb(elem) {
                const challenge = abab.atob(Strophe.getText(elem));

                const response = this._sasl_mechanism.onChallenge(this, challenge);

                const stanza = $build('response', {
                  'xmlns': Strophe.NS.SASL
                });

                if (response !== "") {
                  stanza.t(abab.btoa(response));
                }

                this.send(stanza.tree());
                return true;
              }
              /** PrivateFunction: _attemptLegacyAuth
               *
               *  Attempt legacy (i.e. non-SASL) authentication.
               */


              _attemptLegacyAuth() {
                if (Strophe.getNodeFromJid(this.jid) === null) {
                  // we don't have a node, which is required for non-anonymous
                  // client connections
                  this._changeConnectStatus(Strophe.Status.CONNFAIL, Strophe.ErrorCondition.MISSING_JID_NODE);

                  this.disconnect(Strophe.ErrorCondition.MISSING_JID_NODE);
                } else {
                  // Fall back to legacy authentication
                  this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);

                  this._addSysHandler(this._onLegacyAuthIQResult.bind(this), null, null, null, "_auth_1");

                  this.send($iq({
                    'type': "get",
                    'to': this.domain,
                    'id': "_auth_1"
                  }).c("query", {
                    xmlns: Strophe.NS.AUTH
                  }).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).tree());
                }
              }
              /** PrivateFunction: _onLegacyAuthIQResult
               *  _Private_ handler for legacy authentication.
               *
               *  This handler is called in response to the initial <iq type='get'/>
               *  for legacy authentication.  It builds an authentication <iq/> and
               *  sends it, creating a handler (calling back to _auth2_cb()) to
               *  handle the result
               *
               *  Parameters:
               *    (XMLElement) elem - The stanza that triggered the callback.
               *
               *  Returns:
               *    false to remove the handler.
               */


              _onLegacyAuthIQResult(elem) {
                // eslint-disable-line no-unused-vars
                // build plaintext auth iq
                const iq = $iq({
                  type: "set",
                  id: "_auth_2"
                }).c('query', {
                  xmlns: Strophe.NS.AUTH
                }).c('username', {}).t(Strophe.getNodeFromJid(this.jid)).up().c('password').t(this.pass);

                if (!Strophe.getResourceFromJid(this.jid)) {
                  // since the user has not supplied a resource, we pick
                  // a default one here.  unlike other auth methods, the server
                  // cannot do this for us.
                  this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';
                }

                iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));

                this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2");

                this.send(iq.tree());
                return false;
              }
              /** PrivateFunction: _sasl_success_cb
               *  _Private_ handler for succesful SASL authentication.
               *
               *  Parameters:
               *    (XMLElement) elem - The matching stanza.
               *
               *  Returns:
               *    false to remove the handler.
               */


              _sasl_success_cb(elem) {
                if (this._sasl_data["server-signature"]) {
                  let serverSignature;
                  const success = abab.atob(Strophe.getText(elem));
                  const attribMatch = /([a-z]+)=([^,]+)(,|$)/;
                  const matches = success.match(attribMatch);

                  if (matches[1] === "v") {
                    serverSignature = matches[2];
                  }

                  if (serverSignature !== this._sasl_data["server-signature"]) {
                    // remove old handlers
                    this.deleteHandler(this._sasl_failure_handler);
                    this._sasl_failure_handler = null;

                    if (this._sasl_challenge_handler) {
                      this.deleteHandler(this._sasl_challenge_handler);
                      this._sasl_challenge_handler = null;
                    }

                    this._sasl_data = {};
                    return this._sasl_failure_cb(null);
                  }
                }

                Strophe.info("SASL authentication succeeded.");

                if (this._sasl_mechanism) {
                  this._sasl_mechanism.onSuccess();
                } // remove old handlers


                this.deleteHandler(this._sasl_failure_handler);
                this._sasl_failure_handler = null;

                if (this._sasl_challenge_handler) {
                  this.deleteHandler(this._sasl_challenge_handler);
                  this._sasl_challenge_handler = null;
                }

                const streamfeature_handlers = [];

                const wrapper = (handlers, elem) => {
                  while (handlers.length) {
                    this.deleteHandler(handlers.pop());
                  }

                  this._onStreamFeaturesAfterSASL(elem);

                  return false;
                };

                streamfeature_handlers.push(this._addSysHandler(elem => wrapper(streamfeature_handlers, elem), null, "stream:features", null, null));
                streamfeature_handlers.push(this._addSysHandler(elem => wrapper(streamfeature_handlers, elem), Strophe.NS.STREAM, "features", null, null)); // we must send an xmpp:restart now

                this._sendRestart();

                return false;
              }
              /** PrivateFunction: _onStreamFeaturesAfterSASL
               *  Parameters:
               *    (XMLElement) elem - The matching stanza.
               *
               *  Returns:
               *    false to remove the handler.
               */


              _onStreamFeaturesAfterSASL(elem) {
                // save stream:features for future usage
                this.features = elem;

                for (let i = 0; i < elem.childNodes.length; i++) {
                  const child = elem.childNodes[i];

                  if (child.nodeName === 'bind') {
                    this.do_bind = true;
                  }

                  if (child.nodeName === 'session') {
                    this.do_session = true;
                  }
                }

                if (!this.do_bind) {
                  this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);

                  return false;
                } else if (!this.options.explicitResourceBinding) {
                  this.bind();
                } else {
                  this._changeConnectStatus(Strophe.Status.BINDREQUIRED, null);
                }

                return false;
              }
              /** Function: bind
               *
               *  Sends an IQ to the XMPP server to bind a JID resource for this session.
               *
               *  https://tools.ietf.org/html/rfc6120#section-7.5
               *
               *  If `explicitResourceBinding` was set to a truthy value in the options
               *  passed to the Strophe.Connection constructor, then this function needs
               *  to be called explicitly by the client author.
               *
               *  Otherwise it'll be called automatically as soon as the XMPP server
               *  advertises the "urn:ietf:params:xml:ns:xmpp-bind" stream feature.
               */


              bind() {
                if (!this.do_bind) {
                  Strophe.log(Strophe.LogLevel.INFO, `Strophe.Connection.prototype.bind called but "do_bind" is false`);
                  return;
                }

                this._addSysHandler(this._onResourceBindResultIQ.bind(this), null, null, null, "_bind_auth_2");

                const resource = Strophe.getResourceFromJid(this.jid);

                if (resource) {
                  this.send($iq({
                    type: "set",
                    id: "_bind_auth_2"
                  }).c('bind', {
                    xmlns: Strophe.NS.BIND
                  }).c('resource', {}).t(resource).tree());
                } else {
                  this.send($iq({
                    type: "set",
                    id: "_bind_auth_2"
                  }).c('bind', {
                    xmlns: Strophe.NS.BIND
                  }).tree());
                }
              }
              /** PrivateFunction: _onResourceBindIQ
               *  _Private_ handler for binding result and session start.
               *
               *  Parameters:
               *    (XMLElement) elem - The matching stanza.
               *
               *  Returns:
               *    false to remove the handler.
               */


              _onResourceBindResultIQ(elem) {
                if (elem.getAttribute("type") === "error") {
                  Strophe.warn("Resource binding failed.");
                  const conflict = elem.getElementsByTagName("conflict");
                  let condition;

                  if (conflict.length > 0) {
                    condition = Strophe.ErrorCondition.CONFLICT;
                  }

                  this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition, elem);

                  return false;
                } // TODO - need to grab errors


                const bind = elem.getElementsByTagName("bind");

                if (bind.length > 0) {
                  const jidNode = bind[0].getElementsByTagName("jid");

                  if (jidNode.length > 0) {
                    this.authenticated = true;
                    this.jid = Strophe.getText(jidNode[0]);

                    if (this.do_session) {
                      this._establishSession();
                    } else {
                      this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                    }
                  }
                } else {
                  Strophe.warn("Resource binding failed.");

                  this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);

                  return false;
                }
              }
              /** PrivateFunction: _establishSession
               *  Send IQ request to establish a session with the XMPP server.
               *
               *  See https://xmpp.org/rfcs/rfc3921.html#session
               *
               *  Note: The protocol for session establishment has been determined as
               *  unnecessary and removed in RFC-6121.
               */


              _establishSession() {
                if (!this.do_session) {
                  throw new Error(`Strophe.Connection.prototype._establishSession ` + `called but apparently ${Strophe.NS.SESSION} wasn't advertised by the server`);
                }

                this._addSysHandler(this._onSessionResultIQ.bind(this), null, null, null, "_session_auth_2");

                this.send($iq({
                  type: "set",
                  id: "_session_auth_2"
                }).c('session', {
                  xmlns: Strophe.NS.SESSION
                }).tree());
              }
              /** PrivateFunction: _onSessionResultIQ
               *  _Private_ handler for the server's IQ response to a client's session
               *  request.
               *
               *  This sets Connection.authenticated to true on success, which
               *  starts the processing of user handlers.
               *
               *  See https://xmpp.org/rfcs/rfc3921.html#session
               *
               *  Note: The protocol for session establishment has been determined as
               *  unnecessary and removed in RFC-6121.
               *
               *  Parameters:
               *    (XMLElement) elem - The matching stanza.
               *
               *  Returns:
               *    false to remove the handler.
               */


              _onSessionResultIQ(elem) {
                if (elem.getAttribute("type") === "result") {
                  this.authenticated = true;

                  this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                } else if (elem.getAttribute("type") === "error") {
                  this.authenticated = false;
                  Strophe.warn("Session creation failed.");

                  this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);

                  return false;
                }

                return false;
              }
              /** PrivateFunction: _sasl_failure_cb
               *  _Private_ handler for SASL authentication failure.
               *
               *  Parameters:
               *    (XMLElement) elem - The matching stanza.
               *
               *  Returns:
               *    false to remove the handler.
               */


              _sasl_failure_cb(elem) {
                // delete unneeded handlers
                if (this._sasl_success_handler) {
                  this.deleteHandler(this._sasl_success_handler);
                  this._sasl_success_handler = null;
                }

                if (this._sasl_challenge_handler) {
                  this.deleteHandler(this._sasl_challenge_handler);
                  this._sasl_challenge_handler = null;
                }

                if (this._sasl_mechanism) this._sasl_mechanism.onFailure();

                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);

                return false;
              }
              /** PrivateFunction: _auth2_cb
               *  _Private_ handler to finish legacy authentication.
               *
               *  This handler is called when the result from the jabber:iq:auth
               *  <iq/> stanza is returned.
               *
               *  Parameters:
               *    (XMLElement) elem - The stanza that triggered the callback.
               *
               *  Returns:
               *    false to remove the handler.
               */


              _auth2_cb(elem) {
                if (elem.getAttribute("type") === "result") {
                  this.authenticated = true;

                  this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                } else if (elem.getAttribute("type") === "error") {
                  this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);

                  this.disconnect('authentication failed');
                }

                return false;
              }
              /** PrivateFunction: _addSysTimedHandler
               *  _Private_ function to add a system level timed handler.
               *
               *  This function is used to add a Strophe.TimedHandler for the
               *  library code.  System timed handlers are allowed to run before
               *  authentication is complete.
               *
               *  Parameters:
               *    (Integer) period - The period of the handler.
               *    (Function) handler - The callback function.
               */


              _addSysTimedHandler(period, handler) {
                const thand = new Strophe.TimedHandler(period, handler);
                thand.user = false;
                this.addTimeds.push(thand);
                return thand;
              }
              /** PrivateFunction: _addSysHandler
               *  _Private_ function to add a system level stanza handler.
               *
               *  This function is used to add a Strophe.Handler for the
               *  library code.  System stanza handlers are allowed to run before
               *  authentication is complete.
               *
               *  Parameters:
               *    (Function) handler - The callback function.
               *    (String) ns - The namespace to match.
               *    (String) name - The stanza name to match.
               *    (String) type - The stanza type attribute to match.
               *    (String) id - The stanza id attribute to match.
               */


              _addSysHandler(handler, ns, name, type, id) {
                const hand = new Strophe.Handler(handler, ns, name, type, id);
                hand.user = false;
                this.addHandlers.push(hand);
                return hand;
              }
              /** PrivateFunction: _onDisconnectTimeout
               *  _Private_ timeout handler for handling non-graceful disconnection.
               *
               *  If the graceful disconnect process does not complete within the
               *  time allotted, this handler finishes the disconnect anyway.
               *
               *  Returns:
               *    false to remove the handler.
               */


              _onDisconnectTimeout() {
                Strophe.debug("_onDisconnectTimeout was called");

                this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);

                this._proto._onDisconnectTimeout(); // actually disconnect


                this._doDisconnect();

                return false;
              }
              /** PrivateFunction: _onIdle
               *  _Private_ handler to process events during idle cycle.
               *
               *  This handler is called every 100ms to fire timed handlers that
               *  are ready and keep poll requests going.
               */


              _onIdle() {
                // add timed handlers scheduled for addition
                // NOTE: we add before remove in the case a timed handler is
                // added and then deleted before the next _onIdle() call.
                while (this.addTimeds.length > 0) {
                  this.timedHandlers.push(this.addTimeds.pop());
                } // remove timed handlers that have been scheduled for deletion


                while (this.removeTimeds.length > 0) {
                  const thand = this.removeTimeds.pop();
                  const i = this.timedHandlers.indexOf(thand);

                  if (i >= 0) {
                    this.timedHandlers.splice(i, 1);
                  }
                } // call ready timed handlers


                const now = new Date().getTime();
                const newList = [];

                for (let i = 0; i < this.timedHandlers.length; i++) {
                  const thand = this.timedHandlers[i];

                  if (this.authenticated || !thand.user) {
                    const since = thand.lastCalled + thand.period;

                    if (since - now <= 0) {
                      if (thand.run()) {
                        newList.push(thand);
                      }
                    } else {
                      newList.push(thand);
                    }
                  }
                }

                this.timedHandlers = newList;
                clearTimeout(this._idleTimeout);

                this._proto._onIdle(); // reactivate the timer only if connected


                if (this.connected) {
                  this._idleTimeout = setTimeout(() => this._onIdle(), 100);
                }
              }

            };
            Strophe.SASLMechanism = SASLMechanism;
            /** Constants: SASL mechanisms
             *  Available authentication mechanisms
             *
             *  Strophe.SASLAnonymous   - SASL ANONYMOUS authentication.
             *  Strophe.SASLPlain       - SASL PLAIN authentication.
             *  Strophe.SASLSHA1        - SASL SCRAM-SHA-1 authentication
             *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication
             *  Strophe.SASLExternal    - SASL EXTERNAL authentication
             *  Strophe.SASLXOAuth2     - SASL X-OAuth2 authentication
             */

            Strophe.SASLAnonymous = SASLAnonymous;
            Strophe.SASLPlain = SASLPlain;
            Strophe.SASLSHA1 = SASLSHA1;
            Strophe.SASLOAuthBearer = SASLOAuthBearer;
            Strophe.SASLExternal = SASLExternal;
            Strophe.SASLXOAuth2 = SASLXOAuth2;
            var core = {
              'Strophe': Strophe,
              '$build': $build,
              '$iq': $iq,
              '$msg': $msg,
              '$pres': $pres,
              'SHA1': SHA1,
              'MD5': MD5,
              'b64_hmac_sha1': SHA1.b64_hmac_sha1,
              'b64_sha1': SHA1.b64_sha1,
              'str_hmac_sha1': SHA1.str_hmac_sha1,
              'str_sha1': SHA1.str_sha1
            };

            /*
                This program is distributed under the terms of the MIT license.
                Please see the LICENSE file for details.

                Copyright 2006-2008, OGG, LLC
            */
            /** PrivateClass: Strophe.Request
             *  _Private_ helper class that provides a cross implementation abstraction
             *  for a BOSH related XMLHttpRequest.
             *
             *  The Strophe.Request class is used internally to encapsulate BOSH request
             *  information.  It is not meant to be used from user's code.
             */

            Strophe.Request = class Request {
              /** PrivateConstructor: Strophe.Request
               *  Create and initialize a new Strophe.Request object.
               *
               *  Parameters:
               *    (XMLElement) elem - The XML data to be sent in the request.
               *    (Function) func - The function that will be called when the
               *      XMLHttpRequest readyState changes.
               *    (Integer) rid - The BOSH rid attribute associated with this request.
               *    (Integer) sends - The number of times this same request has been sent.
               */
              constructor(elem, func, rid, sends) {
                this.id = ++Strophe._requestId;
                this.xmlData = elem;
                this.data = Strophe.serialize(elem); // save original function in case we need to make a new request
                // from this one.

                this.origFunc = func;
                this.func = func;
                this.rid = rid;
                this.date = NaN;
                this.sends = sends || 0;
                this.abort = false;
                this.dead = null;

                this.age = function () {
                  if (!this.date) {
                    return 0;
                  }

                  const now = new Date();
                  return (now - this.date) / 1000;
                };

                this.timeDead = function () {
                  if (!this.dead) {
                    return 0;
                  }

                  const now = new Date();
                  return (now - this.dead) / 1000;
                };

                this.xhr = this._newXHR();
              }
              /** PrivateFunction: getResponse
               *  Get a response from the underlying XMLHttpRequest.
               *
               *  This function attempts to get a response from the request and checks
               *  for errors.
               *
               *  Throws:
               *    "parsererror" - A parser error occured.
               *    "bad-format" - The entity has sent XML that cannot be processed.
               *
               *  Returns:
               *    The DOM element tree of the response.
               */


              getResponse() {
                let node = null;

                if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                  node = this.xhr.responseXML.documentElement;

                  if (node.tagName === "parsererror") {
                    Strophe.error("invalid response received");
                    Strophe.error("responseText: " + this.xhr.responseText);
                    Strophe.error("responseXML: " + Strophe.serialize(this.xhr.responseXML));
                    throw new Error("parsererror");
                  }
                } else if (this.xhr.responseText) {
                  // In React Native, we may get responseText but no responseXML.  We can try to parse it manually.
                  Strophe.debug("Got responseText but no responseXML; attempting to parse it with DOMParser...");
                  node = new DOMParser().parseFromString(this.xhr.responseText, 'application/xml').documentElement;

                  if (!node) {
                    throw new Error('Parsing produced null node');
                  } else if (node.querySelector('parsererror')) {
                    Strophe.error("invalid response received: " + node.querySelector('parsererror').textContent);
                    Strophe.error("responseText: " + this.xhr.responseText);
                    const error = new Error();
                    error.name = Strophe.ErrorCondition.BAD_FORMAT;
                    throw error;
                  }
                }

                return node;
              }
              /** PrivateFunction: _newXHR
               *  _Private_ helper function to create XMLHttpRequests.
               *
               *  This function creates XMLHttpRequests across all implementations.
               *
               *  Returns:
               *    A new XMLHttpRequest.
               */


              _newXHR() {
                let xhr = null;

                if (window.XMLHttpRequest) {
                  xhr = new XMLHttpRequest();

                  if (xhr.overrideMimeType) {
                    xhr.overrideMimeType("text/xml; charset=utf-8");
                  }
                } else if (window.ActiveXObject) {
                  xhr = new ActiveXObject("Microsoft.XMLHTTP");
                } // use Function.bind() to prepend ourselves as an argument


                xhr.onreadystatechange = this.func.bind(null, this);
                return xhr;
              }

            };
            /** Class: Strophe.Bosh
             *  _Private_ helper class that handles BOSH Connections
             *
             *  The Strophe.Bosh class is used internally by Strophe.Connection
             *  to encapsulate BOSH sessions. It is not meant to be used from user's code.
             */

            /** File: bosh.js
             *  A JavaScript library to enable BOSH in Strophejs.
             *
             *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)
             *  to emulate a persistent, stateful, two-way connection to an XMPP server.
             *  More information on BOSH can be found in XEP 124.
             */

            /** PrivateConstructor: Strophe.Bosh
             *  Create and initialize a Strophe.Bosh object.
             *
             *  Parameters:
             *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.
             *
             *  Returns:
             *    A new Strophe.Bosh object.
             */

            Strophe.Bosh = class Bosh {
              constructor(connection) {
                this._conn = connection;
                /* request id for body tags */

                this.rid = Math.floor(Math.random() * 4294967295);
                /* The current session ID. */

                this.sid = null; // default BOSH values

                this.hold = 1;
                this.wait = 60;
                this.window = 5;
                this.errors = 0;
                this.inactivity = null;
                this.lastResponseHeaders = null;
                this._requests = [];
              }
              /** PrivateFunction: _buildBody
               *  _Private_ helper function to generate the <body/> wrapper for BOSH.
               *
               *  Returns:
               *    A Strophe.Builder with a <body/> element.
               */


              _buildBody() {
                const bodyWrap = $build('body', {
                  'rid': this.rid++,
                  'xmlns': Strophe.NS.HTTPBIND
                });

                if (this.sid !== null) {
                  bodyWrap.attrs({
                    'sid': this.sid
                  });
                }

                if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {
                  this._cacheSession();
                }

                return bodyWrap;
              }
              /** PrivateFunction: _reset
               *  Reset the connection.
               *
               *  This function is called by the reset function of the Strophe Connection
               */


              _reset() {
                this.rid = Math.floor(Math.random() * 4294967295);
                this.sid = null;
                this.errors = 0;

                if (this._conn._sessionCachingSupported()) {
                  window.sessionStorage.removeItem('strophe-bosh-session');
                }

                this._conn.nextValidRid(this.rid);
              }
              /** PrivateFunction: _connect
               *  _Private_ function that initializes the BOSH connection.
               *
               *  Creates and sends the Request that initializes the BOSH connection.
               */


              _connect(wait, hold, route) {
                this.wait = wait || this.wait;
                this.hold = hold || this.hold;
                this.errors = 0;

                const body = this._buildBody().attrs({
                  "to": this._conn.domain,
                  "xml:lang": "en",
                  "wait": this.wait,
                  "hold": this.hold,
                  "content": "text/xml; charset=utf-8",
                  "ver": "1.6",
                  "xmpp:version": "1.0",
                  "xmlns:xmpp": Strophe.NS.BOSH
                });

                if (route) {
                  body.attrs({
                    'route': route
                  });
                }

                const _connect_cb = this._conn._connect_cb;

                this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, _connect_cb.bind(this._conn)), body.tree().getAttribute("rid")));

                this._throttledRequestHandler();
              }
              /** PrivateFunction: _attach
               *  Attach to an already created and authenticated BOSH session.
               *
               *  This function is provided to allow Strophe to attach to BOSH
               *  sessions which have been created externally, perhaps by a Web
               *  application.  This is often used to support auto-login type features
               *  without putting user credentials into the page.
               *
               *  Parameters:
               *    (String) jid - The full JID that is bound by the session.
               *    (String) sid - The SID of the BOSH session.
               *    (String) rid - The current RID of the BOSH session.  This RID
               *      will be used by the next request.
               *    (Function) callback The connect callback function.
               *    (Integer) wait - The optional HTTPBIND wait value.  This is the
               *      time the server will wait before returning an empty result for
               *      a request.  The default setting of 60 seconds is recommended.
               *      Other settings will require tweaks to the Strophe.TIMEOUT value.
               *    (Integer) hold - The optional HTTPBIND hold value.  This is the
               *      number of connections the server will hold at one time.  This
               *      should almost always be set to 1 (the default).
               *    (Integer) wind - The optional HTTBIND window value.  This is the
               *      allowed range of request ids that are valid.  The default is 5.
               */


              _attach(jid, sid, rid, callback, wait, hold, wind) {
                this._conn.jid = jid;
                this.sid = sid;
                this.rid = rid;
                this._conn.connect_callback = callback;
                this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);
                this._conn.authenticated = true;
                this._conn.connected = true;
                this.wait = wait || this.wait;
                this.hold = hold || this.hold;
                this.window = wind || this.window;

                this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);
              }
              /** PrivateFunction: _restore
               *  Attempt to restore a cached BOSH session
               *
               *  Parameters:
               *    (String) jid - The full JID that is bound by the session.
               *      This parameter is optional but recommended, specifically in cases
               *      where prebinded BOSH sessions are used where it's important to know
               *      that the right session is being restored.
               *    (Function) callback The connect callback function.
               *    (Integer) wait - The optional HTTPBIND wait value.  This is the
               *      time the server will wait before returning an empty result for
               *      a request.  The default setting of 60 seconds is recommended.
               *      Other settings will require tweaks to the Strophe.TIMEOUT value.
               *    (Integer) hold - The optional HTTPBIND hold value.  This is the
               *      number of connections the server will hold at one time.  This
               *      should almost always be set to 1 (the default).
               *    (Integer) wind - The optional HTTBIND window value.  This is the
               *      allowed range of request ids that are valid.  The default is 5.
               */


              _restore(jid, callback, wait, hold, wind) {
                const session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));

                if (typeof session !== "undefined" && session !== null && session.rid && session.sid && session.jid && (typeof jid === "undefined" || jid === null || Strophe.getBareJidFromJid(session.jid) === Strophe.getBareJidFromJid(jid) || // If authcid is null, then it's an anonymous login, so
                // we compare only the domains:
                Strophe.getNodeFromJid(jid) === null && Strophe.getDomainFromJid(session.jid) === jid)) {
                  this._conn.restored = true;

                  this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
                } else {
                  const error = new Error("_restore: no restoreable session.");
                  error.name = "StropheSessionError";
                  throw error;
                }
              }
              /** PrivateFunction: _cacheSession
               *  _Private_ handler for the beforeunload event.
               *
               *  This handler is used to process the Bosh-part of the initial request.
               *  Parameters:
               *    (Strophe.Request) bodyWrap - The received stanza.
               */


              _cacheSession() {
                if (this._conn.authenticated) {
                  if (this._conn.jid && this.rid && this.sid) {
                    window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({
                      'jid': this._conn.jid,
                      'rid': this.rid,
                      'sid': this.sid
                    }));
                  }
                } else {
                  window.sessionStorage.removeItem('strophe-bosh-session');
                }
              }
              /** PrivateFunction: _connect_cb
               *  _Private_ handler for initial connection request.
               *
               *  This handler is used to process the Bosh-part of the initial request.
               *  Parameters:
               *    (Strophe.Request) bodyWrap - The received stanza.
               */


              _connect_cb(bodyWrap) {
                const typ = bodyWrap.getAttribute("type");

                if (typ !== null && typ === "terminate") {
                  // an error occurred
                  let cond = bodyWrap.getAttribute("condition");
                  Strophe.error("BOSH-Connection failed: " + cond);
                  const conflict = bodyWrap.getElementsByTagName("conflict");

                  if (cond !== null) {
                    if (cond === "remote-stream-error" && conflict.length > 0) {
                      cond = "conflict";
                    }

                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
                  } else {
                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
                  }

                  this._conn._doDisconnect(cond);

                  return Strophe.Status.CONNFAIL;
                } // check to make sure we don't overwrite these if _connect_cb is
                // called multiple times in the case of missing stream:features


                if (!this.sid) {
                  this.sid = bodyWrap.getAttribute("sid");
                }

                const wind = bodyWrap.getAttribute('requests');

                if (wind) {
                  this.window = parseInt(wind, 10);
                }

                const hold = bodyWrap.getAttribute('hold');

                if (hold) {
                  this.hold = parseInt(hold, 10);
                }

                const wait = bodyWrap.getAttribute('wait');

                if (wait) {
                  this.wait = parseInt(wait, 10);
                }

                const inactivity = bodyWrap.getAttribute('inactivity');

                if (inactivity) {
                  this.inactivity = parseInt(inactivity, 10);
                }
              }
              /** PrivateFunction: _disconnect
               *  _Private_ part of Connection.disconnect for Bosh
               *
               *  Parameters:
               *    (Request) pres - This stanza will be sent before disconnecting.
               */


              _disconnect(pres) {
                this._sendTerminate(pres);
              }
              /** PrivateFunction: _doDisconnect
               *  _Private_ function to disconnect.
               *
               *  Resets the SID and RID.
               */


              _doDisconnect() {
                this.sid = null;
                this.rid = Math.floor(Math.random() * 4294967295);

                if (this._conn._sessionCachingSupported()) {
                  window.sessionStorage.removeItem('strophe-bosh-session');
                }

                this._conn.nextValidRid(this.rid);
              }
              /** PrivateFunction: _emptyQueue
               * _Private_ function to check if the Request queue is empty.
               *
               *  Returns:
               *    True, if there are no Requests queued, False otherwise.
               */


              _emptyQueue() {
                return this._requests.length === 0;
              }
              /** PrivateFunction: _callProtocolErrorHandlers
               *  _Private_ function to call error handlers registered for HTTP errors.
               *
               *  Parameters:
               *    (Strophe.Request) req - The request that is changing readyState.
               */


              _callProtocolErrorHandlers(req) {
                const reqStatus = Bosh._getRequestStatus(req);

                const err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];

                if (err_callback) {
                  err_callback.call(this, reqStatus);
                }
              }
              /** PrivateFunction: _hitError
               *  _Private_ function to handle the error count.
               *
               *  Requests are resent automatically until their error count reaches
               *  5.  Each time an error is encountered, this function is called to
               *  increment the count and disconnect if the count is too high.
               *
               *  Parameters:
               *    (Integer) reqStatus - The request status.
               */


              _hitError(reqStatus) {
                this.errors++;
                Strophe.warn("request errored, status: " + reqStatus + ", number of errors: " + this.errors);

                if (this.errors > 4) {
                  this._conn._onDisconnectTimeout();
                }
              }
              /** PrivateFunction: _no_auth_received
               *
               * Called on stream start/restart when no stream:features
               * has been received and sends a blank poll request.
               */


              _no_auth_received(callback) {
                Strophe.warn("Server did not yet offer a supported authentication " + "mechanism. Sending a blank poll request.");

                if (callback) {
                  callback = callback.bind(this._conn);
                } else {
                  callback = this._conn._connect_cb.bind(this._conn);
                }

                const body = this._buildBody();

                this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, callback), body.tree().getAttribute("rid")));

                this._throttledRequestHandler();
              }
              /** PrivateFunction: _onDisconnectTimeout
               *  _Private_ timeout handler for handling non-graceful disconnection.
               *
               *  Cancels all remaining Requests and clears the queue.
               */


              _onDisconnectTimeout() {
                this._abortAllRequests();
              }
              /** PrivateFunction: _abortAllRequests
               *  _Private_ helper function that makes sure all pending requests are aborted.
               */


              _abortAllRequests() {
                while (this._requests.length > 0) {
                  const req = this._requests.pop();

                  req.abort = true;
                  req.xhr.abort();

                  req.xhr.onreadystatechange = function () {};
                }
              }
              /** PrivateFunction: _onIdle
               *  _Private_ handler called by Strophe.Connection._onIdle
               *
               *  Sends all queued Requests or polls with empty Request if there are none.
               */


              _onIdle() {
                const data = this._conn._data; // if no requests are in progress, poll

                if (this._conn.authenticated && this._requests.length === 0 && data.length === 0 && !this._conn.disconnecting) {
                  Strophe.debug("no requests during idle cycle, sending blank request");
                  data.push(null);
                }

                if (this._conn.paused) {
                  return;
                }

                if (this._requests.length < 2 && data.length > 0) {
                  const body = this._buildBody();

                  for (let i = 0; i < data.length; i++) {
                    if (data[i] !== null) {
                      if (data[i] === "restart") {
                        body.attrs({
                          "to": this._conn.domain,
                          "xml:lang": "en",
                          "xmpp:restart": "true",
                          "xmlns:xmpp": Strophe.NS.BOSH
                        });
                      } else {
                        body.cnode(data[i]).up();
                      }
                    }
                  }

                  delete this._conn._data;
                  this._conn._data = [];

                  this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute("rid")));

                  this._throttledRequestHandler();
                }

                if (this._requests.length > 0) {
                  const time_elapsed = this._requests[0].age();

                  if (this._requests[0].dead !== null) {
                    if (this._requests[0].timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                      this._throttledRequestHandler();
                    }
                  }

                  if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                    Strophe.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) + " seconds since last activity");

                    this._throttledRequestHandler();
                  }
                }
              }
              /** PrivateFunction: _getRequestStatus
               *
               *  Returns the HTTP status code from a Strophe.Request
               *
               *  Parameters:
               *    (Strophe.Request) req - The Strophe.Request instance.
               *    (Integer) def - The default value that should be returned if no
               *          status value was found.
               */


              static _getRequestStatus(req, def) {
                let reqStatus;

                if (req.xhr.readyState === 4) {
                  try {
                    reqStatus = req.xhr.status;
                  } catch (e) {
                    // ignore errors from undefined status attribute. Works
                    // around a browser bug
                    Strophe.error("Caught an error while retrieving a request's status, " + "reqStatus: " + reqStatus);
                  }
                }

                if (typeof reqStatus === "undefined") {
                  reqStatus = typeof def === 'number' ? def : 0;
                }

                return reqStatus;
              }
              /** PrivateFunction: _onRequestStateChange
               *  _Private_ handler for Strophe.Request state changes.
               *
               *  This function is called when the XMLHttpRequest readyState changes.
               *  It contains a lot of error handling logic for the many ways that
               *  requests can fail, and calls the request callback when requests
               *  succeed.
               *
               *  Parameters:
               *    (Function) func - The handler for the request.
               *    (Strophe.Request) req - The request that is changing readyState.
               */


              _onRequestStateChange(func, req) {
                Strophe.debug("request id " + req.id + "." + req.sends + " state changed to " + req.xhr.readyState);

                if (req.abort) {
                  req.abort = false;
                  return;
                }

                if (req.xhr.readyState !== 4) {
                  // The request is not yet complete
                  return;
                }

                const reqStatus = Bosh._getRequestStatus(req);

                this.lastResponseHeaders = req.xhr.getAllResponseHeaders();

                if (this._conn.disconnecting && reqStatus >= 400) {
                  this._hitError(reqStatus);

                  this._callProtocolErrorHandlers(req);

                  return;
                }

                const reqIs0 = this._requests[0] === req;
                const reqIs1 = this._requests[1] === req;
                const valid_request = reqStatus > 0 && reqStatus < 500;
                const too_many_retries = req.sends > this._conn.maxRetries;

                if (valid_request || too_many_retries) {
                  // remove from internal queue
                  this._removeRequest(req);

                  Strophe.debug("request id " + req.id + " should now be removed");
                }

                if (reqStatus === 200) {
                  // request succeeded
                  // if request 1 finished, or request 0 finished and request
                  // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to
                  // restart the other - both will be in the first spot, as the
                  // completed request has been removed from the queue already
                  if (reqIs1 || reqIs0 && this._requests.length > 0 && this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                    this._restartRequest(0);
                  }

                  this._conn.nextValidRid(Number(req.rid) + 1);

                  Strophe.debug("request id " + req.id + "." + req.sends + " got 200");
                  func(req); // call handler

                  this.errors = 0;
                } else if (reqStatus === 0 || reqStatus >= 400 && reqStatus < 600 || reqStatus >= 12000) {
                  // request failed
                  Strophe.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");

                  this._hitError(reqStatus);

                  this._callProtocolErrorHandlers(req);

                  if (reqStatus >= 400 && reqStatus < 500) {
                    this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);

                    this._conn._doDisconnect();
                  }
                } else {
                  Strophe.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");
                }

                if (!valid_request && !too_many_retries) {
                  this._throttledRequestHandler();
                } else if (too_many_retries && !this._conn.connected) {
                  this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "giving-up");
                }
              }
              /** PrivateFunction: _processRequest
               *  _Private_ function to process a request in the queue.
               *
               *  This function takes requests off the queue and sends them and
               *  restarts dead requests.
               *
               *  Parameters:
               *    (Integer) i - The index of the request in the queue.
               */


              _processRequest(i) {
                let req = this._requests[i];

                const reqStatus = Bosh._getRequestStatus(req, -1); // make sure we limit the number of retries


                if (req.sends > this._conn.maxRetries) {
                  this._conn._onDisconnectTimeout();

                  return;
                }

                const time_elapsed = req.age();
                const primary_timeout = !isNaN(time_elapsed) && time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait);
                const secondary_timeout = req.dead !== null && req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait);
                const server_error = req.xhr.readyState === 4 && (reqStatus < 1 || reqStatus >= 500);

                if (primary_timeout || secondary_timeout || server_error) {
                  if (secondary_timeout) {
                    Strophe.error(`Request ${this._requests[i].id} timed out (secondary), restarting`);
                  }

                  req.abort = true;
                  req.xhr.abort(); // setting to null fails on IE6, so set to empty function

                  req.xhr.onreadystatechange = function () {};

                  this._requests[i] = new Strophe.Request(req.xmlData, req.origFunc, req.rid, req.sends);
                  req = this._requests[i];
                }

                if (req.xhr.readyState === 0) {
                  Strophe.debug("request id " + req.id + "." + req.sends + " posting");

                  try {
                    const content_type = this._conn.options.contentType || "text/xml; charset=utf-8";
                    req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);

                    if (typeof req.xhr.setRequestHeader !== 'undefined') {
                      // IE9 doesn't have setRequestHeader
                      req.xhr.setRequestHeader("Content-Type", content_type);
                    }

                    if (this._conn.options.withCredentials) {
                      req.xhr.withCredentials = true;
                    }
                  } catch (e2) {
                    Strophe.error("XHR open failed: " + e2.toString());

                    if (!this._conn.connected) {
                      this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "bad-service");
                    }

                    this._conn.disconnect();

                    return;
                  } // Fires the XHR request -- may be invoked immediately
                  // or on a gradually expanding retry window for reconnects


                  const sendFunc = () => {
                    req.date = new Date();

                    if (this._conn.options.customHeaders) {
                      const headers = this._conn.options.customHeaders;

                      for (const header in headers) {
                        if (Object.prototype.hasOwnProperty.call(headers, header)) {
                          req.xhr.setRequestHeader(header, headers[header]);
                        }
                      }
                    }

                    req.xhr.send(req.data);
                  }; // Implement progressive backoff for reconnects --
                  // First retry (send === 1) should also be instantaneous


                  if (req.sends > 1) {
                    // Using a cube of the retry number creates a nicely
                    // expanding retry window
                    const backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait), Math.pow(req.sends, 3)) * 1000;
                    setTimeout(function () {
                      // XXX: setTimeout should be called only with function expressions (23974bc1)
                      sendFunc();
                    }, backoff);
                  } else {
                    sendFunc();
                  }

                  req.sends++;

                  if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
                    if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {
                      this._conn.xmlOutput(req.xmlData.childNodes[0]);
                    } else {
                      this._conn.xmlOutput(req.xmlData);
                    }
                  }

                  if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {
                    this._conn.rawOutput(req.data);
                  }
                } else {
                  Strophe.debug("_processRequest: " + (i === 0 ? "first" : "second") + " request has readyState of " + req.xhr.readyState);
                }
              }
              /** PrivateFunction: _removeRequest
               *  _Private_ function to remove a request from the queue.
               *
               *  Parameters:
               *    (Strophe.Request) req - The request to remove.
               */


              _removeRequest(req) {
                Strophe.debug("removing request");

                for (let i = this._requests.length - 1; i >= 0; i--) {
                  if (req === this._requests[i]) {
                    this._requests.splice(i, 1);
                  }
                } // IE6 fails on setting to null, so set to empty function


                req.xhr.onreadystatechange = function () {};

                this._throttledRequestHandler();
              }
              /** PrivateFunction: _restartRequest
               *  _Private_ function to restart a request that is presumed dead.
               *
               *  Parameters:
               *    (Integer) i - The index of the request in the queue.
               */


              _restartRequest(i) {
                const req = this._requests[i];

                if (req.dead === null) {
                  req.dead = new Date();
                }

                this._processRequest(i);
              }
              /** PrivateFunction: _reqToData
               * _Private_ function to get a stanza out of a request.
               *
               * Tries to extract a stanza out of a Request Object.
               * When this fails the current connection will be disconnected.
               *
               *  Parameters:
               *    (Object) req - The Request.
               *
               *  Returns:
               *    The stanza that was passed.
               */


              _reqToData(req) {
                try {
                  return req.getResponse();
                } catch (e) {
                  if (e.message !== "parsererror") {
                    throw e;
                  }

                  this._conn.disconnect("strophe-parsererror");
                }
              }
              /** PrivateFunction: _sendTerminate
               *  _Private_ function to send initial disconnect sequence.
               *
               *  This is the first step in a graceful disconnect.  It sends
               *  the BOSH server a terminate body and includes an unavailable
               *  presence if authentication has completed.
               */


              _sendTerminate(pres) {
                Strophe.debug("_sendTerminate was called");

                const body = this._buildBody().attrs({
                  type: "terminate"
                });

                if (pres) {
                  body.cnode(pres.tree());
                }

                const req = new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute("rid"));

                this._requests.push(req);

                this._throttledRequestHandler();
              }
              /** PrivateFunction: _send
               *  _Private_ part of the Connection.send function for BOSH
               *
               * Just triggers the RequestHandler to send the messages that are in the queue
               */


              _send() {
                clearTimeout(this._conn._idleTimeout);

                this._throttledRequestHandler();

                this._conn._idleTimeout = setTimeout(() => this._conn._onIdle(), 100);
              }
              /** PrivateFunction: _sendRestart
               *
               *  Send an xmpp:restart stanza.
               */


              _sendRestart() {
                this._throttledRequestHandler();

                clearTimeout(this._conn._idleTimeout);
              }
              /** PrivateFunction: _throttledRequestHandler
               *  _Private_ function to throttle requests to the connection window.
               *
               *  This function makes sure we don't send requests so fast that the
               *  request ids overflow the connection window in the case that one
               *  request died.
               */


              _throttledRequestHandler() {
                if (!this._requests) {
                  Strophe.debug("_throttledRequestHandler called with " + "undefined requests");
                } else {
                  Strophe.debug("_throttledRequestHandler called with " + this._requests.length + " requests");
                }

                if (!this._requests || this._requests.length === 0) {
                  return;
                }

                if (this._requests.length > 0) {
                  this._processRequest(0);
                }

                if (this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window) {
                  this._processRequest(1);
                }
              }

            };
            /** Variable: strip
             *
             *  BOSH-Connections will have all stanzas wrapped in a <body> tag when
             *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.
             *  To strip this tag, User code can set <Strophe.Bosh.strip> to "body":
             *
             *  > Strophe.Bosh.prototype.strip = "body";
             *
             *  This will enable stripping of the body tag in both
             *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.
             */

            Strophe.Bosh.prototype.strip = null;

            /*
                This program is distributed under the terms of the MIT license.
                Please see the LICENSE file for details.

                Copyright 2006-2008, OGG, LLC
            */
            /** Class: Strophe.WebSocket
             *  _Private_ helper class that handles WebSocket Connections
             *
             *  The Strophe.WebSocket class is used internally by Strophe.Connection
             *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.
             */

            /** File: websocket.js
             *  A JavaScript library to enable XMPP over Websocket in Strophejs.
             *
             *  This file implements XMPP over WebSockets for Strophejs.
             *  If a Connection is established with a Websocket url (ws://...)
             *  Strophe will use WebSockets.
             *  For more information on XMPP-over-WebSocket see RFC 7395:
             *  http://tools.ietf.org/html/rfc7395
             *
             *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)
             */

            Strophe.Websocket = class Websocket {
              /** PrivateConstructor: Strophe.Websocket
               *  Create and initialize a Strophe.WebSocket object.
               *  Currently only sets the connection Object.
               *
               *  Parameters:
               *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.
               *
               *  Returns:
               *    A new Strophe.WebSocket object.
               */
              constructor(connection) {
                this._conn = connection;
                this.strip = "wrapper";
                const service = connection.service;

                if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
                  // If the service is not an absolute URL, assume it is a path and put the absolute
                  // URL together from options, current URL and the path.
                  let new_service = "";

                  if (connection.options.protocol === "ws" && window.location.protocol !== "https:") {
                    new_service += "ws";
                  } else {
                    new_service += "wss";
                  }

                  new_service += "://" + window.location.host;

                  if (service.indexOf("/") !== 0) {
                    new_service += window.location.pathname + service;
                  } else {
                    new_service += service;
                  }

                  connection.service = new_service;
                }
              }
              /** PrivateFunction: _buildStream
               *  _Private_ helper function to generate the <stream> start tag for WebSockets
               *
               *  Returns:
               *    A Strophe.Builder with a <stream> element.
               */


              _buildStream() {
                return $build("open", {
                  "xmlns": Strophe.NS.FRAMING,
                  "to": this._conn.domain,
                  "version": '1.0'
                });
              }
              /** PrivateFunction: _checkStreamError
               * _Private_ checks a message for stream:error
               *
               *  Parameters:
               *    (Strophe.Request) bodyWrap - The received stanza.
               *    connectstatus - The ConnectStatus that will be set on error.
               *  Returns:
               *     true if there was a streamerror, false otherwise.
               */


              _checkStreamError(bodyWrap, connectstatus) {
                let errors;

                if (bodyWrap.getElementsByTagNameNS) {
                  errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "error");
                } else {
                  errors = bodyWrap.getElementsByTagName("stream:error");
                }

                if (errors.length === 0) {
                  return false;
                }

                const error = errors[0];
                let condition = "";
                let text = "";
                const ns = "urn:ietf:params:xml:ns:xmpp-streams";

                for (let i = 0; i < error.childNodes.length; i++) {
                  const e = error.childNodes[i];

                  if (e.getAttribute("xmlns") !== ns) {
                    break;
                  }

                  if (e.nodeName === "text") {
                    text = e.textContent;
                  } else {
                    condition = e.nodeName;
                  }
                }

                let errorString = "WebSocket stream error: ";

                if (condition) {
                  errorString += condition;
                } else {
                  errorString += "unknown";
                }

                if (text) {
                  errorString += " - " + text;
                }

                Strophe.error(errorString); // close the connection on stream_error

                this._conn._changeConnectStatus(connectstatus, condition);

                this._conn._doDisconnect();

                return true;
              }
              /** PrivateFunction: _reset
               *  Reset the connection.
               *
               *  This function is called by the reset function of the Strophe Connection.
               *  Is not needed by WebSockets.
               */


              _reset() {
                // eslint-disable-line class-methods-use-this
                return;
              }
              /** PrivateFunction: _connect
               *  _Private_ function called by Strophe.Connection.connect
               *
               *  Creates a WebSocket for a connection and assigns Callbacks to it.
               *  Does nothing if there already is a WebSocket.
               */


              _connect() {
                // Ensure that there is no open WebSocket from a previous Connection.
                this._closeSocket();

                this.socket = new WebSocket(this._conn.service, "xmpp");

                this.socket.onopen = () => this._onOpen();

                this.socket.onerror = e => this._onError(e);

                this.socket.onclose = e => this._onClose(e); // Gets replaced with this._onMessage once _onInitialMessage is called


                this.socket.onmessage = message => this._onInitialMessage(message);
              }
              /** PrivateFunction: _connect_cb
               *  _Private_ function called by Strophe.Connection._connect_cb
               *
               * checks for stream:error
               *
               *  Parameters:
               *    (Strophe.Request) bodyWrap - The received stanza.
               */


              _connect_cb(bodyWrap) {
                const error = this._checkStreamError(bodyWrap, Strophe.Status.CONNFAIL);

                if (error) {
                  return Strophe.Status.CONNFAIL;
                }
              }
              /** PrivateFunction: _handleStreamStart
               * _Private_ function that checks the opening <open /> tag for errors.
               *
               * Disconnects if there is an error and returns false, true otherwise.
               *
               *  Parameters:
               *    (Node) message - Stanza containing the <open /> tag.
               */


              _handleStreamStart(message) {
                let error = false; // Check for errors in the <open /> tag

                const ns = message.getAttribute("xmlns");

                if (typeof ns !== "string") {
                  error = "Missing xmlns in <open />";
                } else if (ns !== Strophe.NS.FRAMING) {
                  error = "Wrong xmlns in <open />: " + ns;
                }

                const ver = message.getAttribute("version");

                if (typeof ver !== "string") {
                  error = "Missing version in <open />";
                } else if (ver !== "1.0") {
                  error = "Wrong version in <open />: " + ver;
                }

                if (error) {
                  this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);

                  this._conn._doDisconnect();

                  return false;
                }

                return true;
              }
              /** PrivateFunction: _onInitialMessage
               * _Private_ function that handles the first connection messages.
               *
               * On receiving an opening stream tag this callback replaces itself with the real
               * message handler. On receiving a stream error the connection is terminated.
               */


              _onInitialMessage(message) {
                if (message.data.indexOf("<open ") === 0 || message.data.indexOf("<?xml") === 0) {
                  // Strip the XML Declaration, if there is one
                  const data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
                  if (data === '') return;
                  const streamStart = new DOMParser().parseFromString(data, "text/xml").documentElement;

                  this._conn.xmlInput(streamStart);

                  this._conn.rawInput(message.data); //_handleStreamSteart will check for XML errors and disconnect on error


                  if (this._handleStreamStart(streamStart)) {
                    //_connect_cb will check for stream:error and disconnect on error
                    this._connect_cb(streamStart);
                  }
                } else if (message.data.indexOf("<close ") === 0) {
                  // <close xmlns="urn:ietf:params:xml:ns:xmpp-framing />
                  // Parse the raw string to an XML element
                  const parsedMessage = new DOMParser().parseFromString(message.data, "text/xml").documentElement; // Report this input to the raw and xml handlers

                  this._conn.xmlInput(parsedMessage);

                  this._conn.rawInput(message.data);

                  const see_uri = parsedMessage.getAttribute("see-other-uri");

                  if (see_uri) {
                    const service = this._conn.service; // Valid scenarios: WSS->WSS, WS->ANY

                    const isSecureRedirect = service.indexOf("wss:") >= 0 && see_uri.indexOf("wss:") >= 0 || service.indexOf("ws:") >= 0;

                    if (isSecureRedirect) {
                      this._conn._changeConnectStatus(Strophe.Status.REDIRECT, "Received see-other-uri, resetting connection");

                      this._conn.reset();

                      this._conn.service = see_uri;

                      this._connect();
                    }
                  } else {
                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Received closing stream");

                    this._conn._doDisconnect();
                  }
                } else {
                  this._replaceMessageHandler();

                  const string = this._streamWrap(message.data);

                  const elem = new DOMParser().parseFromString(string, "text/xml").documentElement;

                  this._conn._connect_cb(elem, null, message.data);
                }
              }
              /** PrivateFunction: _replaceMessageHandler
               *
               * Called by _onInitialMessage in order to replace itself with the general message handler.
               * This method is overridden by Strophe.WorkerWebsocket, which manages a
               * websocket connection via a service worker and doesn't have direct access
               * to the socket.
               */


              _replaceMessageHandler() {
                this.socket.onmessage = m => this._onMessage(m);
              }
              /** PrivateFunction: _disconnect
               *  _Private_ function called by Strophe.Connection.disconnect
               *
               *  Disconnects and sends a last stanza if one is given
               *
               *  Parameters:
               *    (Request) pres - This stanza will be sent before disconnecting.
               */


              _disconnect(pres) {
                if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
                  if (pres) {
                    this._conn.send(pres);
                  }

                  const close = $build("close", {
                    "xmlns": Strophe.NS.FRAMING
                  });

                  this._conn.xmlOutput(close.tree());

                  const closeString = Strophe.serialize(close);

                  this._conn.rawOutput(closeString);

                  try {
                    this.socket.send(closeString);
                  } catch (e) {
                    Strophe.warn("Couldn't send <close /> tag.");
                  }
                }

                setTimeout(() => this._conn._doDisconnect(), 0);
              }
              /** PrivateFunction: _doDisconnect
               *  _Private_ function to disconnect.
               *
               *  Just closes the Socket for WebSockets
               */


              _doDisconnect() {
                Strophe.debug("WebSockets _doDisconnect was called");

                this._closeSocket();
              }
              /** PrivateFunction _streamWrap
               *  _Private_ helper function to wrap a stanza in a <stream> tag.
               *  This is used so Strophe can process stanzas from WebSockets like BOSH
               */


              _streamWrap(stanza) {
                // eslint-disable-line class-methods-use-this
                return "<wrapper>" + stanza + '</wrapper>';
              }
              /** PrivateFunction: _closeSocket
               *  _Private_ function to close the WebSocket.
               *
               *  Closes the socket if it is still open and deletes it
               */


              _closeSocket() {
                if (this.socket) {
                  try {
                    this.socket.onclose = null;
                    this.socket.onerror = null;
                    this.socket.onmessage = null;
                    this.socket.close();
                  } catch (e) {
                    Strophe.debug(e.message);
                  }
                }

                this.socket = null;
              }
              /** PrivateFunction: _emptyQueue
               * _Private_ function to check if the message queue is empty.
               *
               *  Returns:
               *    True, because WebSocket messages are send immediately after queueing.
               */


              _emptyQueue() {
                // eslint-disable-line class-methods-use-this
                return true;
              }
              /** PrivateFunction: _onClose
               * _Private_ function to handle websockets closing.
               */


              _onClose(e) {
                if (this._conn.connected && !this._conn.disconnecting) {
                  Strophe.error("Websocket closed unexpectedly");

                  this._conn._doDisconnect();
                } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {
                  // in case the onError callback was not called (Safari 10 does not
                  // call onerror when the initial connection fails) we need to
                  // dispatch a CONNFAIL status update to be consistent with the
                  // behavior on other browsers.
                  Strophe.error("Websocket closed unexcectedly");

                  this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected.");

                  this._conn._doDisconnect();
                } else {
                  Strophe.debug("Websocket closed");
                }
              }
              /** PrivateFunction: _no_auth_received
               *
               * Called on stream start/restart when no stream:features
               * has been received.
               */


              _no_auth_received(callback) {
                Strophe.error("Server did not offer a supported authentication mechanism");

                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, Strophe.ErrorCondition.NO_AUTH_MECH);

                if (callback) {
                  callback.call(this._conn);
                }

                this._conn._doDisconnect();
              }
              /** PrivateFunction: _onDisconnectTimeout
               *  _Private_ timeout handler for handling non-graceful disconnection.
               *
               *  This does nothing for WebSockets
               */


              _onDisconnectTimeout() {} // eslint-disable-line class-methods-use-this

              /** PrivateFunction: _abortAllRequests
               *  _Private_ helper function that makes sure all pending requests are aborted.
               */


              _abortAllRequests() {} // eslint-disable-line class-methods-use-this

              /** PrivateFunction: _onError
               * _Private_ function to handle websockets errors.
               *
               * Parameters:
               * (Object) error - The websocket error.
               */


              _onError(error) {
                Strophe.error("Websocket error " + JSON.stringify(error));

                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected.");

                this._disconnect();
              }
              /** PrivateFunction: _onIdle
               *  _Private_ function called by Strophe.Connection._onIdle
               *
               *  sends all queued stanzas
               */


              _onIdle() {
                const data = this._conn._data;

                if (data.length > 0 && !this._conn.paused) {
                  for (let i = 0; i < data.length; i++) {
                    if (data[i] !== null) {
                      let stanza;

                      if (data[i] === "restart") {
                        stanza = this._buildStream().tree();
                      } else {
                        stanza = data[i];
                      }

                      const rawStanza = Strophe.serialize(stanza);

                      this._conn.xmlOutput(stanza);

                      this._conn.rawOutput(rawStanza);

                      this.socket.send(rawStanza);
                    }
                  }

                  this._conn._data = [];
                }
              }
              /** PrivateFunction: _onMessage
               * _Private_ function to handle websockets messages.
               *
               * This function parses each of the messages as if they are full documents.
               * [TODO : We may actually want to use a SAX Push parser].
               *
               * Since all XMPP traffic starts with
               *  <stream:stream version='1.0'
               *                 xml:lang='en'
               *                 xmlns='jabber:client'
               *                 xmlns:stream='http://etherx.jabber.org/streams'
               *                 id='3697395463'
               *                 from='SERVER'>
               *
               * The first stanza will always fail to be parsed.
               *
               * Additionally, the seconds stanza will always be <stream:features> with
               * the stream NS defined in the previous stanza, so we need to 'force'
               * the inclusion of the NS in this stanza.
               *
               * Parameters:
               * (string) message - The websocket message.
               */


              _onMessage(message) {
                let elem; // check for closing stream

                const close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';

                if (message.data === close) {
                  this._conn.rawInput(close);

                  this._conn.xmlInput(message);

                  if (!this._conn.disconnecting) {
                    this._conn._doDisconnect();
                  }

                  return;
                } else if (message.data.search("<open ") === 0) {
                  // This handles stream restarts
                  elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement;

                  if (!this._handleStreamStart(elem)) {
                    return;
                  }
                } else {
                  const data = this._streamWrap(message.data);

                  elem = new DOMParser().parseFromString(data, "text/xml").documentElement;
                }

                if (this._checkStreamError(elem, Strophe.Status.ERROR)) {
                  return;
                } //handle unavailable presence stanza before disconnecting


                if (this._conn.disconnecting && elem.firstChild.nodeName === "presence" && elem.firstChild.getAttribute("type") === "unavailable") {
                  this._conn.xmlInput(elem);

                  this._conn.rawInput(Strophe.serialize(elem)); // if we are already disconnecting we will ignore the unavailable stanza and
                  // wait for the </stream:stream> tag before we close the connection


                  return;
                }

                this._conn._dataRecv(elem, message.data);
              }
              /** PrivateFunction: _onOpen
               * _Private_ function to handle websockets connection setup.
               *
               * The opening stream tag is sent here.
               */


              _onOpen() {
                Strophe.debug("Websocket open");

                const start = this._buildStream();

                this._conn.xmlOutput(start.tree());

                const startString = Strophe.serialize(start);

                this._conn.rawOutput(startString);

                this.socket.send(startString);
              }
              /** PrivateFunction: _reqToData
               * _Private_ function to get a stanza out of a request.
               *
               * WebSockets don't use requests, so the passed argument is just returned.
               *
               *  Parameters:
               *    (Object) stanza - The stanza.
               *
               *  Returns:
               *    The stanza that was passed.
               */


              _reqToData(stanza) {
                // eslint-disable-line class-methods-use-this
                return stanza;
              }
              /** PrivateFunction: _send
               *  _Private_ part of the Connection.send function for WebSocket
               *
               * Just flushes the messages that are in the queue
               */


              _send() {
                this._conn.flush();
              }
              /** PrivateFunction: _sendRestart
               *
               *  Send an xmpp:restart stanza.
               */


              _sendRestart() {
                clearTimeout(this._conn._idleTimeout);

                this._conn._onIdle.bind(this._conn)();
              }

            };

            /*
                This program is distributed under the terms of the MIT license.
                Please see the LICENSE file for details.

                Copyright 2020, JC Brand
            */
            const lmap = {};
            lmap['debug'] = Strophe.LogLevel.DEBUG;
            lmap['info'] = Strophe.LogLevel.INFO;
            lmap['warn'] = Strophe.LogLevel.WARN;
            lmap['error'] = Strophe.LogLevel.ERROR;
            lmap['fatal'] = Strophe.LogLevel.FATAL;
            /** Class: Strophe.WorkerWebsocket
             *  _Private_ helper class that handles a websocket connection inside a shared worker.
             */

            Strophe.WorkerWebsocket = class WorkerWebsocket extends Strophe.Websocket {
              /** PrivateConstructor: Strophe.WorkerWebsocket
               *  Create and initialize a Strophe.WorkerWebsocket object.
               *
               *  Parameters:
               *    (Strophe.Connection) connection - The Strophe.Connection
               *
               *  Returns:
               *    A new Strophe.WorkerWebsocket object.
               */
              constructor(connection) {
                super(connection);
                this._conn = connection;
                this.worker = new SharedWorker(this._conn.options.worker, 'Strophe XMPP Connection');

                this.worker.onerror = e => {
                  var _console;

                  (_console = console) === null || _console === void 0 ? void 0 : _console.error(e);
                  Strophe.log(Strophe.LogLevel.ERROR, `Shared Worker Error: ${e}`);
                };
              }

              get socket() {
                return {
                  'send': str => this.worker.port.postMessage(['send', str])
                };
              }

              _connect() {
                this._messageHandler = m => this._onInitialMessage(m);

                this.worker.port.start();

                this.worker.port.onmessage = ev => this._onWorkerMessage(ev);

                this.worker.port.postMessage(['_connect', this._conn.service, this._conn.jid]);
              }

              _attach(callback) {
                this._messageHandler = m => this._onMessage(m);

                this._conn.connect_callback = callback;
                this.worker.port.start();

                this.worker.port.onmessage = ev => this._onWorkerMessage(ev);

                this.worker.port.postMessage(['_attach', this._conn.service]);
              }

              _attachCallback(status, jid) {
                if (status === Strophe.Status.ATTACHED) {
                  this._conn.jid = jid;
                  this._conn.authenticated = true;
                  this._conn.connected = true;
                  this._conn.restored = true;

                  this._conn._changeConnectStatus(Strophe.Status.ATTACHED);
                } else if (status === Strophe.Status.ATTACHFAIL) {
                  this._conn.authenticated = false;
                  this._conn.connected = false;
                  this._conn.restored = false;

                  this._conn._changeConnectStatus(Strophe.Status.ATTACHFAIL);
                }
              }

              _disconnect(readyState, pres) {
                pres && this._conn.send(pres);
                const close = $build("close", {
                  "xmlns": Strophe.NS.FRAMING
                });

                this._conn.xmlOutput(close.tree());

                const closeString = Strophe.serialize(close);

                this._conn.rawOutput(closeString);

                this.worker.port.postMessage(['send', closeString]);

                this._conn._doDisconnect();
              }

              _onClose(e) {
                if (this._conn.connected && !this._conn.disconnecting) {
                  Strophe.error("Websocket closed unexpectedly");

                  this._conn._doDisconnect();
                } else if (e && e.code === 1006 && !this._conn.connected) {
                  // in case the onError callback was not called (Safari 10 does not
                  // call onerror when the initial connection fails) we need to
                  // dispatch a CONNFAIL status update to be consistent with the
                  // behavior on other browsers.
                  Strophe.error("Websocket closed unexcectedly");

                  this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected.");

                  this._conn._doDisconnect();
                } else {
                  Strophe.debug("Websocket closed");
                }
              }

              _closeSocket() {
                this.worker.port.postMessage(['_closeSocket']);
              }
              /** PrivateFunction: _replaceMessageHandler
               *
               * Called by _onInitialMessage in order to replace itself with the general message handler.
               * This method is overridden by Strophe.WorkerWebsocket, which manages a
               * websocket connection via a service worker and doesn't have direct access
               * to the socket.
               */


              _replaceMessageHandler() {
                this._messageHandler = m => this._onMessage(m);
              }
              /** PrivateFunction: _onWorkerMessage
               * _Private_ function that handles messages received from the service worker
               */


              _onWorkerMessage(ev) {
                const {
                  data
                } = ev;
                const method_name = data[0];

                if (method_name === '_onMessage') {
                  this._messageHandler(data[1]);
                } else if (method_name in this) {
                  try {
                    this[method_name].apply(this, ev.data.slice(1));
                  } catch (e) {
                    Strophe.log(Strophe.LogLevel.ERROR, e);
                  }
                } else if (method_name === 'log') {
                  const level = data[1];
                  const msg = data[2];
                  Strophe.log(lmap[level], msg);
                } else {
                  Strophe.log(Strophe.LogLevel.ERROR, `Found unhandled service worker message: ${data}`);
                }
              }

            };

            global$1.$build = core.$build;
            global$1.$iq = core.$iq;
            global$1.$msg = core.$msg;
            global$1.$pres = core.$pres;
            global$1.Strophe = core.Strophe;
            const {
              b64_sha1
            } = SHA1;

            exports.$build = $build;
            exports.$iq = $iq;
            exports.$msg = $msg;
            exports.$pres = $pres;
            exports.Strophe = Strophe;
            exports.b64_sha1 = b64_sha1;

            Object.defineProperty(exports, '__esModule', { value: true });

}));


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/strophejs-plugin-disco/lib/strophe.disco.js":
/*!*************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/strophejs-plugin-disco/lib/strophe.disco.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(__webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js")) :
	0;
}(this, (function (strophe_js) { 'use strict';

strophe_js.Strophe.addConnectionPlugin('disco',
{
    _connection: null,
    _identities : [],
    _features : [],
    _items : [],
    /** Function: init
     * Plugin init
     *
     * Parameters:
     *   (Strophe.Connection) conn - Strophe connection
     */
    init: function(conn)
    {
    this._connection = conn;
        this._identities = [];
        this._features   = [];
        this._items      = [];
        // disco info
        conn.addHandler(this._onDiscoInfo.bind(this), strophe_js.Strophe.NS.DISCO_INFO, 'iq', 'get', null, null);
        // disco items
        conn.addHandler(this._onDiscoItems.bind(this), strophe_js.Strophe.NS.DISCO_ITEMS, 'iq', 'get', null, null);
    },
    /** Function: addIdentity
     * See http://xmpp.org/registrar/disco-categories.html
     * Parameters:
     *   (String) category - category of identity (like client, automation, etc ...)
     *   (String) type - type of identity (like pc, web, bot , etc ...)
     *   (String) name - name of identity in natural language
     *   (String) lang - lang of name parameter
     *
     * Returns:
     *   Boolean
     */
    addIdentity: function(category, type, name, lang)
    {
        for (var i=0; i<this._identities.length; i++)
        {
            if (this._identities[i].category == category &&
                this._identities[i].type == type &&
                this._identities[i].name == name &&
                this._identities[i].lang == lang)
            {
                return false;
            }
        }
        this._identities.push({category: category, type: type, name: name, lang: lang});
        return true;
    },
    /** Function: addFeature
     *
     * Parameters:
     *   (String) var_name - feature name (like jabber:iq:version)
     *
     * Returns:
     *   boolean
     */
    addFeature: function(var_name)
    {
        for (var i=0; i<this._features.length; i++)
        {
             if (this._features[i] == var_name)
                 return false;
        }
        this._features.push(var_name);
        return true;
    },
    /** Function: removeFeature
     *
     * Parameters:
     *   (String) var_name - feature name (like jabber:iq:version)
     *
     * Returns:
     *   boolean
     */
    removeFeature: function(var_name)
    {
        for (var i=0; i<this._features.length; i++)
        {
             if (this._features[i] === var_name){
                 this._features.splice(i,1);
                 return true;
             }
        }
        return false;
    },
    /** Function: addItem
     *
     * Parameters:
     *   (String) jid
     *   (String) name
     *   (String) node
     *   (Function) call_back
     *
     * Returns:
     *   boolean
     */
    addItem: function(jid, name, node, call_back)
    {
        if (node && !call_back)
            return false;
        this._items.push({jid: jid, name: name, node: node, call_back: call_back});
        return true;
    },
    /** Function: info
     * Info query
     *
     * Parameters:
     *   (Function) call_back
     *   (String) jid
     *   (String) node
     */
    info: function(jid, node, success, error, timeout)
    {
        var attrs = {xmlns: strophe_js.Strophe.NS.DISCO_INFO};
        if (node)
            attrs.node = node;

        var info = strophe_js.$iq({from:this._connection.jid,
                         to:jid, type:'get'}).c('query', attrs);
        this._connection.sendIQ(info, success, error, timeout);
    },
    /** Function: items
     * Items query
     *
     * Parameters:
     *   (Function) call_back
     *   (String) jid
     *   (String) node
     */
    items: function(jid, node, success, error, timeout)
    {
        var attrs = {xmlns: strophe_js.Strophe.NS.DISCO_ITEMS};
        if (node)
            attrs.node = node;

        var items = strophe_js.$iq({from:this._connection.jid,
                         to:jid, type:'get'}).c('query', attrs);
        this._connection.sendIQ(items, success, error, timeout);
    },

    /** PrivateFunction: _buildIQResult
     */
    _buildIQResult: function(stanza, query_attrs)
    {
        var id   =  stanza.getAttribute('id');
        var from = stanza.getAttribute('from');
        var iqresult = strophe_js.$iq({type: 'result', id: id});

        if (from !== null) {
            iqresult.attrs({to: from});
        }

        return iqresult.c('query', query_attrs);
    },

    /** PrivateFunction: _onDiscoInfo
     * Called when receive info request
     */
    _onDiscoInfo: function(stanza)
    {
        var node = stanza.getElementsByTagName('query')[0].getAttribute('node');
        var attrs = {xmlns: strophe_js.Strophe.NS.DISCO_INFO};
        var i;
        if (node)
        {
            attrs.node = node;
        }
        var iqresult = this._buildIQResult(stanza, attrs);
        for (i=0; i<this._identities.length; i++)
        {
            attrs = {category: this._identities[i].category,
                         type    : this._identities[i].type};
            if (this._identities[i].name)
                attrs.name = this._identities[i].name;
            if (this._identities[i].lang)
                attrs['xml:lang'] = this._identities[i].lang;
            iqresult.c('identity', attrs).up();
        }
        for (i=0; i<this._features.length; i++)
        {
            iqresult.c('feature', {'var':this._features[i]}).up();
        }
        this._connection.send(iqresult.tree());
        return true;
    },
    /** PrivateFunction: _onDiscoItems
     * Called when receive items request
     */
    _onDiscoItems: function(stanza)
    {
        var query_attrs = {xmlns: strophe_js.Strophe.NS.DISCO_ITEMS};
        var node = stanza.getElementsByTagName('query')[0].getAttribute('node');
        var items, i;
        if (node)
        {
            query_attrs.node = node;
            items = [];
            for (i = 0; i < this._items.length; i++)
            {
                if (this._items[i].node == node)
                {
                    items = this._items[i].call_back(stanza);
                    break;
                }
            }
        }
        else
        {
            items = this._items;
        }
        var iqresult = this._buildIQResult(stanza, query_attrs);
        for (i = 0; i < items.length; i++)
        {
            var attrs = {jid:  items[i].jid};
            if (items[i].name)
                attrs.name = items[i].name;
            if (items[i].node)
                attrs.node = items[i].node;
            iqresult.c('item', attrs).up();
        }
        this._connection.send(iqresult.tree());
        return true;
    }
});

})));
//# sourceMappingURL=strophe.disco.js.map


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/strophejs-plugin-stream-management/lib/strophe.stream-management.js":
/*!*************************************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/strophejs-plugin-stream-management/lib/strophe.stream-management.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(__webpack_require__(/*! strophe.js */ "../../lib-jitsi-meet/node_modules/strophe.js/dist/strophe.umd.js")) :
	0;
})(this, (function (strophe_js) { 'use strict';

	/**
	* StropheJS - Stream Management XEP-0198
	*
	* This plugin implements stream management ACK capabilities of the specs XEP-0198.
	* Note: Resumption is not supported in this current implementation.
	*
	* Reference: http://xmpp.org/extensions/xep-0198.html
	*
	* @class streamManagement
	*/
	strophe_js.Strophe.addConnectionPlugin('streamManagement', {

		/**
		* @property {Boolean} logging: Set to true to enable logging regarding out of sync stanzas.
		*/
		logging: false,

		/**
		* @property {Boolean} autoSendCountOnEveryIncomingStanza: Set to true to send an 'a' response after every stanza.
		* @default false
		* @public
		*/
		autoSendCountOnEveryIncomingStanza: false,

		/**
		* @property {Integer} requestResponseInterval: Set this value to send a request for counter on very interval
		* number of stanzas sent. Set to 0 to disable.
		* @default 5
		* @public
		*/
		requestResponseInterval: 5,

		/**
		* @property {Pointer} _c: Strophe connection instance.
		* @private
		*/
		_c: null,

		/**
		* @property {String} _NS XMPP Namespace.
		* @private
		*/
		_NS: 'urn:xmpp:sm:3',

		/**
		* @property {Boolean} _isStreamManagementEnabled
		* @private
		*/
		_isStreamManagementEnabled: false,

		/**
		* @property {Integer} _serverProcesssedStanzasCounter: Keeps count of stanzas confirmed processed by the server.
		* The server is the source of truth of this value. It is the 'h' attribute on the latest 'a' element received
		* from the server.
		* @private
		*/
		_serverProcesssedStanzasCounter: null,

		/**
		* @property {Integer} _clientProcessedStanzasCounter: Counter of stanzas received by the client from the server.
		* Client is the source of truth of this value. It is the 'h' attribute in the 'a' sent from the client to
		* the server.
		* @private
		*/
		_clientProcessedStanzasCounter: null,

		/**
		* @property {Integer} _clientSentStanzasCounter
		* @private
		*/
		_clientSentStanzasCounter: null,

		/**
		* Stores a reference to Strophe connection xmlOutput function to wrap counting functionality.
		* @method _originalXMLOutput
		* @type {Handler}
		* @private
		*/
		_originalXMLOutput: null,

		/**
		* @property {Handler} _requestHandler: Stores reference to handler that process count request from server.
		* @private
		*/
		_requestHandler: null,

		/**
		* @property {Handler} _incomingHandler: Stores reference to handler that processes incoming stanzas count.
		* @private
		*/
		_incomingHandler: null,

		/**
		* @property {Integer} _requestResponseIntervalCount: Counts sent stanzas since last response request.
		*/
		_requestResponseIntervalCount: 0,

		/**
		 * @property {boolean} _isSupported: indicates whether or not the server has advertised support for the stream
		 * management namespace.
		 */
		_isSupported: false,

		/**
		* @property {Queue} _unacknowledgedStanzas: Maintains a list of packet ids for stanzas which have yet to be acknowledged.
		*/
		_unacknowledgedStanzas: [],

		/**
		* @property {Array} _acknowledgedStanzaListeners: Stores callbacks for each stanza acknowledged by the server.
		* Provides the packet id of the stanza as a parameter.
		* @private
		*/
		_acknowledgedStanzaListeners: [],

		addAcknowledgedStanzaListener: function(listener) {
			this._acknowledgedStanzaListeners.push(listener);
		},

		enable: function(resume) {
			if (!this._isSupported) {
				throw new Error('The server doesn\'t support urn:xmpp:sm:3 namespace');
			} else if (this._connectionStatus !== strophe_js.Strophe.Status.CONNECTED) {
				throw new Error('enable() can only be called in the CONNECTED state');
			}
			this._c.send(strophe_js.$build('enable', { xmlns: this._NS, resume }));
			this._c.flush();
			this._c.pause();
		},

		getResumeToken: function() {
			return this._resumeToken;
		},

		isSupported() {
			return this._isSupported;
		},

		resume: function() {
			if (!this.getResumeToken()) {
				throw new Error('No resume token');
			}
			if (this._connectionStatus !== strophe_js.Strophe.Status.DISCONNECTED) {
				throw new Error('resume() can only be called in the DISCONNECTED state');
			}

			this._c.options.explicitResourceBinding = true;
			this._resuming = true;

			this._originalConnect.apply(this._c, this._connectArgs);
		},

		requestAcknowledgement: function() {
			if (this._connectionStatus !== strophe_js.Strophe.Status.CONNECTED) {
				throw new Error('requestAcknowledgement() can only be called in the CONNECTED state');
			}
			this._requestResponseIntervalCount = 0;
			this._c.send(strophe_js.$build('r', { xmlns: this._NS }));
		},

		getOutgoingCounter: function() {
			return this._clientSentStanzasCounter;
		},

		getIncomingCounter: function() {
			return this._clientProcessedStanzasCounter;
		},

		init: function(conn) {
			this._c = conn;
			strophe_js.Strophe.addNamespace('SM', this._NS);

			// Storing original xmlOutput function to use additional logic
			this._originalXMLOutput = this._c.xmlOutput;
			this._c.xmlOutput = this.xmlOutput.bind(this);

			this._originalConnect = this._c.connect;
			this._c.connect = this._interceptConnectArgs.bind(this);

			this._originalOnStreamFeaturesAfterSASL = this._c._onStreamFeaturesAfterSASL;
			this._c._onStreamFeaturesAfterSASL = this._onStreamFeaturesAfterSASL.bind(this);

			this._originalDoDisconnect = this._c._doDisconnect;
			this._c._doDisconnect = this._interceptDoDisconnect.bind(this);

			this._originalDisconnect = this._c.disconnect;
			this._c.disconnect = this._interceptDisconnect.bind(this);
		},

		_interceptDisconnect: function() {
			this._resumeToken = undefined;
			this._originalDisconnect.apply(this._c, arguments);
		},

		_interceptDoDisconnect: function() {
			if (this.getResumeToken()
					&& !this._resuming
					&& this._c.connected && !this._c.disconnecting) {
				this._resumeState = {
					handlers: this._c.handlers,
					timedHandlers: this._c.timedHandlers,
					removeTimeds: this._c.removeTimeds,
					removeHandlers: this._c.removeHandlers,
					addTimeds: this._c.addTimeds,
					addHandlers: this._c.addHandlers
				};
				this._storedJid = this._c.jid;

				this.logging && strophe_js.Strophe.debug('SM stored resume state, handler count: ' + this._resumeState.handlers.length);
			}

			// Remove any queued stanzas from the buffer that have failed to send while the socket was closed,
			// as they would interfere with the resume flow. They will be resent anyway.
			this._c._data = [];

			this._originalDoDisconnect.apply(this._c, arguments);
		},

		_interceptConnectArgs: function() {
			this._connectArgs = arguments;

			this._originalConnect.apply(this._c, arguments);
		},

		_onStreamFeaturesAfterSASL: function(elem) {
			this._isSupported = elem.getElementsByTagNameNS(this._NS, "sm").length > 0;

			return this._originalOnStreamFeaturesAfterSASL.apply(this._c, arguments);
		},

		statusChanged: function (status) {
			this._connectionStatus = status;
			if (!this.getResumeToken()
				&& (status === strophe_js.Strophe.Status.CONNECTED || status === strophe_js.Strophe.Status.DISCONNECTED)) {
				this.logging && strophe_js.Strophe.debug('SM reset state');

				this._serverProcesssedStanzasCounter = 0;
				this._clientProcessedStanzasCounter = 0;

				this._clientSentStanzasCounter = 0;

				this._isStreamManagementEnabled = false;
				this._requestResponseIntervalCount = 0;

				// FIXME not described in JSDocs
				this._resuming = false;

				if (status === strophe_js.Strophe.Status.DISCONNECTED) {
					this._isSupported = false;
				}

				this._unacknowledgedStanzas = [];

				if (this._requestHandler) {
					this._c.deleteHandler(this._requestHandler);
				}

				if (this._incomingHandler) {
					this._c.deleteHandler(this._incomingHandler);
				}

				this._requestHandler = this._c.addHandler(this._handleServerRequestHandler.bind(this), this._NS, 'r');
				this._ackHandler = this._c.addHandler(this._handleServerAck.bind(this), this._NS, 'a');
				this._incomingHandler = this._c.addHandler(this._incomingStanzaHandler.bind(this));

				// FIXME handler instances stored, but never used
				this._enabledHandler = this._c._addSysHandler(this._handleEnabled.bind(this), this._NS, 'enabled');
				this._resumeFailedHandler = this._c._addSysHandler(this._handleResumeFailed.bind(this), this._NS, 'failed');
				this._resumedHandler =  this._c._addSysHandler(this._handleResumed.bind(this), this._NS,'resumed');

			} else if (status === strophe_js.Strophe.Status.BINDREQUIRED)  {
				this._c.jid = this._storedJid;

				// Restore Strophe handlers
				for (const h of (this._resumeState.handlers || [])
						.concat(this._resumeState.addHandlers || [])) {
					this._c._addSysHandler(h.handler, h.ns, h.name, h.type, h.id);
				}
				for (const h of (this._resumeState.timedHandlers || [])
						.concat(this._resumeState.addTimeds)) {
					this._c.addTimedHandler(h.period, h.handler);
				}
				for (const h of (this._resumeState.removeTimeds || [])
						.concat(this._resumeState.removeHandlers || [])) {
					this._c.deleteTimedHandler(h);
				}

				// FIXME check conditions if there's session ID and if enabled
				this._c.send(strophe_js.$build('resume', {
					xmlns: this._NS,
					h: this._clientProcessedStanzasCounter,
					previd: this._resumeToken
				}));
				this._c.flush();
			} else if (status === strophe_js.Strophe.Status.ERROR) {
				this.logging && strophe_js.Strophe.debug('SM cleared resume token on error');
				this._resumeToken = undefined;
			}
		},

		/**
		* This method overrides the send method implemented by Strophe.Connection
		* to count outgoing stanzas
		*
		* @method Send
		* @public
		*/
		xmlOutput: function(elem) {
			if (strophe_js.Strophe.isTagEqual(elem, 'iq') ||
				strophe_js.Strophe.isTagEqual(elem, 'presence') ||
				strophe_js.Strophe.isTagEqual(elem, 'message')) {
				this._increaseSentStanzasCounter(elem);
			}

			return this._originalXMLOutput.call(this._c, elem);
		},

		_handleEnabled: function(elem) {
			this._isStreamManagementEnabled = true;
			// FIXME fail if requested, but not enabled
			this._resumeToken = elem.getAttribute('resume') === 'true' && elem.getAttribute('id');

			this._c.resume();

			return true;
		},

		_handleResumeFailed: function(elem) {
			const error = elem && (
				(elem.firstElementChild && elem.firstElementChild.tagName)
				|| (elem.firstChild && elem.firstChild.tagName));

			this._c._changeConnectStatus(strophe_js.Strophe.Status.ERROR, error, elem);
			this._c._doDisconnect();

			return true;
		},

		_handleResumed: function(elem) {
			// FIXME check if in the correct state
			var handledCount = parseInt(elem.getAttribute('h'));
			this._handleAcknowledgedStanzas(handledCount, this._serverProcesssedStanzasCounter);

			this._resuming = false;
			this._c.do_bind = false; // No need to bind our resource anymore
			this._c.authenticated = true;
			this._c.restored = true;

			if (this._unacknowledgedStanzas.length > 0) {
				this.logging && strophe_js.Strophe.debug('SM Sending unacknowledged stanzas', this._unacknowledgedStanzas);
				for(const stanza of this._unacknowledgedStanzas) {
					this._c.send(stanza);
				}
			} else {
				this.logging && strophe_js.Strophe.debug('SM No unacknowledged stanzas', this._unacknowledgedStanzas);
			}

			this._c._changeConnectStatus(strophe_js.Strophe.Status.CONNECTED, null);

			return true;
		},

		_incomingStanzaHandler: function(elem) {
			if (strophe_js.Strophe.isTagEqual(elem, 'iq') || strophe_js.Strophe.isTagEqual(elem, 'presence') || strophe_js.Strophe.isTagEqual(elem, 'message'))  {
				this._increaseReceivedStanzasCounter();

				if (this.autoSendCountOnEveryIncomingStanza) {
					this._answerProcessedStanzas();
				}
			}

			return true;
		},

		_handleAcknowledgedStanzas: function(reportedHandledCount, lastKnownHandledCount) {
			var delta = reportedHandledCount - lastKnownHandledCount;

			if (delta < 0) {
				this._throwError('New reported stanza count lower than previous. New: ' + reportedHandledCount + ' - Previous: ' + lastKnownHandledCount);
			}

			if (delta > this._unacknowledgedStanzas.length) {
				this._throwError('Higher reported acknowledge count than unacknowledged stanzas. Reported Acknowledge Count: ' + delta + ' - Unacknowledge Stanza Count: ' + this._unacknowledgedStanzas.length + ' - New: ' + reportedHandledCount + ' - Previous: ' + lastKnownHandledCount);
			}

			for(var i = 0; i < delta; i++) {
				var stanza = this._unacknowledgedStanzas.shift();
				for (var j = 0; j < this._acknowledgedStanzaListeners.length; j++) {
					this._acknowledgedStanzaListeners[j](stanza);
				}
			}

			if (this.logging && this._unacknowledgedStanzas.length > 0) {
				strophe_js.Strophe.warn('SM Unacknowledged stanzas', this._unacknowledgedStanzas);
			}

			this._serverProcesssedStanzasCounter = reportedHandledCount;

			if (this.requestResponseInterval > 0) {
				this._requestResponseIntervalCount = 0;
			}
		},

		_handleServerRequestHandler: function() {
			this._answerProcessedStanzas();

			return true;
		},

		_handleServerAck: function(elem){
			var handledCount = parseInt(elem.getAttribute('h'));
			this._handleAcknowledgedStanzas(handledCount, this._serverProcesssedStanzasCounter);

			return true;
		},

		_answerProcessedStanzas: function() {
			if (this._isStreamManagementEnabled) {
				this._c.send(strophe_js.$build('a', { xmlns: this._NS, h: this._clientProcessedStanzasCounter }));
			}
		},

		_increaseSentStanzasCounter: function(elem) {
			if (this._isStreamManagementEnabled) {
				if (this._unacknowledgedStanzas.indexOf(elem) !== -1) {

					return;
				}

				this._unacknowledgedStanzas.push(elem);
				this._clientSentStanzasCounter++;

				if (this.requestResponseInterval > 0) {
					this._requestResponseIntervalCount++;

					if (this._requestResponseIntervalCount === this.requestResponseInterval) {
						// FIXME Can not call send from onIdle.
						setTimeout(() => {
							if (this._connectionStatus === strophe_js.Strophe.Status.CONNECTED) {
								this.requestAcknowledgement();
							}
						}, 1);
					}
				}
			}
		},

		_increaseReceivedStanzasCounter: function() {
			if (this._isStreamManagementEnabled) {
				this._clientProcessedStanzasCounter++;
			}
		},

		_throwError: function(msg) {
			strophe_js.Strophe.error(msg);
			throw new Error(msg);
		}

	});

}));
//# sourceMappingURL=strophe.stream-management.js.map


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/uuid/dist/bytesToUuid.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/uuid/dist/bytesToUuid.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function bytesToUuid(buf, offset) {
  const i = offset || 0;
  const bth = byteToHex; // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

  return (bth[buf[i + 0]] + bth[buf[i + 1]] + bth[buf[i + 2]] + bth[buf[i + 3]] + '-' + bth[buf[i + 4]] + bth[buf[i + 5]] + '-' + bth[buf[i + 6]] + bth[buf[i + 7]] + '-' + bth[buf[i + 8]] + bth[buf[i + 9]] + '-' + bth[buf[i + 10]] + bth[buf[i + 11]] + bth[buf[i + 12]] + bth[buf[i + 13]] + bth[buf[i + 14]] + bth[buf[i + 15]]).toLowerCase();
}

var _default = bytesToUuid;
exports["default"] = _default;

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/uuid/dist/index.js":
/*!************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/uuid/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return _v4.default;
  }
}));

var _v = _interopRequireDefault(__webpack_require__(/*! ./v1.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/v1.js"));

var _v2 = _interopRequireDefault(__webpack_require__(/*! ./v3.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/v3.js"));

var _v3 = _interopRequireDefault(__webpack_require__(/*! ./v4.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/v4.js"));

var _v4 = _interopRequireDefault(__webpack_require__(/*! ./v5.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/v5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/uuid/dist/md5-browser.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/uuid/dist/md5-browser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/uuid/dist/rng-browser.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/uuid/dist/rng-browser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
// find the complete implementation of crypto (msCrypto) on IE11.
const getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
const rnds8 = new Uint8Array(16);

function rng() {
  if (!getRandomValues) {
    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/uuid/dist/sha1-browser.js":
/*!*******************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/uuid/dist/sha1-browser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/uuid/dist/v1.js":
/*!*********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/uuid/dist/v1.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/rng-browser.js"));

var _bytesToUuid = _interopRequireDefault(__webpack_require__(/*! ./bytesToUuid.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/bytesToUuid.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || [];
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _bytesToUuid.default)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/uuid/dist/v3.js":
/*!*********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/uuid/dist/v3.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/v35.js"));

var _md = _interopRequireDefault(__webpack_require__(/*! ./md5.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/md5-browser.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/uuid/dist/v35.js":
/*!**********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/uuid/dist/v35.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;

var _bytesToUuid = _interopRequireDefault(__webpack_require__(/*! ./bytesToUuid.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/bytesToUuid.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function uuidToBytes(uuid) {
  // Note: We assume we're being passed a valid uuid string
  const bytes = [];
  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {
    bytes.push(parseInt(hex, 16));
  });
  return bytes;
}

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    const off = buf && offset || 0;
    if (typeof value === 'string') value = stringToBytes(value);
    if (typeof namespace === 'string') namespace = uuidToBytes(namespace);

    if (!Array.isArray(value)) {
      throw TypeError('value must be an array of bytes');
    }

    if (!Array.isArray(namespace) || namespace.length !== 16) {
      throw TypeError('namespace must be uuid string or an Array of 16 byte values');
    } // Per 4.3


    const bytes = hashfunc(namespace.concat(value));
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      for (let idx = 0; idx < 16; ++idx) {
        buf[off + idx] = bytes[idx];
      }
    }

    return buf || (0, _bytesToUuid.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/uuid/dist/v4.js":
/*!*********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/uuid/dist/v4.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/rng-browser.js"));

var _bytesToUuid = _interopRequireDefault(__webpack_require__(/*! ./bytesToUuid.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/bytesToUuid.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  if (typeof options === 'string') {
    buf = options === 'binary' ? new Uint8Array(16) : null;
    options = null;
  }

  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    const start = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[start + i] = rnds[i];
    }

    return buf;
  }

  return (0, _bytesToUuid.default)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/uuid/dist/v5.js":
/*!*********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/uuid/dist/v5.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/v35.js"));

var _sha = _interopRequireDefault(__webpack_require__(/*! ./sha1.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/sha1-browser.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/adapter_core.js":
/*!*******************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/adapter_core.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter_factory.js */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/adapter_factory.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */





const adapter =
  (0,_adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__.adapterFactory)({window: typeof window === 'undefined' ? undefined : window});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (adapter);


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/adapter_factory.js":
/*!**********************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/adapter_factory.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   adapterFactory: () => (/* binding */ adapterFactory)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/utils.js");
/* harmony import */ var _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chrome/chrome_shim */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js");
/* harmony import */ var _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./firefox/firefox_shim */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js");
/* harmony import */ var _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./safari/safari_shim */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/safari/safari_shim.js");
/* harmony import */ var _common_shim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common_shim */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/common_shim.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! sdp */ "../../lib-jitsi-meet/node_modules/sdp/sdp.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_5__);
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */


  // Browser shims.






// Shimming starts here.
function adapterFactory({window} = {}, options = {
  shimChrome: true,
  shimFirefox: true,
  shimSafari: true,
}) {
  // Utils.
  const logging = _utils__WEBPACK_IMPORTED_MODULE_0__.log;
  const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_0__.detectBrowser(window);

  const adapter = {
    browserDetails,
    commonShim: _common_shim__WEBPACK_IMPORTED_MODULE_4__,
    extractVersion: _utils__WEBPACK_IMPORTED_MODULE_0__.extractVersion,
    disableLog: _utils__WEBPACK_IMPORTED_MODULE_0__.disableLog,
    disableWarnings: _utils__WEBPACK_IMPORTED_MODULE_0__.disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp: sdp__WEBPACK_IMPORTED_MODULE_5__,
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ || !_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection ||
          !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      if (browserDetails.version === null) {
        logging('Chrome shim can not determine version, not shimming.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__;

      // Must be called before shimPeerConnection.
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);

      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimMediaStream(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimOnTrack(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimAddTrackRemoveTrack(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetSendersWithDtmf(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetStats(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimSenderReceiverGetStats(window, browserDetails);
      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.fixNegotiationNeeded(window, browserDetails);

      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);
      break;
    case 'firefox':
      if (!_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ || !_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection ||
          !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__;

      // Must be called before shimPeerConnection.
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);

      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetUserMedia(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimOnTrack(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRemoveStream(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimSenderGetStats(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimReceiverGetStats(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRTCDataChannel(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimAddTransceiver(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetParameters(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateOffer(window, browserDetails);
      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateAnswer(window, browserDetails);

      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);
      break;
    case 'safari':
      if (!_safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__;

      // Must be called before shimCallbackAPI.
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);

      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRTCIceServerUrls(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCreateOfferLegacy(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCallbacksAPI(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimLocalStreamsAPI(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRemoteStreamsAPI(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimTrackEventTransceiver(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimGetUserMedia(window, browserDetails);
      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimAudioContext(window, browserDetails);

      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);
      _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js":
/*!*************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fixNegotiationNeeded: () => (/* binding */ fixNegotiationNeeded),
/* harmony export */   shimAddTrackRemoveTrack: () => (/* binding */ shimAddTrackRemoveTrack),
/* harmony export */   shimAddTrackRemoveTrackWithNative: () => (/* binding */ shimAddTrackRemoveTrackWithNative),
/* harmony export */   shimGetDisplayMedia: () => (/* reexport safe */ _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__.shimGetDisplayMedia),
/* harmony export */   shimGetSendersWithDtmf: () => (/* binding */ shimGetSendersWithDtmf),
/* harmony export */   shimGetStats: () => (/* binding */ shimGetStats),
/* harmony export */   shimGetUserMedia: () => (/* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia),
/* harmony export */   shimMediaStream: () => (/* binding */ shimMediaStream),
/* harmony export */   shimOnTrack: () => (/* binding */ shimOnTrack),
/* harmony export */   shimPeerConnection: () => (/* binding */ shimPeerConnection),
/* harmony export */   shimSenderReceiverGetStats: () => (/* binding */ shimSenderReceiverGetStats)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/utils.js");
/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js");
/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getdisplaymedia */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */






function shimMediaStream(window) {
  window.MediaStream = window.MediaStream || window.webkitMediaStream;
}

function shimOnTrack(window) {
  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
      window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
      get() {
        return this._ontrack;
      },
      set(f) {
        if (this._ontrack) {
          this.removeEventListener('track', this._ontrack);
        }
        this.addEventListener('track', this._ontrack = f);
      },
      enumerable: true,
      configurable: true
    });
    const origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription =
      function setRemoteDescription() {
        if (!this._ontrackpoly) {
          this._ontrackpoly = (e) => {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', te => {
              let receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers()
                  .find(r => r.track && r.track.id === te.track.id);
              } else {
                receiver = {track: te.track};
              }

              const event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = {receiver};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(track => {
              let receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers()
                  .find(r => r.track && r.track.id === track.id);
              } else {
                receiver = {track};
              }
              const event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {receiver};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            });
          };
          this.addEventListener('addstream', this._ontrackpoly);
        }
        return origSetRemoteDescription.apply(this, arguments);
      };
  } else {
    // even if RTCRtpTransceiver is in window, it is only used and
    // emitted in unified-plan. Unfortunately this means we need
    // to unconditionally wrap the event.
    _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {
      if (!e.transceiver) {
        Object.defineProperty(e, 'transceiver',
          {value: {receiver: e.receiver}});
      }
      return e;
    });
  }
}

function shimGetSendersWithDtmf(window) {
  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
  if (typeof window === 'object' && window.RTCPeerConnection &&
      !('getSenders' in window.RTCPeerConnection.prototype) &&
      'createDTMFSender' in window.RTCPeerConnection.prototype) {
    const shimSenderWithDtmf = function(pc, track) {
      return {
        track,
        get dtmf() {
          if (this._dtmf === undefined) {
            if (track.kind === 'audio') {
              this._dtmf = pc.createDTMFSender(track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc
      };
    };

    // augment addTrack when getSenders is not available.
    if (!window.RTCPeerConnection.prototype.getSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice(); // return a copy of the internal state.
      };
      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addTrack =
        function addTrack(track, stream) {
          let sender = origAddTrack.apply(this, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(this, track);
            this._senders.push(sender);
          }
          return sender;
        };

      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
      window.RTCPeerConnection.prototype.removeTrack =
        function removeTrack(sender) {
          origRemoveTrack.apply(this, arguments);
          const idx = this._senders.indexOf(sender);
          if (idx !== -1) {
            this._senders.splice(idx, 1);
          }
        };
    }
    const origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach(track => {
        this._senders.push(shimSenderWithDtmf(this, track));
      });
    };

    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream =
      function removeStream(stream) {
        this._senders = this._senders || [];
        origRemoveStream.apply(this, [stream]);

        stream.getTracks().forEach(track => {
          const sender = this._senders.find(s => s.track === track);
          if (sender) { // remove sender
            this._senders.splice(this._senders.indexOf(sender), 1);
          }
        });
      };
  } else if (typeof window === 'object' && window.RTCPeerConnection &&
             'getSenders' in window.RTCPeerConnection.prototype &&
             'createDTMFSender' in window.RTCPeerConnection.prototype &&
             window.RTCRtpSender &&
             !('dtmf' in window.RTCRtpSender.prototype)) {
    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach(sender => sender._pc = this);
      return senders;
    };

    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
      get() {
        if (this._dtmf === undefined) {
          if (this.track.kind === 'audio') {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}

function shimGetStats(window) {
  if (!window.RTCPeerConnection) {
    return;
  }

  const origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;

    // If selector is a function then we are in the old style stats so just
    // pass back the original getStats format to avoid breaking old users.
    if (arguments.length > 0 && typeof selector === 'function') {
      return origGetStats.apply(this, arguments);
    }

    // When spec-style getStats is supported, return those when called with
    // either no arguments or the selector argument is null.
    if (origGetStats.length === 0 && (arguments.length === 0 ||
        typeof selector !== 'function')) {
      return origGetStats.apply(this, []);
    }

    const fixChromeStats_ = function(response) {
      const standardReport = {};
      const reports = response.result();
      reports.forEach(report => {
        const standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate'
          }[report.type] || report.type
        };
        report.names().forEach(name => {
          standardStats[name] = report.stat(name);
        });
        standardReport[standardStats.id] = standardStats;
      });

      return standardReport;
    };

    // shim getStats with maplike support
    const makeMapStats = function(stats) {
      return new Map(Object.keys(stats).map(key => [key, stats[key]]));
    };

    if (arguments.length >= 2) {
      const successCallbackWrapper_ = function(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };

      return origGetStats.apply(this, [successCallbackWrapper_,
        selector]);
    }

    // promise-support
    return new Promise((resolve, reject) => {
      origGetStats.apply(this, [
        function(response) {
          resolve(makeMapStats(fixChromeStats_(response)));
        }, reject]);
    }).then(onSucc, onErr);
  };
}

function shimSenderReceiverGetStats(window) {
  if (!(typeof window === 'object' && window.RTCPeerConnection &&
      window.RTCRtpSender && window.RTCRtpReceiver)) {
    return;
  }

  // shim sender stats.
  if (!('getStats' in window.RTCRtpSender.prototype)) {
    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach(sender => sender._pc = this);
        return senders;
      };
    }

    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function getStats() {
      const sender = this;
      return this._pc.getStats().then(result =>
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, sender.track, true));
    };
  }

  // shim receiver stats.
  if (!('getStats' in window.RTCRtpReceiver.prototype)) {
    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers =
        function getReceivers() {
          const receivers = origGetReceivers.apply(this, []);
          receivers.forEach(receiver => receiver._pc = this);
          return receivers;
        };
    }
    _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function getStats() {
      const receiver = this;
      return this._pc.getStats().then(result =>
        _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, receiver.track, false));
    };
  }

  if (!('getStats' in window.RTCRtpSender.prototype &&
      'getStats' in window.RTCRtpReceiver.prototype)) {
    return;
  }

  // shim RTCPeerConnection.getStats(track).
  const origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 &&
        arguments[0] instanceof window.MediaStreamTrack) {
      const track = arguments[0];
      let sender;
      let receiver;
      let err;
      this.getSenders().forEach(s => {
        if (s.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s;
          }
        }
      });
      this.getReceivers().forEach(r => {
        if (r.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r;
          }
        }
        return r.track === track;
      });
      if (err || (sender && receiver)) {
        return Promise.reject(new DOMException(
          'There are more than one sender or receiver for the track.',
          'InvalidAccessError'));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException(
        'There is no sender or receiver for the track.',
        'InvalidAccessError'));
    }
    return origGetStats.apply(this, arguments);
  };
}

function shimAddTrackRemoveTrackWithNative(window) {
  // shim addTrack/removeTrack with native variants in order to make
  // the interactions with legacy getLocalStreams behave as in other browsers.
  // Keeps a mapping stream.id => [stream, rtpsenders...]
  window.RTCPeerConnection.prototype.getLocalStreams =
    function getLocalStreams() {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams)
        .map(streamId => this._shimmedLocalStreams[streamId][0]);
    };

  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  window.RTCPeerConnection.prototype.addTrack =
    function addTrack(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      const sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };

  const origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

    stream.getTracks().forEach(track => {
      const alreadyExists = this.getSenders().find(s => s.track === track);
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }
    });
    const existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    const newSenders = this.getSenders()
      .filter(newSender => existingSenders.indexOf(newSender) === -1);
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };

  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream =
    function removeStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };

  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
  window.RTCPeerConnection.prototype.removeTrack =
    function removeTrack(sender) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach(streamId => {
          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            this._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (this._shimmedLocalStreams[streamId].length === 1) {
            delete this._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
}

function shimAddTrackRemoveTrack(window, browserDetails) {
  if (!window.RTCPeerConnection) {
    return;
  }
  // shim addTrack and removeTrack.
  if (window.RTCPeerConnection.prototype.addTrack &&
      browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window);
  }

  // also shim pc.getLocalStreams when addTrack is shimmed
  // to return the original streams.
  const origGetLocalStreams = window.RTCPeerConnection.prototype
      .getLocalStreams;
  window.RTCPeerConnection.prototype.getLocalStreams =
    function getLocalStreams() {
      const nativeStreams = origGetLocalStreams.apply(this);
      this._reverseStreams = this._reverseStreams || {};
      return nativeStreams.map(stream => this._reverseStreams[stream.id]);
    };

  const origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};

    stream.getTracks().forEach(track => {
      const alreadyExists = this.getSenders().find(s => s.track === track);
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }
    });
    // Add identity mapping for consistency with addTrack.
    // Unless this is being used with a stream from addTrack.
    if (!this._reverseStreams[stream.id]) {
      const newStream = new window.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };

  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream =
    function removeStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};

      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);
      delete this._reverseStreams[(this._streams[stream.id] ?
          this._streams[stream.id].id : stream.id)];
      delete this._streams[stream.id];
    };

  window.RTCPeerConnection.prototype.addTrack =
    function addTrack(track, stream) {
      if (this.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      const streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 ||
          !streams[0].getTracks().find(t => t === track)) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException(
          'The adapter.js addTrack polyfill only supports a single ' +
          ' stream which is associated with the specified track.',
          'NotSupportedError');
      }

      const alreadyExists = this.getSenders().find(s => s.track === track);
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }

      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      const oldStream = this._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(() => {
          this.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        const newStream = new window.MediaStream([track]);
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        this.addStream(newStream);
      }
      return this.getSenders().find(s => s.track === track);
    };

  // replace the internal stream id with the external one and
  // vice versa.
  function replaceInternalStreamId(pc, description) {
    let sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(internalId => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
          externalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp
    });
  }
  function replaceExternalStreamId(pc, description) {
    let sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(internalId => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
          internalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp
    });
  }
  ['createOffer', 'createAnswer'].forEach(function(method) {
    const nativeMethod = window.RTCPeerConnection.prototype[method];
    const methodObj = {[method]() {
      const args = arguments;
      const isLegacyCall = arguments.length &&
          typeof arguments[0] === 'function';
      if (isLegacyCall) {
        return nativeMethod.apply(this, [
          (description) => {
            const desc = replaceInternalStreamId(this, description);
            args[0].apply(null, [desc]);
          },
          (err) => {
            if (args[1]) {
              args[1].apply(null, err);
            }
          }, arguments[2]
        ]);
      }
      return nativeMethod.apply(this, arguments)
      .then(description => replaceInternalStreamId(this, description));
    }};
    window.RTCPeerConnection.prototype[method] = methodObj[method];
  });

  const origSetLocalDescription =
      window.RTCPeerConnection.prototype.setLocalDescription;
  window.RTCPeerConnection.prototype.setLocalDescription =
    function setLocalDescription() {
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(this, arguments);
      }
      arguments[0] = replaceExternalStreamId(this, arguments[0]);
      return origSetLocalDescription.apply(this, arguments);
    };

  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

  const origLocalDescription = Object.getOwnPropertyDescriptor(
      window.RTCPeerConnection.prototype, 'localDescription');
  Object.defineProperty(window.RTCPeerConnection.prototype,
      'localDescription', {
        get() {
          const description = origLocalDescription.get.apply(this);
          if (description.type === '') {
            return description;
          }
          return replaceInternalStreamId(this, description);
        }
      });

  window.RTCPeerConnection.prototype.removeTrack =
    function removeTrack(sender) {
      if (this.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.', 'TypeError');
      }
      const isLocal = sender._pc === this;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      this._streams = this._streams || {};
      let stream;
      Object.keys(this._streams).forEach(streamid => {
        const hasTrack = this._streams[streamid].getTracks()
          .find(track => sender.track === track);
        if (hasTrack) {
          stream = this._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          this.removeStream(this._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        this.dispatchEvent(new Event('negotiationneeded'));
      }
    };
}

function shimPeerConnection(window, browserDetails) {
  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.webkitRTCPeerConnection;
  }
  if (!window.RTCPeerConnection) {
    return;
  }

  // shim implicit creation of RTCSessionDescription/RTCIceCandidate
  if (browserDetails.version < 53) {
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          const nativeMethod = window.RTCPeerConnection.prototype[method];
          const methodObj = {[method]() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }};
          window.RTCPeerConnection.prototype[method] = methodObj[method];
        });
  }
}

// Attempt to fix ONN in plan-b mode.
function fixNegotiationNeeded(window, browserDetails) {
  _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {
    const pc = e.target;
    if (browserDetails.version < 72 || (pc.getConfiguration &&
        pc.getConfiguration().sdpSemantics === 'plan-b')) {
      if (pc.signalingState !== 'stable') {
        return;
      }
    }
    return e;
  });
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js":
/*!*****************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shimGetDisplayMedia: () => (/* binding */ shimGetDisplayMedia)
/* harmony export */ });
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */

function shimGetDisplayMedia(window, getSourceId) {
  if (window.navigator.mediaDevices &&
    'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!(window.navigator.mediaDevices)) {
    return;
  }
  // getSourceId is a function that returns a promise resolving with
  // the sourceId of the screen/window/tab to be shared.
  if (typeof getSourceId !== 'function') {
    console.error('shimGetDisplayMedia: getSourceId argument is not ' +
        'a function');
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia =
    function getDisplayMedia(constraints) {
      return getSourceId(constraints)
        .then(sourceId => {
          const widthSpecified = constraints.video && constraints.video.width;
          const heightSpecified = constraints.video &&
            constraints.video.height;
          const frameRateSpecified = constraints.video &&
            constraints.video.frameRate;
          constraints.video = {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: sourceId,
              maxFrameRate: frameRateSpecified || 3
            }
          };
          if (widthSpecified) {
            constraints.video.mandatory.maxWidth = widthSpecified;
          }
          if (heightSpecified) {
            constraints.video.mandatory.maxHeight = heightSpecified;
          }
          return window.navigator.mediaDevices.getUserMedia(constraints);
        });
    };
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js":
/*!**************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shimGetUserMedia: () => (/* binding */ shimGetUserMedia)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/utils.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */


const logging = _utils_js__WEBPACK_IMPORTED_MODULE_0__.log;

function shimGetUserMedia(window, browserDetails) {
  const navigator = window && window.navigator;

  if (!navigator.mediaDevices) {
    return;
  }

  const constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    const cc = {};
    Object.keys(c).forEach(key => {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      const r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      const oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        let oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(mix => {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  const shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === 'object') {
      const remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile & surface pro.
      let face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});
      const getSupportedFacingModeLies = browserDetails.version < 66;

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode &&
            !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        let matches;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices()
          .then(devices => {
            devices = devices.filter(d => d.kind === 'videoinput');
            let dev = devices.find(d => matches.some(match =>
              d.label.toLowerCase().includes(match)));
            if (!dev && devices.length && matches.includes('back')) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :
                                                        {ideal: dev.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  const shimError_ = function(e) {
    if (browserDetails.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  const getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, c => {
      navigator.webkitGetUserMedia(c, onSuccess, e => {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };
  navigator.getUserMedia = getUserMedia_.bind(navigator);

  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
  // function which returns a Promise, it does not accept spec-style
  // constraints.
  if (navigator.mediaDevices.getUserMedia) {
    const origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(track => {
            track.stop();
          });
          throw new DOMException('', 'NotFoundError');
        }
        return stream;
      }, e => Promise.reject(shimError_(e))));
    };
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/common_shim.js":
/*!******************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/common_shim.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   removeExtmapAllowMixed: () => (/* binding */ removeExtmapAllowMixed),
/* harmony export */   shimAddIceCandidateNullOrEmpty: () => (/* binding */ shimAddIceCandidateNullOrEmpty),
/* harmony export */   shimConnectionState: () => (/* binding */ shimConnectionState),
/* harmony export */   shimMaxMessageSize: () => (/* binding */ shimMaxMessageSize),
/* harmony export */   shimParameterlessSetLocalDescription: () => (/* binding */ shimParameterlessSetLocalDescription),
/* harmony export */   shimRTCIceCandidate: () => (/* binding */ shimRTCIceCandidate),
/* harmony export */   shimSendThrowTypeError: () => (/* binding */ shimSendThrowTypeError)
/* harmony export */ });
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdp */ "../../lib-jitsi-meet/node_modules/sdp/sdp.js");
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/utils.js");
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */





function shimRTCIceCandidate(window) {
  // foundation is arbitrarily chosen as an indicator for full support for
  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
  if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in
      window.RTCIceCandidate.prototype)) {
    return;
  }

  const NativeRTCIceCandidate = window.RTCIceCandidate;
  window.RTCIceCandidate = function RTCIceCandidate(args) {
    // Remove the a= which shouldn't be part of the candidate string.
    if (typeof args === 'object' && args.candidate &&
        args.candidate.indexOf('a=') === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substr(2);
    }

    if (args.candidate && args.candidate.length) {
      // Augment the native candidate with the parsed fields.
      const nativeCandidate = new NativeRTCIceCandidate(args);
      const parsedCandidate = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseCandidate(args.candidate);
      const augmentedCandidate = Object.assign(nativeCandidate,
          parsedCandidate);

      // Add a serializer that does not serialize the extra attributes.
      augmentedCandidate.toJSON = function toJSON() {
        return {
          candidate: augmentedCandidate.candidate,
          sdpMid: augmentedCandidate.sdpMid,
          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
          usernameFragment: augmentedCandidate.usernameFragment,
        };
      };
      return augmentedCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

  // Hook up the augmented candidate in onicecandidate and
  // addEventListener('icecandidate', ...)
  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'icecandidate', e => {
    if (e.candidate) {
      Object.defineProperty(e, 'candidate', {
        value: new window.RTCIceCandidate(e.candidate),
        writable: 'false'
      });
    }
    return e;
  });
}

function shimMaxMessageSize(window, browserDetails) {
  if (!window.RTCPeerConnection) {
    return;
  }

  if (!('sctp' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
      get() {
        return typeof this._sctp === 'undefined' ? null : this._sctp;
      }
    });
  }

  const sctpInDescription = function(description) {
    if (!description || !description.sdp) {
      return false;
    }
    const sections = sdp__WEBPACK_IMPORTED_MODULE_0___default().splitSections(description.sdp);
    sections.shift();
    return sections.some(mediaSection => {
      const mLine = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseMLine(mediaSection);
      return mLine && mLine.kind === 'application'
          && mLine.protocol.indexOf('SCTP') !== -1;
    });
  };

  const getRemoteFirefoxVersion = function(description) {
    // TODO: Is there a better solution for detecting Firefox?
    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    const version = parseInt(match[1], 10);
    // Test for NaN (yes, this is ugly)
    return version !== version ? -1 : version;
  };

  const getCanSendMaxMessageSize = function(remoteIsFirefox) {
    // Every implementation we know can send at least 64 KiB.
    // Note: Although Chrome is technically able to send up to 256 KiB, the
    //       data does not reach the other peer reliably.
    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
    let canSendMaxMessageSize = 65536;
    if (browserDetails.browser === 'firefox') {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          // FF < 57 will send in 16 KiB chunks using the deprecated PPID
          // fragmentation.
          canSendMaxMessageSize = 16384;
        } else {
          // However, other FF (and RAWRTC) can reassemble PPID-fragmented
          // messages. Thus, supporting ~2 GiB when sending.
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        // Currently, all FF >= 57 will reset the remote maximum message size
        // to the default value when a data channel is created at a later
        // stage. :(
        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
        canSendMaxMessageSize =
          browserDetails.version === 57 ? 65535 : 65536;
      } else {
        // FF >= 60 supports sending ~2 GiB
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };

  const getMaxMessageSize = function(description, remoteIsFirefox) {
    // Note: 65536 bytes is the default value from the SDP spec. Also,
    //       every implementation we know supports receiving 65536 bytes.
    let maxMessageSize = 65536;

    // FF 57 has a slightly incorrect default remote max message size, so
    // we need to adjust it here to avoid a failure when sending.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
    if (browserDetails.browser === 'firefox'
         && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }

    const match = sdp__WEBPACK_IMPORTED_MODULE_0___default().matchPrefix(description.sdp,
      'a=max-message-size:');
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substr(19), 10);
    } else if (browserDetails.browser === 'firefox' &&
                remoteIsFirefox !== -1) {
      // If the maximum message size is not present in the remote SDP and
      // both local and remote are Firefox, the remote peer can receive
      // ~2 GiB.
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };

  const origSetRemoteDescription =
      window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription =
    function setRemoteDescription() {
      this._sctp = null;
      // Chrome decided to not expose .sctp in plan-b mode.
      // As usual, adapter.js has to do an 'ugly worakaround'
      // to cover up the mess.
      if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
        const {sdpSemantics} = this.getConfiguration();
        if (sdpSemantics === 'plan-b') {
          Object.defineProperty(this, 'sctp', {
            get() {
              return typeof this._sctp === 'undefined' ? null : this._sctp;
            },
            enumerable: true,
            configurable: true,
          });
        }
      }

      if (sctpInDescription(arguments[0])) {
        // Check if the remote is FF.
        const isFirefox = getRemoteFirefoxVersion(arguments[0]);

        // Get the maximum message size the local peer is capable of sending
        const canSendMMS = getCanSendMaxMessageSize(isFirefox);

        // Get the maximum message size of the remote peer.
        const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

        // Determine final maximum message size
        let maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }

        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
        // attribute.
        const sctp = {};
        Object.defineProperty(sctp, 'maxMessageSize', {
          get() {
            return maxMessageSize;
          }
        });
        this._sctp = sctp;
      }

      return origSetRemoteDescription.apply(this, arguments);
    };
}

function shimSendThrowTypeError(window) {
  if (!(window.RTCPeerConnection &&
      'createDataChannel' in window.RTCPeerConnection.prototype)) {
    return;
  }

  // Note: Although Firefox >= 57 has a native implementation, the maximum
  //       message size can be reset for all data channels at a later stage.
  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

  function wrapDcSend(dc, pc) {
    const origDataChannelSend = dc.send;
    dc.send = function send() {
      const data = arguments[0];
      const length = data.length || data.size || data.byteLength;
      if (dc.readyState === 'open' &&
          pc.sctp && length > pc.sctp.maxMessageSize) {
        throw new TypeError('Message too large (can send a maximum of ' +
          pc.sctp.maxMessageSize + ' bytes)');
      }
      return origDataChannelSend.apply(dc, arguments);
    };
  }
  const origCreateDataChannel =
    window.RTCPeerConnection.prototype.createDataChannel;
  window.RTCPeerConnection.prototype.createDataChannel =
    function createDataChannel() {
      const dataChannel = origCreateDataChannel.apply(this, arguments);
      wrapDcSend(dataChannel, this);
      return dataChannel;
    };
  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'datachannel', e => {
    wrapDcSend(e.channel, e.target);
    return e;
  });
}


/* shims RTCConnectionState by pretending it is the same as iceConnectionState.
 * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
 * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
 * since DTLS failures would be hidden. See
 * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
 * for the Firefox tracking bug.
 */
function shimConnectionState(window) {
  if (!window.RTCPeerConnection ||
      'connectionState' in window.RTCPeerConnection.prototype) {
    return;
  }
  const proto = window.RTCPeerConnection.prototype;
  Object.defineProperty(proto, 'connectionState', {
    get() {
      return {
        completed: 'connected',
        checking: 'connecting'
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, 'onconnectionstatechange', {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener('connectionstatechange',
            this._onconnectionstatechange);
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener('connectionstatechange',
            this._onconnectionstatechange = cb);
      }
    },
    enumerable: true,
    configurable: true
  });

  ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {
    const origMethod = proto[method];
    proto[method] = function() {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = e => {
          const pc = e.target;
          if (pc._lastConnectionState !== pc.connectionState) {
            pc._lastConnectionState = pc.connectionState;
            const newEvent = new Event('connectionstatechange', e);
            pc.dispatchEvent(newEvent);
          }
          return e;
        };
        this.addEventListener('iceconnectionstatechange',
          this._connectionstatechangepoly);
      }
      return origMethod.apply(this, arguments);
    };
  });
}

function removeExtmapAllowMixed(window, browserDetails) {
  /* remove a=extmap-allow-mixed for webrtc.org < M71 */
  if (!window.RTCPeerConnection) {
    return;
  }
  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
    return;
  }
  if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {
    return;
  }
  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription =
  function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
      const sdp = desc.sdp.split('\n').filter((line) => {
        return line.trim() !== 'a=extmap-allow-mixed';
      }).join('\n');
      // Safari enforces read-only-ness of RTCSessionDescription fields.
      if (window.RTCSessionDescription &&
          desc instanceof window.RTCSessionDescription) {
        arguments[0] = new window.RTCSessionDescription({
          type: desc.type,
          sdp,
        });
      } else {
        desc.sdp = sdp;
      }
    }
    return nativeSRD.apply(this, arguments);
  };
}

function shimAddIceCandidateNullOrEmpty(window, browserDetails) {
  // Support for addIceCandidate(null or undefined)
  // as well as addIceCandidate({candidate: "", ...})
  // https://bugs.chromium.org/p/chromium/issues/detail?id=978582
  // Note: must be called before other polyfills which change the signature.
  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeAddIceCandidate =
      window.RTCPeerConnection.prototype.addIceCandidate;
  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
    return;
  }
  window.RTCPeerConnection.prototype.addIceCandidate =
    function addIceCandidate() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      // Firefox 68+ emits and processes {candidate: "", ...}, ignore
      // in older versions.
      // Native support for ignoring exists for Chrome M77+.
      // Safari ignores as well, exact version unknown but works in the same
      // version that also ignores addIceCandidate(null).
      if (((browserDetails.browser === 'chrome' && browserDetails.version < 78)
           || (browserDetails.browser === 'firefox'
               && browserDetails.version < 68)
           || (browserDetails.browser === 'safari'))
          && arguments[0] && arguments[0].candidate === '') {
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
}

// Note: Make sure to call this ahead of APIs that modify
// setLocalDescription.length
function shimParameterlessSetLocalDescription(window, browserDetails) {
  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeSetLocalDescription =
      window.RTCPeerConnection.prototype.setLocalDescription;
  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
    return;
  }
  window.RTCPeerConnection.prototype.setLocalDescription =
    function setLocalDescription() {
      let desc = arguments[0] || {};
      if (typeof desc !== 'object' || (desc.type && desc.sdp)) {
        return nativeSetLocalDescription.apply(this, arguments);
      }
      // The remaining steps should technically happen when SLD comes off the
      // RTCPeerConnection's operations chain (not ahead of going on it), but
      // this is too difficult to shim. Instead, this shim only covers the
      // common case where the operations chain is empty. This is imperfect, but
      // should cover many cases. Rationale: Even if we can't reduce the glare
      // window to zero on imperfect implementations, there's value in tapping
      // into the perfect negotiation pattern that several browsers support.
      desc = {type: desc.type, sdp: desc.sdp};
      if (!desc.type) {
        switch (this.signalingState) {
          case 'stable':
          case 'have-local-offer':
          case 'have-remote-pranswer':
            desc.type = 'offer';
            break;
          default:
            desc.type = 'answer';
            break;
        }
      }
      if (desc.sdp || (desc.type !== 'offer' && desc.type !== 'answer')) {
        return nativeSetLocalDescription.apply(this, [desc]);
      }
      const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;
      return func.apply(this)
        .then(d => nativeSetLocalDescription.apply(this, [d]));
    };
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js":
/*!***************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shimAddTransceiver: () => (/* binding */ shimAddTransceiver),
/* harmony export */   shimCreateAnswer: () => (/* binding */ shimCreateAnswer),
/* harmony export */   shimCreateOffer: () => (/* binding */ shimCreateOffer),
/* harmony export */   shimGetDisplayMedia: () => (/* reexport safe */ _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__.shimGetDisplayMedia),
/* harmony export */   shimGetParameters: () => (/* binding */ shimGetParameters),
/* harmony export */   shimGetUserMedia: () => (/* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia),
/* harmony export */   shimOnTrack: () => (/* binding */ shimOnTrack),
/* harmony export */   shimPeerConnection: () => (/* binding */ shimPeerConnection),
/* harmony export */   shimRTCDataChannel: () => (/* binding */ shimRTCDataChannel),
/* harmony export */   shimReceiverGetStats: () => (/* binding */ shimReceiverGetStats),
/* harmony export */   shimRemoveStream: () => (/* binding */ shimRemoveStream),
/* harmony export */   shimSenderGetStats: () => (/* binding */ shimSenderGetStats)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/utils.js");
/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js");
/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getdisplaymedia */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */






function shimOnTrack(window) {
  if (typeof window === 'object' && window.RTCTrackEvent &&
      ('receiver' in window.RTCTrackEvent.prototype) &&
      !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get() {
        return {receiver: this.receiver};
      }
    });
  }
}

function shimPeerConnection(window, browserDetails) {
  if (typeof window !== 'object' ||
      !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
    return; // probably media.peerconnection.enabled=false in about:config
  }
  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.mozRTCPeerConnection;
  }

  if (browserDetails.version < 53) {
    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          const nativeMethod = window.RTCPeerConnection.prototype[method];
          const methodObj = {[method]() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }};
          window.RTCPeerConnection.prototype[method] = methodObj[method];
        });
  }

  const modernStatsTypes = {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  };

  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    return nativeGetStats.apply(this, [selector || null])
      .then(stats => {
        if (browserDetails.version < 53 && !onSucc) {
          // Shim only promise getStats with spec-hyphens in type names
          // Leave callback version alone; misc old uses of forEach before Map
          try {
            stats.forEach(stat => {
              stat.type = modernStatsTypes[stat.type] || stat.type;
            });
          } catch (e) {
            if (e.name !== 'TypeError') {
              throw e;
            }
            // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
            stats.forEach((stat, i) => {
              stats.set(i, Object.assign({}, stat, {
                type: modernStatsTypes[stat.type] || stat.type
              }));
            });
          }
        }
        return stats;
      })
      .then(onSucc, onErr);
  };
}

function shimSenderGetStats(window) {
  if (!(typeof window === 'object' && window.RTCPeerConnection &&
      window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
    return;
  }
  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach(sender => sender._pc = this);
      return senders;
    };
  }

  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window.RTCPeerConnection.prototype.addTrack = function addTrack() {
      const sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) :
        Promise.resolve(new Map());
  };
}

function shimReceiverGetStats(window) {
  if (!(typeof window === 'object' && window.RTCPeerConnection &&
      window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
    return;
  }
  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      const receivers = origGetReceivers.apply(this, []);
      receivers.forEach(receiver => receiver._pc = this);
      return receivers;
    };
  }
  _utils__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {
    e.receiver._pc = e.srcElement;
    return e;
  });
  window.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}

function shimRemoveStream(window) {
  if (!window.RTCPeerConnection ||
      'removeStream' in window.RTCPeerConnection.prototype) {
    return;
  }
  window.RTCPeerConnection.prototype.removeStream =
    function removeStream(stream) {
      _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('removeStream', 'removeTrack');
      this.getSenders().forEach(sender => {
        if (sender.track && stream.getTracks().includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
}

function shimRTCDataChannel(window) {
  // rename DataChannel to RTCDataChannel (native fix in FF60):
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
  if (window.DataChannel && !window.RTCDataChannel) {
    window.RTCDataChannel = window.DataChannel;
  }
}

function shimAddTransceiver(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!(typeof window === 'object' && window.RTCPeerConnection)) {
    return;
  }
  const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window.RTCPeerConnection.prototype.addTransceiver =
      function addTransceiver() {
        this.setParametersPromises = [];
        const initParameters = arguments[1];
        const shouldPerformCheck = initParameters &&
                                  'sendEncodings' in initParameters;
        if (shouldPerformCheck) {
          // If sendEncodings params are provided, validate grammar
          initParameters.sendEncodings.forEach((encodingParam) => {
            if ('rid' in encodingParam) {
              const ridRegex = /^[a-z0-9]{0,16}$/i;
              if (!ridRegex.test(encodingParam.rid)) {
                throw new TypeError('Invalid RID value provided.');
              }
            }
            if ('scaleResolutionDownBy' in encodingParam) {
              if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
                throw new RangeError('scale_resolution_down_by must be >= 1.0');
              }
            }
            if ('maxFramerate' in encodingParam) {
              if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                throw new RangeError('max_framerate must be >= 0.0');
              }
            }
          });
        }
        const transceiver = origAddTransceiver.apply(this, arguments);
        if (shouldPerformCheck) {
          // Check if the init options were applied. If not we do this in an
          // asynchronous way and save the promise reference in a global object.
          // This is an ugly hack, but at the same time is way more robust than
          // checking the sender parameters before and after the createOffer
          // Also note that after the createoffer we are not 100% sure that
          // the params were asynchronously applied so we might miss the
          // opportunity to recreate offer.
          const {sender} = transceiver;
          const params = sender.getParameters();
          if (!('encodings' in params) ||
              // Avoid being fooled by patched getParameters() below.
              (params.encodings.length === 1 &&
               Object.keys(params.encodings[0]).length === 0)) {
            params.encodings = initParameters.sendEncodings;
            sender.sendEncodings = initParameters.sendEncodings;
            this.setParametersPromises.push(sender.setParameters(params)
              .then(() => {
                delete sender.sendEncodings;
              }).catch(() => {
                delete sender.sendEncodings;
              })
            );
          }
        }
        return transceiver;
      };
  }
}

function shimGetParameters(window) {
  if (!(typeof window === 'object' && window.RTCRtpSender)) {
    return;
  }
  const origGetParameters = window.RTCRtpSender.prototype.getParameters;
  if (origGetParameters) {
    window.RTCRtpSender.prototype.getParameters =
      function getParameters() {
        const params = origGetParameters.apply(this, arguments);
        if (!('encodings' in params)) {
          params.encodings = [].concat(this.sendEncodings || [{}]);
        }
        return params;
      };
  }
}

function shimCreateOffer(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!(typeof window === 'object' && window.RTCPeerConnection)) {
    return;
  }
  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
  window.RTCPeerConnection.prototype.createOffer = function createOffer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises)
      .then(() => {
        return origCreateOffer.apply(this, arguments);
      })
      .finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}

function shimCreateAnswer(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!(typeof window === 'object' && window.RTCPeerConnection)) {
    return;
  }
  const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises)
      .then(() => {
        return origCreateAnswer.apply(this, arguments);
      })
      .finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js":
/*!******************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shimGetDisplayMedia: () => (/* binding */ shimGetDisplayMedia)
/* harmony export */ });
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */


function shimGetDisplayMedia(window, preferredMediaSource) {
  if (window.navigator.mediaDevices &&
    'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!(window.navigator.mediaDevices)) {
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia =
    function getDisplayMedia(constraints) {
      if (!(constraints && constraints.video)) {
        const err = new DOMException('getDisplayMedia without video ' +
            'constraints is undefined');
        err.name = 'NotFoundError';
        // from https://heycam.github.io/webidl/#idl-DOMException-error-names
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = {mediaSource: preferredMediaSource};
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return window.navigator.mediaDevices.getUserMedia(constraints);
    };
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js":
/*!***************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shimGetUserMedia: () => (/* binding */ shimGetUserMedia)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/utils.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */




function shimGetUserMedia(window, browserDetails) {
  const navigator = window && window.navigator;
  const MediaStreamTrack = window && window.MediaStreamTrack;

  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('navigator.getUserMedia',
        'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };

  if (!(browserDetails.version > 55 &&
      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    const remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      if (typeof c === 'object' && typeof c.audio === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        const obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      const nativeApplyConstraints =
        MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c) {
        if (this.kind === 'audio' && typeof c === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/safari/safari_shim.js":
/*!*************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/safari/safari_shim.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   shimAudioContext: () => (/* binding */ shimAudioContext),
/* harmony export */   shimCallbacksAPI: () => (/* binding */ shimCallbacksAPI),
/* harmony export */   shimConstraints: () => (/* binding */ shimConstraints),
/* harmony export */   shimCreateOfferLegacy: () => (/* binding */ shimCreateOfferLegacy),
/* harmony export */   shimGetUserMedia: () => (/* binding */ shimGetUserMedia),
/* harmony export */   shimLocalStreamsAPI: () => (/* binding */ shimLocalStreamsAPI),
/* harmony export */   shimRTCIceServerUrls: () => (/* binding */ shimRTCIceServerUrls),
/* harmony export */   shimRemoteStreamsAPI: () => (/* binding */ shimRemoteStreamsAPI),
/* harmony export */   shimTrackEventTransceiver: () => (/* binding */ shimTrackEventTransceiver)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/utils.js");
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */



function shimLocalStreamsAPI(window) {
  if (typeof window !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getLocalStreams =
      function getLocalStreams() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
  }
  if (!('addStream' in window.RTCPeerConnection.prototype)) {
    const _addTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      // Try to emulate Chrome's behaviour of adding in audio-video order.
      // Safari orders by track id.
      stream.getAudioTracks().forEach(track => _addTrack.call(this, track,
        stream));
      stream.getVideoTracks().forEach(track => _addTrack.call(this, track,
        stream));
    };

    window.RTCPeerConnection.prototype.addTrack =
      function addTrack(track, ...streams) {
        if (streams) {
          streams.forEach((stream) => {
            if (!this._localStreams) {
              this._localStreams = [stream];
            } else if (!this._localStreams.includes(stream)) {
              this._localStreams.push(stream);
            }
          });
        }
        return _addTrack.apply(this, arguments);
      };
  }
  if (!('removeStream' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.removeStream =
      function removeStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        const index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        const tracks = stream.getTracks();
        this.getSenders().forEach(sender => {
          if (tracks.includes(sender.track)) {
            this.removeTrack(sender);
          }
        });
      };
  }
}

function shimRemoteStreamsAPI(window) {
  if (typeof window !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getRemoteStreams =
      function getRemoteStreams() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
  }
  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
      get() {
        return this._onaddstream;
      },
      set(f) {
        if (this._onaddstream) {
          this.removeEventListener('addstream', this._onaddstream);
          this.removeEventListener('track', this._onaddstreampoly);
        }
        this.addEventListener('addstream', this._onaddstream = f);
        this.addEventListener('track', this._onaddstreampoly = (e) => {
          e.streams.forEach(stream => {
            if (!this._remoteStreams) {
              this._remoteStreams = [];
            }
            if (this._remoteStreams.includes(stream)) {
              return;
            }
            this._remoteStreams.push(stream);
            const event = new Event('addstream');
            event.stream = stream;
            this.dispatchEvent(event);
          });
        });
      }
    });
    const origSetRemoteDescription =
      window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription =
      function setRemoteDescription() {
        const pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener('track', this._onaddstreampoly = function(e) {
            e.streams.forEach(stream => {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              const event = new Event('addstream');
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
  }
}

function shimCallbacksAPI(window) {
  if (typeof window !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  const prototype = window.RTCPeerConnection.prototype;
  const origCreateOffer = prototype.createOffer;
  const origCreateAnswer = prototype.createAnswer;
  const setLocalDescription = prototype.setLocalDescription;
  const setRemoteDescription = prototype.setRemoteDescription;
  const addIceCandidate = prototype.addIceCandidate;

  prototype.createOffer =
    function createOffer(successCallback, failureCallback) {
      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      const promise = origCreateOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

  prototype.createAnswer =
    function createAnswer(successCallback, failureCallback) {
      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      const promise = origCreateAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

  let withCallback = function(description, successCallback, failureCallback) {
    const promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;

  withCallback = function(description, successCallback, failureCallback) {
    const promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;

  withCallback = function(candidate, successCallback, failureCallback) {
    const promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}

function shimGetUserMedia(window) {
  const navigator = window && window.navigator;

  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    // shim not needed in Safari 12.1
    const mediaDevices = navigator.mediaDevices;
    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator.mediaDevices.getUserMedia = (constraints) => {
      return _getUserMedia(shimConstraints(constraints));
    };
  }

  if (!navigator.getUserMedia && navigator.mediaDevices &&
    navigator.mediaDevices.getUserMedia) {
    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
      navigator.mediaDevices.getUserMedia(constraints)
      .then(cb, errcb);
    }.bind(navigator);
  }
}

function shimConstraints(constraints) {
  if (constraints && constraints.video !== undefined) {
    return Object.assign({},
      constraints,
      {video: _utils__WEBPACK_IMPORTED_MODULE_0__.compactObject(constraints.video)}
    );
  }

  return constraints;
}

function shimRTCIceServerUrls(window) {
  if (!window.RTCPeerConnection) {
    return;
  }
  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
  const OrigPeerConnection = window.RTCPeerConnection;
  window.RTCPeerConnection =
    function RTCPeerConnection(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        const newIceServers = [];
        for (let i = 0; i < pcConfig.iceServers.length; i++) {
          let server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') &&
              server.hasOwnProperty('url')) {
            _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  // wrap static methods. Currently just generateCertificate.
  if ('generateCertificate' in OrigPeerConnection) {
    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
      get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}

function shimTrackEventTransceiver(window) {
  // Add event.transceiver member over deprecated event.receiver
  if (typeof window === 'object' && window.RTCTrackEvent &&
      'receiver' in window.RTCTrackEvent.prototype &&
      !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get() {
        return {receiver: this.receiver};
      }
    });
  }
}

function shimCreateOfferLegacy(window) {
  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
  window.RTCPeerConnection.prototype.createOffer =
    function createOffer(offerOptions) {
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveAudio =
            !!offerOptions.offerToReceiveAudio;
        }
        const audioTransceiver = this.getTransceivers().find(transceiver =>
          transceiver.receiver.track.kind === 'audio');
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('sendonly');
            } else {
              audioTransceiver.direction = 'sendonly';
            }
          } else if (audioTransceiver.direction === 'recvonly') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('inactive');
            } else {
              audioTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true &&
            !audioTransceiver) {
          this.addTransceiver('audio', {direction: 'recvonly'});
        }

        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveVideo =
            !!offerOptions.offerToReceiveVideo;
        }
        const videoTransceiver = this.getTransceivers().find(transceiver =>
          transceiver.receiver.track.kind === 'video');
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection('sendonly');
            } else {
              videoTransceiver.direction = 'sendonly';
            }
          } else if (videoTransceiver.direction === 'recvonly') {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection('inactive');
            } else {
              videoTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveVideo === true &&
            !videoTransceiver) {
          this.addTransceiver('video', {direction: 'recvonly'});
        }
      }
      return origCreateOffer.apply(this, arguments);
    };
}

function shimAudioContext(window) {
  if (typeof window !== 'object' || window.AudioContext) {
    return;
  }
  window.AudioContext = window.webkitAudioContext;
}



/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/utils.js":
/*!************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/webrtc-adapter/src/js/utils.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compactObject: () => (/* binding */ compactObject),
/* harmony export */   deprecated: () => (/* binding */ deprecated),
/* harmony export */   detectBrowser: () => (/* binding */ detectBrowser),
/* harmony export */   disableLog: () => (/* binding */ disableLog),
/* harmony export */   disableWarnings: () => (/* binding */ disableWarnings),
/* harmony export */   extractVersion: () => (/* binding */ extractVersion),
/* harmony export */   filterStats: () => (/* binding */ filterStats),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   walkStats: () => (/* binding */ walkStats),
/* harmony export */   wrapPeerConnectionEvent: () => (/* binding */ wrapPeerConnectionEvent)
/* harmony export */ });
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


let logDisabled_ = true;
let deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  const match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object (or false to prevent
// the event).
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  const proto = window.RTCPeerConnection.prototype;
  const nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    const wrappedCallback = (e) => {
      const modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        if (cb.handleEvent) {
          cb.handleEvent(modifiedEvent);
        } else {
          cb(modifiedEvent);
        }
      }
    };
    this._eventMap = this._eventMap || {};
    if (!this._eventMap[eventNameToWrap]) {
      this._eventMap[eventNameToWrap] = new Map();
    }
    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
    return nativeAddEventListener.apply(this, [nativeEventName,
      wrappedCallback]);
  };

  const nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap
        || !this._eventMap[eventNameToWrap]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    if (!this._eventMap[eventNameToWrap].has(cb)) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
    this._eventMap[eventNameToWrap].delete(cb);
    if (this._eventMap[eventNameToWrap].size === 0) {
      delete this._eventMap[eventNameToWrap];
    }
    if (Object.keys(this._eventMap).length === 0) {
      delete this._eventMap;
    }
    return nativeRemoveEventListener.apply(this, [nativeEventName,
      unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get() {
      return this['_on' + eventNameToWrap];
    },
    set(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap] = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
}

function disableLog(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + typeof bool +
        '. Please use a boolean.');
  }
  logDisabled_ = bool;
  return (bool) ? 'adapter.js logging disabled' :
      'adapter.js logging enabled';
}

/**
 * Disable or enable deprecation warnings
 * @param {!boolean} bool set to true to disable warnings.
 */
function disableWarnings(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + typeof bool +
        '. Please use a boolean.');
  }
  deprecationWarnings_ = !bool;
  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
}

function log() {
  if (typeof window === 'object') {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== 'undefined' && typeof console.log === 'function') {
      console.log.apply(console, arguments);
    }
  }
}

/**
 * Shows a deprecation warning suggesting the modern and spec-compatible API.
 */
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
      ' instead.');
}

/**
 * Browser detector.
 *
 * @return {object} result containing browser and version
 *     properties.
 */
function detectBrowser(window) {
  // Returned result object.
  const result = {browser: null, version: null};

  // Fail early if it's not a browser
  if (typeof window === 'undefined' || !window.navigator) {
    result.browser = 'Not a browser.';
    return result;
  }

  const {navigator} = window;

  if (navigator.mozGetUserMedia) { // Firefox.
    result.browser = 'firefox';
    result.version = extractVersion(navigator.userAgent,
        /Firefox\/(\d+)\./, 1);
  } else if (navigator.webkitGetUserMedia ||
      (window.isSecureContext === false && window.webkitRTCPeerConnection &&
       !window.RTCIceGatherer)) {
    // Chrome, Chromium, Webview, Opera.
    // Version matches Chrome/WebRTC version.
    // Chrome 74 removed webkitGetUserMedia on http as well so we need the
    // more complicated fallback to webkitRTCPeerConnection.
    result.browser = 'chrome';
    result.version = extractVersion(navigator.userAgent,
        /Chrom(e|ium)\/(\d+)\./, 2);
  } else if (window.RTCPeerConnection &&
      navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) { // Safari.
    result.browser = 'safari';
    result.version = extractVersion(navigator.userAgent,
        /AppleWebKit\/(\d+)\./, 1);
    result.supportsUnifiedPlan = window.RTCRtpTransceiver &&
        'currentDirection' in window.RTCRtpTransceiver.prototype;
  } else { // Default fallthrough: not supported.
    result.browser = 'Not a supported browser.';
    return result;
  }

  return result;
}

/**
 * Checks if something is an object.
 *
 * @param {*} val The something you want to check.
 * @return true if val is an object, false otherwise.
 */
function isObject(val) {
  return Object.prototype.toString.call(val) === '[object Object]';
}

/**
 * Remove all empty objects and undefined values
 * from a nested object -- an enhanced and vanilla version
 * of Lodash's `compact`.
 */
function compactObject(data) {
  if (!isObject(data)) {
    return data;
  }

  return Object.keys(data).reduce(function(accumulator, key) {
    const isObj = isObject(data[key]);
    const value = isObj ? compactObject(data[key]) : data[key];
    const isEmptyObject = isObj && !Object.keys(value).length;
    if (value === undefined || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, {[key]: value});
  }, {});
}

/* iterates the stats graph recursively. */
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(name => {
    if (name.endsWith('Id')) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith('Ids')) {
      base[name].forEach(id => {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}

/* filter getStats for a sender/receiver track. */
function filterStats(result, track, outbound) {
  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
  const filteredResult = new Map();
  if (track === null) {
    return filteredResult;
  }
  const trackStats = [];
  result.forEach(value => {
    if (value.type === 'track' &&
        value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(trackStat => {
    result.forEach(stats => {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}



/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/index.js":
/*!*****************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const WebSocket = __webpack_require__(/*! ./lib/websocket */ "../../lib-jitsi-meet/node_modules/ws/lib/websocket.js");

WebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ "../../lib-jitsi-meet/node_modules/ws/lib/stream.js");
WebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ "../../lib-jitsi-meet/node_modules/ws/lib/websocket-server.js");
WebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ "../../lib-jitsi-meet/node_modules/ws/lib/receiver.js");
WebSocket.Sender = __webpack_require__(/*! ./lib/sender */ "../../lib-jitsi-meet/node_modules/ws/lib/sender.js");

WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;

module.exports = WebSocket;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/buffer-util.js":
/*!***************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/buffer-util.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "../../lib-jitsi-meet/node_modules/ws/lib/constants.js");

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

module.exports = {
  concat,
  mask: _mask,
  toArrayBuffer,
  toBuffer,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!({"NODE_ENV":"development"}).WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = __webpack_require__(/*! bufferutil */ "?26cc");

    module.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    module.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/constants.js":
/*!*************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/constants.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/event-target.js":
/*!****************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/event-target.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ "../../lib-jitsi-meet/node_modules/ws/lib/constants.js");

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute] &&
        listener[kListener] === handler &&
        !listener[kForOnEventAttribute]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/extension.js":
/*!*************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/extension.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "../../lib-jitsi-meet/node_modules/ws/lib/validation.js");

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/limiter.js":
/*!***********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/limiter.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/permessage-deflate.js":
/*!**********************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/permessage-deflate.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const zlib = __webpack_require__(/*! zlib */ "?3d0e");

const bufferUtil = __webpack_require__(/*! ./buffer-util */ "../../lib-jitsi-meet/node_modules/ws/lib/buffer-util.js");
const Limiter = __webpack_require__(/*! ./limiter */ "../../lib-jitsi-meet/node_modules/ws/lib/limiter.js");
const { kStatusCode } = __webpack_require__(/*! ./constants */ "../../lib-jitsi-meet/node_modules/ws/lib/constants.js");

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/receiver.js":
/*!************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/receiver.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Writable } = __webpack_require__(/*! stream */ "?8d1b");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../lib-jitsi-meet/node_modules/ws/lib/permessage-deflate.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(/*! ./constants */ "../../lib-jitsi-meet/node_modules/ws/lib/constants.js");
const { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ "../../lib-jitsi-meet/node_modules/ws/lib/buffer-util.js");
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ "../../lib-jitsi-meet/node_modules/ws/lib/validation.js");

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );
      }

      if (compressed) {
        this._loop = false;
        return error(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );
      }
    } else {
      this._loop = false;
      return error(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );
      }
    } else if (this._masked) {
      this._loop = false;
      return error(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(
              RangeError,
              'Max payload size exceeded',
              false,
              1009,
              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
            )
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data, true);
      } else {
        const buf = concat(fragments, messageLength);

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          this._loop = false;
          return error(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );
        }

        this.emit('message', buf, false);
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else if (data.length === 1) {
        return error(
          RangeError,
          'invalid payload length 1',
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );
        }

        const buf = data.slice(2);

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          return error(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );
        }

        this.emit('conclude', code, buf);
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @param {String} errorCode The exposed error code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode, errorCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err.code = errorCode;
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/sender.js":
/*!**********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/sender.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls$" }] */



const net = __webpack_require__(/*! net */ "?18a9");
const tls = __webpack_require__(/*! tls */ "?eccb");
const { randomFillSync } = __webpack_require__(/*! crypto */ "?5011");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../lib-jitsi-meet/node_modules/ws/lib/permessage-deflate.js");
const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "../../lib-jitsi-meet/node_modules/ws/lib/constants.js");
const { isValidStatusCode } = __webpack_require__(/*! ./validation */ "../../lib-jitsi-meet/node_modules/ws/lib/validation.js");
const { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ "../../lib-jitsi-meet/node_modules/ws/lib/buffer-util.js");

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {(net.Socket|tls.Socket)} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        randomFillSync(mask, 0, 4);
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const params = this._queue[i];
          const callback = params[params.length - 1];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/stream.js":
/*!**********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/stream.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Duplex } = __webpack_require__(/*! stream */ "?8d1b");

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/subprotocol.js":
/*!***************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/subprotocol.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "../../lib-jitsi-meet/node_modules/ws/lib/validation.js");

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/validation.js":
/*!**************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/validation.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

module.exports = {
  isValidStatusCode,
  isValidUTF8: _isValidUTF8,
  tokenChars
};

/* istanbul ignore else  */
if (!({"NODE_ENV":"development"}).WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ "?8c93");

    module.exports.isValidUTF8 = function (buf) {
      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/websocket-server.js":
/*!********************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/websocket-server.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls|https$" }] */



const EventEmitter = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
const http = __webpack_require__(/*! http */ "?1d87");
const https = __webpack_require__(/*! https */ "?8b60");
const net = __webpack_require__(/*! net */ "?18a9");
const tls = __webpack_require__(/*! tls */ "?eccb");
const { createHash } = __webpack_require__(/*! crypto */ "?5011");

const extension = __webpack_require__(/*! ./extension */ "../../lib-jitsi-meet/node_modules/ws/lib/extension.js");
const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../lib-jitsi-meet/node_modules/ws/lib/permessage-deflate.js");
const subprotocol = __webpack_require__(/*! ./subprotocol */ "../../lib-jitsi-meet/node_modules/ws/lib/subprotocol.js");
const WebSocket = __webpack_require__(/*! ./websocket */ "../../lib-jitsi-meet/node_modules/ws/lib/websocket.js");
const { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ "../../lib-jitsi-meet/node_modules/ws/lib/constants.js");

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (req.headers.upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!key || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message);
  }
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/ws/lib/websocket.js":
/*!*************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/ws/lib/websocket.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Readable$" }] */



const EventEmitter = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");
const https = __webpack_require__(/*! https */ "?8b60");
const http = __webpack_require__(/*! http */ "?1d87");
const net = __webpack_require__(/*! net */ "?18a9");
const tls = __webpack_require__(/*! tls */ "?eccb");
const { randomBytes, createHash } = __webpack_require__(/*! crypto */ "?5011");
const { Readable } = __webpack_require__(/*! stream */ "?8d1b");
const { URL } = __webpack_require__(/*! url */ "?5a20");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "../../lib-jitsi-meet/node_modules/ws/lib/permessage-deflate.js");
const Receiver = __webpack_require__(/*! ./receiver */ "../../lib-jitsi-meet/node_modules/ws/lib/receiver.js");
const Sender = __webpack_require__(/*! ./sender */ "../../lib-jitsi-meet/node_modules/ws/lib/sender.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(/*! ./constants */ "../../lib-jitsi-meet/node_modules/ws/lib/constants.js");
const {
  EventTarget: { addEventListener, removeEventListener }
} = __webpack_require__(/*! ./event-target */ "../../lib-jitsi-meet/node_modules/ws/lib/event-target.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "../../lib-jitsi-meet/node_modules/ws/lib/extension.js");
const { toBuffer } = __webpack_require__(/*! ./buffer-util */ "../../lib-jitsi-meet/node_modules/ws/lib/buffer-util.js");

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    this._sender = new Sender(socket, this._extensions, options.generateMask);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }

    websocket._url = address;
  }

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
        ? false
        : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    if (res.headers.upgrade.toLowerCase() !== 'websocket') {
      abortHandshake(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  req.end();
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  websocket.emit('error', err);
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ "?9d57":
/*!********************************!*\
  !*** @xmldom/xmldom (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?26cc":
/*!****************************!*\
  !*** bufferutil (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?5011":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?1d87":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?8b60":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?18a9":
/*!*********************!*\
  !*** net (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?8d1b":
/*!************************!*\
  !*** stream (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?eccb":
/*!*********************!*\
  !*** tls (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?5a20":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?8c93":
/*!********************************!*\
  !*** utf-8-validate (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?3d0e":
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/avatar/index.js":
/*!*************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/js-utils/avatar/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGravatarURL: () => (/* binding */ getGravatarURL)
/* harmony export */ });
/* harmony import */ var js_md5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-md5 */ "../../lib-jitsi-meet/node_modules/js-md5/src/md5.js");


/**
 * Returns the Gravatar URL of a given email id.
 *
 * @param {string} key - Email or id for which we need gravatar URL.
 * @param {string} baseURL - Base Gravatar URL.
 * @returns {string} - Gravatar URL.
 */
function getGravatarURL(key, baseURL = 'https://seccdn.libravatar.org/avatar/') {
    const urlSuffix = '?d=404&size=200';

    // If the key is a valid email, we hash it. If it's not, we assume it's already a hashed format
    const avatarKey = isValidEmail(key) ? js_md5__WEBPACK_IMPORTED_MODULE_0__.hex(key.trim().toLowerCase()) : key;

    return `${baseURL}${avatarKey}${urlSuffix}`;
}

/**
 * Returns if the email id is valid.
 *
 * @param {string} email - Email id to be checked.
 * @returns {boolean}
 */
function isValidEmail(email) {
    return email && email.indexOf('@') > 0;
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-capabilities/BrowserCapabilities.js":
/*!*****************************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-capabilities/BrowserCapabilities.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BrowserCapabilities)
/* harmony export */ });
/* harmony import */ var _browser_detection_BrowserDetection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../browser-detection/BrowserDetection.js */ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-detection/BrowserDetection.js");


// TODO: Move BrowserCapabilities from lib-jitsi-meet here and use the JSON
// format for them.

/**
 * Implements browser capabilities for lib-jitsi-meet.
 */
class BrowserCapabilities {
    /**
     * Creates new BrowserCapabilities instance.
     *
     * @param {Object} capabilitiesDB - The JSON database with capabilities.
     * @param {boolean} [isUsingIFrame] - True if Jitsi Meet is loaded in iframe
     * and false otherwise.
     * @param {Object} [browserInfo] - Information about the browser.
     * @param {string} browserInfo.name - The name of the browser.
     * @param {string} browserInfo.version - The version of the browser.
     */
    constructor(capabilitiesDB = {}, isUsingIFrame = false, browserInfo) {
        const browser = new _browser_detection_BrowserDetection_js__WEBPACK_IMPORTED_MODULE_0__["default"](browserInfo);
        let capabilitiesByVersion;

        // If the capabilitiesDB is not in the correct format or the type of the
        // version of the browser is undefined(the version is unknown) or the
        // version type is not compatible (not a string) we'll consider the
        // browser as not supported.
        if (typeof capabilitiesDB === 'object'
                && typeof browser.getVersion() === 'string') {
            const browserCapabilities = capabilitiesDB[browser.getName()] || [];

            for (let i = 0; i < browserCapabilities.length; i++) {
                const capabilities = browserCapabilities[i];

                if (typeof capabilities !== 'object') {
                    // eslint-disable-next-line no-continue
                    continue;
                }

                const version = capabilities.version;

                if (!version || !browser.isVersionGreaterThan(version)) {
                    capabilitiesByVersion = capabilities;
                    break;
                }
            }
        }

        if (!capabilitiesByVersion || !capabilitiesByVersion.capabilities) {
            this._capabilities = { isSupported: false };
        } else if (isUsingIFrame) {
            this._capabilities = {
                ...capabilitiesByVersion.capabilities,
                ...capabilitiesByVersion.iframeCapabilities
            };
        } else {
            this._capabilities = capabilitiesByVersion.capabilities;
        }

        if (typeof this._capabilities.isSupported === 'undefined') {
            // we have some capabilities but isSupported property is not filled.
            this._capabilities.isSupported = true;
        } else if (this._capabilities.isSupported === false) {
            // Clean the other capabilities.
            this._capabilities = { isSupported: false };
        }
    }

    /**
     * Checks whether the browser is supported by Jitsi Meet.
     *
     * @returns {boolean}
     */
    isSupported() {
        return this._capabilities.isSupported;
    }

    /**
     * Checks whether the browser supports incoming audio.
     *
     * @returns {boolean}
     */
    supportsAudioIn() {
        return this._capabilities.audioIn || false;
    }

    /**
     * Checks whether the browser supports outgoing audio.
     *
     * @returns {boolean}
     */
    supportsAudioOut() {
        return this._capabilities.audioOut || false;
    }


    /**
     * Checks whether the browser supports screen sharing.
     *
     * @returns {boolean}
     */
    supportsScreenSharing() {
        return this._capabilities.screenSharing || false;
    }

    /**
     * Checks whether the browser supports incomming video.
     *
     * @returns {boolean}
     */
    supportsVideoIn() {
        return this._capabilities.videoIn || false;
    }

    /**
     * Checks whether the browser supports outgoing video.
     *
     * @returns {boolean}
     */
    supportsVideoOut() {
        return this._capabilities.videoOut || false;
    }
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-capabilities/index.js":
/*!***************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-capabilities/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserCapabilities: () => (/* reexport safe */ _BrowserCapabilities_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _BrowserCapabilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BrowserCapabilities.js */ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-capabilities/BrowserCapabilities.js");



/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-detection/BrowserDetection.js":
/*!***********************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-detection/BrowserDetection.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BrowserDetection)
/* harmony export */ });
/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bowser */ "../../lib-jitsi-meet/node_modules/bowser/es5.js");
/* harmony import */ var _browsers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./browsers.js */ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-detection/browsers.js");




/**
 * Maps the names of the browsers from bowser to the internal names defined in
 * ./browsers.js
 */
const bowserNameToJitsiName = {
    'Chrome': _browsers_js__WEBPACK_IMPORTED_MODULE_1__.CHROME,
    'Chromium': _browsers_js__WEBPACK_IMPORTED_MODULE_1__.CHROME,
    'Opera': _browsers_js__WEBPACK_IMPORTED_MODULE_1__.OPERA,
    'Firefox': _browsers_js__WEBPACK_IMPORTED_MODULE_1__.FIREFOX,
    'Internet Explorer': _browsers_js__WEBPACK_IMPORTED_MODULE_1__.INTERNET_EXPLORER,
    'Safari': _browsers_js__WEBPACK_IMPORTED_MODULE_1__.SAFARI
};

/**
 * Detects a Chromium based environent.
 *
 * NOTE: Here we cannot check solely for "Chrome" in the UA, because Edge has
 * it too. We need to check explicitly for chromium based Edge first and then
 * detect other chromium based browsers.
 *
 * @returns {Object|undefined} - The name (CHROME) and version.
 */
function _detectChromiumBased() {
    const userAgent = navigator.userAgent;
    const browserInfo = {
        name: _browsers_js__WEBPACK_IMPORTED_MODULE_1__.UNKNOWN,
        version: undefined
    };

    if (userAgent.match(/Chrome/) && !userAgent.match(/Edge/)) {
        // Edge is currenly supported only on desktop and android.
        if (userAgent.match(/Edg(A?)/)) {
            // Compare the underlying chromium version.
            const version = userAgent.match(/Chrome\/([\d.]+)/)[1];

            if (Number.parseInt(version, 10) > 72) {
                browserInfo.name = _browsers_js__WEBPACK_IMPORTED_MODULE_1__.CHROME;
                browserInfo.version = version;
            }
        } else {
            browserInfo.name = _browsers_js__WEBPACK_IMPORTED_MODULE_1__.CHROME;
            browserInfo.version = userAgent.match(/Chrome\/([\d.]+)/)[1];
        }
    }

    return browserInfo;
}

/**
 * Detects Electron environment.
 *
 * @returns {Object|undefined} - The name (ELECTRON) and version.
 */
function _detectElectron() {
    const userAgent = navigator.userAgent;

    if (userAgent.match(/Electron/)) {
        const version = userAgent.match(/Electron(?:\s|\/)([\d.]+)/)[1];

        return {
            name: _browsers_js__WEBPACK_IMPORTED_MODULE_1__.ELECTRON,
            version
        };
    } else if (typeof window.JitsiMeetElectron !== 'undefined') {
        return {
            name: _browsers_js__WEBPACK_IMPORTED_MODULE_1__.ELECTRON,
            version: undefined
        };
    }
}

/**
 * Detects NWJS environment.
 *
 * @returns {Object|undefined} - The name (NWJS) and version.
 */
function _detectNWJS() {
    const userAgent = navigator.userAgent;

    if (userAgent.match(/JitsiMeetNW/)) {
        const version = userAgent.match(/JitsiMeetNW\/([\d.]+)/)[1];

        return {
            name: _browsers_js__WEBPACK_IMPORTED_MODULE_1__.NWJS,
            version
        };
    }
}

/**
 * Detects React Native environment.
 * @returns {Object|undefined} - The name (REACT_NATIVE) and version.
 */
function _detectReactNative() {
    const match
        = navigator.userAgent.match(/\b(react[ \t_-]*native)(?:\/(\S+))?/i);
    let version;

    // If we're remote debugging a React Native app, it may be treated as
    // Chrome. Check navigator.product as well and always return some version
    // even if we can't get the real one.

    if (match || navigator.product === 'ReactNative') {
        let name;

        if (match && match.length > 2) {
            name = match[1];
            version = match[2];
        }
        name || (name = 'react-native');
        version || (version = 'unknown');

        return {
            name: _browsers_js__WEBPACK_IMPORTED_MODULE_1__.REACT_NATIVE,
            version
        };
    }
}

/**
 * Returns information about the current browser.
 * @param {Object} - The bowser instance.
 * @returns {Object} - The name and version of the browser.
 */
function _detect(bowser) {
    let browserInfo;
    const detectors = [
        _detectReactNative,
        _detectElectron,
        _detectNWJS
    ];

    // Try all browser detectors
    for (let i = 0; i < detectors.length; i++) {
        browserInfo = detectors[i]();
        if (browserInfo) {
            return browserInfo;
        }
    }

    const name = bowser.getBrowserName();

    if (name in bowserNameToJitsiName) {
        return {
            name: bowserNameToJitsiName[name],
            version: bowser.getBrowserVersion()
        };
    }

    // Detect other browsers with the Chrome engine, such as Vivaldi and Brave.
    browserInfo = _detectChromiumBased();
    if (browserInfo) {
        return browserInfo;
    }

    return {
        name: _browsers_js__WEBPACK_IMPORTED_MODULE_1__.UNKNOWN,
        version: undefined
    };
}

/**
 * Implements browser detection.
 */
class BrowserDetection {
    /**
     * Creates new BrowserDetection instance.
     *
     * @param {Object} [browserInfo] - Information about the browser.
     * @param {string} browserInfo.name - The name of the browser.
     * @param {string} browserInfo.version - The version of the browser.
     */
    constructor(browserInfo) {
        let name, version;

        this._bowser = bowser__WEBPACK_IMPORTED_MODULE_0__.getParser(navigator.userAgent);
        if (typeof browserInfo === 'undefined') {
            const detectedBrowserInfo = _detect(this._bowser);

            name = detectedBrowserInfo.name;
            version = detectedBrowserInfo.version;
        } else if (browserInfo.name in bowserNameToJitsiName) {
            name = bowserNameToJitsiName[browserInfo.name];
            version = browserInfo.version;
        } else {
            name = _browsers_js__WEBPACK_IMPORTED_MODULE_1__.UNKNOWN;
            version = undefined;
        }

        this._name = name;
        this._version = version;
    }

    /**
     * Gets current browser name.
     * @returns {string}
     */
    getName() {
        return this._name;
    }

    /**
     * Checks if current browser is Chrome.
     * @returns {boolean}
     */
    isChrome() {
        return this._name === _browsers_js__WEBPACK_IMPORTED_MODULE_1__.CHROME;
    }

    /**
     * Checks if current browser is Opera.
     * @returns {boolean}
     */
    isOpera() {
        return this._name === _browsers_js__WEBPACK_IMPORTED_MODULE_1__.OPERA;
    }

    /**
     * Checks if current browser is Firefox.
     * @returns {boolean}
     */
    isFirefox() {
        return this._name === _browsers_js__WEBPACK_IMPORTED_MODULE_1__.FIREFOX;
    }

    /**
     * Checks if current browser is Internet Explorer.
     * @returns {boolean}
     */
    isIExplorer() {
        return this._name === _browsers_js__WEBPACK_IMPORTED_MODULE_1__.INTERNET_EXPLORER;
    }

    /**
     * Checks if current browser is Safari.
     * @returns {boolean}
     */
    isSafari() {
        return this._name === _browsers_js__WEBPACK_IMPORTED_MODULE_1__.SAFARI;
    }

    /**
     * Checks if current environment is NWJS.
     * @returns {boolean}
     */
    isNWJS() {
        return this._name === _browsers_js__WEBPACK_IMPORTED_MODULE_1__.NWJS;
    }

    /**
     * Checks if current environment is Electron.
     * @returns {boolean}
     */
    isElectron() {
        return this._name === _browsers_js__WEBPACK_IMPORTED_MODULE_1__.ELECTRON;
    }

    /**
     * Checks if current environment is React Native.
     * @returns {boolean}
     */
    isReactNative() {
        return this._name === _browsers_js__WEBPACK_IMPORTED_MODULE_1__.REACT_NATIVE;
    }

    /**
     * Returns the version of the current browser.
     * @returns {string}
     */
    getVersion() {
        return this._version;
    }

    /**
     * Check if the parsed browser matches the passed condition.
     *
     * @param {Object} checkTree - It's one or two layered object, which can include a
     * platform or an OS on the first layer and should have browsers specs on the
     * bottom layer.
     * Eg. { chrome: '>71.1.0' }
     *     { windows: { chrome: '<70.2' } }
     * @returns {boolean | undefined} - Returns true if the browser satisfies the set
     * conditions, false if not and undefined when the browser is not defined in the
     * checktree object or when the current browser's version is unknown.
     * @private
     */
    _checkCondition(checkTree) {
        if (this._version) {
            return this._bowser.satisfies(checkTree);
        }
    }

    /**
     * Compares the passed version with the current browser version.
     *
     * @param {*} version - The version to compare with. Anything different
     * than string will be converted to string.
     * @returns {boolean|undefined} - Returns true if the current version is
     * greater than the passed version and false otherwise. Returns undefined if
     * the current browser version is unknown.
     */
    isVersionGreaterThan(version) {
        return this._checkCondition({ [this._name]: `>${version}` });
    }

    /**
     * Compares the passed version with the current browser version.
     *
     * @param {*} version - The version to compare with. Anything different
     * than string will be converted to string.
     * @returns {boolean|undefined} - Returns true if the current version is
     * lower than the passed version and false otherwise. Returns undefined if
     * the current browser version is unknown.
     */
    isVersionLessThan(version) {
        return this._checkCondition({ [this._name]: `<${version}` });
    }

    /**
     * Compares the passed version with the current browser version.
     *
     * @param {*} version - The version to compare with. Anything different
     * than string will be converted to string.
     * @returns {boolean|undefined} - Returns true if the current version is
     * equal to the passed version and false otherwise. Returns undefined if
     * the current browser version is unknown.
     * A loose-equality operator is used here so that it matches the sub-versions as well.
     */
    isVersionEqualTo(version) {
        return this._checkCondition({ [this._name]: `~${version}` });
    }
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-detection/browsers.js":
/*!***************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-detection/browsers.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHROME: () => (/* binding */ CHROME),
/* harmony export */   ELECTRON: () => (/* binding */ ELECTRON),
/* harmony export */   FIREFOX: () => (/* binding */ FIREFOX),
/* harmony export */   INTERNET_EXPLORER: () => (/* binding */ INTERNET_EXPLORER),
/* harmony export */   NWJS: () => (/* binding */ NWJS),
/* harmony export */   OPERA: () => (/* binding */ OPERA),
/* harmony export */   REACT_NATIVE: () => (/* binding */ REACT_NATIVE),
/* harmony export */   SAFARI: () => (/* binding */ SAFARI),
/* harmony export */   UNKNOWN: () => (/* binding */ UNKNOWN)
/* harmony export */ });
// TODO: Maybe fix the values to 'Chrome', 'Internet Explorer', etc. Currently
// this values needs to be as they are becuse they are going to analytics,
// callstats, etc.

const CHROME = 'chrome';

const OPERA = 'opera';

const FIREFOX = 'firefox';

const INTERNET_EXPLORER = 'iexplorer';

const SAFARI = 'safari';

const NWJS = 'nwjs';

const ELECTRON = 'electron';

const REACT_NATIVE = 'react-native';

const UNKNOWN = 'unknown';


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-detection/index.js":
/*!************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-detection/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserDetection: () => (/* reexport safe */ _BrowserDetection_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   browsers: () => (/* reexport module object */ _browsers_js__WEBPACK_IMPORTED_MODULE_1__)
/* harmony export */ });
/* harmony import */ var _BrowserDetection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BrowserDetection.js */ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-detection/BrowserDetection.js");
/* harmony import */ var _browsers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./browsers.js */ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-detection/browsers.js");





/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/index.js":
/*!******************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/js-utils/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserCapabilities: () => (/* reexport safe */ _browser_capabilities_index_js__WEBPACK_IMPORTED_MODULE_1__.BrowserCapabilities),
/* harmony export */   BrowserDetection: () => (/* reexport safe */ _browser_detection_index_js__WEBPACK_IMPORTED_MODULE_2__.BrowserDetection),
/* harmony export */   browsers: () => (/* reexport safe */ _browser_detection_index_js__WEBPACK_IMPORTED_MODULE_2__.browsers),
/* harmony export */   getGravatarURL: () => (/* reexport safe */ _avatar_index_js__WEBPACK_IMPORTED_MODULE_0__.getGravatarURL),
/* harmony export */   jitsiLocalStorage: () => (/* reexport safe */ _jitsi_local_storage_index_js__WEBPACK_IMPORTED_MODULE_3__.jitsiLocalStorage)
/* harmony export */ });
/* harmony import */ var _avatar_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avatar/index.js */ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/avatar/index.js");
/* harmony import */ var _browser_capabilities_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./browser-capabilities/index.js */ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-capabilities/index.js");
/* harmony import */ var _browser_detection_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./browser-detection/index.js */ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/browser-detection/index.js");
/* harmony import */ var _jitsi_local_storage_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jitsi-local-storage/index.js */ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/jitsi-local-storage/index.js");






/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/js-utils/jitsi-local-storage/index.js":
/*!**************************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/js-utils/jitsi-local-storage/index.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   jitsiLocalStorage: () => (/* binding */ jitsiLocalStorage)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "../../lib-jitsi-meet/node_modules/events/events.js");


/**
 * Dummy implementation of Storage interface.
 */
class DummyLocalStorage extends events__WEBPACK_IMPORTED_MODULE_0__ {

    /**
     * The object used for storage.
     */
    _storage = {};

    /**
     * Empties all keys out of the storage.
     *
     * @returns {void}
     */
    clear() {
        this._storage = {};
    }

    /**
     * Returns the number of data items stored in the Storage object.
     *
     * @returns {number} - The number of data items stored in the Storage object.
     */
    get length() {
        return Object.keys(this._storage).length;
    }

    /**
     * Will return that key's value associated to the passed key name.
     *
     * @param {string} keyName - The key name.
     * @returns {*} - The key value.
     */
    getItem(keyName) {
        return this._storage[keyName];
    }

    /**
     * When passed a key name and value, will add that key to the storage,
     * or update that key's value if it already exists.
     *
     * @param {string} keyName - The key name.
     * @param {*} keyValue - The key value.
     * @returns {void}
     */
    setItem(keyName, keyValue) {
        this._storage[keyName] = keyValue;
    }

    /**
     * When passed a key name, will remove that key from the storage.
     *
     * @param {string} keyName - The key name.
     * @returns {void}
     */
    removeItem(keyName) {
        delete this._storage[keyName];
    }

    /**
     * When passed a number n, this method will return the name of the nth key in the storage.
     *
     * @param {number} idx - The index of the key.
     * @returns {string} - The nth key name.
     */
    key(n) {
        const keys = Object.keys(this._storage);

        if (keys.length <= n) {
            return undefined;
        }

        return keys[n];
    }

    /**
     * Serializes the content of the storage.
     *
     * @returns {string} - The serialized content.
     */
    serialize() {
        return JSON.stringify(this._storage);
    }
}

/**
 * Wrapper class for browser's local storage object.
 */
class JitsiLocalStorage extends events__WEBPACK_IMPORTED_MODULE_0__ {
    /**
     * @constructor
     * @param {Storage} storage browser's local storage object.
     */
    constructor() {
        super();

        try {
            this._storage = window.localStorage;
            this._localStorageDisabled = false;
        } catch (ignore) {
            // localStorage throws an exception.
        }

        if (!this._storage) { // Handles the case when window.localStorage is undefined or throws an exception.
            console.warn('Local storage is disabled.');
            this._storage = new DummyLocalStorage();
            this._localStorageDisabled = true;
        }
    }

    /**
     * Returns true if window.localStorage is disabled and false otherwise.
     *
     * @returns {boolean} - True if window.localStorage is disabled and false otherwise.
     */
    isLocalStorageDisabled() {
        return this._localStorageDisabled;
    }

    /**
     * Empties all keys out of the storage.
     *
     * @returns {void}
     */
    clear() {
        this._storage.clear();
        this.emit('changed');
    }

    /**
     * Returns the number of data items stored in the Storage object.
     *
     * @returns {number} - The number of data items stored in the Storage object.
     */
    get length() {
        return this._storage.length;
    }

    /**
     * Returns that passed key's value.
     * @param {string} keyName the name of the key you want to retrieve
     * the value of.
     * @returns {String|null} the value of the key. If the key does not exist,
     * null is returned.
     */
    getItem(keyName) {
        return this._storage.getItem(keyName);
    }

    /**
     * Adds a key to the storage, or update key's value if it already exists.
     * @param {string} keyName - the name of the key you want to create/update.
     * @param {string} keyValue - the value you want to give the key you are
     * creating/updating.
     * @param {boolean} dontEmitChangedEvent - If true a changed event won't be emitted.
     */
    setItem(keyName, keyValue, dontEmitChangedEvent = false) {
        this._storage.setItem(keyName, keyValue);

        if (!dontEmitChangedEvent) {
            this.emit('changed');
        }
    }

    /**
     * Remove a key from the storage.
     * @param {string} keyName the name of the key you want to remove.
     */
    removeItem(keyName) {
        this._storage.removeItem(keyName);
        this.emit('changed');
    }

    /**
     * Returns the name of the nth key in the list, or null if n is greater
     * than or equal to the number of key/value pairs in the object.
     *
     * @param {number} i - The index of the key in the list.
     * @returns {string}
     */
    key(i) {
        return this._storage.key(i);
    }

    /**
     * Serializes the content of the storage.
     *
     * @returns {string} - The serialized content.
     */
    serialize() {
        if (this.isLocalStorageDisabled()) {
            return this._storage.serialize();
        }

        const length = this._storage.length;
        const localStorageContent = {};

        for (let i = 0; i < length; i++) {
            const key = this._storage.key(i);

            localStorageContent[key] = this._storage.getItem(key);
        }

        return JSON.stringify(localStorageContent);
    }
}

const jitsiLocalStorage = new JitsiLocalStorage();


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/lib/index.js":
/*!*************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/lib/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Interop: () => (/* reexport safe */ _interop_js__WEBPACK_IMPORTED_MODULE_0__.Interop)
/* harmony export */ });
/* harmony import */ var _interop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interop.js */ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/lib/interop.js");
/* Copyright @ 2015 - Present, 8x8 Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/lib/interop.js":
/*!***************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/lib/interop.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Interop: () => (/* binding */ Interop)
/* harmony export */ });
/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.clonedeep */ "../../lib-jitsi-meet/node_modules/lodash.clonedeep/index.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/lib/transform.js");
/* Copyright @ 2015 - Present, 8x8 Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const PLAN_B_MIDS = [ 'audio', 'video', 'data' ];
const findSimGroup = ssrcGroup => ssrcGroup.find(grp => grp.semantics === 'SIM');
const findFidGroup = ssrcGroup => ssrcGroup.find(grp => grp.semantics === 'FID');

/**
 * Add the ssrcs of the SIM group and their corresponding FID group ssrcs
 * to the m-line.
 * @param {Object} mLine - The m-line to which ssrcs have to be added.
 * @param {Object} simGroup - The SIM group whose ssrcs have to be added to
 * the m-line.
 * @param {Object} sourceGroups - inverted source-group map.
 * @param {Array<Object>} sourceList - array containing all the sources.
 */
function addSimGroupSources(mLine, simGroup, sourceGroups, sourceList) {
    if (!mLine || !simGroup) {
        return;
    }
    const findSourcebyId = src => sourceList.find(source => source.id.toString() === src);

    simGroup.ssrcs.forEach(src => {
        mLine.sources.push(findSourcebyId(src));

        // find the related FID group member for this ssrc.
        const relatedFidGroup = sourceGroups[parseInt(src, 10)].find(grp => grp.semantics === 'FID');

        if (relatedFidGroup) {
            const relatedSsrc = relatedFidGroup.ssrcs.find(s => s !== src);

            mLine.sources.push(findSourcebyId(relatedSsrc));
            mLine.ssrcGroups.push(relatedFidGroup);
        }
    });

    // Add the SIM group last.
    mLine.ssrcGroups.push(simGroup);
}

/**
 * Add ssrcs and ssrc-groups to the m-line. When a primary ssrc, i.e., the
 * first ssrc in a SIM group is passed, all the other ssrcs from the SIM
 * group and the other ssrcs from the related FID groups are added to the same
 * m-line since they all belong to the same remote source. Since the ssrcs are
 * not guaranteed to be in the correct order, try to find if a SIM group exists,
 * if not, just add the FID group.
 * @param {Object} mLine - The m-line to which ssrcs have to be added.
 * @param {Object} ssrc - the primary ssrc.
 * @param {Object} sourceGroups - inverted source-group map.
 * @param {Array<Object>} sourceList - array containing all the sources.
 * @returns {void}
 */
function addSourcesToMline(mLine, ssrc, sourceGroups, sourceList) {
    if (!mLine || !ssrc) {
        return;
    }
    mLine.sources = [];
    mLine.ssrcGroups = [];

    // If there are no associated ssrc-groups, just add the ssrc and msid.
    if (!sourceGroups[ssrc.id]) {
        mLine.sources.push(ssrc);
        mLine.msid = ssrc.msid;

        return;
    }
    const findSourcebyId = src => sourceList.find(source => source.id.toString() === src);

    // Find the SIM and FID groups that this ssrc belongs to.
    const simGroup = findSimGroup(sourceGroups[ssrc.id]);
    const fidGroup = findFidGroup(sourceGroups[ssrc.id]);

    // Add the ssrcs for the SIM group and their corresponding FID groups.
    if (simGroup) {
        addSimGroupSources(mLine, simGroup, sourceGroups, sourceList);
    } else if (fidGroup) {
        // check if the other ssrc from this FID group is part of a SIM group
        const otherSsrc = fidGroup.ssrcs.find(s => s !== ssrc);
        const simGroup2 = findSimGroup(sourceGroups[otherSsrc]);

        if (simGroup2) {
            addSimGroupSources(mLine, simGroup2, sourceGroups, sourceList);
        } else {
            // Add the FID group ssrcs.
            fidGroup.ssrcs.forEach(src => {
                mLine.sources.push(findSourcebyId(src));
            });
            mLine.ssrcGroups.push(fidGroup);
        }
    }

    // Set the msid for the media description using the msid attribute of the ssrcs.
    mLine.msid = mLine.sources[0].msid;
}

/**
 * Checks if there is a mline for the given ssrc or its related primary ssrc.
 * We always implode the SIM group to the first ssrc in the SIM group before sRD,
 * so we also check if mline for that ssrc exists.
 * For example:
 * If the following ssrcs are in a SIM group,
 * <ssrc-group xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\" semantics=\"SIM\">
 *        <source ssrc=\"1806330949\"/>
 *        <source ssrc=\"4173145196\"/>
 *        <source ssrc=\"2002632207\"/>
 * </ssrc-group>
 * This method returns true for any one of the 3 ssrcs if there is a mline for 1806330949.
 * @param {Object} ssrc - ssrc to check.
 * @param {Object} sourceGroups - inverted source-group map.
 * @param {Array<Object>} mlines - mlines in the description

 * @returns {Boolean} - Returns true if mline for the given ssrc or the related primary ssrc
 * exists, returns false otherwise.
 */
function checkIfMlineForSsrcExists(ssrc, sourceGroups, mlines) {
    const findMatchingMline = mline => {
        if (mline.sources) {
            return mline.sources.some(source => source.id === ssrc.id);
        }

        return false;
    };

    if (!mlines.find(findMatchingMline)) {
        // check if this ssrc is member of a SIM group. If so, check if there
        // is a matching m-line for the primary ssrc of the SIM group.
        if (!sourceGroups[ssrc.id]) {
            return false;
        }
        const simGroup = findSimGroup(sourceGroups[ssrc.id]);
        const fidGroup = findFidGroup(sourceGroups[ssrc.id]);

        if (simGroup) {
            return mlines.some(mline => mline.sources
                && mline.sources.some(src => src.id.toString() === simGroup.ssrcs[0]));
        } else if (fidGroup && ssrc.id.toString() !== fidGroup.ssrcs[0]) {
            const otherSsrc = { id: fidGroup.ssrcs[0] };

            return checkIfMlineForSsrcExists(otherSsrc, sourceGroups, mlines);

        }

        return false;
    }

    return true;
}

/**
 * Create an inverted sourceGroup map to put all the grouped ssrcs
 * in the same m-line.
 * @param {Array<Object>} sourceGroups
 * @returns {Object} - An inverted sourceGroup map.
 */
function createSourceGroupMap(sourceGroups) {
    const ssrc2group = {};

    if (!sourceGroups || !Array.isArray(sourceGroups)) {
        return ssrc2group;
    }
    sourceGroups.forEach(group => {
        if (group.ssrcs && Array.isArray(group.ssrcs)) {
            group.ssrcs.forEach(ssrc => {
                if (typeof ssrc2group[ssrc] === 'undefined') {
                    ssrc2group[ssrc] = [];
                }
                ssrc2group[ssrc].push(group);
            });
        }
    });

    return ssrc2group;
}

/**
 * Check if a new SDP requests an ICE restart.
 * @param {Object} - the parsed new SDP
 * @param {Object} - the parsed previous SDP
 * @returns {Boolean} - Returns true if an ICE restart is requested otherwise false.
 */
function checkForIceRestart(newDesc, oldDesc) {
    if (!newDesc || !oldDesc || newDesc.media.length === 0 || oldDesc.media.length === 0) {
        return false;
    }

    const newMLine = newDesc.media[0];
    const oldMLine = oldDesc.media[0];

    return newMLine.iceUfrag !== oldMLine.iceUfrag || newMLine.icePwd !== oldMLine.icePwd;
}

/**
 * Interop provides an API for tranforming a Plan B SDP to a Unified Plan SDP and
 * vice versa.
 */
class Interop {
    /**
     * This method transforms a Unified Plan SDP to an equivalent Plan B SDP.
     * @param {RTCSessionDescription} description - The description in Unified plan format.
     * @returns RTCSessionDescription - The transformed session description.
     */
    toPlanB(description) {
        if (!description || typeof description.sdp !== 'string') {
            console.warn('An empty description was passed as an argument.');

            return description;
        }

        // Objectify the SDP for easier manipulation.
        const session = _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"].parse(description.sdp);

        // If the SDP contains no media, there's nothing to transform.
        if (!session.media || !session.media.length) {
            console.warn('The description has no media.');

            return description;
        }

        // Make sure this is a unified plan sdp
        if (session.media.every(m => PLAN_B_MIDS.indexOf(m.mid) !== -1)) {
            console.warn('The description does not look like unified plan sdp');

            return description;
        }

        const media = {};
        const sessionMedia = session.media;

        session.media = [];
        sessionMedia.forEach(mLine => {
            const type = mLine.type;

            if (type === 'application') {
                mLine.mid = 'data';
                media[mLine.mid] = mLine;

                return;
            }
            if (typeof media[type] === 'undefined') {
                const bLine = lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__(mLine);

                // Copy the msid attribute to all the ssrcs if they belong to the same source group
                if (bLine.sources && Array.isArray(bLine.sources)) {
                    bLine.sources.forEach(source => {
                        mLine.msid ? source.msid = mLine.msid : delete source.msid;
                    });
                }

                // Do not signal the FID groups if there is no msid attribute present
                // on the sources as sesison-accept with this source info will fail strophe
                // validation and the session will not be established. This behavior is seen
                // on Firefox (with RTX enabled) when no video source is added at the join time.
                // FF generates two recvonly ssrcs with no msid and a corresponding FID group in
                // this case.
                if (!bLine.ssrcGroups || !mLine.msid) {
                    bLine.ssrcGroups = [];
                }
                delete bLine.msid;
                bLine.mid = type;
                media[type] = bLine;
            } else if (mLine.msid) {
                // Add sources and source-groups to the existing m-line of the same media type.
                const bLine = lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__(mLine);

                if (bLine.sources && Array.isArray(bLine.sources)) {
                    // Copy the msid attribute to each ssrc.
                    bLine.sources.forEach(ssrc => {
                        ssrc.msid = mLine.msid;
                    });
                    media[type].sources = (media[type].sources || []).concat(bLine.sources);
                }
                if (typeof bLine.ssrcGroups !== 'undefined' && Array.isArray(bLine.ssrcGroups)) {
                    media[type].ssrcGroups = (media[type].ssrcGroups || []).concat(bLine.ssrcGroups);
                }
            }
        });
        session.media = Object.values(media);

        // Bundle the media only if it is active.
        const bundle = [];

        Object.values(media).forEach(mline => {
            if (mline.direction !== 'inactive') {
                bundle.push(mline.mid);
            }
        });

        // We regenerate the BUNDLE group with the new mids.
        session.groups.forEach(group => {
            if (group.type === 'BUNDLE') {
                group.mids = bundle.join(' ');
            }
        });

        // msid semantic
        session.msidSemantic = {
            semantic: 'WMS',
            token: '*'
        };
        const resStr = _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"].write(session);

        return new RTCSessionDescription({
            type: description.type,
            sdp: resStr
        });
    }

    /**
     * This method transforms a Plan B SDP to an equivalent Unified Plan SDP.
     * @param {RTCSessionDescription} description - The description in plan-b format.
     * @param {RTCSessionDescription} current - The current description set on
     * the peerconnection in Unified-plan format, i.e., the readonly attribute
     * remoteDescription on the RTCPeerConnection object.
     * @returns RTCSessionDescription - The transformed session description.
     */
    toUnifiedPlan(description, current = null) {
        if (!description || typeof description.sdp !== 'string') {
            console.warn('An empty description was passed as an argument.');

            return description;
        }

        // Objectify the SDP for easier manipulation.
        const session = _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"].parse(description.sdp);

        // If the SDP contains no media, there's nothing to transform.
        if (!session.media || !session.media.length) {
            console.warn('The description has no media.');

            return description;
        }

        // Make sure this is a plan-b sdp.
        if (session.media.length > 3 || session.media.every(m => PLAN_B_MIDS.indexOf(m.mid) === -1)) {
            console.warn('The description does not look like plan-b');

            return description;
        }
        const currentDesc = current ? _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"].parse(current.sdp) : null;
        const iceRestart = checkForIceRestart(session, currentDesc);
        const newIceUfrag = session.media[0].iceUfrag;
        const newIcePwd = session.media[0].icePwd;
        const newFingerprint = session.media[0].fingerprint;
        const media = {};

        session.media.forEach(mLine => {
            const type = mLine.type;

            if (type === 'application') {
                if (!currentDesc || !currentDesc.media) {
                    const newMline = lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__(mLine);

                    newMline.mid = Object.keys(media).length.toString();
                    media[mLine.mid] = newMline;

                    return;
                }
                const mLineForData = currentDesc.media.findIndex(m => m.type === type);

                if (mLineForData) {
                    currentDesc.media[mLineForData] = mLine;
                    currentDesc.media[mLineForData].mid = mLineForData;
                }

                return;
            }

            // Create an inverted sourceGroup map here to put all the grouped SSRCs in the same m-line.
            const ssrc2group = createSourceGroupMap(mLine.ssrcGroups);

            // If there are no sources advertised for a media type, add the description if this is the first
            // remote offer, i.e., no current description was passed. Chrome in Unified plan does not produce
            // recvonly ssrcs unlike Firefox and Safari.
            if (!mLine.sources) {
                if (!currentDesc) {
                    const newMline = lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__(mLine);

                    newMline.mid = Object.keys(media).length.toString();
                    media[mLine.mid] = newMline;
                }

                return;
            }
            mLine.sources.forEach((ssrc, idx) => {
                // Do not add the receive-only ssrcs that Jicofo sends in the source-add.
                // These ssrcs do not have the "msid" attribute set.
                if (!ssrc.msid) {
                    return;
                }

                // If there is no description set on the peerconnection, create new m-lines.
                if (!currentDesc || !currentDesc.media) {
                    if (checkIfMlineForSsrcExists(ssrc, ssrc2group, Object.values(media))) {
                        return;
                    }
                    const newMline = lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__(mLine);

                    newMline.mid = Object.keys(media).length.toString();
                    newMline.direction = idx
                        ? 'sendonly'
                        : mLine.direction === 'sendonly' ? 'sendonly' : 'sendrecv';
                    newMline.bundleOnly = undefined;
                    addSourcesToMline(newMline, ssrc, ssrc2group, mLine.sources);
                    media[newMline.mid] = newMline;

                    return;
                }

                // Create and append the m-lines to the existing description.
                if (checkIfMlineForSsrcExists(ssrc, ssrc2group, currentDesc.media)) {
                    return;
                }
                const newMline = lodash_clonedeep__WEBPACK_IMPORTED_MODULE_0__(mLine);

                newMline.mid = currentDesc.media.length.toString();
                newMline.direction = 'sendonly';
                addSourcesToMline(newMline, ssrc, ssrc2group, mLine.sources);
                currentDesc.media.push(newMline);
            });
        });
        session.media = currentDesc ? currentDesc.media : Object.values(media);
        const mids = [];

        session.media.forEach(mLine => {
            mids.push(mLine.mid);
            if (iceRestart) {
                mLine.iceUfrag = newIceUfrag;
                mLine.icePwd = newIcePwd;
                mLine.fingerprint = newFingerprint;
            }
        });

        // We regenerate the BUNDLE group (since we regenerated the mids)
        session.groups.forEach(group => {
            if (group.type === 'BUNDLE') {
                group.mids = mids.join(' ');
            }
        });

        // msid semantic
        session.msidSemantic = {
            semantic: 'WMS',
            token: '*'
        };

        // Increment the session version every time.
        session.origin.sessionVersion++;
        const resultSdp = _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"].write(session);

        return new RTCSessionDescription({
            type: description.type,
            sdp: resultSdp
        });
    }
}


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/lib/transform.js":
/*!*****************************************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/lib/transform.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var sdp_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdp-transform */ "../../lib-jitsi-meet/node_modules/@jitsi/sdp-interop/node_modules/sdp-transform/lib/index.js");
/* Copyright @ 2015 - Present, 8x8 Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Rewrites the source information in the way sdp-transform expects.
 * Source information is split into multiple ssrc objects each containing
 * an id, attribute and value.
 * @param {Object} media - media description to be modified.
 * @returns {void}
 */
const write = function(session, opts) {
    if (typeof session !== 'undefined' && typeof session.media !== 'undefined' && Array.isArray(session.media)) {
        session.media.forEach(mLine => {
            if (mLine.sources && mLine.sources.length) {
                mLine.ssrcs = [];
                mLine.sources.forEach(source => {
                    Object.keys(source).forEach(attribute => {
                        if (attribute === 'id') {
                            return;
                        }
                        mLine.ssrcs.push({
                            id: source.id,
                            attribute,
                            value: source[attribute]
                        });
                    });
                });
                delete mLine.sources;
            }

            // join ssrcs in ssrc groups
            if (mLine.ssrcGroups && mLine.ssrcGroups.length) {
                mLine.ssrcGroups.forEach(ssrcGroup => {
                    if (typeof ssrcGroup.ssrcs !== 'undefined'
                    && Array.isArray(ssrcGroup.ssrcs)) {
                        ssrcGroup.ssrcs = ssrcGroup.ssrcs.join(' ');
                    }
                });
            }
        });
    }

    return sdp_transform__WEBPACK_IMPORTED_MODULE_0__.write(session, opts);
};

/**
 * Rewrites the source information that we get from sdp-transform.
 * All the ssrc lines with different attributes that belong to the
 * same ssrc are grouped into a single soure object with multiple key value pairs.
 * @param {Object} media - media description to be modified.
 * @returns {void}
 */
const parse = function(sdp) {
    const session = sdp_transform__WEBPACK_IMPORTED_MODULE_0__.parse(sdp);

    if (typeof session !== 'undefined' && typeof session.media !== 'undefined' && Array.isArray(session.media)) {
        session.media.forEach(mLine => {
            // group sources attributes by ssrc
            if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {
                mLine.sources = [];
                mLine.ssrcs.forEach(ssrc => {
                    const found = mLine.sources.findIndex(source => source.id === ssrc.id);

                    if (found > -1) {
                        mLine.sources[found][ssrc.attribute] = ssrc.value;
                    } else {
                        const src = { id: ssrc.id };

                        src[ssrc.attribute] = ssrc.value;
                        mLine.sources.push(src);
                    }
                });
                delete mLine.ssrcs;
            }

            // split ssrcs in ssrc groups
            if (typeof mLine.ssrcGroups !== 'undefined' && Array.isArray(mLine.ssrcGroups)) {
                mLine.ssrcGroups.forEach(ssrcGroup => {
                    if (typeof ssrcGroup.ssrcs === 'string') {
                        ssrcGroup.ssrcs = ssrcGroup.ssrcs.split(' ');
                    }
                });
            }
        });
    }

    return session;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    write,
    parse
});


/***/ }),

/***/ "../../lib-jitsi-meet/node_modules/uuid/wrapper.mjs":
/*!**********************************************************!*\
  !*** ../../lib-jitsi-meet/node_modules/uuid/wrapper.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v1: () => (/* binding */ v1),
/* harmony export */   v3: () => (/* binding */ v3),
/* harmony export */   v4: () => (/* binding */ v4),
/* harmony export */   v5: () => (/* binding */ v5)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "../../lib-jitsi-meet/node_modules/uuid/dist/index.js");

const v1 = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.v1;
const v3 = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.v3;
const v4 = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.v4;
const v5 = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.v5;


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@jspatcher/package-jitsi","version":"1.0.0","description":"The Jitsi package for JSPatcher","main":"dist/index.js","scripts":{"build":"webpack --mode development","build-watch":"webpack --mode development --watch --stats-children"},"keywords":["jspatcher"],"jspatcher":{"isJSPatcherPackage":true,"thumbnail":"","jspatpkg":"index.jspatpkg.js"},"author":"Fr0stbyteR","license":"GPL-3.0-or-later","repository":"https://github.com/jspatcher/package-jitsi","devDependencies":{"@jspatcher/jspatcher":"^0.0.10","@shren/lib-jitsi-meet":"file:../../lib-jitsi-meet","clean-webpack-plugin":"^4.0.0-alpha.0","esbuild-loader":"^2.15.1","typescript":"^4.4.2","webpack":"^5.51.1","webpack-cli":"^4.8.0"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*******************************!*\
  !*** ./src/index.jspatpkg.ts ***!
  \*******************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _objects_meeting__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objects/meeting */ "./src/objects/meeting.ts");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (async () => {
  return {
    meeting: _objects_meeting__WEBPACK_IMPORTED_MODULE_0__["default"]
  };
});

})();

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;
//# sourceMappingURL=index.jspatpkg.js.map