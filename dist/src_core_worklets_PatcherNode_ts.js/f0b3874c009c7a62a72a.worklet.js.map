{"version":3,"file":"src_core_worklets_PatcherNode_ts.js/f0b3874c009c7a62a72a.worklet.js","mappings":"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","sources":["webpack://JSPatcher/./src/core/worklets/AudioWorkletProxyNode.ts","webpack://JSPatcher/./src/core/worklets/AudioWorkletRegister.ts","webpack://JSPatcher/./src/core/worklets/PatcherNode.ts","webpack://JSPatcher/./src/core/worklets/Patcher.worklet.ts"],"sourcesContent":["import { TypedMessageEvent, MessagePortResponse, MessagePortRequest } from \"./TypedAudioWorklet\";\nimport { AudioWorkletProxyNode } from \"./AudioWorkletProxyNode.types\";\n\nconst Node = class AudioWorkletProxyNode extends AudioWorkletNode {\n    static fnNames: string[] = [];\n    _disposed = false;\n    constructor(context: AudioContext, name: string, options?: AudioWorkletNodeOptions) {\n        super(context, name, options);\n        const resolves: Record<number, ((...args: any[]) => any)> = {};\n        const rejects: Record<number, ((...args: any[]) => any)> = {};\n        let messagePortRequestId = 1;\n        const handleDisposed = () => {\n            this.port.removeEventListener(\"message\", handleMessage);\n            this.port.close();\n        };\n        const handleMessage = async (e: TypedMessageEvent<MessagePortResponse & MessagePortRequest>) => {\n            const { id, call, args, value, error } = e.data;\n            if (call) {\n                const r: MessagePortResponse = { id };\n                try {\n                    r.value = await (this as any)[call](...args);\n                } catch (e) {\n                    r.error = e;\n                }\n                this.port.postMessage(r);\n                if (this._disposed) handleDisposed();\n            } else {\n                if (error) rejects[id]?.(error);\n                else if (resolves[id]) resolves[id]?.(value);\n                delete resolves[id];\n                delete rejects[id];\n            }\n        };\n        // eslint-disable-next-line\n        const call = (call: string, ...args: any[]) => {\n            return new Promise<any>((resolve, reject) => {\n                const id = messagePortRequestId++;\n                resolves[id] = resolve;\n                rejects[id] = reject;\n                this.port.postMessage({ id, call, args });\n            });\n        };\n        const Ctor = (this.constructor as typeof AudioWorkletProxyNode);\n        Ctor.fnNames.forEach(name => (this as any)[name] = (...args: any[]) => call(name, ...args));\n        this.port.start();\n        this.port.addEventListener(\"message\", handleMessage);\n    }\n} as typeof AudioWorkletProxyNode;\n\nexport default Node;\n","export const registeredProcessors: WeakMap<AudioWorklet, Set<string>> = window.jspatcherEnv?.AudioWorkletRegister?.registeredProcessors || new WeakMap();\nexport const registeringProcessors: WeakMap<AudioWorklet, Set<string>> = window.jspatcherEnv?.AudioWorkletRegister?.registeringProcessors || new WeakMap();\nexport const resolves: Record<string, ((value?: void | PromiseLike<void>) => void)[]> = window.jspatcherEnv?.AudioWorkletRegister?.resolves || {};\nexport const rejects: Record<string, ((reason?: any) => void)[]> = window.jspatcherEnv?.AudioWorkletRegister?.rejects || {};\n\nexport default class AudioWorkletRegister {\n    static registeredProcessors = registeredProcessors;\n\n    static registeringProcessors = registeringProcessors;\n\n    static resolves = resolves;\n\n    static rejects = rejects;\n\n    private static async registerProcessor(audioWorklet: AudioWorklet, processorId: string, processor: string | ((id: string, ...injections: any[]) => void), ...injection: any[]) {\n        this.registeringProcessors.get(audioWorklet).add(processorId);\n        try {\n            const url = typeof processor === \"string\" ? processor : URL.createObjectURL(new Blob([`(${processor.toString()})(${[processorId, ...injection].map(JSON.stringify as (arg: any) => string).join(\", \")});`], { type: \"text/javascript\" }));\n            await audioWorklet.addModule(url);\n            this.resolves[processorId].forEach(f => f());\n            this.registeringProcessors.get(audioWorklet).delete(processorId);\n            this.registeredProcessors.get(audioWorklet).add(processorId);\n        } catch (e) {\n            this.rejects[processorId].forEach(f => f(e));\n        }\n        this.rejects[processorId] = [];\n        this.resolves[processorId] = [];\n    }\n\n    static async register(audioWorklet: AudioWorklet, processorId: string, processor: string | ((id: string, ...injections: any[]) => void), ...injection: any[]) {\n        if (!this.resolves[processorId]) this.resolves[processorId] = [];\n        if (!this.rejects[processorId]) this.rejects[processorId] = [];\n        const promise = new Promise<void>((resolve, reject) => {\n            this.resolves[processorId].push(resolve);\n            this.rejects[processorId].push(reject);\n        });\n        if (!this.registeringProcessors.has(audioWorklet)) {\n            this.registeringProcessors.set(audioWorklet, new Set());\n        }\n        if (!this.registeredProcessors.has(audioWorklet)) {\n            this.registeredProcessors.set(audioWorklet, new Set());\n        }\n        const registered = this.registeredProcessors.get(audioWorklet).has(processorId);\n        const registering = this.registeringProcessors.get(audioWorklet).has(processorId);\n        if (registered) return Promise.resolve();\n        if (registering) return promise;\n        if (!registered && audioWorklet) {\n            this.registerProcessor(audioWorklet, processorId, processor, ...injection);\n        }\n        return promise;\n    }\n}\n","import processorURL from \"./Patcher.worklet.ts\"; // eslint-disable-line import/extensions\nimport AudioWorkletProxyNode from \"./AudioWorkletProxyNode\";\nimport AudioWorkletRegister from \"./AudioWorkletRegister\";\nimport type Patcher from \"../patcher/Patcher\";\nimport type { PatcherEventMap } from \"../patcher/Patcher\";\nimport type { IPatcherNode, IPatcherProcessor, PatcherOptions, PatcherParameters } from \"./PatcherWorklet.types\";\nimport type { IJSPatcherEnv } from \"../Env\";\n\nconst processorId = \"__JSPatcher_Patcher\";\n\nexport default class PatcherNode extends AudioWorkletProxyNode<IPatcherNode, IPatcherProcessor, PatcherParameters, PatcherOptions> implements IPatcherNode {\n    static processorId = processorId;\n    static register = (audioWorklet: AudioWorklet) => AudioWorkletRegister.register(audioWorklet, processorId, processorURL);\n    static fnNames: (keyof IPatcherProcessor)[] = [\"init\", \"fn\", \"sync\", \"objectEmit\", \"destroy\"];\n    readonly patcher: Patcher;\n    constructor(context: BaseAudioContext, options: { env: IJSPatcherEnv; inputs: number; outputs: number } & PatcherOptions) {\n        super(context, processorId, {\n            numberOfInputs: options.inputs,\n            numberOfOutputs: options.outputs,\n            channelCountMode: \"explicit\",\n            channelInterpretation: \"discrete\",\n            processorOptions: { instanceId: options.instanceId, fileId: options.fileId, data: options.data }\n        });\n        this.patcher = options.env.getInstanceById(options.instanceId) as Patcher;\n        this.patcher.on(\"changed\", this.handleChanged);\n        this.patcher.on(\"dataInput\", this.handleInput);\n        this.patcher.on(\"destroy\", this.handleDestroy);\n        const _destroy = this.destroy;\n        this.destroy = async () => {\n            await _destroy.call(this);\n            this._disposed = true;\n        };\n    }\n    handleChanged = () => {\n        const syncData = this.patcher.history.getSyncData();\n        this.sync(syncData);\n    };\n    handleInput = (e: PatcherEventMap[\"dataInput\"]) => this.fn(e.data, e.inlet);\n    handleDestroy = () => this.destroy();\n    outlet(port: number, data: any) {\n        this.patcher.outlet(port, data);\n    }\n    objectEmitFromWorklet(boxId: string, eventName: string, eventData: any) {\n        return this.patcher.boxes[boxId]?.object.emit(eventName as any, eventData);\n    }\n}\n","module.exports = __webpack_public_path__ + \"js/1b130d9deb0c69ced1ab.worklet.js\";"],"names":[],"sourceRoot":""}