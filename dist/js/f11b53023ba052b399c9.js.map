{"version":3,"file":"js/f11b53023ba052b399c9.js","mappings":"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","sources":["webpack://JSPatcher/./src/misc/monaco-faust/Faust2Doc.ts","webpack://JSPatcher/./src/misc/monaco-faust/Faust2MD.ts","webpack://JSPatcher/./src/misc/monaco-faust/FaustLang.ts","webpack://JSPatcher/./src/misc/monaco-faust/documentation.ts"],"sourcesContent":["/* eslint-disable no-await-in-loop */\nimport { Faust2MD } from \"./Faust2MD\";\n/*\nRetrive faust2md doc by parsing .dsp file\n\nThe format of a title is :\n    //############# Title Name #################\n    //  markdown text....\n    //  markdown text....\n    //##########################################\n\nThe format of a section is :\n    //============== Section Name ==============\n    //  markdown text....\n    //  markdown text....\n    //==========================================\n\nThe format of a comment is :\n    //-------------- foo(x,y) ------------------\n    //  markdown text....\n    //  markdown text....\n    //------------------------------------------\neverything else is considered Faust code.\n--------------------------------------------------------\n*/\nexport type TFaustDocs = { [key: string]: TFaustDoc };\nexport type TFaustDoc = { path: string[]; name: string; doc: string };\n/**\n *\n * @class Faust2Doc\n */\nexport class Faust2Doc {\n    private static readonly REGEX_DEF_LIB = /\\b(\\w+)\\s*=\\s*library\\(\"(.+)\"\\);/;\n    private static readonly REGEX_DEF_IMP = /\\bimport\\(\"(.+)\"\\);/;\n    private static readonly REGEX_FUNC_NAME = /`.*?([\\w[\\]|]+)`/;\n    private static readonly REGEX_FUNC_NAME_COND = /\\[(.+?)(\\|.+?)*?]/;\n    /**\n     * Retrieve a library definition\n     *\n     * @static\n     * @param {string} line\n     * @returns {{ namespace: string, fileName: string }[]}\n     * @memberof Faust2Doc\n     */\n    static matchLibrary(line: string): { namespace: string; fileName: string }[] {\n        const libs = [] as { namespace: string; fileName: string }[];\n        const exps = line.match(new RegExp(this.REGEX_DEF_LIB, \"g\"));\n        if (exps) {\n            exps.forEach((exp) => {\n                const matched = exp.match(this.REGEX_DEF_LIB);\n                if (matched) libs.push({ namespace: matched[1], fileName: matched[2] });\n            });\n        }\n        return libs;\n    }\n    /**\n     * Retrieve an import expression\n     *\n     * @static\n     * @param {string} line\n     * @returns {string[]}\n     * @memberof Faust2Doc\n     */\n    static matchImport(line: string): string[] {\n        const imps = [] as string[];\n        const exps = line.match(new RegExp(this.REGEX_DEF_IMP, \"g\"));\n        if (exps) {\n            exps.forEach((exp) => {\n                const matched = exp.match(this.REGEX_DEF_IMP);\n                if (matched) imps.push(matched[1]);\n            });\n        }\n        return imps;\n    }\n    /**\n     * Retrieve true function name from string in comments\n     * `(si.)bus`\n     *\n     * @static\n     * @param {string} str\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchFuncName(str: string): string {\n        const matched = str.match(this.REGEX_FUNC_NAME);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Get all conditions in func name like `[third|half]_octave_[analyzer|filterbank][n]`\n     *\n     * @static\n     * @param {string} str\n     * @returns {string[]}\n     * @memberof Faust2Doc\n     */\n    static getAllConditions(str: string): string[] {\n        return this.getCondition([str]);\n    }\n    /**\n     * getAllConditions Recursive body\n     *\n     * @static\n     * @param {string[]} [condsIn]\n     * @param {RegExp} [regexp]\n     * @returns {string[]}\n     * @memberof Faust2Doc\n     */\n    private static getCondition(condsIn?: string[]): string[] {\n        const conds = [] as string[];\n        condsIn.forEach((cond) => {\n            const regexp = new RegExp(this.REGEX_FUNC_NAME_COND, \"g\");\n            const result = regexp.exec(cond);\n            if (!result) return;\n            const found = result[0];\n            const index = result.index;\n            const subConds = result.splice(1).filter(el => typeof el === \"string\").map(str => str.replace(/^\\|/, \"\"));\n            const before = cond.substring(0, index);\n            const after = cond.substring(index + found.length);\n            if (subConds.length === 1) {\n                conds.push(before + after);\n                conds.push(before + subConds + after);\n            } else {\n                subConds.forEach(subCond => conds.push(before + subCond + after));\n            }\n        });\n        return conds.length ? this.getCondition(conds) : condsIn;\n    }\n    /**\n     * Process the file\n     *\n     * @static\n     * @param {string} fileName fileName to be fetch using getFile\n     * @param {string} getFile callback used for import and library expressions\n     * @param {string[]} [depthIn] current Depth, stop when 0;\n     * @param {string[]} [pathIn] path of current namespace\n     * @param {string} [docIn] recursive accum object for output\n     * @returns {Promise<TFaustDocs>}\n     * @memberof Faust2MD\n     */\n    static async parse(fileName: string, getFile: (fileName: string) => Promise<string>, depthIn?: number, pathIn?: string[], docIn?: TFaustDocs): Promise<TFaustDocs> {\n        if (depthIn === 0) return docIn;\n        const depth = depthIn || 2;\n        const strIn = await getFile(fileName);\n        const doc: TFaustDocs = docIn || {};\n        const path = pathIn || [];\n        let inComment = false; // false: in code; true: in md-comment\n        let idt = 0; // indentation retained to outdent comment lines\n        let curName = \"\"; // current function name\n        let strBuffer = \"\"; // current function doc\n        const lines = strIn.split(\"\\n\");\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            if (!line) continue; // empty line\n            if (!Faust2MD.isComment(line)) {\n                if (inComment) { // we are closing a md-comment\n                    inComment = false;\n                    if (curName) this.getAllConditions(curName).forEach(name => doc[path.concat(name).join(\".\")] = { name: curName, path: [...path], doc: strBuffer });\n                    curName = \"\";\n                    strBuffer = \"\";\n                }\n                const libs = this.matchLibrary(line);\n                const imps = this.matchImport(line);\n                for (let j = 0; j < libs.length; j++) {\n                    const lib = libs[j];\n                    await this.parse(lib.fileName, getFile, depth - 1, [...path, lib.namespace], doc);\n                }\n                for (let j = 0; j < imps.length; j++) {\n                    const imp = imps[j];\n                    await this.parse(imp, getFile, depth - 1, path, doc);\n                }\n                continue;\n            }\n            if (inComment) { // we are in a md-comment (not first line)\n                if (idt === 0) idt = Faust2MD.indentation(line); // we have to measure the indentation\n                // check end of md-comment\n                const { endC, endS, endT } = { endC: Faust2MD.matchEndComment(line), endS: Faust2MD.matchEndSection(line), endT: Faust2MD.matchEndTitle(line) };\n                if (endC || endS || endT) inComment = false; // end of md-comment switch back to mode O\n                else strBuffer += Faust2MD.outdent(line, idt) + \"\\n\";\n                if (endC) { // pop buffer\n                    if (curName) this.getAllConditions(curName).forEach(name => doc[path.concat(name).join(\".\")] = { name: curName, path: [...path], doc: strBuffer });\n                    curName = \"\";\n                    strBuffer = \"\";\n                }\n                continue;\n            }\n            // check begin of md-comment\n            const { c, s, t } = { c: Faust2MD.matchBeginComment(line), s: Faust2MD.matchBeginSection(line), t: Faust2MD.matchBeginTitle(line) };\n            if (c) curName = this.matchFuncName(c);\n            if (c || s || t) {\n                inComment = true;\n                idt = 0;\n                strBuffer = \"\";\n            }\n        }\n        return doc;\n    }\n}\n","/*\n\nUltra simple automatic documentation system for Faust.\nCreates a markdown file by extracting the comments from\na Faust file. The option -t n can be used to change the\ndefault (4) tab setting. The option -c can be used to\ninclude the Faust code itself into the generated doc.\nAnd the option -f can be used to include a YAML front\nmatter with the name of the file and the date.\n\nThe format of a title is :\n    //############# Title Name #################\n    //  markdown text....\n    //  markdown text....\n    //##########################################\n\nThe format of a section is :\n    //============== Section Name ==============\n    //  markdown text....\n    //  markdown text....\n    //==========================================\n\nThe format of a comment is :\n    //-------------- foo(x,y) ------------------\n    //  markdown text....\n    //  markdown text....\n    //------------------------------------------\neverything else is considered Faust code.\nThe translation is the following:\n  ## foo(x,y)\n    markdown text....\n    markdown text....\n--------------------------------------------------------\n*/\ntype Faust2MDOptions = { tabsize: number; code: boolean; front: boolean };\n/**\n * faust2md ts port\n *\n * @class Faust2MD\n */\nexport class Faust2MD {\n    private static readonly REGEX_BEG_TITLE = /^\\s*\\/\\/#{3,}\\s*([^#]*[^#\\s])\\s*#{3,}$/;\n    private static readonly REGEX_END_TITLE = /^\\s*((\\/\\/#{3,})|(\\s*))$/;\n    private static readonly REGEX_BEG_SECTION = /^\\s*\\/\\/={3,}\\s*([^=]*[^=\\s])\\s*={3,}$/;\n    private static readonly REGEX_END_SECTION = /^\\s*((\\/\\/={3,})|(\\s*))$/;\n    private static readonly REGEX_BEG_COMMENT = /^\\s*\\/\\/-{3,}\\s*([^-]*[^=\\s])\\s*-{3,}$/;\n    private static readonly REGEX_END_COMMENT = /^\\s*((\\/\\/-{3,})|(\\s*))$/;\n    private static readonly REGEX_INDENT = /(^\\s*\\/\\/\\s*)[^\\s]/;\n    private static readonly REGEX_COMMENT = /^\\s*\\/\\//;\n    /**\n     * Print the front matter of the file\n     *\n     * @static\n     * @param {string} fileName\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static frontMatter(fileName: string): string {\n        return \"---\\n\"\n        + `file: ${fileName}\\n`\n        + `date: ${new Date().toLocaleDateString()}\\n`\n        + \"---\\n\";\n    }\n    /**\n     * Outdent a comment line by n characters in\n     * order to remove the prefix \"//   \"\n     *\n     * @static\n     * @param {string} line\n     * @param {number} idt\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static outdent(line: string, idt: number): string {\n        return line.length <= idt ? \"\\n\" : line.substr(idt);\n    }\n    /**\n     * Match the first line of a title\n     * of type \"//#### Title ####\"\n     * at least 3 # are needed\n     *\n     * @static\n     * @param {string} line\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchBeginTitle(line: string): string {\n        const matched = line.match(this.REGEX_BEG_TITLE);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Match the last line of a title\n     * of type \"//########\"\n     * or a blank line\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static matchEndTitle(line: string): boolean {\n        const matched = line.match(this.REGEX_END_TITLE);\n        return !!matched;\n    }\n    /**\n     * Match the first line of a section\n     * of type \"//==== Section ====\"\n     * at least 3 = are needed\n     *\n     * @static\n     * @param {string} line\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchBeginSection(line: string): string {\n        const matched = line.match(this.REGEX_BEG_SECTION);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Match the last line of a section\n     * of type \"//=======\"\n     * or a blank line\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static matchEndSection(line: string): boolean {\n        const matched = line.match(this.REGEX_END_SECTION);\n        return !!matched;\n    }\n    /**\n     * Match the first line of a comment\n     * of type \"//--- foo(x,y) ----\"\n     * at least 3 - are needed\n     *\n     * @static\n     * @param {string} line\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchBeginComment(line: string): string {\n        const matched = line.match(this.REGEX_BEG_COMMENT);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Match the last line of a comment\n     * of type \"//-----------------\"\n     * or a blank line\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static matchEndComment(line: string): boolean {\n        const matched = line.match(this.REGEX_END_COMMENT);\n        return !!matched;\n    }\n    /**\n     * Measure the indentation of a md-comment line\n     * that is the len of the prefix '//   '\n     *\n     * @static\n     * @param {string} line\n     * @returns {number}\n     * @memberof Faust2MD\n     */\n    static indentation(line: string): number {\n        const matched = line.match(this.REGEX_INDENT);\n        return matched ? matched[1].length : 0;\n    }\n    /**\n     * Indicates if a line is a comment\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static isComment(line: string): boolean {\n        const matched = line.match(this.REGEX_COMMENT);\n        return !!matched;\n    }\n    /**\n     * Process the file\n     *\n     * @static\n     * @param {string} strIn\n     * @param {string} [fileName]\n     * @param {{ tabsize?: number, code?: boolean, front?: boolean }} [optionsIn]\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static parse(strIn: string, fileName?: string, optionsIn?: { tabsize?: number; code?: boolean; front?: boolean }): string {\n        const options: Faust2MDOptions = { tabsize: 4, code: false, front: false, ...optionsIn };\n        let strOut = \"\";\n        let inComment = false; // false: in code; true: in md-comment\n        let idt = 0; // indentation retained to outdent comment lines\n        if (options.front && fileName) strOut += this.frontMatter(fileName);\n        strIn.split(\"\\n\").forEach((line) => {\n            if (!this.isComment(line)) {\n                if (inComment) { // we are closing a md-comment\n                    strOut += \"\\n\";\n                    inComment = false;\n                }\n                if (options.code) strOut += `\\t${line}\\n`;\n                return;\n            }\n            if (inComment) { // we are in a md-comment\n                if (idt === 0) idt = this.indentation(line); // we have to measure the indentation\n                // check end of md-comment\n                const { endC, endS, endT } = { endC: this.matchEndComment(line), endS: this.matchEndSection(line), endT: this.matchEndTitle(line) };\n                if (endC) strOut += \"\\n---\\n\\n\";\n                if (endC || endS || endT) inComment = false; // end of md-comment switch back to mode O\n                else strOut += this.outdent(line, idt) + \"\\n\";\n                return;\n            }\n            // check begin of md-comment\n            const { c, s, t } = { c: this.matchBeginComment(line), s: this.matchBeginSection(line), t: this.matchBeginTitle(line) };\n            if (c) strOut += `\\n### ${c}\\n`;\n            else if (s) strOut += `\\n## ${s}\\n`;\n            else if (t) strOut += `\\n# ${t}\\n`;\n            if (c || s || t) {\n                inComment = true;\n                idt = 0;\n            } else if (options.code) strOut += `\\t${line}\\n`;\n        });\n        return strOut;\n    }\n}\n","import { languages, editor, Position, Range } from \"monaco-editor/esm/vs/editor/editor.api\"; // instead of simple \"monaco-editor\" for less built languages\nimport type { FaustCompiler } from \"@grame/faustwasm/dist/esm\";\nimport { Faust2Doc, TFaustDocs, TFaustDoc } from \"./Faust2Doc\";\nimport { docSections, faustDocURL } from \"./documentation\";\n\nexport type FaustLanguageProviders = {\n    hoverProvider: languages.HoverProvider;\n    tokensProvider: languages.IMonarchLanguage;\n    completionItemProvider: languages.CompletionItemProvider;\n    docs: TFaustDocs;\n};\nexport const language: languages.ILanguageExtensionPoint = {\n    id: \"faust\",\n    extensions: [\"dsp\", \"lib\"],\n    mimetypes: [\"application/faust\"]\n};\nexport const config: languages.LanguageConfiguration = {\n    comments: {\n        lineComment: \"//\",\n        blockComment: [\"/*\", \"*/\"]\n    },\n    brackets: [\n        [\"{\", \"}\"],\n        [\"[\", \"]\"],\n        [\"(\", \")\"]\n    ],\n    autoClosingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"', notIn: [\"string\"] },\n        { open: \"/*\", close: \"*/\", notIn: [\"string\"] }\n    ]\n};\nexport const theme: editor.IStandaloneThemeData = {\n    base: \"vs-dark\",\n    inherit: true,\n    rules: [\n        { token: \"faustFunctions\", foreground: \"DDDD99\" },\n        { token: \"faustKeywords\", foreground: \"4499CC\" },\n        { token: \"faustLib\", foreground: \"CCCCBB\" },\n        { token: \"faustCompOperators\", foreground: \"FFDDFF\" },\n        { token: \"identifier\", foreground: \"77CCFF\" }\n    ],\n    colors: {}\n};\nconst faustKeywords = [\n    \"import\", \"component\", \"declare\", \"library\", \"environment\", \"int\", \"float\",\n    \"letrec\", \"with\", \"class\", \"process\", \"effect\", \"inputs\", \"outputs\"\n];\nconst faustFunctions = [\n    \"mem\", \"prefix\", \"rdtable\", \"rwtable\",\n    \"select2\", \"select3\", \"ffunction\", \"fconstant\", \"fvariable\",\n    \"route\", \"waveform\", \"soundfile\",\n    \"button\", \"checkbox\", \"vslider\", \"hslider\", \"nentry\",\n    \"vgroup\", \"hgroup\", \"tgroup\", \"vbargraph\", \"hbargraph\", \"attach\",\n    \"acos\", \"asin\", \"atan\", \"atan2\", \"cos\", \"sin\", \"tan\", \"exp\",\n    \"log\", \"log10\", \"pow\", \"sqrt\", \"abs\", \"min\", \"max\", \"fmod\",\n    \"remainder\", \"floor\", \"ceil\", \"rint\",\n    \"seq\", \"par\", \"sum\", \"prod\"\n];\nconst getFile = async (fileName: string, faust: FaustCompiler) => {\n    if (faust) return faust.fs().readFile(\"/usr/share/faust/\" + fileName, { encoding: \"utf8\" }) as string;\n    const libPath = \"https://faustlibraries.grame.fr/libs/\";\n    const res = await fetch(libPath + fileName);\n    return res.text();\n};\ntype TMatchedFaustDoc = { nameArray: string[]; name: string; range: Range; doc: TFaustDoc };\n/**\n * Match an available doc key from monaco editor\n *\n * @param {TFaustDocs} doc\n * @param {editor.ITextModel} model\n * @param {Position} position\n * @returns {TMatchedFaustDoc} full: [...prefixes, name], range: a monaco range object, doc: a FaustDoc object\n */\nexport const matchDocKey = (doc: TFaustDocs, model: editor.ITextModel, position: Position): TMatchedFaustDoc => {\n    const line$ = position.lineNumber;\n    const line = model.getLineContent(line$);\n    const wordAtPosition = model.getWordAtPosition(position);\n    if (!wordAtPosition) return null;\n    let column$ = wordAtPosition.startColumn - 1;\n    const name = wordAtPosition.word;\n    const prefixes: string[] = [];\n    while (column$ - 2 >= 0 && line[column$ - 1] === \".\") {\n        column$ -= 2;\n        const prefixWord = model.getWordAtPosition(new Position(line$, column$));\n        prefixes.splice(0, 0, prefixWord.word);\n        column$ = prefixWord.startColumn - 1;\n    }\n    const nameArray = [...prefixes, name];\n    while (nameArray.length) {\n        const name = nameArray.join(\".\");\n        const e = doc[name];\n        if (e) {\n            return {\n                nameArray,\n                name,\n                range: new Range(line$, column$ + 1, line$, wordAtPosition.endColumn),\n                doc: e\n            };\n        }\n        column$ += nameArray.splice(0, 1)[0].length + 1;\n    }\n    return null;\n};\nexport const getProviders = async (faust: FaustCompiler): Promise<FaustLanguageProviders> => {\n    let libDocs: TFaustDocs = {};\n    let primDocs: TFaustDocs = {};\n    try {\n        libDocs = await Faust2Doc.parse(\"stdfaust.lib\", async (fileName: string) => getFile(fileName, faust));\n        primDocs = await Faust2Doc.parse(\"primitives.lib\", async (fileName: string) => getFile(fileName, faust));\n    } catch (e) { console.error(e); } // eslint-disable-line no-empty, no-console\n    const faustLib = Object.keys(libDocs);\n\n    const hoverProvider: languages.HoverProvider = {\n        provideHover: (model, position) => {\n            const matched = matchDocKey({ ...primDocs, ...libDocs }, model, position);\n            if (matched) {\n                const prefix = matched.nameArray.slice();\n                const name = prefix.pop();\n                const doc = matched.doc;\n                return {\n                    range: matched.range,\n                    contents: [\n                        { value: `\\`\\`\\`\\n${prefix.length ? \"(\" + prefix.join(\".\") + \".)\" : \"\"}${name}\\n\\`\\`\\`` },\n                        { value: doc.doc.replace(/#+/g, \"######\") },\n                        { value: prefix.length ? `[Detail...](${faustDocURL}/${docSections[prefix.slice(0, 2).toString()]}/#${prefix.join(\".\")}${doc.name.replace(/[[\\]|]/g, \"\").toLowerCase()})` : \"[Detail...](https://faustdoc.grame.fr/manual/syntax/index.html#faust-syntax)\" }\n                    ]\n                };\n            }\n            return null;\n        }\n    };\n    const tokensProvider: languages.IMonarchLanguage = ({\n        faustKeywords,\n        faustFunctions,\n        faustLib,\n        defaultToken: \"invalid\",\n        tokenPostfix: \".dsp\",\n        faustCompOperators: [\n            \"~\", \",\", \":\", \"<:\", \":>\"\n        ],\n        operators: [\n            \"=\",\n            \"+\", \"-\", \"*\", \"/\", \"%\", \"^\",\n            \"&\", \"|\", \"xor\", \"<<\", \">>\",\n            \">\", \"<\", \"==\", \"<=\", \">=\", \"!=\",\n            \"@\", \"'\"\n        ],\n        // we include these common regular expressions\n        symbols: /[=><!~?:&|+\\-*/^%]+/,\n        // C# style strings\n        escapes: /\\\\(?:[abfnrtv\\\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,\n        // The main tokenizer for our languages\n        tokenizer: {\n            root: [\n                // identifiers and keywords\n                [/!|_/, \"keyword\"],\n                [/[a-z_$]([\\w.$]*[\\w$])?/, {\n                    cases: {\n                        \"@faustFunctions\": \"faustFunctions\",\n                        \"@faustKeywords\": \"faustKeywords\",\n                        \"@faustLib\": \"faustLib\",\n                        \"@default\": \"identifier\"\n                    }\n                }],\n                [/[A-Z][\\w$]*/, \"type.identifier\"],\n                // whitespace\n                { include: \"@whitespace\" },\n                // delimiters and operators\n                [/[{}()[\\]]/, \"@brackets\"],\n                [/~|,|<:|:>|:/, \"faustCompOperators\"],\n                [/[<>](?!@symbols)/, \"@brackets\"],\n                [/=|\\+|-|\\*|\\/|%|\\^|&|\\||xor|<<|>>|>|<|==|<=|>=|!=|@|'/, {\n                    cases: {\n                        \"@operators\": \"operators\",\n                        \"@default\": \"\"\n                    }\n                }],\n                // numbers\n                [/\\d*\\.\\d+([eE][-+]?\\d+)?/, \"number.float\"],\n                [/0[xX][0-9a-fA-F]+/, \"number.hex\"],\n                [/\\d+/, \"number\"],\n                // delimiter: after number because of .\\d floats\n                [/[;.]/, \"delimiter\"],\n                // strings\n                [/\"/, { token: \"string\", next: \"@string\" }]\n            ],\n            comment: [\n                [/[^/*]+/, \"comment\"],\n                [/\\/\\*/, \"comment\", \"@push\"],\n                [/\\*\\//, \"comment\", \"@pop\"],\n                [/[/*]/, \"comment\"]\n            ],\n            string: [\n                [/[^\\\\\"$]+/, \"string\"],\n                [/@escapes/, \"string.escape\"],\n                [/\\\\./, \"string.escape.invalid\"],\n                [/\"/, \"string\", \"@pop\"]\n            ],\n            whitespace: [\n                [/[ \\t\\r\\n]+/, \"white\"],\n                [/\\/\\*/, \"comment\", \"@comment\"],\n                [/\\/\\/.*$/, \"comment\"]\n            ]\n        }\n    } as any);\n    const completionItemProvider: languages.CompletionItemProvider = {\n        provideCompletionItems: () => {\n            const suggestions: languages.CompletionItem[] = [];\n            [...faustKeywords, ...faustFunctions, ...faustLib].forEach((e) => {\n                suggestions.push({\n                    label: e,\n                    kind: languages.CompletionItemKind.Text,\n                    insertText: e,\n                    range: null\n                });\n            });\n            return { suggestions };\n        }\n    };\n    return { hoverProvider, tokensProvider, completionItemProvider, docs: libDocs };\n};\n","// Definitions related to the libraries documentation system\n\nexport const faustDocURL = \"https://faustlibraries.grame.fr/libs\";\n\nexport const docSections: Record<string, string> = {\n    aa: \"aanl\",\n    an: \"analyzers\",\n    ba: \"basics\",\n    co: \"compressors\",\n    de: \"delays\",\n    dm: \"demos\",\n    dx: \"dx7\",\n    en: \"envelopes\",\n    fd: \"fds\",\n    fi: \"filters\",\n    ho: \"hoa\",\n    it: \"interpolators\",\n    ma: \"maths\",\n    mi: \"mi\",\n    ef: \"misceffects\",\n    os: \"oscillators\",\n    no: \"noises\",\n    pf: \"phaflangers\",\n    pm: \"physmodels\",\n    qu: \"quantizers\",\n    rm: \"reducemaps\",\n    re: \"reverbs\",\n    ro: \"routes\",\n    si: \"signals\",\n    so: \"soundfiles\",\n    sp: \"spats\",\n    sy: \"synths\",\n    ve: \"vaeffects\",\n    vl: \"version\",\n    wa: \"webaudio\",\n    wd: \"wdmodels\"\n};\n"],"names":["name"],"sourceRoot":""}