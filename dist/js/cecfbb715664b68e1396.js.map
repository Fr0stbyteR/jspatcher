{"version":3,"file":"js/cecfbb715664b68e1396.js","mappings":";;;;;;;;AAAA,iBAAiB,qBAAuB;;;;;;;;;;;;;;;;;;;;ACAQ;AACY;AACF;AAM1D,MAAM,cAAc;AAEL,MAAM,oBAAoB,8DAAqB,CAA6F;AAAA,EAKvJ,YAAY,SAA2B,SAAmF;AACtH,UAAM,SAAS,aAAa;AAAA,MACxB,gBAAgB,QAAQ;AAAA,MACxB,iBAAiB,QAAQ;AAAA,MACzB,kBAAkB;AAAA,MAClB,uBAAuB;AAAA,MACvB,kBAAkB,EAAE,YAAY,QAAQ,YAAY,QAAQ,QAAQ,QAAQ,MAAM,QAAQ,KAAK;AAAA,IACnG,CAAC;AAWL,yBAAgB,MAAM;AAClB,YAAM,WAAW,KAAK,QAAQ,QAAQ,YAAY;AAClD,WAAK,KAAK,QAAQ;AAAA,IACtB;AACA,uBAAc,CAAC,MAAoC,KAAK,GAAG,EAAE,MAAM,EAAE,KAAK;AAC1E,yBAAgB,MAAM,KAAK,QAAQ;AAf/B,SAAK,UAAU,QAAQ,IAAI,gBAAgB,QAAQ,UAAU;AAC7D,SAAK,QAAQ,GAAG,WAAW,KAAK,aAAa;AAC7C,SAAK,QAAQ,GAAG,aAAa,KAAK,WAAW;AAC7C,SAAK,QAAQ,GAAG,WAAW,KAAK,aAAa;AAC7C,UAAM,WAAW,KAAK;AACtB,SAAK,UAAU,YAAY;AACvB,YAAM,SAAS,KAAK,IAAI;AACxB,WAAK,YAAY;AAAA,IACrB;AAAA,EACJ;AAAA,EAOA,OAAO,MAAc,MAAW;AAC5B,SAAK,QAAQ,OAAO,MAAM,IAAI;AAAA,EAClC;AAAA,EACA,sBAAsB,OAAe,WAAmB,WAAgB;AA1C5E;AA2CQ,YAAO,UAAK,QAAQ,MAAM,KAAK,MAAxB,mBAA2B,OAAO,KAAK,WAAkB;AAAA,EACpE;AACJ;AAnCqB,YACV,cAAc;AADJ,YAEV,WAAW,CAAC,iBAA+B,sEAA6B,CAAC,cAAc,aAAa,4DAAY;AAFtG,YAGV,UAAuC,CAAC,QAAQ,MAAM,QAAQ,cAAc,SAAS","sources":["webpack://JSPatcher/./src/core/worklets/Patcher.worklet.ts","webpack://JSPatcher/./src/core/worklets/PatcherNode.ts"],"sourcesContent":["module.exports = __webpack_public_path__ + \"js/Patcher.worklet.js\";","import processorURL from \"./Patcher.worklet.ts\"; // eslint-disable-line import/extensions\nimport AudioWorkletProxyNode from \"./AudioWorkletProxyNode\";\nimport AudioWorkletRegister from \"./AudioWorkletRegister\";\nimport type Patcher from \"../patcher/Patcher\";\nimport type { PatcherEventMap } from \"../patcher/Patcher\";\nimport type { IPatcherNode, IPatcherProcessor, PatcherOptions, PatcherParameters } from \"./PatcherWorklet.types\";\nimport type { IJSPatcherEnv } from \"../Env\";\n\nconst processorId = \"__JSPatcher_Patcher\";\n\nexport default class PatcherNode extends AudioWorkletProxyNode<IPatcherNode, IPatcherProcessor, PatcherParameters, PatcherOptions> implements IPatcherNode {\n    static processorId = processorId;\n    static register = (audioWorklet: AudioWorklet) => AudioWorkletRegister.register(audioWorklet, processorId, processorURL);\n    static fnNames: (keyof IPatcherProcessor)[] = [\"init\", \"fn\", \"sync\", \"objectEmit\", \"destroy\"];\n    readonly patcher: Patcher;\n    constructor(context: BaseAudioContext, options: { env: IJSPatcherEnv; inputs: number; outputs: number } & PatcherOptions) {\n        super(context, processorId, {\n            numberOfInputs: options.inputs,\n            numberOfOutputs: options.outputs,\n            channelCountMode: \"explicit\",\n            channelInterpretation: \"discrete\",\n            processorOptions: { instanceId: options.instanceId, fileId: options.fileId, data: options.data }\n        });\n        this.patcher = options.env.getInstanceById(options.instanceId) as Patcher;\n        this.patcher.on(\"changed\", this.handleChanged);\n        this.patcher.on(\"dataInput\", this.handleInput);\n        this.patcher.on(\"destroy\", this.handleDestroy);\n        const _destroy = this.destroy;\n        this.destroy = async () => {\n            await _destroy.call(this);\n            this._disposed = true;\n        };\n    }\n    handleChanged = () => {\n        const syncData = this.patcher.history.getSyncData();\n        this.sync(syncData);\n    };\n    handleInput = (e: PatcherEventMap[\"dataInput\"]) => this.fn(e.data, e.inlet);\n    handleDestroy = () => this.destroy();\n    outlet(port: number, data: any) {\n        this.patcher.outlet(port, data);\n    }\n    objectEmitFromWorklet(boxId: string, eventName: string, eventData: any) {\n        return this.patcher.boxes[boxId]?.object.emit(eventName as any, eventData);\n    }\n}\n"],"names":[],"sourceRoot":""}