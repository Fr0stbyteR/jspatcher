{"version":3,"file":"js/ed9d26e0c15fbfe1f527.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,aAAa;AACxE;AACA;AACA;AACA;AACA;AACA,6BAA6B,4FAA4F;AACzH;AACA;AACA;AACA,mGAAmG,qFAAqF,8BAA8B;;AAEtN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,4DAA4D,aAAa;AACzE,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qDAAqD,gBAAgB;AACrE;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,cAAc;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS,qBAAqB;AAC9B,qBAAqB,oDAAoD;AACzE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,gBAAgB;AAChB,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA,6CAA6C,QAAQ;AACrD,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,gCAAgC,gDAAgD;AAChF,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G;AAC/G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C,WAAW;AACX;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA;AACA;AACA,0CAA0C,gCAAgC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA,0BAA0B,MAAM,oBAAoB,MAAM;AAC1D,aAAa,MAAM;AACnB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA,wDAAwD;AACxD;AACA,OAAO;AACP;AACA,oDAAoD;AACpD;AACA,OAAO;AACP;AACA,mDAAmD;AACnD;AACA,OAAO;AACP;AACA,wDAAwD;AACxD;AACA,OAAO;AACP;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,iBAAiB,gDAAgD;AACjE;AACA,+DAA+D,yBAAyB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,YAAY,eAAe,QAAQ,2HAAY;AAC/C,YAAY,gBAAgB,QAAQ,4HAAa;AACjD,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA,SAAS,gBAAgB;AACzB,SAAS,gBAAgB;;AAEzB;AACA;AACA;;AAEA,EAAE;;AAEF,iBAAiB,gDAAgD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,UAAU,uDAAuD;AACjE;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oGAAoG;AAC9H;AACA,UAAU;AACV;AACA,0BAA0B,4EAA4E;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,4CAA4C;AACxI,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8CAA8C;AAC5D,cAAc,sBAAsB;AACpC;AACA;AACA,mFAAmF,4BAA4B;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8CAA8C;AAC5D,cAAc,+DAA+D;AAC7E;AACA;AACA;AACA,mFAAmF,4BAA4B;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC,wBAAwB;AACxB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC;AACA,0FAA0F,yEAAyE;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA,6EAA6E,mBAAmB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,oEAAoE,mBAAmB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,2EAA2E,mBAAmB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0CAA0C;AAC9E;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,SAAS;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,MAAM;AACN,yEAAyE,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB;AACnE,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN,oEAAoE,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,sBAAsB,mCAAmC;AACzD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC,6FAA6F,KAAK,OAAO,KAAK;AAC9G,MAAM;AACN;AACA,kFAAkF,KAAK;AACvF;AACA;AACA;AACA,iCAAiC,KAAK;AACtC,yGAAyG,KAAK,OAAO,KAAK,KAAK,kBAAkB;AACjJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa,cAAc,eAAe;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sEAAsE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAuD;AACnE;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,4EAA4E;AAC5E,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,yCAAyC,kDAAkD;AAC3F,YAAY;AACZ;AACA;AACA;AACA,yDAAyD,kDAAkD;AAC3G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAkD;AAClF;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,gCAAgC,4CAA4C;AAC5E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,sBAAsB;AACtB,qBAAqB;AACrB,sBAAsB;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAoD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAsD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,sBAAsB;AACtB,qBAAqB;AACrB,sBAAsB;AACtB,qBAAqB;AACrB,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,wDAAwD,sCAAsC,UAAU,aAAa;AACrH;AACA;AACA;AACA,wDAAwD,sCAAsC,UAAU,aAAa;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAoD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB,sDAAsD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB,eAAe;AACtE;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAkD;AAC9D,YAAY;AACZ;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,8BAA8B,uCAAuC;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oCAAoC;AAClE,MAAM;AACN,8BAA8B,qCAAqC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAkD;AAC9D,YAAY;AACZ;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qCAAqC;AAC9D;AACA;AACA,yBAAyB,sCAAsC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ,8BAA8B,aAAa;AACnD,QAAQ,2BAA2B,IAAI;AACvC,QAAQ,2BAA2B,IAAI;AACvC,QAAQ,oCAAoC,IAAI;AAChD;AACA;AACA,MAAM,0BAA0B;AAChC,MAAM,0BAA0B;AAChC,MAAM;AACN;AACA;AACA,GAAG,8CAA8C;AACjD;AACA,sEAAsE,yBAAyB;AAC/F;AACA;AACA,UAAU;AACV,6EAA6E,EAAE;AAC/E,yEAAyE,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,yEAAyE,EAAE;AAC3E,qEAAqE,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB,uBAAuB;AACzD;AACA,uBAAuB,EAAE;AACzB,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA,+SAA+S,KAAK;AACpT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ,8BAA8B,aAAa;AACnD,QAAQ,2BAA2B,IAAI;AACvC,QAAQ,2BAA2B,IAAI;AACvC,QAAQ,4BAA4B,IAAI;AACxC,QAAQ,oCAAoC,IAAI;AAChD;AACA;AACA,MAAM,0BAA0B;AAChC,MAAM,0BAA0B;AAChC,MAAM;AACN;AACA;AACA,GAAG,8CAA8C;AACjD;AACA,sEAAsE,yBAAyB;AAC/F;AACA;AACA,UAAU;AACV,6EAA6E,EAAE;AAC/E,yEAAyE,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gPAAgP,KAAK;AACrP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,yEAAyE,EAAE;AAC3E,qEAAqE,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AA0BE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://JSPatcher/./node_modules/@shren/faustwasm/dist/esm/index.js"],"sourcesContent":["var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target, mod));\n\n// node_modules/tslib/tslib.js\nvar require_tslib = __commonJS({\n  \"node_modules/tslib/tslib.js\"(exports, module) {\n    var __extends;\n    var __assign;\n    var __rest;\n    var __decorate;\n    var __param;\n    var __metadata;\n    var __awaiter;\n    var __generator;\n    var __exportStar;\n    var __values;\n    var __read;\n    var __spread;\n    var __spreadArrays;\n    var __await;\n    var __asyncGenerator;\n    var __asyncDelegator;\n    var __asyncValues;\n    var __makeTemplateObject;\n    var __importStar;\n    var __importDefault;\n    var __classPrivateFieldGet;\n    var __classPrivateFieldSet;\n    var __createBinding;\n    (function(factory) {\n      var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n      if (typeof define === \"function\" && define.amd) {\n        define(\"tslib\", [\"exports\"], function(exports2) {\n          factory(createExporter(root, createExporter(exports2)));\n        });\n      } else if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        factory(createExporter(root, createExporter(module.exports)));\n      } else {\n        factory(createExporter(root));\n      }\n      function createExporter(exports2, previous) {\n        if (exports2 !== root) {\n          if (typeof Object.create === \"function\") {\n            Object.defineProperty(exports2, \"__esModule\", { value: true });\n          } else {\n            exports2.__esModule = true;\n          }\n        }\n        return function(id, v) {\n          return exports2[id] = previous ? previous(id, v) : v;\n        };\n      }\n    })(function(exporter) {\n      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {\n        d.__proto__ = b;\n      } || function(d, b) {\n        for (var p in b)\n          if (b.hasOwnProperty(p))\n            d[p] = b[p];\n      };\n      __extends = function(d, b) {\n        extendStatics(d, b);\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n      __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n              t[p] = s[p];\n        }\n        return t;\n      };\n      __rest = function(s, e) {\n        var t = {};\n        for (var p in s)\n          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n            t[p] = s[p];\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n          }\n        return t;\n      };\n      __decorate = function(decorators, target, key, desc) {\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n          r = Reflect.decorate(decorators, target, key, desc);\n        else\n          for (var i = decorators.length - 1; i >= 0; i--)\n            if (d = decorators[i])\n              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\n      };\n      __param = function(paramIndex, decorator) {\n        return function(target, key) {\n          decorator(target, key, paramIndex);\n        };\n      };\n      __metadata = function(metadataKey, metadataValue) {\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n          return Reflect.metadata(metadataKey, metadataValue);\n      };\n      __awaiter = function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      __generator = function(thisArg, body) {\n        var _ = { label: 0, sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        }, trys: [], ops: [] }, f, y, t, g;\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n          return this;\n        }), g;\n        function verb(n) {\n          return function(v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f)\n            throw new TypeError(\"Generator is already executing.\");\n          while (_)\n            try {\n              if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                return t;\n              if (y = 0, t)\n                op = [op[0] & 2, t.value];\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n                case 4:\n                  _.label++;\n                  return { value: op[1], done: false };\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n                case 7:\n                  op = _.ops.pop();\n                  _.trys.pop();\n                  continue;\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n                    _.ops.push(op);\n                    break;\n                  }\n                  if (t[2])\n                    _.ops.pop();\n                  _.trys.pop();\n                  continue;\n              }\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f = t = 0;\n            }\n          if (op[0] & 5)\n            throw op[1];\n          return { value: op[0] ? op[1] : void 0, done: true };\n        }\n      };\n      __createBinding = function(o, m, k, k2) {\n        if (k2 === void 0)\n          k2 = k;\n        o[k2] = m[k];\n      };\n      __exportStar = function(m, exports2) {\n        for (var p in m)\n          if (p !== \"default\" && !exports2.hasOwnProperty(p))\n            exports2[p] = m[p];\n      };\n      __values = function(o) {\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n        if (m)\n          return m.call(o);\n        if (o && typeof o.length === \"number\")\n          return {\n            next: function() {\n              if (o && i >= o.length)\n                o = void 0;\n              return { value: o && o[i++], done: !o };\n            }\n          };\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n      };\n      __read = function(o, n) {\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n        if (!m)\n          return o;\n        var i = m.call(o), r, ar = [], e;\n        try {\n          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n            ar.push(r.value);\n        } catch (error) {\n          e = { error };\n        } finally {\n          try {\n            if (r && !r.done && (m = i[\"return\"]))\n              m.call(i);\n          } finally {\n            if (e)\n              throw e.error;\n          }\n        }\n        return ar;\n      };\n      __spread = function() {\n        for (var ar = [], i = 0; i < arguments.length; i++)\n          ar = ar.concat(__read(arguments[i]));\n        return ar;\n      };\n      __spreadArrays = function() {\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++)\n          s += arguments[i].length;\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\n          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n        return r;\n      };\n      __await = function(v) {\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\n      };\n      __asyncGenerator = function(thisArg, _arguments, generator) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n          return this;\n        }, i;\n        function verb(n) {\n          if (g[n])\n            i[n] = function(v) {\n              return new Promise(function(a, b) {\n                q.push([n, v, a, b]) > 1 || resume(n, v);\n              });\n            };\n        }\n        function resume(n, v) {\n          try {\n            step(g[n](v));\n          } catch (e) {\n            settle(q[0][3], e);\n          }\n        }\n        function step(r) {\n          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n        }\n        function fulfill(value) {\n          resume(\"next\", value);\n        }\n        function reject(value) {\n          resume(\"throw\", value);\n        }\n        function settle(f, v) {\n          if (f(v), q.shift(), q.length)\n            resume(q[0][0], q[0][1]);\n        }\n      };\n      __asyncDelegator = function(o) {\n        var i, p;\n        return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n          throw e;\n        }), verb(\"return\"), i[Symbol.iterator] = function() {\n          return this;\n        }, i;\n        function verb(n, f) {\n          i[n] = o[n] ? function(v) {\n            return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v;\n          } : f;\n        }\n      };\n      __asyncValues = function(o) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var m = o[Symbol.asyncIterator], i;\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n          return this;\n        }, i);\n        function verb(n) {\n          i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n              v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n          };\n        }\n        function settle(resolve, reject, d, v) {\n          Promise.resolve(v).then(function(v2) {\n            resolve({ value: v2, done: d });\n          }, reject);\n        }\n      };\n      __makeTemplateObject = function(cooked, raw) {\n        if (Object.defineProperty) {\n          Object.defineProperty(cooked, \"raw\", { value: raw });\n        } else {\n          cooked.raw = raw;\n        }\n        return cooked;\n      };\n      __importStar = function(mod) {\n        if (mod && mod.__esModule)\n          return mod;\n        var result = {};\n        if (mod != null) {\n          for (var k in mod)\n            if (Object.hasOwnProperty.call(mod, k))\n              result[k] = mod[k];\n        }\n        result[\"default\"] = mod;\n        return result;\n      };\n      __importDefault = function(mod) {\n        return mod && mod.__esModule ? mod : { \"default\": mod };\n      };\n      __classPrivateFieldGet = function(receiver, privateMap) {\n        if (!privateMap.has(receiver)) {\n          throw new TypeError(\"attempted to get private field on non-instance\");\n        }\n        return privateMap.get(receiver);\n      };\n      __classPrivateFieldSet = function(receiver, privateMap, value) {\n        if (!privateMap.has(receiver)) {\n          throw new TypeError(\"attempted to set private field on non-instance\");\n        }\n        privateMap.set(receiver, value);\n        return value;\n      };\n      exporter(\"__extends\", __extends);\n      exporter(\"__assign\", __assign);\n      exporter(\"__rest\", __rest);\n      exporter(\"__decorate\", __decorate);\n      exporter(\"__param\", __param);\n      exporter(\"__metadata\", __metadata);\n      exporter(\"__awaiter\", __awaiter);\n      exporter(\"__generator\", __generator);\n      exporter(\"__exportStar\", __exportStar);\n      exporter(\"__createBinding\", __createBinding);\n      exporter(\"__values\", __values);\n      exporter(\"__read\", __read);\n      exporter(\"__spread\", __spread);\n      exporter(\"__spreadArrays\", __spreadArrays);\n      exporter(\"__await\", __await);\n      exporter(\"__asyncGenerator\", __asyncGenerator);\n      exporter(\"__asyncDelegator\", __asyncDelegator);\n      exporter(\"__asyncValues\", __asyncValues);\n      exporter(\"__makeTemplateObject\", __makeTemplateObject);\n      exporter(\"__importStar\", __importStar);\n      exporter(\"__importDefault\", __importDefault);\n      exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet);\n      exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet);\n    });\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/constants.js\nvar require_constants = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/constants.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.MAX_HASHABLE_LENGTH = exports.INIT = exports.KEY = exports.DIGEST_LENGTH = exports.BLOCK_SIZE = void 0;\n    exports.BLOCK_SIZE = 64;\n    exports.DIGEST_LENGTH = 32;\n    exports.KEY = new Uint32Array([\n      1116352408,\n      1899447441,\n      3049323471,\n      3921009573,\n      961987163,\n      1508970993,\n      2453635748,\n      2870763221,\n      3624381080,\n      310598401,\n      607225278,\n      1426881987,\n      1925078388,\n      2162078206,\n      2614888103,\n      3248222580,\n      3835390401,\n      4022224774,\n      264347078,\n      604807628,\n      770255983,\n      1249150122,\n      1555081692,\n      1996064986,\n      2554220882,\n      2821834349,\n      2952996808,\n      3210313671,\n      3336571891,\n      3584528711,\n      113926993,\n      338241895,\n      666307205,\n      773529912,\n      1294757372,\n      1396182291,\n      1695183700,\n      1986661051,\n      2177026350,\n      2456956037,\n      2730485921,\n      2820302411,\n      3259730800,\n      3345764771,\n      3516065817,\n      3600352804,\n      4094571909,\n      275423344,\n      430227734,\n      506948616,\n      659060556,\n      883997877,\n      958139571,\n      1322822218,\n      1537002063,\n      1747873779,\n      1955562222,\n      2024104815,\n      2227730452,\n      2361852424,\n      2428436474,\n      2756734187,\n      3204031479,\n      3329325298\n    ]);\n    exports.INIT = [\n      1779033703,\n      3144134277,\n      1013904242,\n      2773480762,\n      1359893119,\n      2600822924,\n      528734635,\n      1541459225\n    ];\n    exports.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/RawSha256.js\nvar require_RawSha256 = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/RawSha256.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.RawSha256 = void 0;\n    var constants_1 = require_constants();\n    var RawSha256 = function() {\n      function RawSha2562() {\n        this.state = Int32Array.from(constants_1.INIT);\n        this.temp = new Int32Array(64);\n        this.buffer = new Uint8Array(64);\n        this.bufferLength = 0;\n        this.bytesHashed = 0;\n        this.finished = false;\n      }\n      RawSha2562.prototype.update = function(data) {\n        if (this.finished) {\n          throw new Error(\"Attempted to update an already finished hash.\");\n        }\n        var position = 0;\n        var byteLength = data.byteLength;\n        this.bytesHashed += byteLength;\n        if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {\n          throw new Error(\"Cannot hash more than 2^53 - 1 bits\");\n        }\n        while (byteLength > 0) {\n          this.buffer[this.bufferLength++] = data[position++];\n          byteLength--;\n          if (this.bufferLength === constants_1.BLOCK_SIZE) {\n            this.hashBuffer();\n            this.bufferLength = 0;\n          }\n        }\n      };\n      RawSha2562.prototype.digest = function() {\n        if (!this.finished) {\n          var bitsHashed = this.bytesHashed * 8;\n          var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n          var undecoratedLength = this.bufferLength;\n          bufferView.setUint8(this.bufferLength++, 128);\n          if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {\n            for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {\n              bufferView.setUint8(i, 0);\n            }\n            this.hashBuffer();\n            this.bufferLength = 0;\n          }\n          for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {\n            bufferView.setUint8(i, 0);\n          }\n          bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);\n          bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);\n          this.hashBuffer();\n          this.finished = true;\n        }\n        var out = new Uint8Array(constants_1.DIGEST_LENGTH);\n        for (var i = 0; i < 8; i++) {\n          out[i * 4] = this.state[i] >>> 24 & 255;\n          out[i * 4 + 1] = this.state[i] >>> 16 & 255;\n          out[i * 4 + 2] = this.state[i] >>> 8 & 255;\n          out[i * 4 + 3] = this.state[i] >>> 0 & 255;\n        }\n        return out;\n      };\n      RawSha2562.prototype.hashBuffer = function() {\n        var _a = this, buffer = _a.buffer, state = _a.state;\n        var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];\n        for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {\n          if (i < 16) {\n            this.temp[i] = (buffer[i * 4] & 255) << 24 | (buffer[i * 4 + 1] & 255) << 16 | (buffer[i * 4 + 2] & 255) << 8 | buffer[i * 4 + 3] & 255;\n          } else {\n            var u = this.temp[i - 2];\n            var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;\n            u = this.temp[i - 15];\n            var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;\n            this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);\n          }\n          var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i] + this.temp[i] | 0) | 0) | 0;\n          var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;\n          state7 = state6;\n          state6 = state5;\n          state5 = state4;\n          state4 = state3 + t1 | 0;\n          state3 = state2;\n          state2 = state1;\n          state1 = state0;\n          state0 = t1 + t2 | 0;\n        }\n        state[0] += state0;\n        state[1] += state1;\n        state[2] += state2;\n        state[3] += state3;\n        state[4] += state4;\n        state[5] += state5;\n        state[6] += state6;\n        state[7] += state7;\n      };\n      return RawSha2562;\n    }();\n    exports.RawSha256 = RawSha256;\n  }\n});\n\n// node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js\nvar require_pureJs = __commonJS({\n  \"node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.toUtf8 = exports.fromUtf8 = void 0;\n    var fromUtf8 = (input) => {\n      const bytes = [];\n      for (let i = 0, len = input.length; i < len; i++) {\n        const value = input.charCodeAt(i);\n        if (value < 128) {\n          bytes.push(value);\n        } else if (value < 2048) {\n          bytes.push(value >> 6 | 192, value & 63 | 128);\n        } else if (i + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i + 1) & 64512) === 56320) {\n          const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i) & 1023);\n          bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);\n        } else {\n          bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);\n        }\n      }\n      return Uint8Array.from(bytes);\n    };\n    exports.fromUtf8 = fromUtf8;\n    var toUtf8 = (input) => {\n      let decoded = \"\";\n      for (let i = 0, len = input.length; i < len; i++) {\n        const byte = input[i];\n        if (byte < 128) {\n          decoded += String.fromCharCode(byte);\n        } else if (192 <= byte && byte < 224) {\n          const nextByte = input[++i];\n          decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);\n        } else if (240 <= byte && byte < 365) {\n          const surrogatePair = [byte, input[++i], input[++i], input[++i]];\n          const encoded = \"%\" + surrogatePair.map((byteValue) => byteValue.toString(16)).join(\"%\");\n          decoded += decodeURIComponent(encoded);\n        } else {\n          decoded += String.fromCharCode((byte & 15) << 12 | (input[++i] & 63) << 6 | input[++i] & 63);\n        }\n      }\n      return decoded;\n    };\n    exports.toUtf8 = toUtf8;\n  }\n});\n\n// node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js\nvar require_whatwgEncodingApi = __commonJS({\n  \"node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.toUtf8 = exports.fromUtf8 = void 0;\n    function fromUtf8(input) {\n      return new TextEncoder().encode(input);\n    }\n    exports.fromUtf8 = fromUtf8;\n    function toUtf8(input) {\n      return new TextDecoder(\"utf-8\").decode(input);\n    }\n    exports.toUtf8 = toUtf8;\n  }\n});\n\n// node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js\nvar require_dist_cjs = __commonJS({\n  \"node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.toUtf8 = exports.fromUtf8 = void 0;\n    var pureJs_1 = require_pureJs();\n    var whatwgEncodingApi_1 = require_whatwgEncodingApi();\n    var fromUtf8 = (input) => typeof TextEncoder === \"function\" ? (0, whatwgEncodingApi_1.fromUtf8)(input) : (0, pureJs_1.fromUtf8)(input);\n    exports.fromUtf8 = fromUtf8;\n    var toUtf8 = (input) => typeof TextDecoder === \"function\" ? (0, whatwgEncodingApi_1.toUtf8)(input) : (0, pureJs_1.toUtf8)(input);\n    exports.toUtf8 = toUtf8;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/convertToBuffer.js\nvar require_convertToBuffer = __commonJS({\n  \"node_modules/@aws-crypto/util/build/convertToBuffer.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.convertToBuffer = void 0;\n    var util_utf8_browser_1 = require_dist_cjs();\n    var fromUtf8 = typeof Buffer !== \"undefined\" && Buffer.from ? function(input) {\n      return Buffer.from(input, \"utf8\");\n    } : util_utf8_browser_1.fromUtf8;\n    function convertToBuffer(data) {\n      if (data instanceof Uint8Array)\n        return data;\n      if (typeof data === \"string\") {\n        return fromUtf8(data);\n      }\n      if (ArrayBuffer.isView(data)) {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n      }\n      return new Uint8Array(data);\n    }\n    exports.convertToBuffer = convertToBuffer;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/isEmptyData.js\nvar require_isEmptyData = __commonJS({\n  \"node_modules/@aws-crypto/util/build/isEmptyData.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.isEmptyData = void 0;\n    function isEmptyData(data) {\n      if (typeof data === \"string\") {\n        return data.length === 0;\n      }\n      return data.byteLength === 0;\n    }\n    exports.isEmptyData = isEmptyData;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/numToUint8.js\nvar require_numToUint8 = __commonJS({\n  \"node_modules/@aws-crypto/util/build/numToUint8.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.numToUint8 = void 0;\n    function numToUint8(num) {\n      return new Uint8Array([\n        (num & 4278190080) >> 24,\n        (num & 16711680) >> 16,\n        (num & 65280) >> 8,\n        num & 255\n      ]);\n    }\n    exports.numToUint8 = numToUint8;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/uint32ArrayFrom.js\nvar require_uint32ArrayFrom = __commonJS({\n  \"node_modules/@aws-crypto/util/build/uint32ArrayFrom.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.uint32ArrayFrom = void 0;\n    function uint32ArrayFrom(a_lookUpTable) {\n      if (!Uint32Array.from) {\n        var return_array = new Uint32Array(a_lookUpTable.length);\n        var a_index = 0;\n        while (a_index < a_lookUpTable.length) {\n          return_array[a_index] = a_lookUpTable[a_index];\n          a_index += 1;\n        }\n        return return_array;\n      }\n      return Uint32Array.from(a_lookUpTable);\n    }\n    exports.uint32ArrayFrom = uint32ArrayFrom;\n  }\n});\n\n// node_modules/@aws-crypto/util/build/index.js\nvar require_build = __commonJS({\n  \"node_modules/@aws-crypto/util/build/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;\n    var convertToBuffer_1 = require_convertToBuffer();\n    Object.defineProperty(exports, \"convertToBuffer\", { enumerable: true, get: function() {\n      return convertToBuffer_1.convertToBuffer;\n    } });\n    var isEmptyData_1 = require_isEmptyData();\n    Object.defineProperty(exports, \"isEmptyData\", { enumerable: true, get: function() {\n      return isEmptyData_1.isEmptyData;\n    } });\n    var numToUint8_1 = require_numToUint8();\n    Object.defineProperty(exports, \"numToUint8\", { enumerable: true, get: function() {\n      return numToUint8_1.numToUint8;\n    } });\n    var uint32ArrayFrom_1 = require_uint32ArrayFrom();\n    Object.defineProperty(exports, \"uint32ArrayFrom\", { enumerable: true, get: function() {\n      return uint32ArrayFrom_1.uint32ArrayFrom;\n    } });\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/jsSha256.js\nvar require_jsSha256 = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/jsSha256.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Sha256 = void 0;\n    var tslib_1 = require_tslib();\n    var constants_1 = require_constants();\n    var RawSha256_1 = require_RawSha256();\n    var util_1 = require_build();\n    var Sha2562 = function() {\n      function Sha2563(secret) {\n        this.hash = new RawSha256_1.RawSha256();\n        if (secret) {\n          this.outer = new RawSha256_1.RawSha256();\n          var inner = bufferFromSecret(secret);\n          var outer = new Uint8Array(constants_1.BLOCK_SIZE);\n          outer.set(inner);\n          for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {\n            inner[i] ^= 54;\n            outer[i] ^= 92;\n          }\n          this.hash.update(inner);\n          this.outer.update(outer);\n          for (var i = 0; i < inner.byteLength; i++) {\n            inner[i] = 0;\n          }\n        }\n      }\n      Sha2563.prototype.update = function(toHash) {\n        if ((0, util_1.isEmptyData)(toHash) || this.error) {\n          return;\n        }\n        try {\n          this.hash.update((0, util_1.convertToBuffer)(toHash));\n        } catch (e) {\n          this.error = e;\n        }\n      };\n      Sha2563.prototype.digestSync = function() {\n        if (this.error) {\n          throw this.error;\n        }\n        if (this.outer) {\n          if (!this.outer.finished) {\n            this.outer.update(this.hash.digest());\n          }\n          return this.outer.digest();\n        }\n        return this.hash.digest();\n      };\n      Sha2563.prototype.digest = function() {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function() {\n          return (0, tslib_1.__generator)(this, function(_a) {\n            return [2, this.digestSync()];\n          });\n        });\n      };\n      return Sha2563;\n    }();\n    exports.Sha256 = Sha2562;\n    function bufferFromSecret(secret) {\n      var input = (0, util_1.convertToBuffer)(secret);\n      if (input.byteLength > constants_1.BLOCK_SIZE) {\n        var bufferHash = new RawSha256_1.RawSha256();\n        bufferHash.update(input);\n        input = bufferHash.digest();\n      }\n      var buffer = new Uint8Array(constants_1.BLOCK_SIZE);\n      buffer.set(input);\n      return buffer;\n    }\n  }\n});\n\n// node_modules/@aws-crypto/sha256-js/build/index.js\nvar require_build2 = __commonJS({\n  \"node_modules/@aws-crypto/sha256-js/build/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var tslib_1 = require_tslib();\n    (0, tslib_1.__exportStar)(require_jsSha256(), exports);\n  }\n});\n\n// src/instantiateFaustModuleFromFile.ts\nvar instantiateFaustModuleFromFile = async (jsFile, dataFile = jsFile.replace(/c?js$/, \"data\"), wasmFile = jsFile.replace(/c?js$/, \"wasm\")) => {\n  var _a, _b;\n  let FaustModule;\n  let dataBinary;\n  let wasmBinary;\n  if (typeof globalThis.fetch === \"function\") {\n    let jsCode = await (await fetch(jsFile)).text();\n    jsCode = `${jsCode}\nexport default ${(_a = jsCode.match(/var (.+) = \\(function\\(\\) \\{/)) == null ? void 0 : _a[1]};\n`;\n    const jsFileMod = URL.createObjectURL(new Blob([jsCode], { type: \"text/javascript\" }));\n    FaustModule = (await import(\n      /* webpackIgnore: true */\n      jsFileMod\n    )).default;\n    dataBinary = await (await fetch(dataFile)).arrayBuffer();\n    wasmBinary = new Uint8Array(await (await fetch(wasmFile)).arrayBuffer());\n  } else {\n    const { promises: fs } = await import(\"fs\");\n    const { pathToFileURL } = await import(\"url\");\n    let jsCode = await fs.readFile(jsFile, { encoding: \"utf-8\" });\n    jsCode = `\nimport process from \"process\";\nimport * as path from \"path\";\nimport { createRequire } from \"module\";\nimport { fileURLToPath } from \"url\";\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\nconst __filename = fileURLToPath(import.meta.url);\nconst require = createRequire(import.meta.url);\n\n${jsCode}\n\nexport default ${(_b = jsCode.match(/var (.+) = \\(function\\(\\) \\{/)) == null ? void 0 : _b[1]};\n`;\n    const jsFileMod = jsFile.replace(/c?js$/, \"mjs\");\n    await fs.writeFile(jsFileMod, jsCode);\n    FaustModule = (await import(\n      /* webpackIgnore: true */\n      pathToFileURL(jsFileMod).href\n    )).default;\n    await fs.unlink(jsFileMod);\n    dataBinary = (await fs.readFile(dataFile)).buffer;\n    wasmBinary = (await fs.readFile(wasmFile)).buffer;\n  }\n  const faustModule = await FaustModule({\n    wasmBinary,\n    getPreloadedPackage: (remotePackageName, remotePackageSize) => {\n      if (remotePackageName === \"libfaust-wasm.data\")\n        return dataBinary;\n      return new ArrayBuffer(0);\n    }\n  });\n  return faustModule;\n};\nvar instantiateFaustModuleFromFile_default = instantiateFaustModuleFromFile;\n\n// src/FaustAudioWorkletProcessor.ts\nvar getFaustAudioWorkletProcessor = (dependencies, faustData, register = true) => {\n  const { registerProcessor, AudioWorkletProcessor, sampleRate } = globalThis;\n  const {\n    FaustBaseWebAudioDsp: FaustBaseWebAudioDsp2,\n    FaustWasmInstantiator: FaustWasmInstantiator2\n  } = dependencies;\n  const {\n    processorName,\n    dspName,\n    dspMeta,\n    effectMeta,\n    poly\n  } = faustData;\n  class FaustAudioWorkletProcessor extends AudioWorkletProcessor {\n    constructor(options) {\n      super(options);\n      this.port.onmessage = (e) => this.handleMessageAux(e);\n    }\n    static get parameterDescriptors() {\n      const params = [];\n      const callback = (item) => {\n        if (item.type === \"vslider\" || item.type === \"hslider\" || item.type === \"nentry\") {\n          if (!poly || !item.address.endsWith(\"/gate\") && !item.address.endsWith(\"/freq\") && !item.address.endsWith(\"/gain\")) {\n            params.push({ name: item.address, defaultValue: item.init || 0, minValue: item.min || 0, maxValue: item.max || 0 });\n          }\n        } else if (item.type === \"button\" || item.type === \"checkbox\") {\n          if (!poly || !item.address.endsWith(\"/gate\") && !item.address.endsWith(\"/freq\") && !item.address.endsWith(\"/gain\")) {\n            params.push({ name: item.address, defaultValue: item.init || 0, minValue: 0, maxValue: 1 });\n          }\n        }\n      };\n      FaustBaseWebAudioDsp2.parseUI(dspMeta.ui, callback);\n      if (effectMeta)\n        FaustBaseWebAudioDsp2.parseUI(effectMeta.ui, callback);\n      return params;\n    }\n    process(inputs, outputs, parameters) {\n      for (const path in parameters) {\n        const paramArray = parameters[path];\n        this.fDSPCode.setParamValue(path, paramArray[0]);\n      }\n      return this.fDSPCode.compute(inputs[0], outputs[0]);\n    }\n    handleMessageAux(e) {\n      const msg = e.data;\n      switch (msg.type) {\n        case \"midi\":\n          this.midiMessage(msg.data);\n          break;\n        case \"ctrlChange\":\n          this.ctrlChange(msg.data[0], msg.data[1], msg.data[2]);\n          break;\n        case \"pitchWheel\":\n          this.pitchWheel(msg.data[0], msg.data[1]);\n          break;\n        case \"param\":\n          this.setParamValue(msg.data.path, msg.data.value);\n          break;\n        case \"setPlotHandler\": {\n          if (msg.data) {\n            this.fDSPCode.setPlotHandler((output, index, events) => this.port.postMessage({ type: \"plot\", value: output, index, events }));\n          } else {\n            this.fDSPCode.setPlotHandler(null);\n          }\n          break;\n        }\n        case \"start\": {\n          this.fDSPCode.start();\n          break;\n        }\n        case \"stop\": {\n          this.fDSPCode.stop();\n          break;\n        }\n        case \"destroy\": {\n          this.port.close();\n          this.fDSPCode.destroy();\n          break;\n        }\n        default:\n          break;\n      }\n    }\n    setParamValue(path, value) {\n      this.fDSPCode.setParamValue(path, value);\n    }\n    midiMessage(data) {\n      this.fDSPCode.midiMessage(data);\n    }\n    ctrlChange(channel, ctrl, value) {\n      this.fDSPCode.ctrlChange(channel, ctrl, value);\n    }\n    pitchWheel(channel, wheel) {\n      this.fDSPCode.pitchWheel(channel, wheel);\n    }\n  }\n  class FaustMonoAudioWorkletProcessor extends FaustAudioWorkletProcessor {\n    constructor(options) {\n      super(options);\n      const { FaustMonoWebAudioDsp: FaustMonoWebAudioDsp2 } = dependencies;\n      const { factory, sampleSize } = options.processorOptions;\n      const instance = FaustWasmInstantiator2.createSyncMonoDSPInstance(factory);\n      this.fDSPCode = new FaustMonoWebAudioDsp2(instance, sampleRate, sampleSize, 128);\n      this.fDSPCode.setOutputParamHandler((path, value) => this.port.postMessage({ path, value, type: \"param\" }));\n      this.fDSPCode.start();\n    }\n  }\n  class FaustPolyAudioWorkletProcessor extends FaustAudioWorkletProcessor {\n    constructor(options) {\n      super(options);\n      this.handleMessageAux = (e) => {\n        const msg = e.data;\n        switch (msg.type) {\n          case \"keyOn\":\n            this.keyOn(msg.data[0], msg.data[1], msg.data[2]);\n            break;\n          case \"keyOff\":\n            this.keyOff(msg.data[0], msg.data[1], msg.data[2]);\n            break;\n          default:\n            super.handleMessageAux(e);\n            break;\n        }\n      };\n      const { FaustPolyWebAudioDsp: FaustPolyWebAudioDsp2 } = dependencies;\n      const { voiceFactory, mixerModule, voices, effectFactory, sampleSize } = options.processorOptions;\n      const instance = FaustWasmInstantiator2.createSyncPolyDSPInstance(voiceFactory, mixerModule, voices, effectFactory);\n      this.fDSPCode = new FaustPolyWebAudioDsp2(instance, sampleRate, sampleSize, 128);\n      this.port.onmessage = (e) => this.handleMessageAux(e);\n      this.fDSPCode.setOutputParamHandler((path, value) => this.port.postMessage({ path, value, type: \"param\" }));\n      this.fDSPCode.start();\n    }\n    midiMessage(data) {\n      const cmd = data[0] >> 4;\n      const channel = data[0] & 15;\n      const data1 = data[1];\n      const data2 = data[2];\n      if (cmd === 8 || cmd === 9 && data2 === 0)\n        this.keyOff(channel, data1, data2);\n      else if (cmd === 9)\n        this.keyOn(channel, data1, data2);\n      else\n        super.midiMessage(data);\n    }\n    keyOn(channel, pitch, velocity) {\n      this.fDSPCode.keyOn(channel, pitch, velocity);\n    }\n    keyOff(channel, pitch, velocity) {\n      this.fDSPCode.keyOff(channel, pitch, velocity);\n    }\n    allNotesOff(hard) {\n      this.fDSPCode.allNotesOff(hard);\n    }\n  }\n  const Processor = poly ? FaustPolyAudioWorkletProcessor : FaustMonoAudioWorkletProcessor;\n  if (register) {\n    try {\n      registerProcessor(processorName || dspName || (poly ? \"mydsp_poly\" : \"mydsp\"), Processor);\n    } catch (error) {\n      console.warn(error);\n    }\n  }\n  return poly ? FaustPolyAudioWorkletProcessor : FaustMonoAudioWorkletProcessor;\n};\nvar FaustAudioWorkletProcessor_default = getFaustAudioWorkletProcessor;\n\n// src/FaustCompiler.ts\nvar import_sha256_js = __toESM(require_build2(), 1);\nvar ab2str = (buf) => String.fromCharCode.apply(null, buf);\nvar str2ab = (str) => {\n  const buf = new ArrayBuffer(str.length);\n  const bufView = new Uint8Array(buf);\n  for (let i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return bufView;\n};\nvar sha256 = async (str) => {\n  const sha2562 = new import_sha256_js.Sha256();\n  sha2562.update(str);\n  const hashArray = Array.from(await sha2562.digest());\n  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hashHex;\n};\nvar _FaustCompiler = class {\n  static stringifyDSPFactories() {\n    const table = {};\n    this.gFactories.forEach((factory, shaKey) => {\n      const { code, json, poly } = factory;\n      table[shaKey] = { code: btoa(ab2str(code)), json: JSON.parse(json), poly };\n    });\n    return JSON.stringify(table);\n  }\n  static async importDSPFactories(tableStr) {\n    const table = JSON.parse(tableStr);\n    const awaited = [];\n    for (const shaKey in table) {\n      const factory = table[shaKey];\n      const { code, json, poly } = factory;\n      const ab = str2ab(atob(code));\n      awaited.push(WebAssembly.compile(ab).then((module) => this.gFactories.set(shaKey, { shaKey, cfactory: 0, code: ab, module, json: JSON.stringify(json), poly })));\n    }\n    return Promise.all(awaited);\n  }\n  constructor(libFaust) {\n    this.fLibFaust = libFaust;\n    this.fErrorMessage = \"\";\n  }\n  intVec2intArray(vec) {\n    const size = vec.size();\n    const ui8Code = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n      ui8Code[i] = vec.get(i);\n    }\n    return ui8Code;\n  }\n  async createDSPFactory(name, code, args, poly) {\n    if (_FaustCompiler.gFactories.size > 10) {\n      _FaustCompiler.gFactories.clear();\n    }\n    let shaKey = await sha256(name + code + args + (poly ? \"poly\" : \"mono\"));\n    if (_FaustCompiler.gFactories.has(shaKey)) {\n      return _FaustCompiler.gFactories.get(shaKey) || null;\n    } else {\n      try {\n        const faustDspWasm = this.fLibFaust.createDSPFactory(name, code, args, !poly);\n        try {\n          const code2 = this.intVec2intArray(faustDspWasm.data);\n          faustDspWasm.data.delete();\n          const module = await WebAssembly.compile(code2);\n          const factory = { shaKey, cfactory: faustDspWasm.cfactory, code: code2, module, json: faustDspWasm.json, poly };\n          this.deleteDSPFactory(factory);\n          _FaustCompiler.gFactories.set(shaKey, factory);\n          return factory;\n        } catch (e) {\n          console.error(e);\n          return null;\n        }\n      } catch (e) {\n        this.fErrorMessage = this.fLibFaust.getErrorAfterException();\n        console.error(`=> exception raised while running createDSPFactory: ${this.fErrorMessage}`, e);\n        this.fLibFaust.cleanupAfterException();\n        return null;\n      }\n    }\n  }\n  version() {\n    return this.fLibFaust.version();\n  }\n  getErrorMessage() {\n    return this.fErrorMessage;\n  }\n  async createMonoDSPFactory(name, code, args) {\n    return this.createDSPFactory(name, code, args, false);\n  }\n  async createPolyDSPFactory(name, code, args) {\n    return this.createDSPFactory(name, code, args, true);\n  }\n  deleteDSPFactory(factory) {\n    this.fLibFaust.deleteDSPFactory(factory.cfactory);\n    factory.cfactory = 0;\n  }\n  expandDSP(code, args) {\n    try {\n      return this.fLibFaust.expandDSP(\"FaustDSP\", code, args);\n    } catch {\n      this.fErrorMessage = this.fLibFaust.getErrorAfterException();\n      console.error(`=> exception raised while running expandDSP: ${this.fErrorMessage}`);\n      this.fLibFaust.cleanupAfterException();\n      return null;\n    }\n  }\n  generateAuxFiles(name, code, args) {\n    try {\n      return this.fLibFaust.generateAuxFiles(name, code, args);\n    } catch {\n      this.fErrorMessage = this.fLibFaust.getErrorAfterException();\n      console.error(`=> exception raised while running generateAuxFiles: ${this.fErrorMessage}`);\n      this.fLibFaust.cleanupAfterException();\n      return false;\n    }\n  }\n  deleteAllDSPFactories() {\n    this.fLibFaust.deleteAllDSPFactories();\n  }\n  fs() {\n    return this.fLibFaust.fs();\n  }\n  async getAsyncInternalMixerModule(isDouble = false) {\n    const bufferKey = isDouble ? \"mixer64Buffer\" : \"mixer32Buffer\";\n    const moduleKey = isDouble ? \"mixer64Module\" : \"mixer32Module\";\n    if (this[moduleKey])\n      return { mixerBuffer: this[bufferKey], mixerModule: this[moduleKey] };\n    const path = isDouble ? \"/usr/rsrc/mixer64.wasm\" : \"/usr/rsrc/mixer32.wasm\";\n    const mixerBuffer = this.fs().readFile(path, { encoding: \"binary\" });\n    this[bufferKey] = mixerBuffer;\n    const mixerModule = await WebAssembly.compile(mixerBuffer);\n    this[moduleKey] = mixerModule;\n    return { mixerBuffer, mixerModule };\n  }\n  getSyncInternalMixerModule(isDouble = false) {\n    const bufferKey = isDouble ? \"mixer64Buffer\" : \"mixer32Buffer\";\n    const moduleKey = isDouble ? \"mixer64Module\" : \"mixer32Module\";\n    if (this[moduleKey])\n      return { mixerBuffer: this[bufferKey], mixerModule: this[moduleKey] };\n    const path = isDouble ? \"/usr/rsrc/mixer64.wasm\" : \"/usr/rsrc/mixer32.wasm\";\n    const mixerBuffer = this.fs().readFile(path, { encoding: \"binary\" });\n    this[bufferKey] = mixerBuffer;\n    const mixerModule = new WebAssembly.Module(mixerBuffer);\n    this[moduleKey] = mixerModule;\n    return { mixerBuffer, mixerModule };\n  }\n};\nvar FaustCompiler = _FaustCompiler;\nFaustCompiler.gFactories = /* @__PURE__ */ new Map();\nvar FaustCompiler_default = FaustCompiler;\n\n// src/FaustDspInstance.ts\nvar FaustDspInstance = class {\n  constructor(exports) {\n    this.fExports = exports;\n  }\n  compute($dsp, count, $input, $output) {\n    this.fExports.compute($dsp, count, $input, $output);\n  }\n  getNumInputs($dsp) {\n    return this.fExports.getNumInputs($dsp);\n  }\n  getNumOutputs($dsp) {\n    return this.fExports.getNumOutputs($dsp);\n  }\n  getParamValue($dsp, index) {\n    return this.fExports.getParamValue($dsp, index);\n  }\n  getSampleRate($dsp) {\n    return this.fExports.getSampleRate($dsp);\n  }\n  init($dsp, sampleRate) {\n    this.fExports.init($dsp, sampleRate);\n  }\n  instanceClear($dsp) {\n    this.fExports.instanceClear($dsp);\n  }\n  instanceConstants($dsp, sampleRate) {\n    this.fExports.instanceConstants($dsp, sampleRate);\n  }\n  instanceInit($dsp, sampleRate) {\n    this.fExports.instanceInit($dsp, sampleRate);\n  }\n  instanceResetUserInterface($dsp) {\n    this.fExports.instanceResetUserInterface($dsp);\n  }\n  setParamValue($dsp, index, value) {\n    this.fExports.setParamValue($dsp, index, value);\n  }\n};\nvar FaustDspInstance_default = FaustDspInstance;\n\n// src/FaustWasmInstantiator.ts\nvar FaustWasmInstantiator = class {\n  static createWasmImport(memory) {\n    return {\n      env: {\n        memory: memory || new WebAssembly.Memory({ initial: 100 }),\n        memoryBase: 0,\n        tableBase: 0,\n        _abs: Math.abs,\n        _acosf: Math.acos,\n        _asinf: Math.asin,\n        _atanf: Math.atan,\n        _atan2f: Math.atan2,\n        _ceilf: Math.ceil,\n        _cosf: Math.cos,\n        _expf: Math.exp,\n        _floorf: Math.floor,\n        _fmodf: (x, y) => x % y,\n        _logf: Math.log,\n        _log10f: Math.log10,\n        _max_f: Math.max,\n        _min_f: Math.min,\n        _remainderf: (x, y) => x - Math.round(x / y) * y,\n        _powf: Math.pow,\n        _roundf: Math.fround,\n        _sinf: Math.sin,\n        _sqrtf: Math.sqrt,\n        _tanf: Math.tan,\n        _acoshf: Math.acosh,\n        _asinhf: Math.asinh,\n        _atanhf: Math.atanh,\n        _coshf: Math.cosh,\n        _sinhf: Math.sinh,\n        _tanhf: Math.tanh,\n        _isnanf: Number.isNaN,\n        _isinff: (x) => !isFinite(x),\n        _copysignf: (x, y) => Math.sign(x) === Math.sign(y) ? x : -x,\n        _acos: Math.acos,\n        _asin: Math.asin,\n        _atan: Math.atan,\n        _atan2: Math.atan2,\n        _ceil: Math.ceil,\n        _cos: Math.cos,\n        _exp: Math.exp,\n        _floor: Math.floor,\n        _fmod: (x, y) => x % y,\n        _log: Math.log,\n        _log10: Math.log10,\n        _max_: Math.max,\n        _min_: Math.min,\n        _remainder: (x, y) => x - Math.round(x / y) * y,\n        _pow: Math.pow,\n        _round: Math.fround,\n        _sin: Math.sin,\n        _sqrt: Math.sqrt,\n        _tan: Math.tan,\n        _acosh: Math.acosh,\n        _asinh: Math.asinh,\n        _atanh: Math.atanh,\n        _cosh: Math.cosh,\n        _sinh: Math.sinh,\n        _tanh: Math.tanh,\n        _isnan: Number.isNaN,\n        _isinf: (x) => !isFinite(x),\n        _copysign: (x, y) => Math.sign(x) === Math.sign(y) ? x : -x,\n        table: new WebAssembly.Table({ initial: 0, element: \"anyfunc\" })\n      }\n    };\n  }\n  static createWasmMemory(voicesIn, sampleSize, dspMeta, effectMeta, bufferSize) {\n    const voices = Math.max(4, voicesIn);\n    const ptrSize = sampleSize;\n    const pow2limit = (x) => {\n      let n = 65536;\n      while (n < x) {\n        n *= 2;\n      }\n      return n;\n    };\n    const effectSize = effectMeta ? effectMeta.size : 0;\n    let memorySize = pow2limit(effectSize + dspMeta.size * voices + (dspMeta.inputs + dspMeta.outputs * 2) * (ptrSize + bufferSize * sampleSize)) / 65536;\n    memorySize = Math.max(2, memorySize);\n    return new WebAssembly.Memory({ initial: memorySize, maximum: memorySize });\n  }\n  static createMonoDSPInstanceAux(instance, json) {\n    const functions = instance.exports;\n    const api = new FaustDspInstance_default(functions);\n    const memory = instance.exports.memory;\n    return { memory, api, json };\n  }\n  static createMemoryAux(voices, voiceFactory, effectFactory) {\n    const voiceMeta = JSON.parse(voiceFactory.json);\n    const effectMeta = effectFactory && effectFactory.json ? JSON.parse(effectFactory.json) : null;\n    const sampleSize = voiceMeta.compile_options.match(\"-double\") ? 8 : 4;\n    return this.createWasmMemory(voices, sampleSize, voiceMeta, effectMeta, 8192);\n  }\n  static createMixerAux(mixerModule, memory) {\n    const mixerImport = {\n      imports: { print: console.log },\n      memory: { memory }\n    };\n    const mixerInstance = new WebAssembly.Instance(mixerModule, mixerImport);\n    const mixerFunctions = mixerInstance.exports;\n    return mixerFunctions;\n  }\n  static async loadDSPFactory(wasmPath, jsonPath) {\n    const wasmFile = await fetch(wasmPath);\n    if (!wasmFile.ok) {\n      console.error(`=> exception raised while running loadDSPFactory, file not found: ${wasmPath}`);\n      return null;\n    }\n    try {\n      const wasmBuffer = await wasmFile.arrayBuffer();\n      const module = await WebAssembly.compile(wasmBuffer);\n      const jsonFile = await fetch(jsonPath);\n      const json = await jsonFile.text();\n      const meta = JSON.parse(json);\n      const cOptions = meta.compile_options;\n      const poly = cOptions.indexOf(\"wasm-e\") !== -1;\n      return { cfactory: 0, code: new Uint8Array(wasmBuffer), module, json, poly };\n    } catch (e) {\n      console.error(`=> exception raised while running loadDSPFactory: ${e}`);\n      return null;\n    }\n  }\n  static async loadDSPMixer(mixerPath, fs) {\n    try {\n      let mixerBuffer = null;\n      if (fs) {\n        mixerBuffer = fs.readFile(mixerPath, { encoding: \"binary\" });\n      } else {\n        const mixerFile = await fetch(mixerPath);\n        mixerBuffer = await mixerFile.arrayBuffer();\n      }\n      return WebAssembly.compile(mixerBuffer);\n    } catch (e) {\n      console.error(`=> exception raised while running loadMixer: ${e}`);\n      return null;\n    }\n  }\n  static async createAsyncMonoDSPInstance(factory) {\n    const instance = await WebAssembly.instantiate(factory.module, this.createWasmImport());\n    return this.createMonoDSPInstanceAux(instance, factory.json);\n  }\n  static createSyncMonoDSPInstance(factory) {\n    const instance = new WebAssembly.Instance(factory.module, this.createWasmImport());\n    return this.createMonoDSPInstanceAux(instance, factory.json);\n  }\n  static async createAsyncPolyDSPInstance(voiceFactory, mixerModule, voices, effectFactory) {\n    const memory = this.createMemoryAux(voices, voiceFactory, effectFactory);\n    const voiceInstance = await WebAssembly.instantiate(voiceFactory.module, this.createWasmImport(memory));\n    const voiceFunctions = voiceInstance.exports;\n    const voiceAPI = new FaustDspInstance_default(voiceFunctions);\n    const mixerAPI = this.createMixerAux(mixerModule, memory);\n    if (effectFactory) {\n      const effectInstance = await WebAssembly.instantiate(effectFactory.module, this.createWasmImport(memory));\n      const effectFunctions = effectInstance.exports;\n      const effectAPI = new FaustDspInstance_default(effectFunctions);\n      return {\n        memory,\n        voices,\n        voiceAPI,\n        effectAPI,\n        mixerAPI,\n        voiceJSON: voiceFactory.json,\n        effectJSON: effectFactory.json\n      };\n    } else {\n      return {\n        memory,\n        voices,\n        voiceAPI,\n        mixerAPI,\n        voiceJSON: voiceFactory.json\n      };\n    }\n  }\n  static createSyncPolyDSPInstance(voiceFactory, mixerModule, voices, effectFactory) {\n    const memory = this.createMemoryAux(voices, voiceFactory, effectFactory);\n    const voiceInstance = new WebAssembly.Instance(voiceFactory.module, this.createWasmImport(memory));\n    const voiceFunctions = voiceInstance.exports;\n    const voiceAPI = new FaustDspInstance_default(voiceFunctions);\n    const mixerAPI = this.createMixerAux(mixerModule, memory);\n    if (effectFactory) {\n      const effectInstance = new WebAssembly.Instance(effectFactory.module, this.createWasmImport(memory));\n      const effectFunctions = effectInstance.exports;\n      const effectAPI = new FaustDspInstance_default(effectFunctions);\n      return {\n        memory,\n        voices,\n        voiceAPI,\n        effectAPI,\n        mixerAPI,\n        voiceJSON: voiceFactory.json,\n        effectJSON: effectFactory.json\n      };\n    } else {\n      return {\n        memory,\n        voices,\n        voiceAPI,\n        mixerAPI,\n        voiceJSON: voiceFactory.json\n      };\n    }\n  }\n};\nvar FaustWasmInstantiator_default = FaustWasmInstantiator;\n\n// src/FaustOfflineProcessor.ts\nvar FaustOfflineProcessor = class {\n  constructor(instance, bufferSize) {\n    this.fDSPCode = instance;\n    this.fBufferSize = bufferSize;\n    this.fInputs = new Array(this.fDSPCode.getNumInputs()).fill(null).map(() => new Float32Array(bufferSize));\n    this.fOutputs = new Array(this.fDSPCode.getNumOutputs()).fill(null).map(() => new Float32Array(bufferSize));\n  }\n  render(inputs = [], length = this.fBufferSize, onUpdate) {\n    let l = 0;\n    const outputs = new Array(this.fDSPCode.getNumOutputs()).fill(null).map(() => new Float32Array(length));\n    this.fDSPCode.start();\n    while (l < length) {\n      const sliceLength = Math.min(length - l, this.fBufferSize);\n      for (let i = 0; i < this.fDSPCode.getNumInputs(); i++) {\n        let input;\n        if (inputs[i]) {\n          if (inputs[i].length <= l) {\n            input = new Float32Array(sliceLength);\n          } else if (inputs[i].length > l + sliceLength) {\n            input = inputs[i].subarray(l, l + sliceLength);\n          } else {\n            input = inputs[i].subarray(l, inputs[i].length);\n          }\n        } else {\n          input = new Float32Array(sliceLength);\n        }\n        this.fInputs[i] = input;\n      }\n      this.fDSPCode.compute(this.fInputs, this.fOutputs);\n      for (let i = 0; i < this.fDSPCode.getNumOutputs(); i++) {\n        const output = this.fOutputs[i];\n        if (sliceLength < this.fBufferSize) {\n          outputs[i].set(output.subarray(0, sliceLength), l);\n        } else {\n          outputs[i].set(output, l);\n        }\n      }\n      l += this.fBufferSize;\n      onUpdate == null ? void 0 : onUpdate(l);\n    }\n    this.fDSPCode.stop();\n    return outputs;\n  }\n};\nvar FaustOfflineProcessor_default = FaustOfflineProcessor;\n\n// src/FaustSvgDiagrams.ts\nvar FaustSvgDiagrams = class {\n  constructor(compiler) {\n    this.compiler = compiler;\n  }\n  from(name, code, args) {\n    const fs = this.compiler.fs();\n    try {\n      const files2 = fs.readdir(`/${name}-svg/`);\n      files2.filter((file) => file !== \".\" && file !== \"..\").forEach((file) => fs.unlink(`/${name}-svg/${file}`));\n    } catch {\n    }\n    const success = this.compiler.generateAuxFiles(name, code, `-lang wasm -svg ${args}`);\n    if (!success)\n      throw new Error(this.compiler.getErrorMessage());\n    const svgs = {};\n    const files = fs.readdir(`/${name}-svg/`);\n    files.filter((file) => file !== \".\" && file !== \"..\").forEach((file) => svgs[file] = fs.readFile(`/${name}-svg/${file}`, { encoding: \"utf8\" }));\n    return svgs;\n  }\n};\nvar FaustSvgDiagrams_default = FaustSvgDiagrams;\n\n// src/LibFaust.ts\nvar LibFaust = class {\n  constructor(module) {\n    this.fModule = module;\n    this.fCompiler = new module.libFaustWasm();\n    this.fFileSystem = this.fModule.FS;\n  }\n  module() {\n    return this.fModule;\n  }\n  fs() {\n    return this.fFileSystem;\n  }\n  version() {\n    return this.fCompiler.version();\n  }\n  createDSPFactory(name, code, args, useInternalMemory) {\n    return this.fCompiler.createDSPFactory(name, code, args, useInternalMemory);\n  }\n  deleteDSPFactory(cFactory) {\n    return this.fCompiler.deleteDSPFactory(cFactory);\n  }\n  expandDSP(name, code, args) {\n    return this.fCompiler.expandDSP(name, code, args);\n  }\n  generateAuxFiles(name, code, args) {\n    return this.fCompiler.generateAuxFiles(name, code, args);\n  }\n  deleteAllDSPFactories() {\n    return this.fCompiler.deleteAllDSPFactories();\n  }\n  getErrorAfterException() {\n    return this.fCompiler.getErrorAfterException();\n  }\n  cleanupAfterException() {\n    return this.fCompiler.cleanupAfterException();\n  }\n  getInfos(what) {\n    return this.fCompiler.getInfos(what);\n  }\n  toString() {\n    return `LibFaust module: ${this.fModule}, compiler: ${this.fCompiler}`;\n  }\n};\nvar LibFaust_default = LibFaust;\n\n// src/WavEncoder.ts\nvar WavEncoder = class {\n  static encode(audioBuffer, options) {\n    const numberOfChannels = audioBuffer.length;\n    const length = audioBuffer[0].length;\n    const { shared, float } = options;\n    const bitDepth = float ? 32 : options.bitDepth | 0 || 16;\n    const byteDepth = bitDepth >> 3;\n    const byteLength = length * numberOfChannels * byteDepth;\n    const AB = shared ? globalThis.SharedArrayBuffer || globalThis.ArrayBuffer : globalThis.ArrayBuffer;\n    const ab = new AB((44 + byteLength) * Uint8Array.BYTES_PER_ELEMENT);\n    const dataView = new DataView(ab);\n    const writer = new Writer(dataView);\n    const format = {\n      formatId: float ? 3 : 1,\n      float: !!float,\n      numberOfChannels,\n      sampleRate: options.sampleRate,\n      symmetric: !!options.symmetric,\n      length,\n      bitDepth,\n      byteDepth\n    };\n    this.writeHeader(writer, format);\n    this.writeData(writer, audioBuffer, format);\n    return ab;\n  }\n  static writeHeader(writer, format) {\n    const { formatId, sampleRate, bitDepth, numberOfChannels, length, byteDepth } = format;\n    writer.string(\"RIFF\");\n    writer.uint32(writer.dataView.byteLength - 8);\n    writer.string(\"WAVE\");\n    writer.string(\"fmt \");\n    writer.uint32(16);\n    writer.uint16(formatId);\n    writer.uint16(numberOfChannels);\n    writer.uint32(sampleRate);\n    writer.uint32(sampleRate * numberOfChannels * byteDepth);\n    writer.uint16(numberOfChannels * byteDepth);\n    writer.uint16(bitDepth);\n    writer.string(\"data\");\n    writer.uint32(length * numberOfChannels * byteDepth);\n    return writer.pos;\n  }\n  static writeData(writer, audioBuffer, format) {\n    const { bitDepth, float, length, numberOfChannels, symmetric } = format;\n    if (bitDepth === 32 && float) {\n      const { dataView, pos } = writer;\n      const ab = dataView.buffer;\n      const f32View = new Float32Array(ab, pos);\n      if (numberOfChannels === 1) {\n        f32View.set(audioBuffer[0]);\n        return;\n      }\n      for (let ch = 0; ch < numberOfChannels; ch++) {\n        const channel = audioBuffer[ch];\n        for (let i = 0; i < length; i++) {\n          f32View[i * numberOfChannels + ch] = channel[i];\n        }\n      }\n      return;\n    }\n    const encoderOption = float ? \"f\" : symmetric ? \"s\" : \"\";\n    const methodName = \"pcm\" + bitDepth + encoderOption;\n    if (!writer[methodName]) {\n      throw new TypeError(\"Not supported bit depth: \" + bitDepth);\n    }\n    const write = writer[methodName].bind(writer);\n    for (let i = 0; i < length; i++) {\n      for (let j = 0; j < numberOfChannels; j++) {\n        write(audioBuffer[j][i]);\n      }\n    }\n  }\n};\nvar Writer = class {\n  constructor(dataView) {\n    this.pos = 0;\n    this.dataView = dataView;\n  }\n  int16(value) {\n    this.dataView.setInt16(this.pos, value, true);\n    this.pos += 2;\n  }\n  uint16(value) {\n    this.dataView.setUint16(this.pos, value, true);\n    this.pos += 2;\n  }\n  uint32(value) {\n    this.dataView.setUint32(this.pos, value, true);\n    this.pos += 4;\n  }\n  string(value) {\n    for (let i = 0, imax = value.length; i < imax; i++) {\n      this.dataView.setUint8(this.pos++, value.charCodeAt(i));\n    }\n  }\n  pcm8(valueIn) {\n    let value = valueIn;\n    value = Math.max(-1, Math.min(value, 1));\n    value = (value * 0.5 + 0.5) * 255;\n    value = Math.round(value) | 0;\n    this.dataView.setUint8(this.pos, value);\n    this.pos += 1;\n  }\n  pcm8s(valueIn) {\n    let value = valueIn;\n    value = Math.round(value * 128) + 128;\n    value = Math.max(0, Math.min(value, 255));\n    this.dataView.setUint8(this.pos, value);\n    this.pos += 1;\n  }\n  pcm16(valueIn) {\n    let value = valueIn;\n    value = Math.max(-1, Math.min(value, 1));\n    value = value < 0 ? value * 32768 : value * 32767;\n    value = Math.round(value) | 0;\n    this.dataView.setInt16(this.pos, value, true);\n    this.pos += 2;\n  }\n  pcm16s(valueIn) {\n    let value = valueIn;\n    value = Math.round(value * 32768);\n    value = Math.max(-32768, Math.min(value, 32767));\n    this.dataView.setInt16(this.pos, value, true);\n    this.pos += 2;\n  }\n  pcm24(valueIn) {\n    let value = valueIn;\n    value = Math.max(-1, Math.min(value, 1));\n    value = value < 0 ? 16777216 + value * 8388608 : value * 8388607;\n    value = Math.round(value) | 0;\n    const x0 = value >> 0 & 255;\n    const x1 = value >> 8 & 255;\n    const x2 = value >> 16 & 255;\n    this.dataView.setUint8(this.pos + 0, x0);\n    this.dataView.setUint8(this.pos + 1, x1);\n    this.dataView.setUint8(this.pos + 2, x2);\n    this.pos += 3;\n  }\n  pcm24s(valueIn) {\n    let value = valueIn;\n    value = Math.round(value * 8388608);\n    value = Math.max(-8388608, Math.min(value, 8388607));\n    const x0 = value >> 0 & 255;\n    const x1 = value >> 8 & 255;\n    const x2 = value >> 16 & 255;\n    this.dataView.setUint8(this.pos + 0, x0);\n    this.dataView.setUint8(this.pos + 1, x1);\n    this.dataView.setUint8(this.pos + 2, x2);\n    this.pos += 3;\n  }\n  pcm32(valueIn) {\n    let value = valueIn;\n    value = Math.max(-1, Math.min(value, 1));\n    value = value < 0 ? value * 2147483648 : value * 2147483647;\n    value = Math.round(value) | 0;\n    this.dataView.setInt32(this.pos, value, true);\n    this.pos += 4;\n  }\n  pcm32s(valueIn) {\n    let value = valueIn;\n    value = Math.round(value * 2147483648);\n    value = Math.max(-2147483648, Math.min(value, 2147483647));\n    this.dataView.setInt32(this.pos, value, true);\n    this.pos += 4;\n  }\n  pcm32f(value) {\n    this.dataView.setFloat32(this.pos, value, true);\n    this.pos += 4;\n  }\n};\nvar WavEncoder_default = WavEncoder;\n\n// src/WavDecoder.ts\nvar WavDecoder = class {\n  static decode(buffer, options) {\n    const dataView = new DataView(buffer);\n    const reader = new Reader(dataView);\n    if (reader.string(4) !== \"RIFF\") {\n      throw new TypeError(\"Invalid WAV file\");\n    }\n    reader.uint32();\n    if (reader.string(4) !== \"WAVE\") {\n      throw new TypeError(\"Invalid WAV file\");\n    }\n    let format = null;\n    let audioData = null;\n    do {\n      const chunkType = reader.string(4);\n      const chunkSize = reader.uint32();\n      if (chunkType === \"fmt \") {\n        format = this.decodeFormat(reader, chunkSize);\n      } else if (chunkType === \"data\") {\n        audioData = this.decodeData(reader, chunkSize, format, options || {});\n      } else {\n        reader.skip(chunkSize);\n      }\n    } while (audioData === null);\n    return audioData;\n  }\n  static decodeFormat(reader, chunkSize) {\n    const formats = {\n      1: \"lpcm\",\n      3: \"lpcm\"\n    };\n    const formatId = reader.uint16();\n    if (!formats.hasOwnProperty(formatId)) {\n      throw new TypeError(\"Unsupported format in WAV file: 0x\" + formatId.toString(16));\n    }\n    const format = {\n      formatId,\n      float: formatId === 3,\n      numberOfChannels: reader.uint16(),\n      sampleRate: reader.uint32(),\n      byteRate: reader.uint32(),\n      blockSize: reader.uint16(),\n      bitDepth: reader.uint16()\n    };\n    reader.skip(chunkSize - 16);\n    return format;\n  }\n  static decodeData(reader, chunkSizeIn, format, options) {\n    const chunkSize = Math.min(chunkSizeIn, reader.remain());\n    const length = Math.floor(chunkSize / format.blockSize);\n    const numberOfChannels = format.numberOfChannels;\n    const sampleRate = format.sampleRate;\n    const channelData = new Array(numberOfChannels);\n    for (let ch = 0; ch < numberOfChannels; ch++) {\n      const AB = options.shared ? globalThis.SharedArrayBuffer || globalThis.ArrayBuffer : globalThis.ArrayBuffer;\n      const ab = new AB(length * Float32Array.BYTES_PER_ELEMENT);\n      channelData[ch] = new Float32Array(ab);\n    }\n    this.readPCM(reader, channelData, length, format, options);\n    return {\n      numberOfChannels,\n      length,\n      sampleRate,\n      channelData\n    };\n  }\n  static readPCM(reader, channelData, length, format, options) {\n    const bitDepth = format.bitDepth;\n    const decoderOption = format.float ? \"f\" : options.symmetric ? \"s\" : \"\";\n    const methodName = \"pcm\" + bitDepth + decoderOption;\n    if (!reader[methodName]) {\n      throw new TypeError(\"Not supported bit depth: \" + format.bitDepth);\n    }\n    const read = reader[methodName].bind(reader);\n    const numberOfChannels = format.numberOfChannels;\n    for (let i = 0; i < length; i++) {\n      for (let ch = 0; ch < numberOfChannels; ch++) {\n        channelData[ch][i] = read();\n      }\n    }\n  }\n};\nvar Reader = class {\n  constructor(dataView) {\n    this.pos = 0;\n    this.dataView = dataView;\n  }\n  remain() {\n    return this.dataView.byteLength - this.pos;\n  }\n  skip(n) {\n    this.pos += n;\n  }\n  uint8() {\n    const data = this.dataView.getUint8(this.pos);\n    this.pos += 1;\n    return data;\n  }\n  int16() {\n    const data = this.dataView.getInt16(this.pos, true);\n    this.pos += 2;\n    return data;\n  }\n  uint16() {\n    const data = this.dataView.getUint16(this.pos, true);\n    this.pos += 2;\n    return data;\n  }\n  uint32() {\n    const data = this.dataView.getUint32(this.pos, true);\n    this.pos += 4;\n    return data;\n  }\n  string(n) {\n    let data = \"\";\n    for (let i = 0; i < n; i++) {\n      data += String.fromCharCode(this.uint8());\n    }\n    return data;\n  }\n  pcm8() {\n    const data = this.dataView.getUint8(this.pos) - 128;\n    this.pos += 1;\n    return data < 0 ? data / 128 : data / 127;\n  }\n  pcm8s() {\n    const data = this.dataView.getUint8(this.pos) - 127.5;\n    this.pos += 1;\n    return data / 127.5;\n  }\n  pcm16() {\n    const data = this.dataView.getInt16(this.pos, true);\n    this.pos += 2;\n    return data < 0 ? data / 32768 : data / 32767;\n  }\n  pcm16s() {\n    const data = this.dataView.getInt16(this.pos, true);\n    this.pos += 2;\n    return data / 32768;\n  }\n  pcm24() {\n    const x0 = this.dataView.getUint8(this.pos + 0);\n    const x1 = this.dataView.getUint8(this.pos + 1);\n    const x2 = this.dataView.getUint8(this.pos + 2);\n    const xx = x0 + (x1 << 8) + (x2 << 16);\n    const data = xx > 8388608 ? xx - 16777216 : xx;\n    this.pos += 3;\n    return data < 0 ? data / 8388608 : data / 8388607;\n  }\n  pcm24s() {\n    const x0 = this.dataView.getUint8(this.pos + 0);\n    const x1 = this.dataView.getUint8(this.pos + 1);\n    const x2 = this.dataView.getUint8(this.pos + 2);\n    const xx = x0 + (x1 << 8) + (x2 << 16);\n    const data = xx > 8388608 ? xx - 16777216 : xx;\n    this.pos += 3;\n    return data / 8388608;\n  }\n  pcm32() {\n    const data = this.dataView.getInt32(this.pos, true);\n    this.pos += 4;\n    return data < 0 ? data / 2147483648 : data / 2147483647;\n  }\n  pcm32s() {\n    const data = this.dataView.getInt32(this.pos, true);\n    this.pos += 4;\n    return data / 2147483648;\n  }\n  pcm32f() {\n    const data = this.dataView.getFloat32(this.pos, true);\n    this.pos += 4;\n    return data;\n  }\n  pcm64f() {\n    const data = this.dataView.getFloat64(this.pos, true);\n    this.pos += 8;\n    return data;\n  }\n};\nvar WavDecoder_default = WavDecoder;\n\n// src/FaustWebAudioDsp.ts\nvar FaustBaseWebAudioDsp = class {\n  constructor(sampleSize, bufferSize) {\n    this.fOutputHandler = null;\n    this.fComputeHandler = null;\n    this.fCachedEvents = [];\n    this.fBufferNum = 0;\n    this.fPlotHandler = null;\n    this.fBufferSize = bufferSize;\n    this.fInChannels = [];\n    this.fOutChannels = [];\n    this.gPtrSize = sampleSize;\n    this.gSampleSize = sampleSize;\n    this.fOutputsTimer = 5;\n    this.fInputsItems = [];\n    this.fOutputsItems = [];\n    this.fDescriptor = [];\n    this.fPitchwheelLabel = [];\n    this.fCtrlLabel = new Array(128).fill(null).map(() => []);\n    this.fPathTable = {};\n    this.fProcessing = false;\n    this.fDestroyed = false;\n    this.fUICallback = (item) => {\n      if (item.type === \"hbargraph\" || item.type === \"vbargraph\") {\n        this.fOutputsItems.push(item.address);\n        this.fPathTable[item.address] = item.index;\n      } else if (item.type === \"vslider\" || item.type === \"hslider\" || item.type === \"button\" || item.type === \"checkbox\" || item.type === \"nentry\") {\n        this.fInputsItems.push(item.address);\n        this.fPathTable[item.address] = item.index;\n        this.fDescriptor.push(item);\n        if (!item.meta)\n          return;\n        item.meta.forEach((meta) => {\n          const { midi } = meta;\n          if (!midi)\n            return;\n          const strMidi = midi.trim();\n          if (strMidi === \"pitchwheel\") {\n            this.fPitchwheelLabel.push({ path: item.address, min: item.min, max: item.max });\n          } else {\n            const matched = strMidi.match(/^ctrl\\s(\\d+)/);\n            if (!matched)\n              return;\n            this.fCtrlLabel[parseInt(matched[1])].push({ path: item.address, min: item.min, max: item.max });\n          }\n        });\n      }\n    };\n  }\n  static remap(v, mn0, mx0, mn1, mx1) {\n    return (v - mn0) / (mx0 - mn0) * (mx1 - mn1) + mn1;\n  }\n  static parseUI(ui, callback) {\n    ui.forEach((group) => this.parseGroup(group, callback));\n  }\n  static parseGroup(group, callback) {\n    if (group.items) {\n      this.parseItems(group.items, callback);\n    }\n  }\n  static parseItems(items, callback) {\n    items.forEach((item) => this.parseItem(item, callback));\n  }\n  static parseItem(item, callback) {\n    if (item.type === \"vgroup\" || item.type === \"hgroup\" || item.type === \"tgroup\") {\n      this.parseItems(item.items, callback);\n    } else {\n      callback(item);\n    }\n  }\n  updateOutputs() {\n    if (this.fOutputsItems.length > 0 && this.fOutputHandler && this.fOutputsTimer-- === 0) {\n      this.fOutputsTimer = 5;\n      this.fOutputsItems.forEach((item) => {\n        var _a;\n        return (_a = this.fOutputHandler) == null ? void 0 : _a.call(this, item, this.getParamValue(item));\n      });\n    }\n  }\n  metadata(handler) {\n    if (this.fJSONDsp.meta) {\n      this.fJSONDsp.meta.forEach((meta) => handler(Object.keys(meta)[0], meta[Object.keys(meta)[0]]));\n    }\n  }\n  compute(input, output) {\n    return false;\n  }\n  setOutputParamHandler(handler) {\n    this.fOutputHandler = handler;\n  }\n  getOutputParamHandler() {\n    return this.fOutputHandler;\n  }\n  setComputeHandler(handler) {\n    this.fComputeHandler = handler;\n  }\n  getComputeHandler() {\n    return this.fComputeHandler;\n  }\n  setPlotHandler(handler) {\n    this.fPlotHandler = handler;\n  }\n  getPlotHandler() {\n    return this.fPlotHandler;\n  }\n  getNumInputs() {\n    return -1;\n  }\n  getNumOutputs() {\n    return -1;\n  }\n  midiMessage(data) {\n    if (this.fPlotHandler)\n      this.fCachedEvents.push({ data, type: \"midi\" });\n    const cmd = data[0] >> 4;\n    const channel = data[0] & 15;\n    const data1 = data[1];\n    const data2 = data[2];\n    if (cmd === 11)\n      return this.ctrlChange(channel, data1, data2);\n    if (cmd === 14)\n      return this.pitchWheel(channel, data2 * 128 + data1);\n  }\n  ctrlChange(channel, ctrl, value) {\n    if (this.fPlotHandler)\n      this.fCachedEvents.push({ type: \"ctrlChange\", data: [channel, ctrl, value] });\n    if (this.fCtrlLabel[ctrl].length) {\n      this.fCtrlLabel[ctrl].forEach((ctrl2) => {\n        const { path } = ctrl2;\n        this.setParamValue(path, FaustBaseWebAudioDsp.remap(value, 0, 127, ctrl2.min, ctrl2.max));\n        if (this.fOutputHandler)\n          this.fOutputHandler(path, this.getParamValue(path));\n      });\n    }\n  }\n  pitchWheel(channel, wheel) {\n    if (this.fPlotHandler)\n      this.fCachedEvents.push({ type: \"pitchWheel\", data: [channel, wheel] });\n    this.fPitchwheelLabel.forEach((pw) => {\n      this.setParamValue(pw.path, FaustBaseWebAudioDsp.remap(wheel, 0, 16383, pw.min, pw.max));\n      if (this.fOutputHandler)\n        this.fOutputHandler(pw.path, this.getParamValue(pw.path));\n    });\n  }\n  setParamValue(path, value) {\n  }\n  getParamValue(path) {\n    return 0;\n  }\n  getParams() {\n    return this.fInputsItems;\n  }\n  getMeta() {\n    return this.fJSONDsp;\n  }\n  getJSON() {\n    return JSON.stringify(this.getMeta());\n  }\n  getUI() {\n    return this.fJSONDsp.ui;\n  }\n  getDescriptors() {\n    return this.fDescriptor;\n  }\n  start() {\n    this.fProcessing = true;\n  }\n  stop() {\n    this.fProcessing = false;\n  }\n  destroy() {\n    this.fDestroyed = true;\n    this.fOutputHandler = null;\n    this.fComputeHandler = null;\n    this.fPlotHandler = null;\n  }\n};\nvar FaustMonoWebAudioDsp = class extends FaustBaseWebAudioDsp {\n  constructor(instance, sampleRate, sampleSize, bufferSize) {\n    super(sampleSize, bufferSize);\n    this.fInstance = instance;\n    this.fJSONDsp = JSON.parse(this.fInstance.json);\n    FaustBaseWebAudioDsp.parseUI(this.fJSONDsp.ui, this.fUICallback);\n    this.initMemory();\n    this.fInstance.api.init(this.fDSP, sampleRate);\n  }\n  initMemory() {\n    this.fDSP = 0;\n    const $audio = this.fJSONDsp.size;\n    this.fAudioInputs = $audio;\n    this.fAudioOutputs = this.fAudioInputs + this.getNumInputs() * this.gPtrSize;\n    const $audioInputs = this.fAudioOutputs + this.getNumOutputs() * this.gPtrSize;\n    const $audioOutputs = $audioInputs + this.getNumInputs() * this.fBufferSize * this.gSampleSize;\n    const HEAP = this.fInstance.memory.buffer;\n    const HEAP32 = new Int32Array(HEAP);\n    const HEAPF = this.gSampleSize === 4 ? new Float32Array(HEAP) : new Float64Array(HEAP);\n    if (this.getNumInputs() > 0) {\n      for (let chan = 0; chan < this.getNumInputs(); chan++) {\n        HEAP32[(this.fAudioInputs >> 2) + chan] = $audioInputs + this.fBufferSize * this.gSampleSize * chan;\n      }\n      const dspInChans = HEAP32.subarray(this.fAudioInputs >> 2, this.fAudioInputs + this.getNumInputs() * this.gPtrSize >> 2);\n      for (let chan = 0; chan < this.getNumInputs(); chan++) {\n        this.fInChannels[chan] = HEAPF.subarray(dspInChans[chan] >> Math.log2(this.gSampleSize), dspInChans[chan] + this.fBufferSize * this.gSampleSize >> Math.log2(this.gSampleSize));\n      }\n    }\n    if (this.getNumOutputs() > 0) {\n      for (let chan = 0; chan < this.getNumOutputs(); chan++) {\n        HEAP32[(this.fAudioOutputs >> 2) + chan] = $audioOutputs + this.fBufferSize * this.gSampleSize * chan;\n      }\n      const dspOutChans = HEAP32.subarray(this.fAudioOutputs >> 2, this.fAudioOutputs + this.getNumOutputs() * this.gPtrSize >> 2);\n      for (let chan = 0; chan < this.getNumOutputs(); chan++) {\n        this.fOutChannels[chan] = HEAPF.subarray(dspOutChans[chan] >> Math.log2(this.gSampleSize), dspOutChans[chan] + this.fBufferSize * this.gSampleSize >> Math.log2(this.gSampleSize));\n      }\n    }\n  }\n  toString() {\n    return `============== Mono Memory layout ==============\nthis.fBufferSize: ${this.fBufferSize}\nthis.fJSONDsp.size: ${this.fJSONDsp.size}\nthis.fAudioInputs: ${this.fAudioInputs}\nthis.fAudioOutputs: ${this.fAudioOutputs}\nthis.fDSP: ${this.fDSP}`;\n  }\n  compute(input, output) {\n    if (this.fDestroyed)\n      return false;\n    if (!this.fProcessing)\n      return true;\n    if (this.getNumInputs() > 0 && (!input || !input[0] || input[0].length === 0)) {\n      return true;\n    }\n    if (this.getNumOutputs() > 0 && (!output || !output[0] || output[0].length === 0)) {\n      return true;\n    }\n    if (input !== void 0) {\n      for (let chan = 0; chan < Math.min(this.getNumInputs(), input.length); ++chan) {\n        const dspInput = this.fInChannels[chan];\n        dspInput.set(input[chan]);\n      }\n    }\n    if (this.fComputeHandler)\n      this.fComputeHandler(this.fBufferSize);\n    this.fInstance.api.compute(this.fDSP, this.fBufferSize, this.fAudioInputs, this.fAudioOutputs);\n    this.updateOutputs();\n    if (output !== void 0) {\n      for (let chan = 0; chan < Math.min(this.getNumOutputs(), output.length); chan++) {\n        const dspOutput = this.fOutChannels[chan];\n        output[chan].set(dspOutput);\n      }\n      if (this.fPlotHandler) {\n        this.fPlotHandler(output, this.fBufferNum++, this.fCachedEvents.length ? this.fCachedEvents : void 0);\n        this.fCachedEvents = [];\n      }\n    }\n    return true;\n  }\n  metadata(handler) {\n    super.metadata(handler);\n  }\n  getNumInputs() {\n    return this.fInstance.api.getNumInputs(this.fDSP);\n  }\n  getNumOutputs() {\n    return this.fInstance.api.getNumOutputs(this.fDSP);\n  }\n  setParamValue(path, value) {\n    if (this.fPlotHandler)\n      this.fCachedEvents.push({ type: \"param\", data: { path, value } });\n    this.fInstance.api.setParamValue(this.fDSP, this.fPathTable[path], value);\n  }\n  getParamValue(path) {\n    return this.fInstance.api.getParamValue(this.fDSP, this.fPathTable[path]);\n  }\n  getMeta() {\n    return this.fJSONDsp;\n  }\n  getJSON() {\n    return this.fInstance.json;\n  }\n  getDescriptors() {\n    return this.fDescriptor;\n  }\n  getUI() {\n    return this.fJSONDsp.ui;\n  }\n};\nvar FaustWebAudioDspVoice = class {\n  constructor($dsp, api, inputItems, pathTable, sampleRate) {\n    FaustWebAudioDspVoice.kActiveVoice = 0;\n    FaustWebAudioDspVoice.kFreeVoice = -1;\n    FaustWebAudioDspVoice.kReleaseVoice = -2;\n    FaustWebAudioDspVoice.kLegatoVoice = -3;\n    FaustWebAudioDspVoice.kNoVoice = -4;\n    FaustWebAudioDspVoice.VOICE_STOP_LEVEL = 5e-4;\n    this.fKeyFun = (pitch) => FaustWebAudioDspVoice.midiToFreq(pitch);\n    this.fVelFun = (velocity) => velocity / 127;\n    this.fCurNote = FaustWebAudioDspVoice.kFreeVoice;\n    this.fNextNote = this.fNextVel = -1;\n    this.fLevel = 0;\n    this.fDate = this.fRelease = 0;\n    this.fDSP = $dsp;\n    this.fAPI = api;\n    this.fGateLabel = [];\n    this.fGainLabel = [];\n    this.fFreqLabel = [];\n    this.fAPI.init(this.fDSP, sampleRate);\n    this.extractPaths(inputItems, pathTable);\n  }\n  static midiToFreq(note) {\n    return 440 * 2 ** ((note - 69) / 12);\n  }\n  extractPaths(inputItems, pathTable) {\n    inputItems.forEach((item) => {\n      if (item.endsWith(\"/gate\")) {\n        this.fGateLabel.push(pathTable[item]);\n      } else if (item.endsWith(\"/freq\")) {\n        this.fKeyFun = (pitch) => FaustWebAudioDspVoice.midiToFreq(pitch);\n        this.fFreqLabel.push(pathTable[item]);\n      } else if (item.endsWith(\"/key\")) {\n        this.fKeyFun = (pitch) => pitch;\n        this.fFreqLabel.push(pathTable[item]);\n      } else if (item.endsWith(\"/gain\")) {\n        this.fVelFun = (velocity) => velocity / 127;\n        this.fGainLabel.push(pathTable[item]);\n      } else if (item.endsWith(\"/vel\") && item.endsWith(\"/velocity\")) {\n        this.fVelFun = (velocity) => velocity;\n        this.fGainLabel.push(pathTable[item]);\n      }\n    });\n  }\n  keyOn(pitch, velocity, legato = false) {\n    if (legato) {\n      this.fNextNote = pitch;\n      this.fNextVel = velocity;\n    } else {\n      this.fFreqLabel.forEach((index) => this.fAPI.setParamValue(this.fDSP, index, this.fKeyFun(pitch)));\n      this.fGateLabel.forEach((index) => this.fAPI.setParamValue(this.fDSP, index, 1));\n      this.fGainLabel.forEach((index) => this.fAPI.setParamValue(this.fDSP, index, this.fVelFun(velocity)));\n      this.fCurNote = pitch;\n    }\n  }\n  keyOff(hard = false) {\n    this.fGateLabel.forEach((index) => this.fAPI.setParamValue(this.fDSP, index, 0));\n    if (hard) {\n      this.fCurNote = FaustWebAudioDspVoice.kFreeVoice;\n    } else {\n      this.fRelease = this.fAPI.getSampleRate(this.fDSP) / 2;\n      this.fCurNote = FaustWebAudioDspVoice.kReleaseVoice;\n    }\n  }\n  computeLegato(bufferSize, $inputs, $outputZero, $outputsHalf) {\n    let size = bufferSize / 2;\n    this.fGateLabel.forEach((index) => this.fAPI.setParamValue(this.fDSP, index, 0));\n    this.fAPI.compute(this.fDSP, size, $inputs, $outputZero);\n    this.keyOn(this.fNextNote, this.fNextVel);\n    this.fAPI.compute(this.fDSP, size, $inputs, $outputsHalf);\n  }\n  compute(bufferSize, $inputs, $outputs) {\n    this.fAPI.compute(this.fDSP, bufferSize, $inputs, $outputs);\n  }\n  setParamValue(index, value) {\n    this.fAPI.setParamValue(this.fDSP, index, value);\n  }\n  getParamValue(index) {\n    return this.fAPI.getParamValue(this.fDSP, index);\n  }\n};\nvar FaustPolyWebAudioDsp = class extends FaustBaseWebAudioDsp {\n  constructor(instance, sampleRate, sampleSize, bufferSize) {\n    super(sampleSize, bufferSize);\n    this.fInstance = instance;\n    this.fJSONDsp = JSON.parse(this.fInstance.voiceJSON);\n    this.fJSONEffect = this.fInstance.effectAPI && this.fInstance.effectJSON ? JSON.parse(this.fInstance.effectJSON) : null;\n    FaustBaseWebAudioDsp.parseUI(this.fJSONDsp.ui, this.fUICallback);\n    if (this.fJSONEffect)\n      FaustBaseWebAudioDsp.parseUI(this.fJSONEffect.ui, this.fUICallback);\n    this.initMemory();\n    this.fVoiceTable = [];\n    for (let voice = 0; voice < this.fInstance.voices; voice++) {\n      this.fVoiceTable.push(new FaustWebAudioDspVoice(this.fJSONDsp.size * voice, this.fInstance.voiceAPI, this.fInputsItems, this.fPathTable, sampleRate));\n    }\n    if (this.fInstance.effectAPI)\n      this.fInstance.effectAPI.init(this.fEffect, sampleRate);\n  }\n  initMemory() {\n    this.fEffect = this.fJSONDsp.size * this.fInstance.voices;\n    const $audio = this.fEffect + (this.fJSONEffect ? this.fJSONEffect.size : 0);\n    this.fAudioInputs = $audio;\n    this.fAudioOutputs = this.fAudioInputs + this.getNumInputs() * this.gPtrSize;\n    this.fAudioMixing = this.fAudioOutputs + this.getNumOutputs() * this.gPtrSize;\n    this.fAudioMixingHalf = this.fAudioMixing + this.getNumOutputs() * this.gPtrSize;\n    const $audioInputs = this.fAudioMixingHalf + this.getNumOutputs() * this.gPtrSize;\n    const $audioOutputs = $audioInputs + this.getNumInputs() * this.fBufferSize * this.gSampleSize;\n    const $audioMixing = $audioOutputs + this.getNumOutputs() * this.fBufferSize * this.gSampleSize;\n    const HEAP = this.fInstance.memory.buffer;\n    const HEAP32 = new Int32Array(HEAP);\n    const HEAPF = this.gSampleSize === 4 ? new Float32Array(HEAP) : new Float64Array(HEAP);\n    if (this.getNumInputs() > 0) {\n      for (let chan = 0; chan < this.getNumInputs(); chan++) {\n        HEAP32[(this.fAudioInputs >> 2) + chan] = $audioInputs + this.fBufferSize * this.gSampleSize * chan;\n      }\n      const dspInChans = HEAP32.subarray(this.fAudioInputs >> 2, this.fAudioInputs + this.getNumInputs() * this.gPtrSize >> 2);\n      for (let chan = 0; chan < this.getNumInputs(); chan++) {\n        this.fInChannels[chan] = HEAPF.subarray(dspInChans[chan] >> Math.log2(this.gSampleSize), dspInChans[chan] + this.fBufferSize * this.gSampleSize >> Math.log2(this.gSampleSize));\n      }\n    }\n    if (this.getNumOutputs() > 0) {\n      for (let chan = 0; chan < this.getNumOutputs(); chan++) {\n        HEAP32[(this.fAudioOutputs >> 2) + chan] = $audioOutputs + this.fBufferSize * this.gSampleSize * chan;\n        HEAP32[(this.fAudioMixing >> 2) + chan] = $audioMixing + this.fBufferSize * this.gSampleSize * chan;\n        HEAP32[(this.fAudioMixingHalf >> 2) + chan] = $audioMixing + this.fBufferSize * this.gSampleSize * chan + this.fBufferSize / 2 * this.gSampleSize;\n      }\n      const dspOutChans = HEAP32.subarray(this.fAudioOutputs >> 2, this.fAudioOutputs + this.getNumOutputs() * this.gPtrSize >> 2);\n      for (let chan = 0; chan < this.getNumOutputs(); chan++) {\n        this.fOutChannels[chan] = HEAPF.subarray(dspOutChans[chan] >> Math.log2(this.gSampleSize), dspOutChans[chan] + this.fBufferSize * this.gSampleSize >> Math.log2(this.gSampleSize));\n      }\n    }\n  }\n  toString() {\n    return `============== Poly Memory layout ==============\nthis.fBufferSize: ${this.fBufferSize}\nthis.fJSONDsp.size: ${this.fJSONDsp.size}\nthis.fAudioInputs: ${this.fAudioInputs}\nthis.fAudioOutputs: ${this.fAudioOutputs}\nthis.fAudioMixing: ${this.fAudioMixing}\nthis.fAudioMixingHalf: ${this.fAudioMixingHalf}`;\n  }\n  allocVoice(voice, type) {\n    this.fVoiceTable[voice].fDate++;\n    this.fVoiceTable[voice].fCurNote = type;\n    return voice;\n  }\n  getPlayingVoice(pitch) {\n    let voicePlaying = FaustWebAudioDspVoice.kNoVoice;\n    let oldestDatePlaying = Number.MAX_VALUE;\n    for (let voice = 0; voice < this.fInstance.voices; voice++) {\n      if (this.fVoiceTable[voice].fCurNote === pitch) {\n        if (this.fVoiceTable[voice].fDate < oldestDatePlaying) {\n          oldestDatePlaying = this.fVoiceTable[voice].fDate;\n          voicePlaying = voice;\n        }\n      }\n    }\n    return voicePlaying;\n  }\n  getFreeVoice() {\n    for (let voice = 0; voice < this.fInstance.voices; voice++) {\n      if (this.fVoiceTable[voice].fCurNote === FaustWebAudioDspVoice.kFreeVoice) {\n        return this.allocVoice(voice, FaustWebAudioDspVoice.kActiveVoice);\n      }\n    }\n    let voiceRelease = FaustWebAudioDspVoice.kNoVoice;\n    let voicePlaying = FaustWebAudioDspVoice.kNoVoice;\n    let oldestDateRelease = Number.MAX_VALUE;\n    let oldestDatePlaying = Number.MAX_VALUE;\n    for (let voice = 0; voice < this.fInstance.voices; voice++) {\n      if (this.fVoiceTable[voice].fCurNote === FaustWebAudioDspVoice.kReleaseVoice) {\n        if (this.fVoiceTable[voice].fDate < oldestDateRelease) {\n          oldestDateRelease = this.fVoiceTable[voice].fDate;\n          voiceRelease = voice;\n        }\n      } else if (this.fVoiceTable[voice].fDate < oldestDatePlaying) {\n        oldestDatePlaying = this.fVoiceTable[voice].fDate;\n        voicePlaying = voice;\n      }\n    }\n    if (oldestDateRelease !== Number.MAX_VALUE) {\n      console.log(`Steal release voice : voice_date = ${this.fVoiceTable[voiceRelease].fDate} voice = ${voiceRelease}`);\n      return this.allocVoice(voiceRelease, FaustWebAudioDspVoice.kLegatoVoice);\n    }\n    if (oldestDatePlaying !== Number.MAX_VALUE) {\n      console.log(`Steal playing voice : voice_date = ${this.fVoiceTable[voicePlaying].fDate} voice = ${voicePlaying}`);\n      return this.allocVoice(voicePlaying, FaustWebAudioDspVoice.kLegatoVoice);\n    }\n    return FaustWebAudioDspVoice.kNoVoice;\n  }\n  compute(input, output) {\n    if (this.fDestroyed)\n      return false;\n    if (!this.fProcessing)\n      return true;\n    if (this.getNumInputs() > 0 && (!input || !input[0] || input[0].length === 0)) {\n      return true;\n    }\n    if (this.getNumOutputs() > 0 && (!output || !output[0] || output[0].length === 0)) {\n      return true;\n    }\n    if (input !== void 0) {\n      for (let chan = 0; chan < Math.min(this.getNumInputs(), input.length); ++chan) {\n        const dspInput = this.fInChannels[chan];\n        dspInput.set(input[chan]);\n      }\n    }\n    if (this.fComputeHandler)\n      this.fComputeHandler(this.fBufferSize);\n    this.fInstance.mixerAPI.clearOutput(this.fBufferSize, this.getNumOutputs(), this.fAudioOutputs);\n    this.fVoiceTable.forEach((voice) => {\n      if (voice.fCurNote === FaustWebAudioDspVoice.kLegatoVoice) {\n        voice.computeLegato(this.fBufferSize, this.fAudioInputs, this.fAudioMixing, this.fAudioMixingHalf);\n        this.fInstance.mixerAPI.fadeOut(this.fBufferSize / 2, this.getNumOutputs(), this.fAudioMixing);\n        voice.fLevel = this.fInstance.mixerAPI.mixCheckVoice(this.fBufferSize, this.getNumOutputs(), this.fAudioMixing, this.fAudioOutputs);\n      } else if (voice.fCurNote !== FaustWebAudioDspVoice.kFreeVoice) {\n        voice.compute(this.fBufferSize, this.fAudioInputs, this.fAudioMixing);\n        voice.fLevel = this.fInstance.mixerAPI.mixCheckVoice(this.fBufferSize, this.getNumOutputs(), this.fAudioMixing, this.fAudioOutputs);\n        voice.fRelease -= this.fBufferSize;\n        if (voice.fCurNote == FaustWebAudioDspVoice.kReleaseVoice && (voice.fLevel < FaustWebAudioDspVoice.VOICE_STOP_LEVEL && voice.fRelease < 0)) {\n          voice.fCurNote = FaustWebAudioDspVoice.kFreeVoice;\n        }\n      }\n    });\n    if (this.fInstance.effectAPI)\n      this.fInstance.effectAPI.compute(this.fEffect, this.fBufferSize, this.fAudioOutputs, this.fAudioOutputs);\n    this.updateOutputs();\n    if (output !== void 0) {\n      for (let chan = 0; chan < Math.min(this.getNumOutputs(), output.length); chan++) {\n        const dspOutput = this.fOutChannels[chan];\n        output[chan].set(dspOutput);\n      }\n      if (this.fPlotHandler) {\n        this.fPlotHandler(output, this.fBufferNum++, this.fCachedEvents.length ? this.fCachedEvents : void 0);\n        this.fCachedEvents = [];\n      }\n    }\n    return true;\n  }\n  getNumInputs() {\n    return this.fInstance.voiceAPI.getNumInputs(0);\n  }\n  getNumOutputs() {\n    return this.fInstance.voiceAPI.getNumOutputs(0);\n  }\n  static findPath(o, p) {\n    if (typeof o !== \"object\") {\n      return false;\n    } else if (o.address) {\n      return o.address === p;\n    } else {\n      for (const k in o) {\n        if (FaustPolyWebAudioDsp.findPath(o[k], p))\n          return true;\n      }\n      return false;\n    }\n  }\n  setParamValue(path, value) {\n    if (this.fPlotHandler)\n      this.fCachedEvents.push({ type: \"param\", data: { path, value } });\n    if (this.fJSONEffect && FaustPolyWebAudioDsp.findPath(this.fJSONEffect.ui, path) && this.fInstance.effectAPI) {\n      this.fInstance.effectAPI.setParamValue(this.fEffect, this.fPathTable[path], value);\n    } else {\n      this.fVoiceTable.forEach((voice) => voice.setParamValue(this.fPathTable[path], value));\n    }\n  }\n  getParamValue(path) {\n    if (this.fJSONEffect && FaustPolyWebAudioDsp.findPath(this.fJSONEffect.ui, path) && this.fInstance.effectAPI) {\n      return this.fInstance.effectAPI.getParamValue(this.fEffect, this.fPathTable[path]);\n    } else {\n      return this.fVoiceTable[0].getParamValue(this.fPathTable[path]);\n    }\n  }\n  getMeta() {\n    const o = this.fJSONDsp;\n    const e = this.fJSONEffect;\n    const r = { ...o };\n    if (e) {\n      r.ui = [{\n        type: \"tgroup\",\n        label: \"Sequencer\",\n        items: [\n          { type: \"vgroup\", label: \"Instrument\", items: o.ui },\n          { type: \"vgroup\", label: \"Effect\", items: e.ui }\n        ]\n      }];\n    } else {\n      r.ui = [{\n        type: \"tgroup\",\n        label: \"Polyphonic\",\n        items: [\n          { type: \"vgroup\", label: \"Voices\", items: o.ui }\n        ]\n      }];\n    }\n    return r;\n  }\n  getJSON() {\n    return JSON.stringify(this.getMeta());\n  }\n  getUI() {\n    return this.getMeta().ui;\n  }\n  getDescriptors() {\n    return this.fDescriptor;\n  }\n  midiMessage(data) {\n    const cmd = data[0] >> 4;\n    const channel = data[0] & 15;\n    const data1 = data[1];\n    const data2 = data[2];\n    if (cmd === 8 || cmd === 9 && data2 === 0)\n      return this.keyOff(channel, data1, data2);\n    else if (cmd === 9)\n      return this.keyOn(channel, data1, data2);\n    else\n      super.midiMessage(data);\n  }\n  ctrlChange(channel, ctrl, value) {\n    if (ctrl === 123 || ctrl === 120) {\n      this.allNotesOff(true);\n    } else {\n      super.ctrlChange(channel, ctrl, value);\n    }\n  }\n  keyOn(channel, pitch, velocity) {\n    const voice = this.getFreeVoice();\n    this.fVoiceTable[voice].keyOn(pitch, velocity, this.fVoiceTable[voice].fCurNote == FaustWebAudioDspVoice.kLegatoVoice);\n  }\n  keyOff(channel, pitch, velocity) {\n    const voice = this.getPlayingVoice(pitch);\n    if (voice !== FaustWebAudioDspVoice.kNoVoice) {\n      this.fVoiceTable[voice].keyOff();\n    } else {\n      console.log(\"Playing pitch = %d not found\\n\", pitch);\n    }\n  }\n  allNotesOff(hard = true) {\n    this.fCachedEvents.push({ type: \"ctrlChange\", data: [0, 123, 0] });\n    this.fVoiceTable.forEach((voice) => voice.keyOff(hard));\n  }\n};\n\n// src/FaustAudioWorkletNode.ts\nvar FaustAudioWorkletNode = class extends (globalThis.AudioWorkletNode || null) {\n  constructor(context, name, factory, options) {\n    const JSONObj = JSON.parse(factory.json);\n    super(context, name, {\n      numberOfInputs: JSONObj.inputs > 0 ? 1 : 0,\n      numberOfOutputs: JSONObj.outputs > 0 ? 1 : 0,\n      channelCount: Math.max(1, JSONObj.inputs),\n      outputChannelCount: [JSONObj.outputs],\n      channelCountMode: \"explicit\",\n      channelInterpretation: \"speakers\",\n      processorOptions: options\n    });\n    this.fJSONDsp = JSONObj;\n    this.fJSON = factory.json;\n    this.fOutputHandler = null;\n    this.fComputeHandler = null;\n    this.fPlotHandler = null;\n    this.fDescriptor = [];\n    this.fInputsItems = [];\n    this.fUICallback = (item) => {\n      if (item.type === \"vslider\" || item.type === \"hslider\" || item.type === \"button\" || item.type === \"checkbox\" || item.type === \"nentry\") {\n        this.fInputsItems.push(item.address);\n        this.fDescriptor.push(item);\n      }\n    };\n    FaustBaseWebAudioDsp.parseUI(this.fJSONDsp.ui, this.fUICallback);\n    this.port.onmessage = (e) => {\n      if (e.data.type === \"param\" && this.fOutputHandler) {\n        this.fOutputHandler(e.data.path, e.data.value);\n      } else if (e.data.type === \"plot\" && this.fPlotHandler) {\n        this.fPlotHandler(e.data.value, e.data.index, e.data.events);\n      }\n    };\n  }\n  setOutputParamHandler(handler) {\n    this.fOutputHandler = handler;\n  }\n  getOutputParamHandler() {\n    return this.fOutputHandler;\n  }\n  setComputeHandler(handler) {\n    this.fComputeHandler = handler;\n  }\n  getComputeHandler() {\n    return this.fComputeHandler;\n  }\n  setPlotHandler(handler) {\n    this.fPlotHandler = handler;\n    if (this.fPlotHandler) {\n      this.port.postMessage({ type: \"setPlotHandler\", data: true });\n    } else {\n      this.port.postMessage({ type: \"setPlotHandler\", data: false });\n    }\n  }\n  getPlotHandler() {\n    return this.fPlotHandler;\n  }\n  getNumInputs() {\n    return this.fJSONDsp.inputs;\n  }\n  getNumOutputs() {\n    return this.fJSONDsp.outputs;\n  }\n  compute(inputs, outputs) {\n    return false;\n  }\n  metadata(handler) {\n    if (this.fJSONDsp.meta) {\n      this.fJSONDsp.meta.forEach((meta) => handler(Object.keys(meta)[0], meta[Object.keys(meta)[0]]));\n    }\n  }\n  midiMessage(data) {\n    const cmd = data[0] >> 4;\n    const channel = data[0] & 15;\n    const data1 = data[1];\n    const data2 = data[2];\n    if (cmd === 11)\n      this.ctrlChange(channel, data1, data2);\n    else if (cmd === 14)\n      this.pitchWheel(channel, data2 * 128 + data1);\n    else\n      this.port.postMessage({ type: \"midi\", data });\n  }\n  ctrlChange(channel, ctrl, value) {\n    const e = { type: \"ctrlChange\", data: [channel, ctrl, value] };\n    this.port.postMessage(e);\n  }\n  pitchWheel(channel, wheel) {\n    const e = { type: \"pitchWheel\", data: [channel, wheel] };\n    this.port.postMessage(e);\n  }\n  setParamValue(path, value) {\n    const e = { type: \"param\", data: { path, value } };\n    this.port.postMessage(e);\n    const param = this.parameters.get(path);\n    if (param)\n      param.setValueAtTime(value, this.context.currentTime);\n  }\n  getParamValue(path) {\n    const param = this.parameters.get(path);\n    return param ? param.value : 0;\n  }\n  getParams() {\n    return this.fInputsItems;\n  }\n  getMeta() {\n    return this.fJSONDsp;\n  }\n  getJSON() {\n    return JSON.stringify(this.getMeta());\n  }\n  getUI() {\n    return this.fJSONDsp.ui;\n  }\n  getDescriptors() {\n    return this.fDescriptor;\n  }\n  start() {\n    this.port.postMessage({ type: \"start\" });\n  }\n  stop() {\n    this.port.postMessage({ type: \"stop\" });\n  }\n  destroy() {\n    this.port.postMessage({ type: \"destroy\" });\n    this.port.close();\n  }\n};\nvar FaustMonoAudioWorkletNode = class extends FaustAudioWorkletNode {\n  constructor(context, name, factory, sampleSize) {\n    super(context, name, factory, { name, factory, sampleSize });\n    this.onprocessorerror = (e) => {\n      console.error(\"Error from \" + this.fJSONDsp.name + \" FaustMonoAudioWorkletNode\");\n      throw e;\n    };\n  }\n};\nvar FaustPolyAudioWorkletNode = class extends FaustAudioWorkletNode {\n  constructor(context, name, voiceFactory, mixerModule, voices, sampleSize, effectFactory) {\n    super(context, name, voiceFactory, {\n      name,\n      voiceFactory,\n      mixerModule,\n      voices,\n      sampleSize,\n      effectFactory\n    });\n    this.onprocessorerror = (e) => {\n      console.error(\"Error from \" + this.fJSONDsp.name + \" FaustPolyAudioWorkletNode\");\n      throw e;\n    };\n    this.fJSONEffect = effectFactory ? JSON.parse(effectFactory.json) : null;\n    if (this.fJSONEffect) {\n      FaustBaseWebAudioDsp.parseUI(this.fJSONEffect.ui, this.fUICallback);\n    }\n  }\n  keyOn(channel, pitch, velocity) {\n    const e = { type: \"keyOn\", data: [channel, pitch, velocity] };\n    this.port.postMessage(e);\n  }\n  keyOff(channel, pitch, velocity) {\n    const e = { type: \"keyOff\", data: [channel, pitch, velocity] };\n    this.port.postMessage(e);\n  }\n  allNotesOff(hard) {\n    const e = { type: \"ctrlChange\", data: [0, 123, 0] };\n    this.port.postMessage(e);\n  }\n  getMeta() {\n    const o = this.fJSONDsp;\n    const e = this.fJSONEffect;\n    const r = { ...o };\n    if (e) {\n      r.ui = [{\n        type: \"tgroup\",\n        label: \"Sequencer\",\n        items: [\n          { type: \"vgroup\", label: \"Instrument\", items: o.ui },\n          { type: \"vgroup\", label: \"Effect\", items: e.ui }\n        ]\n      }];\n    } else {\n      r.ui = [{\n        type: \"tgroup\",\n        label: \"Polyphonic\",\n        items: [\n          { type: \"vgroup\", label: \"Voices\", items: o.ui }\n        ]\n      }];\n    }\n    return r;\n  }\n  getJSON() {\n    return JSON.stringify(this.getMeta());\n  }\n  getUI() {\n    return this.getMeta().ui;\n  }\n};\n\n// src/FaustScriptProcessorNode.ts\nvar FaustScriptProcessorNode = class extends (globalThis.ScriptProcessorNode || null) {\n  init(instance) {\n    this.fDSPCode = instance;\n    this.fInputs = new Array(this.fDSPCode.getNumInputs());\n    this.fOutputs = new Array(this.fDSPCode.getNumOutputs());\n    this.onaudioprocess = (e) => {\n      for (let chan = 0; chan < this.fDSPCode.getNumInputs(); chan++) {\n        this.fInputs[chan] = e.inputBuffer.getChannelData(chan);\n      }\n      for (let chan = 0; chan < this.fDSPCode.getNumOutputs(); chan++) {\n        this.fOutputs[chan] = e.outputBuffer.getChannelData(chan);\n      }\n      return this.fDSPCode.compute(this.fInputs, this.fOutputs);\n    };\n    this.start();\n  }\n  compute(input, output) {\n    return this.fDSPCode.compute(input, output);\n  }\n  setOutputParamHandler(handler) {\n    this.fDSPCode.setOutputParamHandler(handler);\n  }\n  getOutputParamHandler() {\n    return this.fDSPCode.getOutputParamHandler();\n  }\n  setComputeHandler(handler) {\n    this.fDSPCode.setComputeHandler(handler);\n  }\n  getComputeHandler() {\n    return this.fDSPCode.getComputeHandler();\n  }\n  setPlotHandler(handler) {\n    this.fDSPCode.setPlotHandler(handler);\n  }\n  getPlotHandler() {\n    return this.fDSPCode.getPlotHandler();\n  }\n  getNumInputs() {\n    return this.fDSPCode.getNumInputs();\n  }\n  getNumOutputs() {\n    return this.fDSPCode.getNumOutputs();\n  }\n  metadata(handler) {\n  }\n  midiMessage(data) {\n    this.fDSPCode.midiMessage(data);\n  }\n  ctrlChange(chan, ctrl, value) {\n    this.fDSPCode.ctrlChange(chan, ctrl, value);\n  }\n  pitchWheel(chan, value) {\n    this.fDSPCode.pitchWheel(chan, value);\n  }\n  setParamValue(path, value) {\n    this.fDSPCode.setParamValue(path, value);\n  }\n  getParamValue(path) {\n    return this.fDSPCode.getParamValue(path);\n  }\n  getParams() {\n    return this.fDSPCode.getParams();\n  }\n  getMeta() {\n    return this.fDSPCode.getMeta();\n  }\n  getJSON() {\n    return this.fDSPCode.getJSON();\n  }\n  getDescriptors() {\n    return this.fDSPCode.getDescriptors();\n  }\n  getUI() {\n    return this.fDSPCode.getUI();\n  }\n  start() {\n    this.fDSPCode.start();\n  }\n  stop() {\n    this.fDSPCode.stop();\n  }\n  destroy() {\n    this.fDSPCode.destroy();\n  }\n};\nvar FaustMonoScriptProcessorNode = class extends FaustScriptProcessorNode {\n};\nvar FaustPolyScriptProcessorNode = class extends FaustScriptProcessorNode {\n  keyOn(channel, pitch, velocity) {\n    this.fDSPCode.keyOn(channel, pitch, velocity);\n  }\n  keyOff(channel, pitch, velocity) {\n    this.fDSPCode.keyOff(channel, pitch, velocity);\n  }\n  allNotesOff(hard) {\n    this.fDSPCode.allNotesOff(hard);\n  }\n};\n\n// src/FaustDspGenerator.ts\nvar _FaustMonoDspGenerator = class {\n  constructor() {\n    this.factory = null;\n  }\n  async compile(compiler, name, code, args) {\n    this.factory = await compiler.createMonoDSPFactory(name, code, args);\n    if (!this.factory)\n      return null;\n    this.name = name;\n    return this;\n  }\n  async createNode(context, name = this.name, factory = this.factory, sp = false, bufferSize = 1024, processorName = factory.shaKey || name) {\n    var _a, _b;\n    if (!factory)\n      throw new Error(\"Code is not compiled, please define the factory or call `await this.compile()` first.\");\n    const meta = JSON.parse(factory.json);\n    const sampleSize = meta.compile_options.match(\"-double\") ? 8 : 4;\n    if (sp) {\n      const instance = await FaustWasmInstantiator_default.createAsyncMonoDSPInstance(factory);\n      const monoDsp = new FaustMonoWebAudioDsp(instance, context.sampleRate, sampleSize, bufferSize);\n      const sp2 = context.createScriptProcessor(bufferSize, monoDsp.getNumInputs(), monoDsp.getNumOutputs());\n      Object.setPrototypeOf(sp2, FaustMonoScriptProcessorNode.prototype);\n      sp2.init(monoDsp);\n      return sp2;\n    } else {\n      if (!_FaustMonoDspGenerator.gWorkletProcessors.has(context))\n        _FaustMonoDspGenerator.gWorkletProcessors.set(context, /* @__PURE__ */ new Set());\n      if (!((_a = _FaustMonoDspGenerator.gWorkletProcessors.get(context)) == null ? void 0 : _a.has(processorName))) {\n        try {\n          const processorCode = `\n// DSP name and JSON string for DSP are generated\nconst faustData = ${JSON.stringify({\n            processorName,\n            dspName: name,\n            dspMeta: meta,\n            poly: false\n          })};\n// Implementation needed classes of functions\nconst ${FaustDspInstance_default.name}_default = ${FaustDspInstance_default.toString()}\nconst ${FaustBaseWebAudioDsp.name} = ${FaustBaseWebAudioDsp.toString()}\nconst ${FaustMonoWebAudioDsp.name} = ${FaustMonoWebAudioDsp.toString()}\nconst ${FaustWasmInstantiator_default.name} = ${FaustWasmInstantiator_default.toString()}\n// Put them in dependencies\nconst dependencies = {\n    ${FaustBaseWebAudioDsp.name},\n    ${FaustMonoWebAudioDsp.name},\n    ${FaustWasmInstantiator_default.name}\n};\n// Generate the actual AudioWorkletProcessor code\n(${FaustAudioWorkletProcessor_default.toString()})(dependencies, faustData);\n`;\n          const url = URL.createObjectURL(new Blob([processorCode], { type: \"text/javascript\" }));\n          await context.audioWorklet.addModule(url);\n          (_b = _FaustMonoDspGenerator.gWorkletProcessors.get(context)) == null ? void 0 : _b.add(processorName);\n        } catch (e) {\n          console.error(`=> exception raised while running createMonoNode: ${e}`);\n          console.error(`=> check that your page is served using https.${e}`);\n          return null;\n        }\n      }\n      const node = new FaustMonoAudioWorkletNode(context, processorName, factory, sampleSize);\n      return node;\n    }\n  }\n  async createAudioWorkletProcessor(name = this.name, factory = this.factory, processorName = factory.shaKey || name) {\n    if (!factory)\n      throw new Error(\"Code is not compiled, please define the factory or call `await this.compile()` first.\");\n    const meta = JSON.parse(factory.json);\n    const dependencies = {\n      FaustBaseWebAudioDsp,\n      FaustMonoWebAudioDsp,\n      FaustWasmInstantiator: FaustWasmInstantiator_default,\n      FaustPolyWebAudioDsp: void 0,\n      FaustWebAudioDspVoice: void 0\n    };\n    try {\n      const faustData = {\n        processorName,\n        dspName: name,\n        dspMeta: meta,\n        poly: false\n      };\n      const Processor = FaustAudioWorkletProcessor_default(dependencies, faustData);\n      return Processor;\n    } catch (e) {\n      console.error(`=> exception raised while running createMonoNode: ${e}`);\n      console.error(`=> check that your page is served using https.${e}`);\n      return null;\n    }\n  }\n  async createOfflineProcessor(sampleRate, bufferSize, factory = this.factory) {\n    if (!factory)\n      throw new Error(\"Code is not compiled, please define the factory or call `await this.compile()` first.\");\n    const meta = JSON.parse(factory.json);\n    const instance = await FaustWasmInstantiator_default.createAsyncMonoDSPInstance(factory);\n    const sampleSize = meta.compile_options.match(\"-double\") ? 8 : 4;\n    const monoDsp = new FaustMonoWebAudioDsp(instance, sampleRate, sampleSize, bufferSize);\n    return new FaustOfflineProcessor_default(monoDsp, bufferSize);\n  }\n};\nvar FaustMonoDspGenerator = _FaustMonoDspGenerator;\nFaustMonoDspGenerator.gWorkletProcessors = /* @__PURE__ */ new Map();\nvar _FaustPolyDspGenerator = class {\n  constructor() {\n    this.voiceFactory = null;\n    this.effectFactory = null;\n  }\n  async compile(compiler, name, dspCode, args, effectCode = `\nadapt(1,1) = _; adapt(2,2) = _,_; adapt(1,2) = _ <: _,_; adapt(2,1) = _,_ :> _;\nadaptor(F,G) = adapt(outputs(F),inputs(G));\ndsp_code = environment{${dspCode}};\nprocess = adaptor(dsp_code.process, dsp_code.effect) : dsp_code.effect;`) {\n    this.voiceFactory = await compiler.createPolyDSPFactory(name, dspCode, args);\n    if (!this.voiceFactory)\n      return null;\n    this.effectFactory = await compiler.createPolyDSPFactory(name, effectCode, args);\n    this.name = name;\n    const voiceMeta = JSON.parse(this.voiceFactory.json);\n    const isDouble = voiceMeta.compile_options.match(\"-double\");\n    const { mixerBuffer, mixerModule } = await compiler.getAsyncInternalMixerModule(!!isDouble);\n    this.mixerBuffer = mixerBuffer;\n    this.mixerModule = mixerModule;\n    return this;\n  }\n  async createNode(context, voices, name = this.name, voiceFactory = this.voiceFactory, mixerModule = this.mixerModule, effectFactory = this.effectFactory, sp = false, bufferSize = 1024, processorName = (voiceFactory.shaKey || \"\") + ((effectFactory == null ? void 0 : effectFactory.shaKey) || \"\") || `${name}_poly`) {\n    var _a, _b;\n    if (!voiceFactory)\n      throw new Error(\"Code is not compiled, please define the factory or call `await this.compile()` first.\");\n    const voiceMeta = JSON.parse(voiceFactory.json);\n    const effectMeta = effectFactory ? JSON.parse(effectFactory.json) : void 0;\n    const sampleSize = voiceMeta.compile_options.match(\"-double\") ? 8 : 4;\n    if (sp) {\n      const instance = await FaustWasmInstantiator_default.createAsyncPolyDSPInstance(voiceFactory, mixerModule, voices, effectFactory || void 0);\n      const polyDsp = new FaustPolyWebAudioDsp(instance, context.sampleRate, sampleSize, bufferSize);\n      const sp2 = context.createScriptProcessor(bufferSize, polyDsp.getNumInputs(), polyDsp.getNumOutputs());\n      Object.setPrototypeOf(sp2, FaustPolyScriptProcessorNode.prototype);\n      sp2.init(polyDsp);\n      return sp2;\n    } else {\n      if (!_FaustPolyDspGenerator.gWorkletProcessors.has(context))\n        _FaustPolyDspGenerator.gWorkletProcessors.set(context, /* @__PURE__ */ new Set());\n      if (!((_a = _FaustPolyDspGenerator.gWorkletProcessors.get(context)) == null ? void 0 : _a.has(processorName))) {\n        try {\n          const processorCode = `\n// DSP name and JSON string for DSP are generated\nconst faustData = ${JSON.stringify({\n            processorName,\n            dspName: name,\n            dspMeta: voiceMeta,\n            poly: true,\n            effectMeta\n          })};\n// Implementation needed classes of functions\nconst ${FaustDspInstance_default.name}_default = ${FaustDspInstance_default.toString()}\nconst ${FaustBaseWebAudioDsp.name} = ${FaustBaseWebAudioDsp.toString()}\nconst ${FaustPolyWebAudioDsp.name} = ${FaustPolyWebAudioDsp.toString()}\nconst ${FaustWebAudioDspVoice.name} = ${FaustWebAudioDspVoice.toString()}\nconst ${FaustWasmInstantiator_default.name} = ${FaustWasmInstantiator_default.toString()}\n// Put them in dependencies\nconst dependencies = {\n    ${FaustBaseWebAudioDsp.name},\n    ${FaustPolyWebAudioDsp.name},\n    ${FaustWasmInstantiator_default.name}\n};\n// Generate the actual AudioWorkletProcessor code\n(${FaustAudioWorkletProcessor_default.toString()})(dependencies, faustData);\n`;\n          const url = URL.createObjectURL(new Blob([processorCode], { type: \"text/javascript\" }));\n          await context.audioWorklet.addModule(url);\n          (_b = _FaustPolyDspGenerator.gWorkletProcessors.get(context)) == null ? void 0 : _b.add(processorName);\n        } catch (e) {\n          console.error(`=> exception raised while running createPolyNode: ${e}`);\n          console.error(`=> check that your page is served using https.${e}`);\n          return null;\n        }\n      }\n      const node = new FaustPolyAudioWorkletNode(context, processorName, voiceFactory, mixerModule, voices, sampleSize, effectFactory || void 0);\n      return node;\n    }\n  }\n  async createAudioWorkletProcessor(name = this.name, voiceFactory = this.voiceFactory, effectFactory = this.effectFactory, processorName = (voiceFactory.shaKey || \"\") + ((effectFactory == null ? void 0 : effectFactory.shaKey) || \"\") || `${name}_poly`) {\n    if (!voiceFactory)\n      throw new Error(\"Code is not compiled, please define the factory or call `await this.compile()` first.\");\n    const voiceMeta = JSON.parse(voiceFactory.json);\n    const effectMeta = effectFactory ? JSON.parse(effectFactory.json) : void 0;\n    const sampleSize = voiceMeta.compile_options.match(\"-double\") ? 8 : 4;\n    try {\n      const dependencies = {\n        FaustBaseWebAudioDsp,\n        FaustMonoWebAudioDsp: void 0,\n        FaustWasmInstantiator: FaustWasmInstantiator_default,\n        FaustPolyWebAudioDsp,\n        FaustWebAudioDspVoice\n      };\n      const faustData = {\n        processorName,\n        dspName: name,\n        dspMeta: voiceMeta,\n        poly: true,\n        effectMeta\n      };\n      const Processor = FaustAudioWorkletProcessor_default(dependencies, faustData);\n      return Processor;\n    } catch (e) {\n      console.error(`=> exception raised while running createPolyNode: ${e}`);\n      console.error(`=> check that your page is served using https.${e}`);\n      return null;\n    }\n  }\n};\nvar FaustPolyDspGenerator = _FaustPolyDspGenerator;\nFaustPolyDspGenerator.gWorkletProcessors = /* @__PURE__ */ new Map();\nexport {\n  FaustAudioWorkletNode,\n  FaustBaseWebAudioDsp,\n  FaustCompiler_default as FaustCompiler,\n  FaustDspInstance_default as FaustDspInstance,\n  FaustMonoAudioWorkletNode,\n  FaustMonoDspGenerator,\n  FaustMonoScriptProcessorNode,\n  FaustMonoWebAudioDsp,\n  FaustOfflineProcessor_default as FaustOfflineProcessor,\n  FaustPolyAudioWorkletNode,\n  FaustPolyDspGenerator,\n  FaustPolyScriptProcessorNode,\n  FaustPolyWebAudioDsp,\n  FaustScriptProcessorNode,\n  FaustSvgDiagrams_default as FaustSvgDiagrams,\n  FaustWasmInstantiator_default as FaustWasmInstantiator,\n  FaustWebAudioDspVoice,\n  LibFaust_default as LibFaust,\n  WavDecoder_default as WavDecoder,\n  WavEncoder_default as WavEncoder,\n  ab2str,\n  FaustAudioWorkletProcessor_default as getFaustAudioWorkletProcessor,\n  instantiateFaustModuleFromFile_default as instantiateFaustModuleFromFile,\n  str2ab\n};\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n//# sourceMappingURL=index.js.map\n"],"names":[],"sourceRoot":""}