{"version":3,"file":"js/3d66d3399e31e10f1c80.js","mappings":"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","sources":["webpack://JSPatcher/./src/core/objects/csound/CsoundNode.ts","webpack://JSPatcher/./src/core/objects/csound/index.jspatpkg.ts"],"sourcesContent":["import type { CsoundObj } from \"@csound/browser\";\nimport CodePopupUI from \"../base/CodePopupUI\";\nimport Bang, { isBang } from \"../base/Bang\";\nimport DefaultObject from \"../base/DefaultObject\";\nimport { isMIDIEvent, decodeLine } from \"../../../utils/utils\";\nimport type DefaultUI from \"../base/DefaultUI\";\nimport type { TBPF, TMIDIEvent } from \"../../types\";\nimport type { UnPromisifiedFunction } from \"../../workers/Worker\";\nimport type { IInletMeta, IOutletMeta, IInletsMeta, IOutletsMeta, IArgsMeta } from \"../base/AbstractObject\";\n\nclass CsoundNodeUI extends CodePopupUI<CsoundNode> {\n    editorLanguage = \"plain\";\n    get code() {\n        return this.object.data.code;\n    }\n    handleSave = (code: string) => {\n        this.object.setData({ code });\n        this.object.newNode(code, this.object._.voices);\n    };\n}\nexport interface CsoundNodeData {\n    code?: string;\n}\nexport interface CsoundNodeInternalState {\n    merger: ChannelMergerNode;\n    splitter: ChannelSplitterNode;\n    csoundObj: CsoundObj;\n    node: AudioWorkletNode;\n    voices: number;\n}\ntype Args = [number];\ntype I = [Bang | number | string | TMIDIEvent | Record<string, TBPF>, ...TBPF[]];\ntype O = (null | string | AudioWorkletNode)[];\n\nexport default class CsoundNode<\n    D extends Record<string, any> & Partial<CsoundNodeData> = {},\n    S extends {} = {},\n    A extends any[] = Args,\n    U extends {} = {}\n> extends DefaultObject<D & CsoundNodeData, S, I, O, A, {}, U> {\n    static package = \"Csound\";\n    static author = \"Fr0stbyteR\";\n    static version = \"1.0.0\";\n    static description = \"Dynamically generate WebAudioNode from Csound\";\n    static inlets: IInletsMeta = [{\n        isHot: true,\n        type: \"anything\",\n        description: \"A bang to output the node, csd string to compile, number to set voices, or a param-bpf map, or a MIDI event\"\n    }];\n    static outlets: IOutletsMeta = [{\n        type: \"object\",\n        description: \"CsoundNode instance output: AudioWorkletNode | ScriptProcessor\"\n    }];\n    static args: IArgsMeta = [{\n        type: \"number\",\n        optional: true,\n        default: 0,\n        description: \"Polyphonic instrument voices count\"\n    }];\n    static UI: typeof DefaultUI = CsoundNodeUI;\n    _: CsoundNodeInternalState = { merger: undefined, splitter: undefined, csoundObj: undefined, node: undefined, voices: ~~Math.max(0, this.args[0]) };\n    async getCsoundNode(code: string) {\n        const Csound = await this.env.getCsound();\n        const csoundObj = await Csound({\n            audioContext: this.audioCtx,\n            autoConnect: false,\n            useSAB: typeof SharedArrayBuffer !== \"undefined\",\n            useSPN: false,\n            useWorker: false\n        });\n        csoundObj.setOption(\"-odac\");\n        csoundObj.on(\"message\", (message: string) => this.outlet(0, message));\n        // console.log(csoundObj);\n        const result = await csoundObj.compileCsdText(code);\n        if (result === 0) {\n            await csoundObj.start();\n        } else {\n            try {\n                await csoundObj.cleanup();\n            } catch (error) {\n                this.error(error);\n            }\n        }\n        const node = await csoundObj.getNode() as AudioWorkletNode;\n        node.channelInterpretation = \"discrete\";\n        // console.log(node);\n        return { csoundObj, node };\n    }\n    async compile(code: string) {\n        let splitter: ChannelSplitterNode;\n        let merger: ChannelMergerNode;\n        const { node, csoundObj } = await this.getCsoundNode(code);\n        if (!node) throw new Error(\"Cannot compile Csound code\");\n        node.channelInterpretation = \"discrete\";\n        const { audioCtx } = this.patcher;\n        const inlets = await csoundObj.getNchnlsInput();\n        const outlets = await csoundObj.getNchnls();\n        if (inlets) {\n            merger = audioCtx.createChannelMerger(inlets);\n            merger.channelInterpretation = \"discrete\";\n            merger.connect(node, 0, 0);\n        }\n        if (outlets) {\n            splitter = audioCtx.createChannelSplitter(outlets);\n            node.connect(splitter, 0, 0);\n        }\n        return { inlets, outlets, node, splitter, merger, csoundObj };\n    }\n    async newNode(code: string, voices: number) {\n        this.disconnectAudio();\n        await this.handleDestroy();\n        let compiled: ReturnType<UnPromisifiedFunction<CsoundNode[\"compile\"]>>;\n        try {\n            compiled = await this.compile(code);\n        } catch (e) {\n            this.error((e as Error).message);\n            return;\n        }\n        const { inlets, outlets, merger, splitter, node, csoundObj } = compiled;\n        Object.assign(this._, { voices, merger, splitter, node, csoundObj } as CsoundNodeInternalState);\n        const Ctor = this.constructor as typeof CsoundNode;\n        const firstInletMeta = Ctor.inlets[0];\n        const firstInletSignalMeta: IInletMeta = { ...firstInletMeta, type: \"signal\" };\n        const inletMeta: IInletMeta = { isHot: false, type: \"signal\", description: \"Node connection\" };\n        const audioParamInletMeta: IInletMeta = { isHot: false, type: \"signal\", description: \": bpf or node connection\" };\n        const outletMeta: IOutletMeta = { type: \"signal\", description: \"Node connection\" };\n        const lastOutletMeta = Ctor.outlets[0];\n        const factoryMeta = Ctor.meta as this[\"meta\"];\n        for (let i = 0; i < inlets; i++) {\n            if (i === 0) factoryMeta.inlets[i] = compiled.inlets ? firstInletSignalMeta : firstInletMeta;\n            else factoryMeta.inlets[i] = inletMeta;\n            this.inletAudioConnections[i] = { node: merger, index: i };\n        }\n        for (let i = 0; i < outlets; i++) {\n            factoryMeta.outlets[i] = outletMeta;\n            this.outletAudioConnections[i] = { node: splitter, index: i };\n        }\n        factoryMeta.outlets[outlets] = lastOutletMeta;\n        const audioParams: string[] = [...node.parameters].map(([k]) => k).sort();\n        for (let i = inlets || 1; i < (inlets || 1) + audioParams.length; i++) {\n            const path = audioParams[i - (inlets || 1)];\n            const param = node.parameters.get(path);\n            const { defaultValue, minValue, maxValue } = param;\n            factoryMeta.inlets[i] = { ...audioParamInletMeta, description: `${path}${audioParamInletMeta.description}: ${defaultValue} (${minValue} - ${maxValue})` };\n            this.inletAudioConnections[i] = { node: param };\n        }\n        this.setMeta(factoryMeta);\n        this.inlets = (inlets || 1) + audioParams.length;\n        this.outlets = outlets + 1;\n        this.connectAudio();\n        this.outlet(this.outlets - 1, this._.node);\n    }\n    handlePreInit = () => undefined as any;\n    handlePostInit = async () => {\n        if (this.data.code) await this.newNode(this.data.code, this._.voices);\n    };\n    handleUpdateArgs = (args: Partial<A>): void => {\n        if (typeof args[0] === \"number\") this._.voices = ~~Math.max(0, args[0]);\n    };\n    handleInlet = async ({ data, inlet }: { data: I[number]; inlet: number }) => {\n        if (inlet === 0) {\n            if (isBang(data)) {\n                if (this._.node) this.outlet(this.outlets - 1, this._.node);\n            } else if (typeof data === \"string\") {\n                this.setData({ code: data } as D);\n                await this.newNode(data, this._.voices);\n            } else if (typeof data === \"number\") {\n                this._.voices = Math.max(0, ~~data);\n            } else if (isMIDIEvent(data)) {\n                if (this._.csoundObj) this._.csoundObj.midiMessage(data[0], data[1], data[2]);\n            } else if (typeof data === \"object\") {\n                if (this._.node) {\n                    for (const key in data) {\n                        try {\n                            const bpf = decodeLine((data as Record<string, TBPF>)[key]);\n                            this.applyBPF(this._.node.parameters.get(key), bpf);\n                        } catch (e) {\n                            this.error(e.message);\n                        }\n                    }\n                }\n            }\n        } else if (this._.node) {\n            const con = this.inletAudioConnections[inlet].node;\n            if (con instanceof AudioParam) {\n                try {\n                    const bpf = decodeLine(data as TBPF);\n                    this.applyBPF(con, bpf);\n                } catch (e) {\n                    this.error(e.message);\n                }\n            }\n        }\n    };\n    handleDestroy = async () => {\n        const { merger, node, csoundObj } = this._;\n        if (merger) merger.disconnect();\n        if (node) {\n            node.disconnect();\n        }\n        if (csoundObj) await csoundObj.destroy();\n    };\n    subscribe() {\n        super.subscribe();\n        this.on(\"preInit\", this.handlePreInit);\n        this.on(\"postInit\", this.handlePostInit);\n        this.on(\"updateArgs\", this.handleUpdateArgs);\n        this.on(\"inlet\", this.handleInlet);\n        this.on(\"destroy\", this.handleDestroy);\n    }\n}\n","import CsoundNode from \"./CsoundNode\";\nimport DefaultImporter from \"../importer/DefaultImporter\";\nimport type Env from \"../../Env\";\n\nexport default async (env: Env) => ({\n    \"csoundnode~\": CsoundNode\n    // ...DefaultImporter.import(\"faust\", { ...env.Faust })\n});\n"],"names":[],"sourceRoot":""}