{"version":3,"file":"src_core_text_PatcherText_ts.js/334367efb9418547ba0b.worklet.js","mappings":"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","sources":["webpack://JSPatcher/./src/core/text/PatcherText.ts","webpack://JSPatcher/./src/core/text/TextEditor.ts","webpack://JSPatcher/./src/core/text/TextHistory.ts"],"sourcesContent":["import FileInstance from \"../file/FileInstance\";\nimport TextEditor from \"./TextEditor\";\nimport TempTextFile from \"./TempTextFile\";\nimport TextHistory from \"./TextHistory\";\nimport type PersistentProjectFile from \"../file/PersistentProjectFile\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\n\nexport interface PatcherTextEventMap {\n    \"textModified\": { text: string; oldText: string };\n}\n\nexport default class PatcherText extends FileInstance<PatcherTextEventMap, PersistentProjectFile | TempTextFile> {\n    static async fromProjectItem(options: { file: PersistentProjectFile; env: IJSPatcherEnv; project?: IProject; instanceId?: string }) {\n        return new this(options).init(options.file.data);\n    }\n    text: string;\n    _history = new TextHistory();\n    async getEditor() {\n        const editor = new TextEditor(this);\n        return editor.init();\n    }\n    async init(data?: ArrayBuffer) {\n        if (data) this.text = await new Response(data).text();\n        else this.text = \"\";\n        this._isReady = true;\n        this.emit(\"ready\");\n        return this;\n    }\n    async serialize() {\n        return new Blob([this.text]).arrayBuffer();\n    }\n    clone() {\n        const patcherText = new PatcherText({ env: this.env, project: this.project, file: this.file });\n        patcherText.text = this.text;\n        return patcherText;\n    }\n}\n","import type { SemanticICONS } from \"semantic-ui-react\";\nimport type MonacoEditor from \"react-monaco-editor\";\nimport type { monaco } from \"react-monaco-editor\";\nimport FileEditor from \"../file/FileEditor\";\nimport TempTextFile from \"./TempTextFile\";\nimport type PatcherText from \"./PatcherText\";\nimport type PersistentProjectFile from \"../file/PersistentProjectFile\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\n\nexport interface TextEditorEventMap {\n    \"textModified\": { text: string; oldText: string };\n}\n\nexport interface TextHistoryEventMap extends TextEditorEventMap {}\n\nexport default class TextEditor extends FileEditor<PatcherText, TextEditorEventMap> {\n    static async fromProjectItem({ file, env, project, instanceId }: { file: PersistentProjectFile | TempTextFile; env: IJSPatcherEnv; project?: IProject; instanceId?: string }) {\n        const text = file instanceof TempTextFile ? file.data : await file.instantiate({ env, project, instanceId }) as PatcherText;\n        const editor = new this(text);\n        return editor.init();\n    }\n    editor: monaco.editor.IStandaloneCodeEditor;\n    editorJSX: typeof MonacoEditor;\n    get fileExtension() {\n        return \"txt\";\n    }\n    get fileIcon(): SemanticICONS {\n        return \"code\";\n    }\n    get text() {\n        return this.instance.text;\n    }\n    set text(value: string) {\n        this.instance.text = value;\n    }\n    async init() {\n        if (!this.instance.isReady) {\n            await new Promise<void>((resolve, reject) => {\n                const handleReady = () => {\n                    resolve();\n                    this.instance.off(\"ready\", handleReady);\n                };\n                this.instance.on(\"ready\", handleReady);\n            });\n        }\n        this._isReady = true;\n        this.emit(\"ready\");\n        return this;\n    }\n    get editorLanguage() {\n        if (!this.file) return \"none\";\n        if (this.file.name.endsWith(\".js\")) return \"js\";\n        if (this.file.name.endsWith(\".json\")) return \"json\";\n        if (this.file.name.endsWith(\".html\")) return \"html\";\n        if (this.file.name.endsWith(\".dsp\")) return \"faust\";\n        return \"none\";\n    }\n    bindEditor(editor: monaco.editor.IStandaloneCodeEditor) {\n        this.editor = editor;\n        const didChanged = editor.onDidChangeModelContent((e) => {\n            const oldText = this.text;\n            const text = editor.getValue();\n            this.text = text;\n            this.emit(\"textModified\", { text, oldText });\n            this.emit(\"changed\");\n        });\n        const didDispose = editor.onDidDispose(() => {\n            didChanged.dispose();\n            didDispose.dispose();\n            this.editor = undefined;\n            this.emit(\"destroy\");\n        });\n        editor.addAction({\n            id: \"editor.action.save\",\n            label: \"Save\",\n            keybindings: [/* KeyMod.CtrlCmd */2048 | /* KeyCode.KEY_S */49],\n            run: () => this.save()\n        });\n    }\n    async copy() {\n        if (!this.editor) return;\n        this.editor.focus();\n        document.execCommand(\"copy\");\n    }\n    async cut() {\n        if (!this.editor) return;\n        this.editor.focus();\n        document.execCommand(\"cut\");\n    }\n    async paste() {\n        if (!this.editor) return;\n        this.editor.focus();\n        const text = await navigator.clipboard.readText();\n        this.editor.executeEdits(\"\", [{ range: this.editor.getSelection(), text, forceMoveMarkers: true }]);\n    }\n    async deleteSelected() {\n        if (!this.editor) return;\n        this.editor.executeEdits(\"\", [{ range: this.editor.getSelection(), text: null }]);\n    }\n    async selectAll() {\n        if (!this.editor) return;\n        const range = this.editor.getModel().getFullModelRange();\n        this.editor.setSelection(range);\n    }\n    onUiResized() {}\n}\n","import History from \"../file/History\";\nimport TextEditor, { TextHistoryEventMap } from \"./TextEditor\";\n\nexport default class TextHistory extends History<TextHistoryEventMap, TextEditor> {\n    get eventListening(): (keyof TextHistoryEventMap)[] {\n        return [\"textModified\"];\n    }\n    async undoOf(editor: TextEditor, eventName: keyof TextHistoryEventMap, eventData: any) {\n        if (eventName === \"textModified\") {\n            const e: TextHistoryEventMap[typeof eventName] = eventData;\n            const { oldText } = e;\n            if (editor.editor) {\n                editor.editor.focus();\n                if (!document.execCommand(\"undo\")) {\n                    (editor.editor.getModel() as any)?.undo();\n                }\n                editor.text = editor.editor.getValue();\n                e.oldText = editor.text;\n            } else {\n                editor.text = oldText;\n            }\n        }\n    }\n    async redoOf(editor: TextEditor, eventName: keyof TextHistoryEventMap, eventData: any) {\n        if (eventName === \"textModified\") {\n            const e: TextHistoryEventMap[typeof eventName] = eventData;\n            const { text } = e;\n            if (editor.editor) {\n                editor.editor.focus();\n                if (!document.execCommand(\"undo\")) {\n                    (editor.editor.getModel() as any)?.redo();\n                }\n                editor.text = editor.editor.getValue();\n                e.text = editor.text;\n            } else {\n                editor.text = text;\n            }\n        }\n    }\n}\n"],"names":[],"sourceRoot":""}