//#################################### primitives.lib ####################################
// This library contains documentations of Faust primitives
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2003-2016 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

//======================================= Program ========================================
//========================================================================================

//-------`process`----------
// The keyword `process` is the equivalent of `main` in C/C++. Any Faust program, 
// to be valid, must at least define `process`.
//
//-----------------------------

//======================================= Metadata =======================================
//========================================================================================

//-------`declare`----------
// ### Global Metadata
//
// All global metadata declaration in Faust start with `declare`, followed by a 
// key and a string. For example:
//
// ```
// declare name "Noise";
// ```
//
// allows us to specify the name of a Faust program in its whole. 
//
// Unlike regular comments, metadata declarations will appear in the C++ code 
// generated by the Faust compiler. A good practice is to start a Faust program 
// with some standard declarations:
//
// ```
// declare name "MyProgram";
// declare author "MySelf";
// declare copyright "MyCompany";
// declare version "1.00";
// declare license "BSD"; 
// ```
//
// ### Function Metadata
//
// Metadata can be associated to a specific function. In that case, `declare` 
// is followed by the name of the function, a key, and a string. For example:
//
// ```
// declare add author "John Doe"
// add = +;
// ```
//
// This is very useful when a library has several contributors and that functions
// potentially have different license terms, etc. 
//
// ### Standard Metadata
//
// There exists a series of standard [global metadata](#global-metadata) in Faust
// whose role role is described in the following table:
//
// | Metadata | Role |
// | --- | --- |
// | `declare options "[key0:value][key1:value]"` | This metadata can be used to specify various options associated to a Faust code such as the fact its polyphonic, if it should have OSC, MIDI support, etc. Specific `keys` usable with this metadata are described throughout this documentation. | 
// | `declare interface "xxx"` | Specifies an interface replacing the standard Faust UI. |
//
//-----------------------------

//======================================= Imports ========================================
//========================================================================================

//-------`import`----------
// File imports allow us to import definitions from other source files.  
//
// For example `import("maths.lib");` imports the definitions of the 
// [`maths.lib`](TODO) library.
//
// The most common file to be imported is the `stdfaust.lib` library which gives
// access to all the standard Faust libraries from a single point:
//
// ```
// import("stdfaust.lib");
// process = os.osc(440); // the "hello world" of computer music
// ```
//
//-----------------------------

//====================================== Iterations ======================================
//========================================================================================

//-------`par`----------
// The `par` iteration can be used to duplicate an expression in parallel. Just
// like other types of iterations in Faust: 
//
// * its first argument is a variable name containing the number of the current 
// iteration (a bit like the variable that is usually named `i` in a for loop)
// starting at 0,
// * its second argument is the number of iterations,
// * its third argument is the expression to be duplicated.
//
//-----------------------------

//-------`seq`----------
// The `seq` iteration can be used to duplicate an expression in series. Just
// like other types of iterations in Faust: 
//
// * its first argument is a variable name containing the number of the current 
// iteration (a bit like the variable that is usually named `i` in a for loop)
// starting at 0,
// * its second argument is the number of iterations,
// * its third argument is the expression to be duplicated.
//
//-----------------------------

//-------`sum`----------
// The `sum` iteration can be used to duplicate an expression as a sum. Just
// like other types of iterations in Faust: 
//
// * its first argument is a variable name containing the number of the current 
// iteration (a bit like the variable that is usually named `i` in a for loop)
// starting at 0,
// * its second argument is the number of iterations,
// * its third argument is the expression to be duplicated.
//
//-----------------------------

//-------`prod`----------
// The `prod` iteration can be used to duplicate an expression as a product. Just
// like other types of iterations in Faust: 
//
// * its first argument is a variable name containing the number of the current 
// iteration (a bit like the variable that is usually named `i` in a for loop)
// starting at 0,
// * its second argument is the number of iterations,
// * its third argument is the expression to be duplicated.
//
//-----------------------------

//=============================== Environment Expressions ================================
//========================================================================================

//-------`with`----------
// The `with` construction allows to specify a *local environment*: a private list 
// of definition that will be used to evaluate the left hand expression.
//
// In the following example :
//
// ```
// pink = f : + ~ g 
// with {
//   f(x) = 0.04957526213389*x - 0.06305581334498*x' + 0.01483220320740*x'';
// 	g(x) = 1.80116083982126*x - 0.80257737639225*x';
// };
// process = pink;
// ```
//
// the definitions of `f(x)` and `g(x)` are local to `f : + ~ g`.
//
// Please note that `with` is left associative and has the lowest priority:
//
// * `f : + ~ g with {...}` is equivalent to `(f : + ~ g)  with {...}`. 
// * `f : + ~ g with {...} with {...}` is equivalent to 
// `((f : + ~ g)  with {...})  with {...}`. 
//
//-----------------------------

//-------`letrec`----------
// The `letrec` construction is somehow similar to `with`, but 
// for difference equations instead of regular definitions. It allows us to easily 
// express groups of mutually recursive signals, for example:
//
// x(t) = y(t-1) + 10
// y(t) = x(t-1) - 1
//
// as `E letrec { 'x = y+10; 'y = x-1; }`	
//
//-----------------------------

//-------`environment`----------
// The `environment` construction allows to create an explicit environment. It is 
// like a `with', but without the left hand expression. It is a 
// convenient way to group together related definitions, to isolate groups of 
// definitions and to create a name space hierarchy. 
// In the following example an `environment` construction is used to group 
// together some constant definitions :
//
// ```
// constant = environment {
//   pi = 3.14159;
//   e = 2,718;
// 	...
// };
// ```
//
// The `.` construction allows to access the definitions of an environment.
//
//-----------------------------

//-------`library`----------
// The `library` construct allows to create an environment by reading the 
// definitions from a file.
//
// For example `library("filters.lib")` represents the 
// environment obtained by reading the file 
// `filters.lib`. It works like `import("miscfilter.lib")` but all the 
// read definitions are stored in a new separate lexical environment. Individual 
// definitions can be accessed as described in the previous paragraph. For example 
// `library("filters.lib").lowpass` denotes the function `lowpass` as defined in 
// the file `miscfilter.lib`.
//
// To avoid name conflicts when importing libraries it is recommended to prefer 
// `library` to `import`. So instead of :
//
// ```
// import("filters.lib");
//   ...
// ...lowpass....
// 	...
// };
// ```
//
// the following will ensure an absence of conflicts : 
//
// ```
// fl = library("filters.lib");
//   ...
// ...fl.lowpass....
// 	...
// };
// ```
//
// In practice, that's how the `stdfaust.lib` library works.
//
//-----------------------------

//-------`component`----------
// The `component` construction allows us to reuse a full Faust program (e.g., a 
// `.dsp` file) as a simple expression.
//
// For example `component("freeverb.dsp")` denotes the signal processor defined 
// in file `freeverb.dsp`. 
//  
// Components can be used within expressions like in: 
//  
// ```
// ...component("karplus32.dsp") : component("freeverb.dsp")... 
// ```
//   
// Please note that `component("freeverb.dsp")` is equivalent to
// `library("freeverb.dsp").process`.
//
// `component` works well in tandem with 
// explicit substitution.
//
//-----------------------------

//================================= Foreign Expressions ==================================
//========================================================================================

//-------`ffunction`----------
// An external C function is declared by indicating its name and signature as well 
// as the required include file. The file `maths.lib` of the Faust distribution 
// contains several foreign function definitions, for example 
// the inverse hyperbolic sine function `asinh`:
//
// ```
// asinh = ffunction(float asinh (float), <math.h>, "");
// ```
//
// <!-- TODO: what happens for other languages than C? -->
//
// Foreign functions with input parameters are considered pure math functions. 
// They are therefore considered free of side effects and called only when their 
// parameters change (that is at the rate of the fastest parameter). 
//
// Exceptions are functions with no input parameters. A typical example is the C 
// `rand()` function. In this case, the compiler generates code to call the 
// function at sample rate.
//
//-----------------------------

//====================================== Primitives ======================================
//========================================================================================

//-------`waveform`----------
// The waveform primitive was designed to facilitate the use of 
// `rdtable` (read table). It allows us to specify a fixed periodic 
// signal as a list of samples. 
//
// `waveform` has two outputs:
//
// * a constant and indicating the size (as a number of samples) of the period, 
// * the periodic signal itself. 
//
// For example `waveform{0,1,2,3}` produces two outputs: the constant signal 4 
// and the periodic signal (0,1,2,3,0,1,2,3,0,1,...). 
//
// In the following example:
//
// ```
// import("stdfaust.lib");
// triangleWave = waveform{0,0.5,1,0.5,0,-0.5,-1,-.5};
// triangleOsc(f) = triangleWave,int(os.phasor(8,f)) : rdtable;
// f = hslider("freq",440,50,2000,0.01);
// process = triangleOsc(f);
// ```
//
// `waveform` is used to define a triangle waveform (in its most primitive form),
// which is then used with a `rdtable` controlled by a phasor to
// implement a triangle wave oscillator. Note that the quality of this oscillator
// is very low because of the low resolution of the triangle waveform.
//
//-----------------------------

//-------`waveform`----------
// The `soundfile("label[url:{'path1';'path2';'path3'}]", n)` primitive allows for the access a list of 
// externally defined sound resources, described as the list of their filename, or complete paths. The `soundfile("label[url:path]", n)` simplified syntax allows to use a single file. A `soundfile` has: 
//
// * two inputs: the sound number (as a integer between 0 and 255 checked at compilation time), and the read index in the sound (which will access the last sample of the sound if the read index is greater than the sound length)
// * two fixed outputs: the first one is the currently accessed sound length in frames, the second one is the currently accessed sound nominal sample rate in frames
// * several more outputs for the sound channels themselves
//
// If more outputs than the actual number of channels in the sound file are used, 
// the audio channels will be automatically duplicated up to the wanted number of 
// outputs (so for instance, if a stereo file is used with four output channels, 
// the same group of two channels will be duplicated).
//
// If the soundfile cannot be loaded for whatever reason, a default sound with one channel, a length of 1024 
// frames and null outputs (with samples of value 0) will be used. Note also that soundfiles are entirely 
// loaded in memory by the architecture file, so that the read index signal can access any sample.
//
// Architecture files are responsible to load the actual soundfile. The 
// `SoundUI` C++ class located in the `faust/gui/SoundUI.h` file in the 
// [Faust repository](https://github.com/grame-cncm/faust) implements the 
// `void addSoundfile(label, path, sf_zone)` method, which loads the actual 
// soundfiles using the `libsndfile` library, or possibly specific audio file loading code 
// (in the case of the JUCE framework for instance), and set up the `sf_zone` sound 
// memory pointers. If *label* is used without any *url* metadata, it will be 
// considered as the soundfile pathname. 
//
// Note that a special architecture file can well decide to access and use 
// sound resources created by another means (that is, not directly loaded from a 
// sound file). For instance a mapping between labels and sound resources defined 
// in memory could be used, with some additional code in charge of actually 
// setting up all sound memory pointers when 
// `void addSoundfile(label, path, sf_zone)` is called by the `buidUserInterface` 
// mechanism.
//
//-----------------------------

//=============================== C-Equivalent Primitives ================================
//========================================================================================

//-------`int`----------
// The `int` primitive can be used to force the cast of a signal to int. It is 
// of type $\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}$ and can be described 
// mathematically as $y(t)=(int)x(t)$. This primitive is useful when declaring
// indices to read in a table, etc.
//
// **Example: Simple Cast**
//
// ```
// process = 1.5 : int;
// ```
//
//-----------------------------

//-------`float`----------
// The `float` primitive can be used to force the cast of a signal to float.
//
// **Example: Simple Cast**
//
// ```
// process = 1.5 : float;
// ```
//
//-----------------------------

//-------`xor`----------
// Logical XOR can be expressed in Faust with the `xor` primitive.
//
// **Example**
//
// ```
// process = _ <: <(0.5) xor >(0.7);
// ```
//
//-----------------------------

//-------`acos`----------
// Arc cosine can be expressed as `acos` in Faust.
//
// **Example**
//
// ```
// process = 0.1 : acos;
// ```
//
//-----------------------------

//-------`asin`----------
// Arc sine can be expressed as `asin` in Faust.
//
// **Example**
//
// ```
// process = 0.1 : asin;
// ```
//
//-----------------------------

//-------`atan`----------
// Arc tangent can be expressed as `atan` in Faust.
//
// **Example**
//
// ```
// process = 0.1 : atan;
// ```
//
//-----------------------------

//-------`atan2`----------
// The arc tangent of 2 signals can be expressed as `atan2` in Faust.
//
// **Example**
//
// ```
// process = 0.1,-0.1 : atan2;
// ```
//
//-----------------------------

//-------`cos`----------
// Cosine can be expressed as `cos` in Faust.
//
// **Example**
//
// ```
// process = 0.1 : cos;
// ```
//
//-----------------------------

//-------`sin`----------
// Sine can be expressed as `sin` in Faust.
//
// **Example**
//
// ```
// process = 0.1 : sin;
// ```
//
//-----------------------------

//-------`tan`----------
// Tangent can be expressed as `tan` in Faust.
//
// **Example**
//
// ```
// process = 0.1 : tan;
// ```
//
//-----------------------------

//-------`exp`----------
// Base-e exponential can be expressed as `exp` in Faust.
//
// **Example**
//
// ```
// process = 0.1 : exp;
// ```
//
//-----------------------------

//-------`log`----------
// Base-e logarithm can be expressed as `log` in Faust.
//
// **Example**
//
// ```
// process = 0.1 : log;
// ```
//
//-----------------------------

//-------`log10`----------
// Base-10 logarithm can be expressed as `log10` in Faust.
//
// **Example**
//
// ```
// process = 0.1 : log10;
// ```
//
//-----------------------------

//-------`pow`----------
// Power can be expressed as `pow` in Faust.
//
// **Example**
//
// ```
// process = 2,4 : pow;
// ```
//
//-----------------------------

//-------`sqrt`----------
// Square root can be expressed as `sqrt` in Faust.
//
// **Example**
//
// ```
// process = 4 : sqrt;
// ```
//
//-----------------------------

//-------`abs`----------
// Absolute value can be expressed as `abs` in Faust.
//
// **Example**
//
// ```
// process = -0.5 : abs;
// ```
//
//-----------------------------

//-------`min`----------
// *Minimum* can be expressed as `min` in Faust.
//
// **Example**
//
// ```
// process = -0.5,0.2 : min;
// ```
//
//-----------------------------

//-------`max`----------
// *Maximum* can be expressed as `max` in Faust.
//
// **Example**
//
// ```
// process = -0.5,0.2 : max;
// ```
//
//-----------------------------

//-------`fmod`----------
// Float modulo can be expressed as `fmod` in Faust.
//
// **Example**
//
// ```
// process = 5.3,2 : fmod;
// ```
//
//-----------------------------

//-------`remainder`----------
// Float remainder can be expressed as `remainder` in Faust.
//
// **Example**
//
// ```
// process = 5.3,2 : remainder;
// ```
//
//-----------------------------

//-------`floor`----------
// Largest int can be expressed as `floor` in Faust.
//
// **Example**
//
// ```
// process = 3.6 : floor;
// ```
//
//-----------------------------

//-------`ceil`----------
// Smallest int can be expressed as `ceil` in Faust.
//
// **Example**
//
// ```
// process = 3.6 : ceil;
// ```
//
//-----------------------------

//-------`rint`----------
// Closest int can be expressed as `rint` in Faust.
//
// **Example**
//
// ```
// process = 3.6 : rint;
// ```
//-----------------------------

//============================ Delay Primitives and Modifiers ============================
//========================================================================================

//-------`mem`----------
// A 1 sample delay can be expressed as `mem` in Faust.
//
// **Example**
//
// ```
// process = mem;
// ```
//
// Note that this is equivalent to `process = _'` (see `'` Modifier)
// and `process = @(1)` (see `@` Primitive)
//
//-----------------------------

//-------`'`----------
// `'` can be used to apply a 1 sample delay to a signal in Faust. It can be seen
// as syntactic sugar to the `mem` primitive. `'` is very 
// convenient when implementing filters and can help significantly decrease the 
// size of the Faust code.
//
// **Example**
//
// ```
// process = _';
// ```
//
//-----------------------------

//-------`@`----------
// An integer delay of `N` samples can be expressed as `@(N)` in Faust. Note that
// `N` can be dynamic but that its range must be bounded. This can be done by
// using a UI primitive (see example below) allowing for the definition of a 
// range such as `hslider`, `vslider`, or `nentry`.
//
// Note that floating point delay is also available in Faust by the mean of
// various fractional delay implementations available in the Faust 
// standard libraries.
//
// **Usage**
//
// ```
// _ : @(N) : _
// ```
//
// Where:
//
// * `N`: the length of the delay as a number of samples
//
//-----------------------------

//=================================== Table Primitives ===================================
//========================================================================================

//-------`rdtable`----------
// The `rdtable` primitive can be used to read through a read-only (pre-defined
// before compilation) table. The table can either be implemented using a 
// function controlled by a timer (such as [`ba.time`](TODO)) as demonstrated in 
// the first example, or by using the `waveform` primitive (as shown in the 
// second example). The idea is that the table is parsed during the initialization
// step and before audio computation begins. 
//
// **Usage**
//
// ```
// rdtable(n,s,r) : _
// ```
//
// Where:
//
// * `n`: the table size
// * `s`: the table
// * `r`: the read index (an `int` between 0 and `n`)
//
//-----------------------------

//-------`rwtable`----------
// The `rwtable` primitive can be used to implement a read/write table. It takes
// an audio input that can be written in the table using a *record index* (i.e.,
// `w` below) and read using a read index (i.e., `r` below).
//
// **Usage**
//
// ```
// _ : rwtable(n,s,w,_,r) : _
// ```
//
// Where:
//
// * `n`: the table size
// * `s`: the table
// * `w`: the write index (an `int` between 0 and `n`) 
// * `r`: the read index (an `int` between 0 and `n`)
//
// Note that the fourth argument of `rwtable` corresponds to the input of the 
// table.
//
//-----------------------------

//=================================== Selector Primitives ===================================
//========================================================================================

//-------`select2`----------
// The `select2` primitive is a "two-ways selector" that can be used to select 
// between 2 signals.
//
// **Usage**
//
// ```
// _,_ : select2(s) : _,_
// ```
//
// Where:
//
// * `s`: the selector (`0` for the first signal, `1` for the second one)
//
//-----------------------------

//-------`select3`----------
// The `select3` primitive is a "three-ways selector" that can be used to select 
// between 3 signals.
//
// **Usage**
//
// ```
// _,_,_ : select3(s) : _,_,_
// ```
//
// Where:
//
// * `s`: the selector (`0` for the first signal, `1` for the second one, `2` for
// the third one)
//
//-----------------------------

//=============================== User Interface Primitives ==============================
//========================================================================================

//-------`button`----------
// The `button` primitive implements a button.
//
// **Usage**
//
// ```
// button("label") : _
// ```
//
// Where:
//
// * `label`: the label (expressed as a string) of the 
// element in the interface
//
// **Example: Trigger**
//
// ```
// import("stdfaust.lib");
// process = no.noise*button("gate");
// ```
//
//-----------------------------

//-------`checkbox`----------
// The `checkbox` primitive implements a checkbox/toggle.
//
// **Usage**
//
// ```
// checkbox("label") : _
// ```
//
// Where:
//
// * `label`: the label (expressed as a string) of the 
// element in the interface
//
// **Example: Trigger**
//
// ```
// import("stdfaust.lib");
// process = no.noise*checkbox("gate");
// ```
//
//-----------------------------

//-------`hslider`----------
// The `hslider` primitive implements a horizontal slider.
//
// **Usage**
//
// ```
// hslider("label",init,min,max,step) : _
// ```
//
// Where:
//
// * `label`: the label (expressed as a string) of the 
// element in the interface
// * `init`: the initial value of the slider
// * `min`: the minimum value of the slider
// * `max`: the maximum value of the slider
// * `step`: the precision (step) of the slider (1 to count 1 by 1, 0.1 to count
// 0.1 by 0.1, etc.)
//
// **Example: Gain Control**
//
// ```
// gain = hslider("gain",0,0,1,0.01);
// process = *(gain);
// ```
//
//-----------------------------

//-------`vslider`----------
// The `vslider` primitive implements a vertical slider.
//
// **Usage**
//
// ```
// vslider("label",init,min,max,step) : _
// ```
//
// Where:
//
// * `label`: the label (expressed as a string) of the 
// element in the interface
// * `init`: the initial value of the slider
// * `min`: the minimum value of the slider
// * `max`: the maximum value of the slider
// * `step`: the precision (step) of the slider (1 to count 1 by 1, 0.1 to count
// 0.1 by 0.1, etc.)
//
// **Example**
//
// ```
// gain = vslider("gain",0,0,1,0.01);
// process = *(gain);
// ```
//
//-----------------------------

//-------`nentry`----------
// The `nentry` primitive implements a "numerical entry".
//
// **Usage**
//
// ```
// nentry("label",init,min,max,step) : _
// ```
//
// Where:
//
// * `label`: the label (expressed as a string) of the 
// element in the interface
// * `init`: the initial value of the numerical entry
// * `min`: the minimum value of the numerical entry
// * `max`: the maximum value of the numerical entry
// * `step`: the precision (step) of the numerical entry (1 to count 1 by 1, 0.1 
// to count 0.1 by 0.1, etc.)
//
// **Example**
//
// ```
// gain = nentry("gain",0,0,1,0.01);
// process = *(gain);
// ```
//
//-----------------------------

//-------`hgroup`----------
// The `hgroup` primitive implements a horizontal group. A group contains other
// UI elements that can also be groups. `hgroup` is not a signal processor per se
// and is just a way to label/delimitate part of a Faust code.
//
// **Usage**
//
// ```
// hgroup("label",x)
// ```
//
// Where:
//
// * `label`: the label (expressed as a string) of the 
// element in the interface
// * `x`: the encapsulated/labeled Faust code
//
// **Example**
//
// In the following example, the 2 UI elements controlling an oscillator are
// encapsulated in a group.
//
// ```
// import("stdfaust.lib");
// freq = vslider("freq",440,50,1000,0.1);
// gain = vslider("gain",0,0,1,0.01);
// process = hgroup("Oscillator",os.sawtooth(freq)*gain);
// ```
//
// Note that the `Oscillator` group can be placed in a function in case we'd
// like to add elements to it multiple times. 
//
// ```
// import("stdfaust.lib");
// oscGroup(x) = hgroup("Oscillator",x);
// freq = oscGroup(vslider("freq",440,50,1000,0.1));
// gain = oscGroup(vslider("gain",0,0,1,0.01));
// process = os.sawtooth(freq)*gain;
// ```
//
//-----------------------------

//-------`vgroup`----------
// The `vgroup` primitive implements a vertical group. A group contains other
// UI elements that can also be groups. `vgroup` is not a signal processor per se
// and is just a way to label/delimitate part of a Faust code.
//
// **Usage**
//
// ```
// vgroup("label",x)
// ```
//
// Where:
//
// * `label`: the label (expressed as a string) of the 
// element in the interface
// * `x`: the encapsulated/labeled Faust code
//
// **Example**
//
// In the following example, the 2 UI elements controlling an oscillator are
// encapsulated in a group.
//
// ```
// import("stdfaust.lib");
// freq = hslider("freq",440,50,1000,0.1);
// gain = hslider("gain",0,0,1,0.01);
// process = vgroup("Oscillator",os.sawtooth(freq)*gain);
// ```
//
// Note that the `Oscillator` group can be placed in a function in case we'd
// like to add elements to it multiple times. 
//
// ```
// import("stdfaust.lib");
// oscGroup(x) = vgroup("Oscillator",x);
// freq = oscGroup(hslider("freq",440,50,1000,0.1));
// gain = oscGroup(hslider("gain",0,0,1,0.01));
// process = os.sawtooth(freq)*gain;
// ```
//
//-----------------------------

//-------`tgroup`----------
// The `tgroup` primitive implements a "tab group." Tab groups can be used to
// group UI elements in tabs in the interface. A group contains other
// UI elements that can also be groups. `tgroup` is not a signal processor per se
// and is just a way to label/delimitate part of a Faust code.
//
// **Usage**
//
// ```
// tgroup("label",x)
// ```
//
// Where:
//
// * `label`: the label (expressed as a string) of the 
// element in the interface
// * `x`: the encapsulated/labeled Faust code
//
// **Example**
//
// In the following example, the 2 UI elements controlling an oscillator are
// encapsulated in a group.
//
// ```
// import("stdfaust.lib");
// freq = hslider("freq",440,50,1000,0.1);
// gain = hslider("gain",0,0,1,0.01);
// process = tgroup("Oscillator",os.sawtooth(freq)*gain);
// ```
//
// Note that the `Oscillator` group can be placed in a function in case we'd
// like to add elements to it multiple times. 
//
// ```
// import("stdfaust.lib");
// oscGroup(x) = tgroup("Oscillator",x);
// freq = oscGroup(hslider("freq",440,50,1000,0.1));
// gain = oscGroup(hslider("gain",0,0,1,0.01));
// process = os.sawtooth(freq)*gain;
// ```
//
//-----------------------------

//-------`vbargraph`----------
// The `vbargraph` primitive implements a vertical bar-graph (typically a meter
// displaying the level of a signal).
//
// **Usage**
//
// `vbargraph` takes an input signal and outputs it while making it available to
// the UI.
//
// ```
// _ : vbargraph("label",min,max) : _
// ``` 
//
// Where:
//
// * `min`: the minimum value of the signal in the interface
// * `max`: the maximum value of the signal in the interface
//
// **Example: Simple VU Meter** 
//
// A simple VU meter can be implemented using the `vbargraph` primitive:
//
// ```
// import("stdfaust.lib");
// process = _ <: attach(_,abs : ba.linear2db : vbargraph("Level",-60,0));
// ```
//
// Note the use of the `attach` primitive here that forces 
// the compilation of the `vbargraph` without using its output signal (see section 
// on the `attach` primitive).
//
//-----------------------------

//-------`hbargraph`----------
// The `hbargraph` primitive implements a horizontal bar-graph (typically a meter
// displaying the level of a signal).
//
// **Usage**
//
// `hbargraph` takes an input signal and outputs it while making it available to
// the UI.
//
// ```
// _ : hbargraph("label",min,max) : _
// ``` 
//
// Where:
//
// * `min`: the minimum value of the signal in the interface
// * `max`: the maximum value of the signal in the interface
//
// **Example: Simple VU Meter** 
//
// A simple VU meter can be implemented using the `hbargraph` primitive:
//
// ```
// import("stdfaust.lib");
// process = _ <: attach(_,abs : ba.linear2db : hbargraph("Level",-60,0));
// ```
//
// Note the use of the `attach` primitive here that forces 
// the compilation of the `hbargraph` without using its output signal (see 
// section on the `attach` primitive).
//
//-----------------------------

//-------`attach`----------
// The `attach` primitive takes two input signals and produces one output signal 
// which is a copy of the first input. The role of `attach` is to force its second 
// input signal to be compiled with the first one. From a mathematical standpoint 
// `attach(x,y)` is equivalent to `1*x+0*y`, which is in turn equivalent to 
// `x`, but it tells the compiler not to optimize-out `y`.
//
// To illustrate this role, let's say that we want to develop a mixer application 
// with a vumeter for each input signals. Such vumeters can be easily coded in 
// Faust using an envelope detector connected to a bargraph. The problem is that 
// the signal of the envelope generators has no role in the output signals. Using 
// `attach(x,vumeter(x))` one can tell the compiler that when `x` is compiled 
// `vumeter(x)` should also be compiled. 
//
// The examples in the `hbargraph` Primitive and the
// `vbargraph` Primitive illustrate well the use of
// `attach`.
//
//-----------------------------
